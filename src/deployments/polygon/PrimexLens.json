{
  "address": "0x044644eCF9EC5A9DD99D0ffbA4f15043a3CeBEcD",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_takeProfitStopLossCCM",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "DS_MATH_ADD_OVERFLOW",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DS_MATH_MUL_OVERFLOW",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_bucketFactories",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_positionManager",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_showDeprecated",
          "type": "bool"
        }
      ],
      "name": "getAllBucketsFactory",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "bucketAddress",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "asset",
              "type": "tuple"
            },
            {
              "internalType": "uint128",
              "name": "bar",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "lar",
              "type": "uint128"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "demand",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "availableLiquidity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "utilizationRatio",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "asset",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    },
                    {
                      "internalType": "bool",
                      "name": "isSupported",
                      "type": "bool"
                    },
                    {
                      "internalType": "uint256",
                      "name": "pairPriceDrop",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxLeverage",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.BucketTokenMetadata",
                  "name": "properties",
                  "type": "tuple"
                }
              ],
              "internalType": "struct IPrimexLens.SupportedAsset[]",
              "name": "supportedAssets",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "pToken",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "debtToken",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "feeBuffer",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "withdrawalFeeRate",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "contract ILiquidityMiningRewardDistributor",
                  "name": "liquidityMiningRewardDistributor",
                  "type": "address"
                },
                {
                  "internalType": "bool",
                  "name": "isBucketLaunched",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "accumulatingAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "deadlineTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "stabilizationDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "stabilizationEndTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxAmountPerUser",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxStabilizationEndTimestamp",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IBucketStorage.LiquidityMiningParams",
              "name": "miningParams",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "amountInMining",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentPercent",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "minReward",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxReward",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "extraReward",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct ILiquidityMiningRewardDistributor.RewardsInPMX",
                  "name": "rewardsInPMX",
                  "type": "tuple"
                }
              ],
              "internalType": "struct IPrimexLens.LenderInfo",
              "name": "lenderInfo",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "pmxAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawnRewards",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalPoints",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.LiquidityMiningBucketInfo",
              "name": "lmBucketInfo",
              "type": "tuple"
            },
            {
              "internalType": "uint128",
              "name": "estimatedBar",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "estimatedLar",
              "type": "uint128"
            },
            {
              "internalType": "bool",
              "name": "isDeprecated",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isDelisted",
              "type": "bool"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "urOptimal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "k0",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "k1",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "b0",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "b1",
                  "type": "int256"
                }
              ],
              "internalType": "struct IInterestRateStrategy.BarCalculationParams",
              "name": "barCalcParams",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "maxTotalDeposit",
              "type": "uint256"
            }
          ],
          "internalType": "struct IPrimexLens.BucketMetaData[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_positionManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_bucket",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_cursor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_count",
          "type": "uint256"
        }
      ],
      "name": "getArrayOpenPositionDataByBucket",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "bucketAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "asset",
                  "type": "tuple"
                },
                {
                  "internalType": "uint128",
                  "name": "bar",
                  "type": "uint128"
                },
                {
                  "internalType": "uint128",
                  "name": "lar",
                  "type": "uint128"
                },
                {
                  "internalType": "uint256",
                  "name": "supply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "demand",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "availableLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "utilizationRatio",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "address",
                          "name": "tokenAddress",
                          "type": "address"
                        },
                        {
                          "internalType": "string",
                          "name": "symbol",
                          "type": "string"
                        },
                        {
                          "internalType": "string",
                          "name": "name",
                          "type": "string"
                        },
                        {
                          "internalType": "uint256",
                          "name": "decimals",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "balance",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct IPrimexLens.TokenMetadata",
                      "name": "asset",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        },
                        {
                          "internalType": "bool",
                          "name": "isSupported",
                          "type": "bool"
                        },
                        {
                          "internalType": "uint256",
                          "name": "pairPriceDrop",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "maxLeverage",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct IPrimexLens.BucketTokenMetadata",
                      "name": "properties",
                      "type": "tuple"
                    }
                  ],
                  "internalType": "struct IPrimexLens.SupportedAsset[]",
                  "name": "supportedAssets",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "pToken",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "debtToken",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "feeBuffer",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawalFeeRate",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "contract ILiquidityMiningRewardDistributor",
                      "name": "liquidityMiningRewardDistributor",
                      "type": "address"
                    },
                    {
                      "internalType": "bool",
                      "name": "isBucketLaunched",
                      "type": "bool"
                    },
                    {
                      "internalType": "uint256",
                      "name": "accumulatingAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "deadlineTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "stabilizationDuration",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "stabilizationEndTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxAmountPerUser",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxDuration",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxStabilizationEndTimestamp",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IBucketStorage.LiquidityMiningParams",
                  "name": "miningParams",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "amountInMining",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "currentPercent",
                      "type": "uint256"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "minReward",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "maxReward",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "extraReward",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct ILiquidityMiningRewardDistributor.RewardsInPMX",
                      "name": "rewardsInPMX",
                      "type": "tuple"
                    }
                  ],
                  "internalType": "struct IPrimexLens.LenderInfo",
                  "name": "lenderInfo",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "pmxAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "withdrawnRewards",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "totalPoints",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.LiquidityMiningBucketInfo",
                  "name": "lmBucketInfo",
                  "type": "tuple"
                },
                {
                  "internalType": "uint128",
                  "name": "estimatedBar",
                  "type": "uint128"
                },
                {
                  "internalType": "uint128",
                  "name": "estimatedLar",
                  "type": "uint128"
                },
                {
                  "internalType": "bool",
                  "name": "isDeprecated",
                  "type": "bool"
                },
                {
                  "internalType": "bool",
                  "name": "isDelisted",
                  "type": "bool"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "urOptimal",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "k0",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "k1",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "b0",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "b1",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct IInterestRateStrategy.BarCalculationParams",
                  "name": "barCalcParams",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "maxTotalDeposit",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.BucketMetaData",
              "name": "bucket",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata[2]",
              "name": "pair",
              "type": "tuple[2]"
            },
            {
              "internalType": "uint256",
              "name": "positionSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidationPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stopLossPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takeProfitPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "depositAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "createdAt",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPrimexLens.OpenPositionData[]",
          "name": "positionsData",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "newCursor",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_positionManager",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_trader",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_cursor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_count",
          "type": "uint256"
        }
      ],
      "name": "getArrayOpenPositionDataByTrader",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "bucketAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "asset",
                  "type": "tuple"
                },
                {
                  "internalType": "uint128",
                  "name": "bar",
                  "type": "uint128"
                },
                {
                  "internalType": "uint128",
                  "name": "lar",
                  "type": "uint128"
                },
                {
                  "internalType": "uint256",
                  "name": "supply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "demand",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "availableLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "utilizationRatio",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "address",
                          "name": "tokenAddress",
                          "type": "address"
                        },
                        {
                          "internalType": "string",
                          "name": "symbol",
                          "type": "string"
                        },
                        {
                          "internalType": "string",
                          "name": "name",
                          "type": "string"
                        },
                        {
                          "internalType": "uint256",
                          "name": "decimals",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "balance",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct IPrimexLens.TokenMetadata",
                      "name": "asset",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        },
                        {
                          "internalType": "bool",
                          "name": "isSupported",
                          "type": "bool"
                        },
                        {
                          "internalType": "uint256",
                          "name": "pairPriceDrop",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "maxLeverage",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct IPrimexLens.BucketTokenMetadata",
                      "name": "properties",
                      "type": "tuple"
                    }
                  ],
                  "internalType": "struct IPrimexLens.SupportedAsset[]",
                  "name": "supportedAssets",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "pToken",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "debtToken",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "feeBuffer",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawalFeeRate",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "contract ILiquidityMiningRewardDistributor",
                      "name": "liquidityMiningRewardDistributor",
                      "type": "address"
                    },
                    {
                      "internalType": "bool",
                      "name": "isBucketLaunched",
                      "type": "bool"
                    },
                    {
                      "internalType": "uint256",
                      "name": "accumulatingAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "deadlineTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "stabilizationDuration",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "stabilizationEndTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxAmountPerUser",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxDuration",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxStabilizationEndTimestamp",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IBucketStorage.LiquidityMiningParams",
                  "name": "miningParams",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "amountInMining",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "currentPercent",
                      "type": "uint256"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "minReward",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "maxReward",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "extraReward",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct ILiquidityMiningRewardDistributor.RewardsInPMX",
                      "name": "rewardsInPMX",
                      "type": "tuple"
                    }
                  ],
                  "internalType": "struct IPrimexLens.LenderInfo",
                  "name": "lenderInfo",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "pmxAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "withdrawnRewards",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "totalPoints",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.LiquidityMiningBucketInfo",
                  "name": "lmBucketInfo",
                  "type": "tuple"
                },
                {
                  "internalType": "uint128",
                  "name": "estimatedBar",
                  "type": "uint128"
                },
                {
                  "internalType": "uint128",
                  "name": "estimatedLar",
                  "type": "uint128"
                },
                {
                  "internalType": "bool",
                  "name": "isDeprecated",
                  "type": "bool"
                },
                {
                  "internalType": "bool",
                  "name": "isDelisted",
                  "type": "bool"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "urOptimal",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "k0",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "k1",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "b0",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "b1",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct IInterestRateStrategy.BarCalculationParams",
                  "name": "barCalcParams",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "maxTotalDeposit",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.BucketMetaData",
              "name": "bucket",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata[2]",
              "name": "pair",
              "type": "tuple[2]"
            },
            {
              "internalType": "uint256",
              "name": "positionSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidationPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stopLossPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takeProfitPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "depositAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "createdAt",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPrimexLens.OpenPositionData[]",
          "name": "positionsData",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "newCursor",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_bucket",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_asset",
          "type": "address"
        }
      ],
      "name": "getAssetMetadata",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "isSupported",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "pairPriceDrop",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxLeverage",
              "type": "uint256"
            }
          ],
          "internalType": "struct IPrimexLens.BucketTokenMetadata",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_bucket",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        }
      ],
      "name": "getBucket",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "bucketAddress",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "asset",
              "type": "tuple"
            },
            {
              "internalType": "uint128",
              "name": "bar",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "lar",
              "type": "uint128"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "demand",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "availableLiquidity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "utilizationRatio",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "asset",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    },
                    {
                      "internalType": "bool",
                      "name": "isSupported",
                      "type": "bool"
                    },
                    {
                      "internalType": "uint256",
                      "name": "pairPriceDrop",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxLeverage",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.BucketTokenMetadata",
                  "name": "properties",
                  "type": "tuple"
                }
              ],
              "internalType": "struct IPrimexLens.SupportedAsset[]",
              "name": "supportedAssets",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "pToken",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "debtToken",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "feeBuffer",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "withdrawalFeeRate",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "contract ILiquidityMiningRewardDistributor",
                  "name": "liquidityMiningRewardDistributor",
                  "type": "address"
                },
                {
                  "internalType": "bool",
                  "name": "isBucketLaunched",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "accumulatingAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "deadlineTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "stabilizationDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "stabilizationEndTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxAmountPerUser",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxStabilizationEndTimestamp",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IBucketStorage.LiquidityMiningParams",
              "name": "miningParams",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "amountInMining",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentPercent",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "minReward",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxReward",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "extraReward",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct ILiquidityMiningRewardDistributor.RewardsInPMX",
                  "name": "rewardsInPMX",
                  "type": "tuple"
                }
              ],
              "internalType": "struct IPrimexLens.LenderInfo",
              "name": "lenderInfo",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "pmxAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawnRewards",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalPoints",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.LiquidityMiningBucketInfo",
              "name": "lmBucketInfo",
              "type": "tuple"
            },
            {
              "internalType": "uint128",
              "name": "estimatedBar",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "estimatedLar",
              "type": "uint128"
            },
            {
              "internalType": "bool",
              "name": "isDeprecated",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isDelisted",
              "type": "bool"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "urOptimal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "k0",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "k1",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "b0",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "b1",
                  "type": "int256"
                }
              ],
              "internalType": "struct IInterestRateStrategy.BarCalculationParams",
              "name": "barCalcParams",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "maxTotalDeposit",
              "type": "uint256"
            }
          ],
          "internalType": "struct IPrimexLens.BucketMetaData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_buckets",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_positionManager",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_showDeprecated",
          "type": "bool"
        }
      ],
      "name": "getBucketsArray",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "bucketAddress",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "asset",
              "type": "tuple"
            },
            {
              "internalType": "uint128",
              "name": "bar",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "lar",
              "type": "uint128"
            },
            {
              "internalType": "uint256",
              "name": "supply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "demand",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "availableLiquidity",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "utilizationRatio",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "asset",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    },
                    {
                      "internalType": "bool",
                      "name": "isSupported",
                      "type": "bool"
                    },
                    {
                      "internalType": "uint256",
                      "name": "pairPriceDrop",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxLeverage",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.BucketTokenMetadata",
                  "name": "properties",
                  "type": "tuple"
                }
              ],
              "internalType": "struct IPrimexLens.SupportedAsset[]",
              "name": "supportedAssets",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "pToken",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "debtToken",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "feeBuffer",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "withdrawalFeeRate",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "contract ILiquidityMiningRewardDistributor",
                  "name": "liquidityMiningRewardDistributor",
                  "type": "address"
                },
                {
                  "internalType": "bool",
                  "name": "isBucketLaunched",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "accumulatingAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "deadlineTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "stabilizationDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "stabilizationEndTimestamp",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxAmountPerUser",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxDuration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxStabilizationEndTimestamp",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IBucketStorage.LiquidityMiningParams",
              "name": "miningParams",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "amountInMining",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "currentPercent",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "minReward",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxReward",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "extraReward",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct ILiquidityMiningRewardDistributor.RewardsInPMX",
                  "name": "rewardsInPMX",
                  "type": "tuple"
                }
              ],
              "internalType": "struct IPrimexLens.LenderInfo",
              "name": "lenderInfo",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "pmxAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawnRewards",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalPoints",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.LiquidityMiningBucketInfo",
              "name": "lmBucketInfo",
              "type": "tuple"
            },
            {
              "internalType": "uint128",
              "name": "estimatedBar",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "estimatedLar",
              "type": "uint128"
            },
            {
              "internalType": "bool",
              "name": "isDeprecated",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "isDelisted",
              "type": "bool"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "urOptimal",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "k0",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "k1",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "b0",
                  "type": "uint256"
                },
                {
                  "internalType": "int256",
                  "name": "b1",
                  "type": "int256"
                }
              ],
              "internalType": "struct IInterestRateStrategy.BarCalculationParams",
              "name": "barCalcParams",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "maxTotalDeposit",
              "type": "uint256"
            }
          ],
          "internalType": "struct IPrimexLens.BucketMetaData[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_feeds",
          "type": "address[]"
        }
      ],
      "name": "getChainlinkLatestRoundData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint80",
              "name": "roundId",
              "type": "uint80"
            },
            {
              "internalType": "int256",
              "name": "answer",
              "type": "int256"
            },
            {
              "internalType": "uint256",
              "name": "startedAt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "updatedAt",
              "type": "uint256"
            },
            {
              "internalType": "uint80",
              "name": "answeredInRound",
              "type": "uint80"
            }
          ],
          "internalType": "struct IPrimexLens.RoundData[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IPrimexDNSStorageV3.TradingOrderType",
          "name": "_tradingOrderType",
          "type": "uint8"
        },
        {
          "internalType": "contract IPositionManagerV2",
          "name": "_pm",
          "type": "address"
        }
      ],
      "name": "getEstimatedMinProtocolFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ILiquidityMiningRewardDistributor",
          "name": "liquidityMiningRewardDistributor",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "bucketName",
          "type": "string"
        }
      ],
      "name": "getLMBucketInfo",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "pmxAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "withdrawnRewards",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalPoints",
              "type": "uint256"
            }
          ],
          "internalType": "struct IPrimexLens.LiquidityMiningBucketInfo",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ILiquidityMiningRewardDistributor",
          "name": "liquidityMiningRewardDistributor",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "bucketName",
          "type": "string"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getLenderInfo",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "amountInMining",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "currentPercent",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "minReward",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxReward",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "extraReward",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ILiquidityMiningRewardDistributor.RewardsInPMX",
              "name": "rewardsInPMX",
              "type": "tuple"
            }
          ],
          "internalType": "struct IPrimexLens.LenderInfo",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_limitOrderManager",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_cursor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_count",
          "type": "uint256"
        }
      ],
      "name": "getLimitOrdersWithConditions",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "contract IBucketV3",
                  "name": "bucket",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "positionAsset",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "depositAsset",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "depositAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "feeToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "protocolFee",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "trader",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "deadline",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "leverage",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "shouldOpenPosition",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "createdAt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "updatedConditionsAt",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "extraParams",
                  "type": "bytes"
                }
              ],
              "internalType": "struct LimitOrderLibrary.LimitOrder",
              "name": "limitOrderData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "managerType",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "params",
                  "type": "bytes"
                }
              ],
              "internalType": "struct LimitOrderLibrary.Condition[]",
              "name": "openConditionsData",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct IPrimexLens.LimitOrderWithConditions[]",
          "name": "limitOrdersWithConditions",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "newCursor",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_positionManager",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "_bucket",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "_borrowedAmount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_positionAsset",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_positionAmount",
          "type": "uint256"
        }
      ],
      "name": "getLiquidationPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_positionManager",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_id",
          "type": "uint256"
        }
      ],
      "name": "getLiquidationPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_positionManager",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_id",
          "type": "uint256"
        }
      ],
      "name": "getOpenPositionData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "bucketAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "asset",
                  "type": "tuple"
                },
                {
                  "internalType": "uint128",
                  "name": "bar",
                  "type": "uint128"
                },
                {
                  "internalType": "uint128",
                  "name": "lar",
                  "type": "uint128"
                },
                {
                  "internalType": "uint256",
                  "name": "supply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "demand",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "availableLiquidity",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "utilizationRatio",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "components": [
                        {
                          "internalType": "address",
                          "name": "tokenAddress",
                          "type": "address"
                        },
                        {
                          "internalType": "string",
                          "name": "symbol",
                          "type": "string"
                        },
                        {
                          "internalType": "string",
                          "name": "name",
                          "type": "string"
                        },
                        {
                          "internalType": "uint256",
                          "name": "decimals",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "balance",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct IPrimexLens.TokenMetadata",
                      "name": "asset",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "id",
                          "type": "uint256"
                        },
                        {
                          "internalType": "bool",
                          "name": "isSupported",
                          "type": "bool"
                        },
                        {
                          "internalType": "uint256",
                          "name": "pairPriceDrop",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "maxLeverage",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct IPrimexLens.BucketTokenMetadata",
                      "name": "properties",
                      "type": "tuple"
                    }
                  ],
                  "internalType": "struct IPrimexLens.SupportedAsset[]",
                  "name": "supportedAssets",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "pToken",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "tokenAddress",
                      "type": "address"
                    },
                    {
                      "internalType": "string",
                      "name": "symbol",
                      "type": "string"
                    },
                    {
                      "internalType": "string",
                      "name": "name",
                      "type": "string"
                    },
                    {
                      "internalType": "uint256",
                      "name": "decimals",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "balance",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.TokenMetadata",
                  "name": "debtToken",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "feeBuffer",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "withdrawalFeeRate",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "contract ILiquidityMiningRewardDistributor",
                      "name": "liquidityMiningRewardDistributor",
                      "type": "address"
                    },
                    {
                      "internalType": "bool",
                      "name": "isBucketLaunched",
                      "type": "bool"
                    },
                    {
                      "internalType": "uint256",
                      "name": "accumulatingAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "deadlineTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "stabilizationDuration",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "stabilizationEndTimestamp",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxAmountPerUser",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxDuration",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "maxStabilizationEndTimestamp",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IBucketStorage.LiquidityMiningParams",
                  "name": "miningParams",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "amountInMining",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "currentPercent",
                      "type": "uint256"
                    },
                    {
                      "components": [
                        {
                          "internalType": "uint256",
                          "name": "minReward",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "maxReward",
                          "type": "uint256"
                        },
                        {
                          "internalType": "uint256",
                          "name": "extraReward",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct ILiquidityMiningRewardDistributor.RewardsInPMX",
                      "name": "rewardsInPMX",
                      "type": "tuple"
                    }
                  ],
                  "internalType": "struct IPrimexLens.LenderInfo",
                  "name": "lenderInfo",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "pmxAmount",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "withdrawnRewards",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "totalPoints",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IPrimexLens.LiquidityMiningBucketInfo",
                  "name": "lmBucketInfo",
                  "type": "tuple"
                },
                {
                  "internalType": "uint128",
                  "name": "estimatedBar",
                  "type": "uint128"
                },
                {
                  "internalType": "uint128",
                  "name": "estimatedLar",
                  "type": "uint128"
                },
                {
                  "internalType": "bool",
                  "name": "isDeprecated",
                  "type": "bool"
                },
                {
                  "internalType": "bool",
                  "name": "isDelisted",
                  "type": "bool"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "urOptimal",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "k0",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "k1",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "b0",
                      "type": "uint256"
                    },
                    {
                      "internalType": "int256",
                      "name": "b1",
                      "type": "int256"
                    }
                  ],
                  "internalType": "struct IInterestRateStrategy.BarCalculationParams",
                  "name": "barCalcParams",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "maxTotalDeposit",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.BucketMetaData",
              "name": "bucket",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata[2]",
              "name": "pair",
              "type": "tuple[2]"
            },
            {
              "internalType": "uint256",
              "name": "positionSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidationPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stopLossPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "takeProfitPrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "debt",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "depositAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "createdAt",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraParams",
              "type": "bytes"
            }
          ],
          "internalType": "struct IPrimexLens.OpenPositionData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_positionManager",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_cursor",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_count",
          "type": "uint256"
        }
      ],
      "name": "getOpenPositionsWithConditions",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "scaledDebtAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "contract IBucketV3",
                  "name": "bucket",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "soldAsset",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "depositAmountInSoldAsset",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "positionAsset",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "positionAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "trader",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "openBorrowIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "createdAt",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "updatedConditionsAt",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "extraParams",
                  "type": "bytes"
                }
              ],
              "internalType": "struct PositionLibrary.Position",
              "name": "positionData",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "managerType",
                  "type": "uint256"
                },
                {
                  "internalType": "bytes",
                  "name": "params",
                  "type": "bytes"
                }
              ],
              "internalType": "struct LimitOrderLibrary.Condition[]",
              "name": "conditionsData",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct IPrimexLens.OpenPositionWithConditions[]",
          "name": "openPositionsWithConditions",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "newCursor",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IPositionManagerV2",
          "name": "_pm",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_id",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_positionSoldAssetOracleData",
          "type": "bytes"
        },
        {
          "internalType": "bytes[][]",
          "name": "_pullOracleData",
          "type": "bytes[][]"
        },
        {
          "internalType": "uint256[]",
          "name": "_pullOracleTypes",
          "type": "uint256[]"
        }
      ],
      "name": "getPositionMaxDecrease",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_bucket",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_asset",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_trader",
          "type": "address"
        }
      ],
      "name": "getSupportedAsset",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "asset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isSupported",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "pairPriceDrop",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxLeverage",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.BucketTokenMetadata",
              "name": "properties",
              "type": "tuple"
            }
          ],
          "internalType": "struct IPrimexLens.SupportedAsset",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_bucket",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "_assets",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "_trader",
          "type": "address"
        }
      ],
      "name": "getSupportedAssetArray",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "tokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "uint256",
                  "name": "decimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "balance",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.TokenMetadata",
              "name": "asset",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isSupported",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "pairPriceDrop",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "maxLeverage",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IPrimexLens.BucketTokenMetadata",
              "name": "properties",
              "type": "tuple"
            }
          ],
          "internalType": "struct IPrimexLens.SupportedAsset[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_tokens",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "_trader",
          "type": "address"
        }
      ],
      "name": "getTokenArrayMetadata",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balance",
              "type": "uint256"
            }
          ],
          "internalType": "struct IPrimexLens.TokenMetadata[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_trader",
          "type": "address"
        }
      ],
      "name": "getTokenMetadata",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenAddress",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "decimals",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balance",
              "type": "uint256"
            }
          ],
          "internalType": "struct IPrimexLens.TokenMetadata",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_positionManager",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_id",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_positionSoldAssetOracleData",
          "type": "bytes"
        },
        {
          "internalType": "bytes[][]",
          "name": "_pullOracleData",
          "type": "bytes[][]"
        },
        {
          "internalType": "uint256[]",
          "name": "_pullOracleTypes",
          "type": "uint256[]"
        }
      ],
      "name": "isStopLossReached",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "takeProfitStopLossCCM",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x933f1200449c359a5da2125f9dcda8bc5fa52f2eb214a4a727191f34b345a542",
  "receipt": {
    "to": null,
    "from": "0xC110b6e93a51ACF1f3DEd19c754789E7A2304F07",
    "contractAddress": "0x044644eCF9EC5A9DD99D0ffbA4f15043a3CeBEcD",
    "transactionIndex": 1,
    "gasUsed": "5247390",
    "logsBloom": "0x00000000000000000000000000000000000000000000000010000004000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000800000000000000000000000000000000000000000080000000000000000000000000000000200000000020000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000040000000000000000000000000000000000100000",
    "blockHash": "0x67b2fca181f25adcbdfa435619be8a6cbb9041e4c3839147fbfecac84649a539",
    "transactionHash": "0x933f1200449c359a5da2125f9dcda8bc5fa52f2eb214a4a727191f34b345a542",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 65248164,
        "transactionHash": "0x933f1200449c359a5da2125f9dcda8bc5fa52f2eb214a4a727191f34b345a542",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000c110b6e93a51acf1f3ded19c754789e7a2304f07",
          "0x0000000000000000000000001d25c827abd466387bda00b429fe728627d6eee6"
        ],
        "data": "0x00000000000000000000000000000000000000000000000007483f57160942b8000000000000000000000000000000000000000000000003f6fd6d6ab2d22272000000000000000000000000000000000000000000000948dc4c9dba9e0a98dc000000000000000000000000000000000000000000000003efb52e139cc8dfba000000000000000000000000000000000000000000000948e394dd11b413db94",
        "logIndex": 5,
        "blockHash": "0x67b2fca181f25adcbdfa435619be8a6cbb9041e4c3839147fbfecac84649a539"
      }
    ],
    "blockNumber": 65248164,
    "cumulativeGasUsed": "5364881",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x9A78eDe3996447a127A98A01b13059809E75E7E1"
  ],
  "numDeployments": 5,
  "solcInputHash": "b9821e6aa5ae8bcd6a583375e546781d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.26+commit.8a97fa7a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_takeProfitStopLossCCM\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DS_MATH_ADD_OVERFLOW\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DS_MATH_MUL_OVERFLOW\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bucketFactories\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_showDeprecated\",\"type\":\"bool\"}],\"name\":\"getAllBucketsFactory\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bucketAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"bar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lar\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"demand\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairPriceDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketTokenMetadata\",\"name\":\"properties\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.SupportedAsset[]\",\"name\":\"supportedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"pToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"debtToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBucketLaunched\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"accumulatingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStabilizationEndTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct IBucketStorage.LiquidityMiningParams\",\"name\":\"miningParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInMining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPercent\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraReward\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityMiningRewardDistributor.RewardsInPMX\",\"name\":\"rewardsInPMX\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.LenderInfo\",\"name\":\"lenderInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pmxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.LiquidityMiningBucketInfo\",\"name\":\"lmBucketInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"estimatedBar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"estimatedLar\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isDeprecated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDelisted\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"urOptimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"b1\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateStrategy.BarCalculationParams\",\"name\":\"barCalcParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketMetaData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bucket\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getArrayOpenPositionDataByBucket\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"bucketAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"bar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lar\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"demand\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairPriceDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketTokenMetadata\",\"name\":\"properties\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.SupportedAsset[]\",\"name\":\"supportedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"pToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"debtToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBucketLaunched\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"accumulatingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStabilizationEndTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct IBucketStorage.LiquidityMiningParams\",\"name\":\"miningParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInMining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPercent\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraReward\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityMiningRewardDistributor.RewardsInPMX\",\"name\":\"rewardsInPMX\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.LenderInfo\",\"name\":\"lenderInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pmxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.LiquidityMiningBucketInfo\",\"name\":\"lmBucketInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"estimatedBar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"estimatedLar\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isDeprecated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDelisted\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"urOptimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"b1\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateStrategy.BarCalculationParams\",\"name\":\"barCalcParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketMetaData\",\"name\":\"bucket\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata[2]\",\"name\":\"pair\",\"type\":\"tuple[2]\"},{\"internalType\":\"uint256\",\"name\":\"positionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stopLossPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeProfitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPrimexLens.OpenPositionData[]\",\"name\":\"positionsData\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"newCursor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getArrayOpenPositionDataByTrader\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"bucketAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"bar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lar\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"demand\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairPriceDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketTokenMetadata\",\"name\":\"properties\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.SupportedAsset[]\",\"name\":\"supportedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"pToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"debtToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBucketLaunched\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"accumulatingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStabilizationEndTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct IBucketStorage.LiquidityMiningParams\",\"name\":\"miningParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInMining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPercent\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraReward\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityMiningRewardDistributor.RewardsInPMX\",\"name\":\"rewardsInPMX\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.LenderInfo\",\"name\":\"lenderInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pmxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.LiquidityMiningBucketInfo\",\"name\":\"lmBucketInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"estimatedBar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"estimatedLar\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isDeprecated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDelisted\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"urOptimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"b1\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateStrategy.BarCalculationParams\",\"name\":\"barCalcParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketMetaData\",\"name\":\"bucket\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata[2]\",\"name\":\"pair\",\"type\":\"tuple[2]\"},{\"internalType\":\"uint256\",\"name\":\"positionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stopLossPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeProfitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPrimexLens.OpenPositionData[]\",\"name\":\"positionsData\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"newCursor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bucket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getAssetMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairPriceDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketTokenMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bucket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getBucket\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bucketAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"bar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lar\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"demand\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairPriceDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketTokenMetadata\",\"name\":\"properties\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.SupportedAsset[]\",\"name\":\"supportedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"pToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"debtToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBucketLaunched\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"accumulatingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStabilizationEndTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct IBucketStorage.LiquidityMiningParams\",\"name\":\"miningParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInMining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPercent\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraReward\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityMiningRewardDistributor.RewardsInPMX\",\"name\":\"rewardsInPMX\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.LenderInfo\",\"name\":\"lenderInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pmxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.LiquidityMiningBucketInfo\",\"name\":\"lmBucketInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"estimatedBar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"estimatedLar\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isDeprecated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDelisted\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"urOptimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"b1\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateStrategy.BarCalculationParams\",\"name\":\"barCalcParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketMetaData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_buckets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_showDeprecated\",\"type\":\"bool\"}],\"name\":\"getBucketsArray\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bucketAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"bar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lar\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"demand\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairPriceDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketTokenMetadata\",\"name\":\"properties\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.SupportedAsset[]\",\"name\":\"supportedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"pToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"debtToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBucketLaunched\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"accumulatingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStabilizationEndTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct IBucketStorage.LiquidityMiningParams\",\"name\":\"miningParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInMining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPercent\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraReward\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityMiningRewardDistributor.RewardsInPMX\",\"name\":\"rewardsInPMX\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.LenderInfo\",\"name\":\"lenderInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pmxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.LiquidityMiningBucketInfo\",\"name\":\"lmBucketInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"estimatedBar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"estimatedLar\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isDeprecated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDelisted\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"urOptimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"b1\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateStrategy.BarCalculationParams\",\"name\":\"barCalcParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketMetaData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_feeds\",\"type\":\"address[]\"}],\"name\":\"getChainlinkLatestRoundData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"internalType\":\"struct IPrimexLens.RoundData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPrimexDNSStorageV3.TradingOrderType\",\"name\":\"_tradingOrderType\",\"type\":\"uint8\"},{\"internalType\":\"contract IPositionManagerV2\",\"name\":\"_pm\",\"type\":\"address\"}],\"name\":\"getEstimatedMinProtocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"bucketName\",\"type\":\"string\"}],\"name\":\"getLMBucketInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pmxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.LiquidityMiningBucketInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"bucketName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLenderInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInMining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPercent\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraReward\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityMiningRewardDistributor.RewardsInPMX\",\"name\":\"rewardsInPMX\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.LenderInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_limitOrderManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getLimitOrdersWithConditions\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"contract IBucketV3\",\"name\":\"bucket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"positionAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"shouldOpenPosition\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedConditionsAt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraParams\",\"type\":\"bytes\"}],\"internalType\":\"struct LimitOrderLibrary.LimitOrder\",\"name\":\"limitOrderData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"managerType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"internalType\":\"struct LimitOrderLibrary.Condition[]\",\"name\":\"openConditionsData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IPrimexLens.LimitOrderWithConditions[]\",\"name\":\"limitOrdersWithConditions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"newCursor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_bucket\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_borrowedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_positionAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_positionAmount\",\"type\":\"uint256\"}],\"name\":\"getLiquidationPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getLiquidationPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getOpenPositionData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"bucketAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"bar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lar\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"demand\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationRatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairPriceDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketTokenMetadata\",\"name\":\"properties\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.SupportedAsset[]\",\"name\":\"supportedAssets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"pToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"debtToken\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"feeBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBucketLaunched\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"accumulatingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStabilizationEndTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct IBucketStorage.LiquidityMiningParams\",\"name\":\"miningParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInMining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPercent\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraReward\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityMiningRewardDistributor.RewardsInPMX\",\"name\":\"rewardsInPMX\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.LenderInfo\",\"name\":\"lenderInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pmxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.LiquidityMiningBucketInfo\",\"name\":\"lmBucketInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint128\",\"name\":\"estimatedBar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"estimatedLar\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"isDeprecated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDelisted\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"urOptimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b0\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"b1\",\"type\":\"int256\"}],\"internalType\":\"struct IInterestRateStrategy.BarCalculationParams\",\"name\":\"barCalcParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketMetaData\",\"name\":\"bucket\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata[2]\",\"name\":\"pair\",\"type\":\"tuple[2]\"},{\"internalType\":\"uint256\",\"name\":\"positionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stopLossPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeProfitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IPrimexLens.OpenPositionData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"getOpenPositionsWithConditions\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scaledDebtAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract IBucketV3\",\"name\":\"bucket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"soldAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmountInSoldAsset\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"positionAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"openBorrowIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedConditionsAt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraParams\",\"type\":\"bytes\"}],\"internalType\":\"struct PositionLibrary.Position\",\"name\":\"positionData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"managerType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"internalType\":\"struct LimitOrderLibrary.Condition[]\",\"name\":\"conditionsData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IPrimexLens.OpenPositionWithConditions[]\",\"name\":\"openPositionsWithConditions\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"newCursor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPositionManagerV2\",\"name\":\"_pm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_positionSoldAssetOracleData\",\"type\":\"bytes\"},{\"internalType\":\"bytes[][]\",\"name\":\"_pullOracleData\",\"type\":\"bytes[][]\"},{\"internalType\":\"uint256[]\",\"name\":\"_pullOracleTypes\",\"type\":\"uint256[]\"}],\"name\":\"getPositionMaxDecrease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bucket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"}],\"name\":\"getSupportedAsset\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairPriceDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketTokenMetadata\",\"name\":\"properties\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.SupportedAsset\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bucket\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"}],\"name\":\"getSupportedAssetArray\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"asset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairPriceDrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.BucketTokenMetadata\",\"name\":\"properties\",\"type\":\"tuple\"}],\"internalType\":\"struct IPrimexLens.SupportedAsset[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"}],\"name\":\"getTokenArrayMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"}],\"name\":\"getTokenMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IPrimexLens.TokenMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_positionManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_positionSoldAssetOracleData\",\"type\":\"bytes\"},{\"internalType\":\"bytes[][]\",\"name\":\"_pullOracleData\",\"type\":\"bytes[][]\"},{\"internalType\":\"uint256[]\",\"name\":\"_pullOracleTypes\",\"type\":\"uint256[]\"}],\"name\":\"isStopLossReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeProfitStopLossCCM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"All functions in this contract are intended to be called off-chain. Do not call functions from other contracts to avoid an out-of-gas error.\",\"kind\":\"dev\",\"methods\":{\"getAllBucketsFactory(address[],address,address,bool)\":{\"params\":{\"_bucketFactories\":\"An array of the BucketFactory contracts addresses.\",\"_positionManager\":\"The address of the PositionManager contract.\",\"_showDeprecated\":\"A boolean flag indicating whether to include deprecated buckets in the result.\",\"_trader\":\"The address of the trader for whom the buckets are retrieved.\"},\"returns\":{\"_0\":\"An array of BucketMetaData structs representing the bucket metadata.\"}},\"getArrayOpenPositionDataByBucket(address,address,uint256,uint256)\":{\"params\":{\"_bucket\":\"The address of the bucket positions are related to\",\"_count\":\"The number of positions to retrieve.\",\"_cursor\":\"The cursor value for pagination.\",\"_positionManager\":\"The address of the PositionManager where the positions is stored\"}},\"getArrayOpenPositionDataByTrader(address,address,uint256,uint256)\":{\"params\":{\"_count\":\"The number of positions to retrieve.\",\"_cursor\":\"The cursor value for pagination.\",\"_positionManager\":\"The address of the PositionManager where the positions is stored\",\"_trader\":\"The address, information about all positions of which will be displayed\"}},\"getAssetMetadata(address,address)\":{\"params\":{\"_asset\":\"The address of the asset to retrieve metadata for.\",\"_bucket\":\"The address of the Bucket contract.\"},\"returns\":{\"_0\":\"metadata The metadata of the asset within the bucket.\"}},\"getBucket(address,address)\":{\"params\":{\"_bucket\":\"The address of the Bucket contract.\",\"_trader\":\"The address of the trader.\"},\"returns\":{\"_0\":\"The metadata of the bucket.\"}},\"getBucketsArray(address[],address,address,bool)\":{\"params\":{\"_buckets\":\"The array of bucket addresses.\",\"_positionManager\":\"The address of the PositionManager contract.\",\"_showDeprecated\":\"Flag to determine whether deprecated buckets should be included.\",\"_trader\":\"The address of the trader.\"},\"returns\":{\"_0\":\"An array of `BucketMetaData` objects.\"}},\"getChainlinkLatestRoundData(address[])\":{\"params\":{\"_feeds\":\"An array of feed addresses.\"},\"returns\":{\"_0\":\"res An array of RoundData structs containing the latest round data for each feed.\"}},\"getEstimatedMinProtocolFee(uint8,address)\":{\"params\":{\"_pm\":\"The instance of the PositionManager contract.\",\"_tradingOrderType\":\"Represents the type of trading order in enum TradingOrderType (IPrimexDNSStorageV3)\"}},\"getLMBucketInfo(address,string)\":{\"params\":{\"_bucketName\":\"The name of the liquidity mining bucket.\",\"liquidityMiningRewardDistributor\":\"The instance of the LiquidityMiningRewardDistributor contract.\"},\"returns\":{\"_0\":\"info The liquidity mining bucket information.\"}},\"getLenderInfo(address,string,address)\":{\"params\":{\"bucketName\":\"The name of the lending bucket.\",\"liquidityMiningRewardDistributor\":\"The instance of the LiquidityMiningRewardDistributor contract.\",\"user\":\"The address of the lender.\"},\"returns\":{\"_0\":\"info The lender information.\"}},\"getLimitOrdersWithConditions(address,uint256,uint256)\":{\"params\":{\"_count\":\"The number of positions to retrieve.\",\"_cursor\":\"The cursor value for pagination.\",\"_limitOrderManager\":\"The address of the LimitOrderManager where the order is stored.\"},\"returns\":{\"limitOrdersWithConditions\":\"limitOrderWithConditions An array of LimitOrderWithConditions structs representing open positions with conditions.\",\"newCursor\":\"The new cursor value for pagination.\"}},\"getLiquidationPrice(address,string,uint256,address,uint256)\":{\"details\":\"The liquidation price is the price at which a position can be liquidated (i.e., its collateral can cover the borrowed amount).\",\"params\":{\"_borrowedAmount\":\"The amount borrowed in the position.\",\"_bucket\":\"The name of the bucket associated with the position.\",\"_positionAmount\":\"The amount of the asset held in the position.\",\"_positionAsset\":\"The address of the asset held in the position.\",\"_positionManager\":\"The address of the PositionManager contract.\"},\"returns\":{\"_0\":\"The liquidation price in borrowed asset for the position.\"}},\"getLiquidationPrice(address,uint256)\":{\"params\":{\"_id\":\"The ID of the position.\",\"_positionManager\":\"The address of the PositionManager contract.\"},\"returns\":{\"_0\":\"The liquidation price in borrowed asset of the position.\"}},\"getOpenPositionData(address,uint256)\":{\"params\":{\"_id\":\"Position id to show the parameters position\",\"_positionManager\":\"The address of the PositionManager where the position is stored\"},\"returns\":{\"_0\":\"openPositionData The open position data including various details.\"}},\"getOpenPositionsWithConditions(address,uint256,uint256)\":{\"params\":{\"_count\":\"The number of positions to retrieve.\",\"_cursor\":\"The cursor value for pagination.\",\"_positionManager\":\"The address of the PositionManager where the position is stored.\"},\"returns\":{\"newCursor\":\"The new cursor value for pagination.\",\"openPositionsWithConditions\":\"openPositionsWithConditionsArray An array of OpenPositionWithConditions structs representing open positions with conditions.\"}},\"getPositionMaxDecrease(address,uint256,bytes,bytes[][],uint256[])\":{\"details\":\"maxDecrease = (1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - pricedrop) * positionAmountInBorrowedAsset / (feeBuffer * (1 + maintenanceBuffer)) - position.bucket.getNormalizedVariableDebt() * position.scaledDebtAmount\",\"params\":{\"_id\":\"The ID of the position.\",\"_pm\":\"The instance of the PositionManager contract.\"},\"returns\":{\"_0\":\"The maximum decrease in position value.\"}},\"getSupportedAsset(address,address,address)\":{\"params\":{\"_asset\":\"The address of the asset for which information is requested.\",\"_bucket\":\"The address of the Bucket where the asset is supported.\",\"_trader\":\"The address of the Trader requesting the information.\"},\"returns\":{\"_0\":\"supportedAsset The SupportedAsset struct containing the asset and its properties.\"}},\"getSupportedAssetArray(address,address[],address)\":{\"params\":{\"_assets\":\"An array of asset addresses.\",\"_bucket\":\"The address of the Bucket.\",\"_trader\":\"The address of the trader.\"},\"returns\":{\"_0\":\"res An array of SupportedAsset structs representing the supported assets.\"}},\"getTokenArrayMetadata(address[],address)\":{\"params\":{\"_tokens\":\"The array of token addresses.\",\"_trader\":\"The address of the trader.\"},\"returns\":{\"_0\":\"res The array of token metadata.\"}},\"getTokenMetadata(address,address)\":{\"params\":{\"_token\":\"The address of the token.\",\"_trader\":\"The address of the trader.\"},\"returns\":{\"_0\":\"metadata The metadata of the token.\"}},\"isStopLossReached(address,uint256,bytes,bytes[][],uint256[])\":{\"params\":{\"_id\":\"The ID of the position to check.\",\"_positionManager\":\"The address of the PositionManager contract.\"},\"returns\":{\"_0\":\"A boolean indicating whether the stop loss condition is reached.\"}},\"supportsInterface(bytes4)\":{\"params\":{\"interfaceId\":\"The interface id to check\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAllBucketsFactory(address[],address,address,bool)\":{\"notice\":\"Retrieves all bucket metadata from a bucket factory contract.\"},\"getArrayOpenPositionDataByBucket(address,address,uint256,uint256)\":{\"notice\":\"The function shows the parameters for all open positions of the `_trader` with the best dex for each position\"},\"getArrayOpenPositionDataByTrader(address,address,uint256,uint256)\":{\"notice\":\"The function shows the parameters for all open positions of the `_trader` with the best dex for each position\"},\"getAssetMetadata(address,address)\":{\"notice\":\"Retrieves the metadata of an asset within a bucket.\"},\"getBucket(address,address)\":{\"notice\":\"Retrieves the metadata of a bucket.\"},\"getBucketsArray(address[],address,address,bool)\":{\"notice\":\"Retrieves an array of `BucketMetaData` for the given `_user`.\"},\"getChainlinkLatestRoundData(address[])\":{\"notice\":\"Retrieves the latest round data for multiple Chainlink feeds.\"},\"getEstimatedMinProtocolFee(uint8,address)\":{\"notice\":\"Calculate an approximate min protocol fee based on averageGasPerAction, which represents the typical amount of gas expended by the Keeper for the relevant action.\"},\"getLMBucketInfo(address,string)\":{\"notice\":\"Retrieves information about a liquidity mining bucket.\"},\"getLenderInfo(address,string,address)\":{\"notice\":\"Retrieves information about a lender from the LiquidityMiningRewardDistributor contract.\"},\"getLimitOrdersWithConditions(address,uint256,uint256)\":{\"notice\":\"The function returns the limit orders with corresponding conditions\"},\"getLiquidationPrice(address,string,uint256,address,uint256)\":{\"notice\":\"Calculates the liquidation price for a given position.\"},\"getLiquidationPrice(address,uint256)\":{\"notice\":\"Retrieves the liquidation price of a position.\"},\"getOpenPositionData(address,uint256)\":{\"notice\":\"Retrieves open position data based on the provided position manager and id.\"},\"getOpenPositionsWithConditions(address,uint256,uint256)\":{\"notice\":\"The function returns the positions with corresponding conditions.\"},\"getPositionMaxDecrease(address,uint256,bytes,bytes[][],uint256[])\":{\"notice\":\"Retrieves the maximum decrease in position value for a given position ID.\"},\"getSupportedAsset(address,address,address)\":{\"notice\":\"Retrieves information about a supported asset.\"},\"getSupportedAssetArray(address,address[],address)\":{\"notice\":\"Retrieves an array of SupportedAsset structs for the given bucket, assets, and trader.\"},\"getTokenArrayMetadata(address[],address)\":{\"notice\":\"Retrieves the metadata of an array of tokens for a given trader.\"},\"getTokenMetadata(address,address)\":{\"notice\":\"Retrieves the metadata of a token for a given trader.\"},\"isStopLossReached(address,uint256,bytes,bytes[][],uint256[])\":{\"notice\":\"Checks if the stop loss condition of a position is reached.\"},\"supportsInterface(bytes4)\":{\"notice\":\"Interface checker\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lens/PrimexLens.sol\":\"PrimexLens\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0x6e6e4b0835904509406b070ee173b5bc8f677c19421b76be38aea3b1b3d30846\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x0e1f0f5f62f67a881cd1a9597acbc0a5e4071f3c2c10449a183b922ae7272e3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"@orally-network/solidity-sdk/IOrallyVerifierOracle.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.18;\\n\\nimport {OrallyStructs} from \\\"./OrallyStructs.sol\\\";\\n\\n/**\\n * @title IOrallyVerifierOracle\\n * @notice Interface for the OrallyVerifierOracle contract.\\n * This interface defines the required functions for verifying and handling\\n * data feeds, specifically focusing on functionality related to price feeds\\n * and custom data verification processes.\\n */\\ninterface IOrallyVerifierOracle {\\n    // Events to notify about changes in reporter status or data updates\\n    event ReporterAdded(address indexed reporter);\\n    event ReporterRemoved(address indexed reporter);\\n    event PriceFeedSaved(string indexed pairId, uint256 price, uint256 decimals, uint256 timestamp);\\n    event CustomNumberSaved(string indexed feedId, uint256 value, uint256 decimals);\\n    event CustomStringSaved(string indexed feedId, string value);\\n\\n    // Price Feeds\\n\\n    /**\\n     * @notice Gets the price feed data for a given pair ID.\\n     * @param pairId The unique identifier for the currency pair.\\n     * @return The price feed data for the given pair ID.\\n     */\\n    function getPriceFeed(string memory pairId) external view returns (OrallyStructs.PriceFeed memory);\\n\\n    /**\\n     * @notice Verifies the integrity and authenticity of price feed data, then returns it (if fee paid with API key / allowed domain).\\n     * @param _data The packed byte array containing the price feed and its signature.\\n     * @return Tuple of pair ID, price, decimals, and timestamp if the verification is successful.\\n     */\\n    function verifyPriceFeed(bytes memory _data) external view returns (OrallyStructs.PriceFeed memory);\\n\\n    /**\\n     * @notice Verifies, caches, and returns the details of a price feed (if fee paid with API key / allowed domain).\\n     * Caching is performed to store the most recent and valid data.\\n     * @param _data The packed data containing the price feed and its signature.\\n     * @return Tuple of pair ID, price, decimals, and timestamp.\\n     */\\n    function updatePriceFeed(bytes memory _data) external returns (OrallyStructs.PriceFeed memory);\\n\\n    // --------------------------------------------------------------\\n    // Custom Numbers\\n\\n    /**\\n     * @notice Gets the custom number data for a given feed ID.\\n     * @param _feedId The unique identifier for the custom number feed.\\n     * @return The custom number data for the given feed ID.\\n     */\\n    function getCustomNumber(string memory _feedId) external view returns (OrallyStructs.CustomNumber memory);\\n\\n    /**\\n     * @notice Verifies and returns custom numerical data from provided packed data.\\n     * @param data The packed data containing custom numerical information and its signature.\\n     * @return Tuple containing the feed ID, numerical value, and decimals.\\n     */\\n    function verifyCustomNumber(bytes memory data) external view returns (OrallyStructs.CustomNumber memory);\\n\\n    /**\\n     * @notice Verifies, caches, and returns the details of a custom number feed (if fee paid with API key / allowed domain).\\n     * Caching is performed to store the most recent and valid data.\\n     * @param _data The packed data containing the custom number feed and its signature.\\n     * @return Tuple of feed ID, numerical value, and decimals.\\n     */\\n    function updateCustomNumber(bytes memory _data) external returns (OrallyStructs.CustomNumber memory);\\n\\n    // --------------------------------------------------------------\\n    // Custom Strings\\n\\n    /**\\n     * @notice Gets the custom string data for a given feed ID.\\n     * @param _feedId The unique identifier for the custom string feed.\\n     * @return The custom string data for the given feed ID.\\n     */\\n    function getCustomString(string memory _feedId) external view returns (OrallyStructs.CustomString memory);\\n\\n    /**\\n     * @notice Verifies and returns custom string data from provided packed data.\\n     * @param data The packed data containing custom string information and its signature.\\n     * @return Tuple containing the feed ID and the string value.\\n     */\\n    function verifyCustomString(bytes memory data) external view returns (OrallyStructs.CustomString memory);\\n\\n    /**\\n     * @notice Verifies, caches, and returns the details of a custom string feed (if fee paid with API key / allowed domain).\\n     * Caching is performed to store the most recent and valid data.\\n     * @param _data The packed data containing the custom string feed and its signature.\\n     * @return Tuple of feed ID and the string value.\\n     */\\n    function updateCustomString(bytes memory _data) external returns (OrallyStructs.CustomString memory);\\n\\n    // --------------------------------------------------------------\\n\\n    /**\\n     * @notice Verifies and returns the details of a chain data feed from provided feed.\\n     * @param _chainData The packed data containing the chain data feed and its signature.\\n     * @return Tuple of chainData and metaData if the verification is successful.\\n     */\\n    function verifyReadContractData(bytes memory _chainData) external view returns (bytes memory, bytes memory);\\n\\n    /**\\n    * @notice Verifies and returns the details of a chain data feed from provided feed.\\n     * @param _chainData The packed data containing the chain data feed and its signature.\\n     * @return Tuple of chainData and metaData if the verification is successful.\\n     */\\n    function verifyReadLogsData(bytes memory _chainData) external view returns (bytes memory, bytes memory);\\n\\n    // Reporters\\n\\n    /**\\n     * @notice Checks if an address is an authorized reporter.\\n     * @param _reporter The address to check.\\n     * @return bool Returns true if the address is authorized to submit data.\\n     */\\n    function isReporter(address _reporter) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xe7e28048dd03c4e0fbe0dab969c0967bf3ec529aeac5fd5539192fb9470fd8b7\",\"license\":\"AGPL-3.0\"},\"@orally-network/solidity-sdk/OrallyStructs.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.18;\\n\\ncontract OrallyStructs {\\n    // Structure to store information about each price feed\\n    struct PriceFeed {\\n        string pairId;     // The identifier for the currency pair\\n        uint256 price;     // The latest price of the currency pair\\n        uint256 decimals;  // The decimal places for the price to ensure precision\\n        uint256 timestamp; // The timestamp when the price was last updated\\n    }\\n\\n    struct Meta {\\n        string feedId;      // The identifier for the data feed\\n        uint256 timestamp;  // The timestamp HTTP Gateway response happened\\n        uint256 fee;        // The update fee in ether (could be zero)\\n//        string fee_symbol;  // The symbol of the fee token\\n    }\\n\\n    // Structure to store custom number data\\n    struct CustomNumber {\\n        string feedId;      // The identifier for the data feed\\n        uint256 value;      // The custom number value\\n        uint256 decimals;   // The timestamp when the number was last updated\\n    }\\n\\n    // Structure to store custom string data\\n    struct CustomString {\\n        string feedId;  // The identifier for the data feed\\n        string value;   // The custom string data\\n    }\\n\\n    // Structure to store chain data feed and metadata\\n    struct ReadContractMetadata {\\n        uint256 chain_id;           // The chain ID of the contract\\n        address contract_address;   // The address of the contract\\n        string method;              // The method of the contract call\\n        string params;              // The parameters of the contract call\\n        uint256 block_number;       // The block number the contract call happened (0 if last one)\\n        uint256 timestamp;          // The timestamp HTTP Gateway response happened\\n        uint256 fee;                // The update fee in ether (could be zero)\\n        string fee_symbol;          // The symbol of the fee token\\n    }\\n\\n    struct ReadLogsData {\\n        address addr;\\n        string[] topics;\\n        bytes data;\\n        string block_hash;\\n        uint256 block_number;\\n        string transaction_hash;\\n        uint256 transaction_index;\\n        string log_index;\\n        string transaction_log_index;\\n        string log_type;\\n        bool removed;\\n    }\\n\\n    struct ReadLogsMetadata {\\n        uint256 chain_id;\\n        uint256 block_from;\\n        uint256 block_to;\\n        string[] topics0;\\n        string[] topics1;\\n        string[] topics2;\\n        string[] topics3;\\n        address[] addresses;\\n        uint256 timestamp;\\n\\n        uint256 fee;        // The update fee in ether (could be zero)\\n        string fee_symbol;  // The symbol of the fee token\\n    }\\n}\\n\",\"keccak256\":\"0x523635406666c42d69898ef784490cd95fb09ef68461455cc58f3311320a4736\",\"license\":\"AGPL-3.0\"},\"@pythnetwork/pyth-sdk-solidity/IPyth.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./PythStructs.sol\\\";\\nimport \\\"./IPythEvents.sol\\\";\\n\\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\\n/// @author Pyth Data Association\\ninterface IPyth is IPythEvents {\\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\\n\\n    /// @notice Returns the price and confidence interval.\\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPrice(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\\n    /// @dev Reverts if the EMA price is not available.\\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPrice(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the price of a price feed without any sanity checks.\\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\\n    ///\\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\\n    /// sufficiently recent for their application. If you are considering using this function, it may be\\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPriceUnsafe(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\\n    /// recently.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPriceNoOlderThan(\\n        bytes32 id,\\n        uint age\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\\n    /// However, if the price is not recent this function returns the latest available price.\\n    ///\\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\\n    /// the returned price is recent or useful for any particular application.\\n    ///\\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\\n    /// sufficiently recent for their application. If you are considering using this function, it may be\\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPriceUnsafe(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\\n    /// of the current time.\\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\\n    /// recently.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPriceNoOlderThan(\\n        bytes32 id,\\n        uint age\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Update price feeds with given update messages.\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    /// Prices will be updated if they are more recent than the current stored prices.\\n    /// The call will succeed even if the update is not the most recent.\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\\n    /// @param updateData Array of price update data.\\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\\n\\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    ///\\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\\n    ///\\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\\n    function updatePriceFeedsIfNecessary(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64[] calldata publishTimes\\n    ) external payable;\\n\\n    /// @notice Returns the required fee to update an array of price updates.\\n    /// @param updateData Array of price update data.\\n    /// @return feeAmount The required fee in Wei.\\n    function getUpdateFee(\\n        bytes[] calldata updateData\\n    ) external view returns (uint feeAmount);\\n\\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\\n    /// within `minPublishTime` and `maxPublishTime`.\\n    ///\\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\\n    /// are more recent than the current stored prices.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    ///\\n    ///\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\\n    /// no update for any of the given `priceIds` within the given time range.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\\n    function parsePriceFeedUpdates(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64 minPublishTime,\\n        uint64 maxPublishTime\\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\\n\\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\\n    /// this method will return the first update. This method may store the price updates on-chain, if they\\n    /// are more recent than the current stored prices.\\n    ///\\n    ///\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\\n    function parsePriceFeedUpdatesUnique(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64 minPublishTime,\\n        uint64 maxPublishTime\\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\\n}\\n\",\"keccak256\":\"0xe06dbd61ccf409fffc0a2449eb8bb6c2d245609698c3c6eddad7cd0f3822d215\",\"license\":\"Apache-2.0\"},\"@pythnetwork/pyth-sdk-solidity/IPythEvents.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @title IPythEvents contains the events that Pyth contract emits.\\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\\ninterface IPythEvents {\\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\\n    /// @param id The Pyth Price Feed ID.\\n    /// @param publishTime Publish time of the given price update.\\n    /// @param price Price of the given price update.\\n    /// @param conf Confidence interval of the given price update.\\n    event PriceFeedUpdate(\\n        bytes32 indexed id,\\n        uint64 publishTime,\\n        int64 price,\\n        uint64 conf\\n    );\\n\\n    /// @dev Emitted when a batch price update is processed successfully.\\n    /// @param chainId ID of the source chain that the batch price update comes from.\\n    /// @param sequenceNumber Sequence number of the batch price update.\\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\\n}\\n\",\"keccak256\":\"0x048a35526c2e77d107d43ba336f1dcf31f64cef25ba429ae1f7a0fbc11c23320\",\"license\":\"Apache-2.0\"},\"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\ncontract PythStructs {\\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\\n    //\\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\\n    // Both the price and confidence are stored in a fixed-point numeric representation,\\n    // `x * (10^expo)`, where `expo` is the exponent.\\n    //\\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\\n    // to how this price safely.\\n    struct Price {\\n        // Price\\n        int64 price;\\n        // Confidence interval around the price\\n        uint64 conf;\\n        // Price exponent\\n        int32 expo;\\n        // Unix timestamp describing when the price was published\\n        uint publishTime;\\n    }\\n\\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\\n    struct PriceFeed {\\n        // The price ID.\\n        bytes32 id;\\n        // Latest available price\\n        Price price;\\n        // Latest available exponentially-weighted moving average price\\n        Price emaPrice;\\n    }\\n}\\n\",\"keccak256\":\"0xade221177dda98ebd194c363f264ceea125bde0e6a7a72f7b54da3ac60316894\",\"license\":\"Apache-2.0\"},\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\":{\"content\":\"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\",\"keccak256\":\"0x7c9bc70e5996c763e02ff38905282bc24fb242b0ef2519a003b36824fc524a4b\"},\"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\n/// @title Quoter Interface\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IQuoter {\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0x124b4334f058f70afd8f3b04315cc0812961d400957225d0875872b2a31afbff\",\"license\":\"GPL-2.0-or-later\"},\"contracts/ActivityRewardDistributor/IActivityRewardDistributor.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IActivityRewardDistributorStorage, IERC20, IPrimexDNSV3, ITraderBalanceVault} from \\\"./IActivityRewardDistributorStorage.sol\\\";\\nimport {IWhiteBlackList} from \\\"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\\\";\\nimport {IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface IActivityRewardDistributor is IActivityRewardDistributorStorage, IPausable {\\n    enum Role {\\n        LENDER,\\n        TRADER\\n    }\\n\\n    struct BucketWithRole {\\n        address bucketAddress;\\n        Role role;\\n    }\\n\\n    /**\\n     * @notice Emitted on claimReward()\\n     * @param user The address of the user who claimed reward\\n     * @param bucket The address of the bucket this reward is related to\\n     * @param role User role - TRADER or LENDER\\n     * @param amount Claimed amount\\n     */\\n    event ClaimReward(address indexed user, address indexed bucket, Role indexed role, uint256 amount);\\n\\n    /**\\n     * @notice  Initializes the ActivityRewardDistributor contract.\\n     * @dev This function should only be called once during the initial setup of the contract.\\n     * @param _pmx The address of the PMXToken contract.\\n     * @param _dns The address of the PrimexDNS contract.\\n     * @param _registry The address of the PrimexRegistry contract.\\n     * @param _treasury The address of the treasury where fees will be collected.\\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\\n     */\\n    function initialize(\\n        IERC20 _pmx,\\n        IPrimexDNSV3 _dns,\\n        address _registry,\\n        address _treasury,\\n        ITraderBalanceVault _traderBalanceVault,\\n        IWhiteBlackList _whiteBlackList\\n    ) external;\\n\\n    /**\\n     * @notice  Saves user activity in the protocol for reward calculation\\n     * @param   bucket  The address of the bucket\\n     * @param   user  User address\\n     * @param   newBalance  User balance after action\\n     * @param   role  User role - TRADER or LENDER\\n     */\\n    function updateUserActivity(IBucketV3 bucket, address user, uint256 newBalance, Role role) external;\\n\\n    /**\\n     * @notice  Saves activity of multiple users in the protocol for reward calculation\\n     * @param   bucket  The address of the bucket\\n     * @param   users  Array of user addresses\\n     * @param   newBalances  Array of users balances after action\\n     * @param   length  The length of the users and oldBalances arrays\\n     * @param   role  User role - TRADER or LENDER\\n     */\\n    function updateUsersActivities(\\n        IBucketV3 bucket,\\n        address[] calldata users,\\n        uint256[] calldata newBalances,\\n        uint256 length,\\n        Role role\\n    ) external;\\n\\n    /**\\n     * @notice Allows the caller to claim their accumulated reward from the specified buckets.\\n     * @param bucketsArray The array of BucketWithRole objects containing the buckets from which to claim the rewards.\\n     */\\n    function claimReward(BucketWithRole[] calldata bucketsArray) external;\\n\\n    /**\\n     * @notice Sets up activity rewards distribution in bucket with the specified role and reward parameters.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param bucket The address of the bucket to set up.\\n     * @param role The role associated with the bucket.\\n     * @param increaseAmount The amount by which to increase the total reward for the bucket (in PMX).\\n     * Adds specified amount to totalReward of the bucket. Initial value of totalReward is 0.\\n     * @param rewardPerDay The reward amount per day for the bucket.\\n     */\\n    function setupBucket(address bucket, Role role, uint256 increaseAmount, uint256 rewardPerDay) external;\\n\\n    /**\\n     * @notice Allows the caller to withdraw PMX tokens from a specific bucket.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param bucket The address of the bucket from which to withdraw PMX tokens.\\n     * @param role The role associated with the bucket.\\n     * @param amount The amount of PMX tokens to withdraw.\\n     */\\n    function withdrawPmx(address bucket, Role role, uint256 amount) external;\\n\\n    /**\\n     * @notice Decreases the reward per day for a bucket and role.\\n     * @dev Only callable by the EMERGENCY_ADMIN role.\\n     * @param bucket The address of the bucket for which to decrease the reward per day.\\n     * @param role The role associated with the bucket.\\n     * @param rewardPerDay The amount by which to decrease the reward per day.\\n     */\\n    function decreaseRewardPerDay(address bucket, Role role, uint256 rewardPerDay) external;\\n\\n    /**\\n     * @notice Returns the accumulated reward for a specific bucket and role.\\n     * @param bucket The address of the bucket for which to retrieve the accumulated reward.\\n     * @param role The role associated with the bucket.\\n     * @return The accumulated reward for the specified bucket and role.\\n     */\\n    function getBucketAccumulatedReward(address bucket, Role role) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the claimable reward for a user across multiple buckets.\\n     * @param bucketsArray The array of BucketWithRole objects containing the buckets to check for claimable rewards.\\n     * @param user The address of the user for whom to calculate the claimable reward.\\n     * @return The total claimable reward for the specified user across all provided buckets.\\n     */\\n    function getClaimableReward(BucketWithRole[] calldata bucketsArray, address user) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the user information from a specific bucket and role.\\n     * @param bucket The address of the bucket from which to retrieve the user information.\\n     * @param role The role associated with the bucket.\\n     * @param user The address of the user for whom to retrieve the information.\\n     * @return A UserInfo struct containing the user information.\\n     */\\n    function getUserInfoFromBucket(address bucket, Role role, address user) external view returns (UserInfo memory);\\n}\\n\",\"keccak256\":\"0xeec30381ae5c694a65a51d831704f2f2d9a969ae6c7ff1901a89c1bc2e668cb3\",\"license\":\"BUSL-1.1\"},\"contracts/ActivityRewardDistributor/IActivityRewardDistributorStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\n\\ninterface IActivityRewardDistributorStorage {\\n    /*\\n     * @param oldBalance last updated balance for user\\n     * @param fixedReward the accumulated value of the reward at the time lastUpdatedRewardIndex\\n     * @param lastUpdatedRewardIndex last index with which the user's reward was accumulated\\n     */\\n    struct UserInfo {\\n        uint256 fixedReward;\\n        uint256 lastUpdatedRewardIndex;\\n        uint256 oldBalance;\\n    }\\n\\n    /*\\n     * @param users data to calculate users rewards in this bucket\\n     * @param rewardIndex an index that accumulates user rewards\\n     * @param lastUpdatedTimestamp timestamp of the last update of user activity\\n     * @param rewardPerToken current reward for one token(PToken or DebtToken of bucket)\\n     * @param isFinished Shows that the bucket has distributed all the rewards\\n     * @param fixedReward reward distributed by a bucket over the past period\\n     * with a certain reward per day or with the entire reward fully distributed\\n     * @param lastUpdatedRewardTimestamp timestamp of last fixed reward update\\n     * @param rewardPerDay current reward distributed for 1 day\\n     * @param totalReward Full distributable reward\\n     * @param endTimestamp end time of the distribution of rewards, which is calculated relative to the rewardPerDay and totalReward\\n     */\\n    struct BucketInfo {\\n        mapping(address => UserInfo) users;\\n        //accumulated reward per token\\n        uint256 rewardIndex;\\n        uint256 lastUpdatedTimestamp;\\n        uint256 rewardPerToken;\\n        uint256 scaledTotalSupply;\\n        bool isFinished;\\n        // setted by admin's actions\\n        uint256 fixedReward;\\n        uint256 lastUpdatedRewardTimestamp;\\n        uint256 rewardPerDay;\\n        uint256 totalReward;\\n        uint256 endTimestamp;\\n    }\\n\\n    function pmx() external returns (IERC20);\\n\\n    function dns() external returns (IPrimexDNSV3);\\n\\n    function registry() external returns (address);\\n\\n    function traderBalanceVault() external returns (ITraderBalanceVault);\\n\\n    function treasury() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc93484ae76ebd5ec509e1fb1b5efee69159abcbee241f97c04579770d0573287\",\"license\":\"BUSL-1.1\"},\"contracts/BonusExecutor/IFeeExecutor.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IFeeExecutorStorage} from \\\"./IFeeExecutorStorage.sol\\\";\\n\\ninterface IFeeExecutor is IFeeExecutorStorage {\\n    /**\\n     * @dev Sets tier bonuses for a specific bucket.\\n     * @param _bucket The address of the bucket.\\n     * @param _tiers The array of tier values.\\n     * @param _bonuses The array of NFT bonus parameters.\\n     */\\n    function setTierBonus(address _bucket, uint256[] calldata _tiers, NFTBonusParams[] calldata _bonuses) external;\\n\\n    /**\\n     * @dev Updates the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called by the Debt-Token\\n     * @param _user User for which the bonus will be updated. If user doesn't have the bonus for paused\\n     * @param _oldScaledBalance Balance of the user before the operation at which the updateBonus function was called (e.g mint/burn)\\n     * @param _bucket The Bucket to which the ActivatedBonus relates\\n     **/\\n    function updateBonus(address _user, uint256 _oldScaledBalance, address _bucket, uint256 _currentIndex) external;\\n\\n    /**\\n     * @dev Updates the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called directly by the user\\n     * @param _nftId Id of activated token\\n     **/\\n    function updateBonus(uint256 _nftId) external;\\n\\n    /**\\n     * @dev Updates the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called by the P-Token or Debt-Token\\n     * @param _users Array of the users for whom the bonus will be updated.\\n     * @param _oldBalances Array of the balances before the operation at which the updateBonus function was called (e.g mint/transfer)\\n     * @param _bucket The Bucket to which the ActivatedBonus relates\\n     **/\\n    function updateBonuses(\\n        address[] memory _users,\\n        uint256[] memory _oldBalances,\\n        address _bucket,\\n        uint256 _currentIndex\\n    ) external;\\n\\n    /**\\n     * @dev Returns accumulated amount of p-tokens at the moment\\n     * @param _user The user for which the accumatedAmount will return. If the bonus does not exist will return 0.\\n     * If the NFT does not exist will throw an error\\n     * @param _nftId Id of activated token\\n     * @return The accumulated amount.\\n     */\\n    function getAccumulatedAmount(address _user, uint256 _nftId) external returns (uint256);\\n\\n    /**\\n     * @dev Returns the available amount (accumulated - claimedAmount) of p-tokens at the moment.\\n     * @param _user The user for which the available amount will return. If the bonus does not exist will return 0.\\n     * If the NFT does not exist will throw an error\\n     * @param _nftId Id of activated token\\n     **/\\n    function getAvailableAmount(address _user, uint256 _nftId) external returns (uint256);\\n\\n    /**\\n     * @dev Retrieves the bonus information for a user and NFT.\\n     * @param _user The address of the user.\\n     * @param _nftId The ID of the NFT.\\n     * @return bonus The activated bonus information.\\n     */\\n    function getBonus(address _user, uint256 _nftId) external view returns (ActivatedBonus memory);\\n}\\n\",\"keccak256\":\"0x53e9c9edcec4c00b7cbac171770da68af43b39a4c7a36d1813c3ea03588e81e1\",\"license\":\"BUSL-1.1\"},\"contracts/BonusExecutor/IFeeExecutorStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\n\\ninterface IFeeExecutorStorage {\\n    struct ActivatedBonus {\\n        uint256 nftId;\\n        IBucketV3 bucket;\\n        uint256 percent;\\n        uint256 maxAmount;\\n        uint256 accumulatedAmount;\\n        uint256 lastUpdatedIndex;\\n        uint256 deadline;\\n        //if we allow to claim funds before the end of the bonus\\n        uint256 claimedAmount;\\n    }\\n\\n    struct NFTBonusParams {\\n        uint256 percent;\\n        uint256 maxAmount;\\n        uint256 duration;\\n    }\\n}\\n\",\"keccak256\":\"0x0e7e8db0434b1c208e47cea395f710edbbcf70bc97d4ce363a8b9c36a8a91205\",\"license\":\"BUSL-1.1\"},\"contracts/Bucket/IBucket.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\nimport {IPToken} from \\\"../PToken/IPToken.sol\\\";\\nimport {IDebtToken} from \\\"../DebtToken/IDebtToken.sol\\\";\\nimport {IPositionManager, IPositionManagerV2} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IPrimexDNS, IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IWhiteBlackList} from \\\"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\\\";\\nimport {IReserve} from \\\"../Reserve/IReserve.sol\\\";\\nimport {ILiquidityMiningRewardDistributor} from \\\"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\\\";\\nimport {IInterestRateStrategy} from \\\"../interfaces/IInterestRateStrategy.sol\\\";\\nimport {ISwapManager} from \\\"../SwapManager/ISwapManager.sol\\\";\\nimport {IBucketStorage} from \\\"./IBucketStorage.sol\\\";\\nimport {IBucketEvents} from \\\"./IBucketEvents.sol\\\";\\n\\ninterface IBucket is IBucketStorage, IBucketEvents {\\n    struct ConstructorParams {\\n        string name;\\n        IPToken pToken;\\n        IDebtToken debtToken;\\n        IPositionManager positionManager;\\n        IPriceOracle priceOracle;\\n        IPrimexDNS dns;\\n        IReserve reserve;\\n        IWhiteBlackList whiteBlackList;\\n        address[] assets;\\n        IERC20Metadata borrowedAsset;\\n        uint256 feeBuffer;\\n        uint256 withdrawalFeeRate;\\n        uint256 reserveRate;\\n        // liquidityMining params\\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor;\\n        uint256 liquidityMiningAmount;\\n        uint256 liquidityMiningDeadline;\\n        uint256 stabilizationDuration;\\n        IInterestRateStrategy interestRateStrategy;\\n        uint128 estimatedBar;\\n        uint128 estimatedLar;\\n        uint256 maxAmountPerUser;\\n        bool isReinvestToAaveEnabled;\\n        bytes barCalcParams;\\n        uint256 maxTotalDeposit;\\n    }\\n\\n    event Deposit(address indexed depositer, address indexed pTokenReceiver, uint256 amount);\\n\\n    event DepositToAave(address indexed pool, uint256 amount);\\n\\n    event FeeBufferChanged(uint256 feeBuffer);\\n\\n    event ReserveRateChanged(uint256 reserveRate);\\n\\n    event RatesIndexesUpdated(\\n        uint128 bar,\\n        uint128 lar,\\n        uint128 variableBorrowIndex,\\n        uint128 liquidityIndex,\\n        uint256 timestamp\\n    );\\n\\n    event WithdrawalFeeChanged(uint256 withdrawalFeeRate);\\n\\n    event InterestRateStrategyChanged(address interestRateStrategy);\\n\\n    event AddAsset(address addedAsset);\\n\\n    event RemoveAsset(address deletedAsset);\\n\\n    event MaxTotalDepositChanged(uint256 maxTotalDeposit);\\n\\n    event BarCalculationParamsChanged(bytes params);\\n\\n    event BucketLaunched();\\n\\n    /**\\n     * @dev Initializes the contract with the given parameters.\\n     * @param _params The ConstructorParams struct containing initialization parameters.\\n     * @param _registry The address of the registry contract.\\n     */\\n    function initialize(ConstructorParams memory _params, address _registry) external;\\n\\n    /**\\n     * @dev Function to add new trading asset for this bucket\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _newAsset The address of trading asset\\n     */\\n    function addAsset(address _newAsset) external;\\n\\n    /**\\n     * @notice Removes a trading asset from this bucket.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _assetToDelete The address of the asset to be removed.\\n     */\\n    function removeAsset(address _assetToDelete) external;\\n\\n    /**\\n     * @dev Sets barCalculationParams (urOptimal, k0, k1, b0, b1)\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     */\\n    function setBarCalculationParams(bytes memory _params) external;\\n\\n    /**\\n     * @dev Sets the reserve rate.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _reserveRate The new reserve rate value.\\n     */\\n    function setReserveRate(uint256 _reserveRate) external;\\n\\n    /**\\n     * @dev Sets the new fee buffer.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _feeBuffer The new fee buffer value.\\n     */\\n    function setFeeBuffer(uint256 _feeBuffer) external;\\n\\n    /**\\n     * @dev Sets the withdrawal fee.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _withdrawalFee The new withdrawal fee value.\\n     */\\n    function setWithdrawalFee(uint256 _withdrawalFee) external;\\n\\n    /**\\n     * @dev Sets the interest rate strategy contract address.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _interestRateStrategy The address of the interest rate strategy contract.\\n     */\\n    function setInterestRateStrategy(address _interestRateStrategy) external;\\n\\n    /**\\n     * @notice The function sets the max total deposit for the particular bucket\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _maxTotalDeposit The amount of max total deposit for the bucket\\n     */\\n    function setMaxTotalDeposit(uint256 _maxTotalDeposit) external;\\n\\n    /**\\n     * @dev Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.\\n     * @param _pTokenReceiver The address to receive the deposited pTokens.\\n     * @param _amount The amount of underlying tokens to be deposited\\n     */\\n    function deposit(address _pTokenReceiver, uint256 _amount) external;\\n\\n    /**\\n     * @dev Withdraws the 'amount' of underlying asset from the bucket. The 'amount' of overlying pTokens will be burned.\\n     * @param _borrowAssetReceiver The address of receiver of the borrowed asset.\\n     * @param amount The amount of underlying tokens to be withdrawn.\\n     */\\n    function withdraw(address _borrowAssetReceiver, uint256 amount) external;\\n\\n    /**\\n     * @notice Allows the BIG_TIMELOCK_ADMIN role to withdraw a specified amount of tokens after delisting.\\n     * @param _amount The amount of tokens to withdraw.\\n     */\\n    function withdrawAfterDelisting(uint256 _amount) external;\\n\\n    /**\\n     * @dev Receives a deposit and distributes it to the specified pToken receiver.\\n     * @dev Can be called only by another bucket.\\n     * @param _pTokenReceiver The address of the recipient of the pToken.\\n     * @param _amount The amount of tokens being deposited.\\n     * @param _duration The blocking time for a fixed-term deposit (if it's 0, then it will be a usual deposit)\\n     * @param _bucketFrom The name of the bucket from which the deposit is being made.\\n     */\\n    function receiveDeposit(\\n        address _pTokenReceiver,\\n        uint256 _amount,\\n        uint256 _duration,\\n        string memory _bucketFrom\\n    ) external;\\n\\n    /**\\n     * @notice Deposits (reinvests) funds from a bucket to another bucket.\\n     * Used only in the case of failed liquidity mining in the bucket from where the transfer happens.\\n     * @param _bucketTo The name of the destination bucket.\\n     * @param _swapManager The address of the swap manager.\\n     * @param _megaRoutes The array of routes for swapping tokens.\\n     * @param _amountOutMin The minimum amount of tokens to receive from the swap.\\n     */\\n    function depositFromBucket(\\n        string calldata _bucketTo,\\n        ISwapManager _swapManager,\\n        PrimexPricingLibrary.MegaRoute[] calldata _megaRoutes,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /**\\n     * @dev Allows the SMALL_TIMELOCK_ADMIN to withdraw all liquidity from Aave to Bucket.\\n     */\\n    function returnLiquidityFromAaveToBucket() external;\\n\\n    /**\\n     * @dev Function to update rates and indexes when a trader opens a trading position.\\n     * Mints debt tokens to trader. Calls only by positionManager contract.\\n     * @param _trader The address of the trader, who opens position.\\n     * @param _amount The 'amount' for which the deal is open, and 'amount' of debtTokens will be minted to the trader.\\n     * @param _to The address to transfer the borrowed asset to.\\n     */\\n\\n    function increaseDebt(address _trader, uint256 _amount, address _to) external;\\n\\n    /**\\n     * @dev Function to update rates and indexes.\\n     * Burns debt tokens of trader. Called only by positionManager contract.\\n     * @param _trader The address of the trader, who opened position.\\n     * @param _debtToBurn The 'amount' of trader's debtTokens will be burned by the trader.\\n     * @param _receiverOfAmountToReturn Treasury in case of liquidation. TraderBalanceVault in other cases\\n     * @param _amountToReturn Amount to transfer from bucket\\n     * @param _permanentLossAmount The amount of the protocol's debt to creditors accrued for this position\\n     */\\n    function decreaseTraderDebt(\\n        address _trader,\\n        uint256 _debtToBurn,\\n        address _receiverOfAmountToReturn,\\n        uint256 _amountToReturn,\\n        uint256 _permanentLossAmount\\n    ) external;\\n\\n    /**\\n     * @notice Batch decreases the debt of multiple traders.\\n     * @dev This function can only be called by the BATCH_MANAGER_ROLE.\\n     * @param _traders An array of addresses representing the traders.\\n     * @param _debtsToBurn An array of uint256 values representing the debts to burn for each trader.\\n     * @param _receiverOfAmountToReturn The address that will receive the amount to be returned.\\n     * @param _amountToReturn The amount to be returned.\\n     * @param _permanentLossAmount The amount of permanent loss.\\n     * @param _length The length of the traders array.\\n     */\\n    function batchDecreaseTradersDebt(\\n        address[] memory _traders,\\n        uint256[] memory _debtsToBurn,\\n        address _receiverOfAmountToReturn,\\n        uint256 _amountToReturn,\\n        uint256 _permanentLossAmount,\\n        uint256 _length\\n    ) external;\\n\\n    /**\\n     * @notice This function allows a user to pay back a permanent loss by burning his pTokens.\\n     * @param amount The amount of pTokens to be burned to pay back the permanent loss.\\n     */\\n    function paybackPermanentLoss(uint256 amount) external;\\n\\n    /**\\n     * @dev Calculates the permanent loss based on the scaled permanent loss and the normalized income.\\n     * @return The amount of permanent loss.\\n     */\\n    function permanentLoss() external view returns (uint256);\\n\\n    /**\\n     * @dev Checks if the bucket is deprecated in the protocol.\\n     * @return Whether the bucket is deprecated or not.\\n     */\\n    function isDeprecated() external view returns (bool);\\n\\n    /**\\n     * @dev Returns a boolean value indicating whether the bucket is delisted.\\n     * @return True if the bucket is delisted, otherwise false.\\n     */\\n    function isDelisted() external view returns (bool);\\n\\n    /**\\n     * @dev Checks if an admin can withdraw from the bucket after delisting.\\n     * @return A boolean indicating whether withdrawal is available.\\n     */\\n    function isWithdrawAfterDelistingAvailable() external view returns (bool);\\n\\n    /**\\n     * @dev Checks if this bucket is active in the protocol.\\n     * @return bool True if the bucket is active, false otherwise.\\n     */\\n    function isActive() external view returns (bool);\\n\\n    /**\\n     * @dev Returns the parameters for liquidity mining.\\n     * @return LMparams The liquidity mining parameters.\\n     */\\n    function getLiquidityMiningParams() external view returns (LiquidityMiningParams memory);\\n\\n    /**\\n     * @dev Returns a boolean value indicating whether the bucket is stable in the liquidity mining event.\\n     * @return A boolean value representing the stability of the bucket.\\n     */\\n    function isBucketStable() external view returns (bool);\\n\\n    /**\\n     * @dev Calculates the max leverage according to the following formula:\\n     * ((1 + maintenanceBuffer) * feeBuffer) / ((1 + maintenanceBuffer) * feeBuffer - (1 - securityBuffer) *\\n     * (1 - pairPriceDropBA) * (1 - oracleTolerableLimitAB) * (1 - oracleTolerableLimitBA))\\n     * @param _asset The address of trading asset\\n     * @return The maximum leverage as a uint256 value.\\n     */\\n    function maxAssetLeverage(address _asset) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the normalized income per unit of underlying asset, expressed in ray\\n     * @return The normalized income per unit of underlying asset, expressed in ray\\n     */\\n    function getNormalizedIncome() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the normalized variable debt per unit of underlying asset, expressed in ray\\n     */\\n    function getNormalizedVariableDebt() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns allowed trading assets for current bucket\\n     * @return List of addresses of allowed assets\\n     */\\n    function getAllowedAssets() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Returns current avalable liquidity of borrowedAsset for trading.\\n     * @return The amount of available borrowedAsset\\n     */\\n    function availableLiquidity() external view returns (uint256);\\n}\\n\\ninterface IBucketV2 is IBucket {\\n    /**\\n     * @dev Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.\\n     * @param _pTokenReceiver The address to receive the deposited pTokens.\\n     * @param _amount The amount of underlying tokens to be deposited\\n     * @param _takeDepositFromWallet A flag indicating whether to make the deposit from user wallet\\n     */\\n    function deposit(address _pTokenReceiver, uint256 _amount, bool _takeDepositFromWallet) external;\\n}\\n\\ninterface IBucketV3 is IBucketV2 {\\n    event ChangedBucketExtension(address newBucketExtension);\\n\\n    /**\\n     * @dev Calculates the max leverage according to the following formula:\\n     * ((1 + maintenanceBuffer) * feeBuffer) / ((1 + maintenanceBuffer) * feeBuffer - (1 - securityBuffer) *\\n     * (1 - pairPriceDropBA) * (1 - oracleTolerableLimitAB) * (1 - oracleTolerableLimitBA) + protocolFeeInPositiontAsset / positionSize)\\n     * @param _asset The address of trading asset\\n     * @param _feeRate The ratio of protocolFeeInPositionAsset to positionSize\\n     * @return The maximum leverage as a uint256 value.\\n     */\\n    function maxAssetLeverage(address _asset, uint256 _feeRate) external view returns (uint256);\\n\\n    /**\\n     * @notice Sets the bucketExtension.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _newBucketExtension The address of BucketExtension contract.\\n     */\\n    function setBucketExtension(address _newBucketExtension) external;\\n}\\n\\ninterface IBucketV4 is IBucketV3 {\\n    /**\\n     * @notice Performs a flash loan transfer of a specified amount to a receiver address.\\n     * @dev Only callable by the FLASH_LOAN_MANAGER_ROLE role.\\n     * @param _to The address to which the flash loan amount will be transferred.\\n     * @param _amount The amount of tokens to transfer in the flash loan.\\n     */\\n    function performFlashLoanTransfer(address _to, uint256 _amount) external;\\n\\n    /**\\n     * @notice Accumulates a predefined amount of asset to the bucket as a fixed, instantaneous income. Used\\n     * to accumulate the flashloan fee to the bucket, and spread it between all the suppliers.\\n     * @dev Only callable by the FLASH_LOAN_MANAGER_ROLE role.\\n     * @param amount The amount to accumulate\\n     * @param availableLiquidity The availableLiquidity before flashLoan\\n     */\\n    function cumulateToLiquidityIndex(uint256 amount, uint256 availableLiquidity) external;\\n\\n    /**\\n     * @notice Updates bucket's BAR and LAR.\\n     * @dev Only callable by the FLASH_LOAN_MANAGER_ROLE role.\\n     */\\n    function updateRates() external;\\n}\\n\",\"keccak256\":\"0x2b9127c5ba8e7c9ceb708d1490b85d8c3552fd05d531a74df8ad5dae8e9ec5e3\",\"license\":\"BUSL-1.1\"},\"contracts/Bucket/IBucketEvents.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IBucketEvents {\\n    event WithdrawFromAave(address indexed pool, uint256 amount);\\n    event Withdraw(address indexed withdrawer, address indexed borrowAssetReceiver, uint256 amount);\\n    event TopUpTreasury(address indexed sender, uint256 amount);\\n}\\n\",\"keccak256\":\"0xefe6ff5ba4275599f84dff3e9accda189d62681a99c2851a843925c287a045ba\",\"license\":\"BUSL-1.1\"},\"contracts/Bucket/IBucketStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport {IPToken} from \\\"../PToken/IPToken.sol\\\";\\nimport {IDebtToken} from \\\"../DebtToken/IDebtToken.sol\\\";\\nimport {IPositionManagerV2} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {IPriceOracleV2} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IReserve} from \\\"../Reserve/IReserve.sol\\\";\\nimport {ILiquidityMiningRewardDistributor} from \\\"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\\\";\\nimport {IWhiteBlackList} from \\\"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\\\";\\nimport {IInterestRateStrategy} from \\\"../interfaces/IInterestRateStrategy.sol\\\";\\n\\ninterface IBucketStorage {\\n    /**\\n     * @dev Parameters of liquidity mining\\n     */\\n    struct LiquidityMiningParams {\\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor;\\n        bool isBucketLaunched;\\n        uint256 accumulatingAmount;\\n        uint256 deadlineTimestamp;\\n        uint256 stabilizationDuration;\\n        uint256 stabilizationEndTimestamp;\\n        uint256 maxAmountPerUser; // if maxAmountPerUser is >= accumulatingAmount then check on maxAmountPerUser is off\\n        // Constant max variables are used for calculating users' points.\\n        // These intervals are used for fair distribution of points among Lenders.\\n        // Lenders who brought liquidity earlier receive more than the ones who deposited later.\\n        // To get maximum points per token, a Lender should deposit immediately after the Bucket deployment.\\n        uint256 maxDuration;\\n        uint256 maxStabilizationEndTimestamp;\\n    }\\n    //                                        1. Corner case of bucket launch\\n    //\\n    //                                              maxDuration\\n    //       ------------------------------------------------------------------------------------------------\\n    //      |                                                                                               |\\n    //      |                                                                        stabilizationDuration  |\\n    //      |                                                                      -------------------------|\\n    //      |                                                                     | bucket launch           |\\n    //   +--+---------------------------------------------------------------------+-------------------------+------> time\\n    //      bucket deploy                                                         deadlineTimestamp         maxStabilizationEndTimestamp\\n    //                                                                                                       (=stabilizationEndTimestamp here)\\n    //                                  (corner case of bucket launch)\\n\\n    //                                        2. One of cases of bucket launch\\n    //\\n    //      |                     stabilizationDuration\\n    //      |                   -------------------------\\n    //      |                  |                         |\\n    //   +--+------------------+-------------------------+------------------------+-------------------------+------> time\\n    //      bucket deploy      bucket launch            stabilizationEndTimestamp  deadlineTimestamp        maxStabilizationEndTimestamp\\n    //                                                                            (after deadline bucket can't be launched)\\n\\n    struct Asset {\\n        uint256 index;\\n        bool isSupported;\\n    }\\n\\n    function liquidityIndex() external returns (uint128);\\n\\n    function variableBorrowIndex() external returns (uint128);\\n\\n    function name() external view returns (string memory);\\n\\n    function registry() external view returns (address);\\n\\n    function positionManager() external view returns (IPositionManagerV2);\\n\\n    function reserve() external view returns (IReserve);\\n\\n    function permanentLossScaled() external view returns (uint256);\\n\\n    function pToken() external view returns (IPToken);\\n\\n    function debtToken() external view returns (IDebtToken);\\n\\n    function borrowedAsset() external view returns (IERC20Metadata);\\n\\n    function feeBuffer() external view returns (uint256);\\n\\n    function withdrawalFeeRate() external view returns (uint256);\\n\\n    /**\\n     * @notice bar = borrowing annual rate (originally APR)\\n     */\\n    function bar() external view returns (uint128);\\n\\n    /**\\n     * @notice lar = lending annual rate (originally APY)\\n     */\\n    function lar() external view returns (uint128);\\n\\n    function interestRateStrategy() external view returns (IInterestRateStrategy);\\n\\n    function estimatedBar() external view returns (uint128);\\n\\n    function estimatedLar() external view returns (uint128);\\n\\n    function allowedAssets(address _asset) external view returns (uint256, bool);\\n\\n    function whiteBlackList() external view returns (IWhiteBlackList);\\n\\n    function maxTotalDeposit() external view returns (uint256);\\n}\\n\\ninterface IBucketStorageV2 {\\n    function bucketExtension() external view returns (address);\\n}\\n\",\"keccak256\":\"0x0d992b76b9281db2418f75de141b8f002edb793224bbe265decd3433bc2fce3a\",\"license\":\"BUSL-1.1\"},\"contracts/Bucket/IBucketsFactory.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport {ILiquidityMiningRewardDistributor} from \\\"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\\\";\\nimport {IInterestRateStrategy} from \\\"../interfaces/IInterestRateStrategy.sol\\\";\\nimport {IPTokensFactory} from \\\"../PToken/IPTokensFactory.sol\\\";\\nimport {IDebtTokensFactory} from \\\"../DebtToken/IDebtTokensFactory.sol\\\";\\n\\ninterface IBucketsFactory {\\n    /**\\n     * @param nameBucket The name of the new Bucket\\n     * @param positionManager The address of PositionManager\\n     * @param assets The list of active assets in bucket\\n     * @param pairPriceDrops The list of pairPriceDrops for active assets\\n     * @param underlyingAsset The underlying asset for bucket operations\\n     * @param feeBuffer The fee buffer of the bucket\\n     * @param reserveRate The reserve portion of the interest that goes to the Primex reserve\\n     */\\n    struct CreateBucketParams {\\n        string nameBucket;\\n        address positionManager;\\n        address priceOracle;\\n        address dns;\\n        address reserve;\\n        address whiteBlackList;\\n        address[] assets;\\n        IERC20Metadata underlyingAsset;\\n        uint256 feeBuffer;\\n        uint256 withdrawalFeeRate;\\n        uint256 reserveRate;\\n        // liquidityMining params\\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor;\\n        uint256 liquidityMiningAmount; // if 0 liquidityMining is off\\n        uint256 liquidityMiningDeadline;\\n        uint256 stabilizationDuration;\\n        IInterestRateStrategy interestRateStrategy;\\n        uint256 maxAmountPerUser;\\n        bool isReinvestToAaveEnabled;\\n        uint128 estimatedBar;\\n        uint128 estimatedLar;\\n        bytes barCalcParams;\\n        uint256 maxTotalDeposit;\\n    }\\n\\n    event BucketCreated(address bucketAddress);\\n    event PTokensFactoryChanged(address pTokensFactory);\\n    event DebtTokensFactoryChanged(address debtTokensFactory);\\n\\n    function registry() external returns (address);\\n\\n    /**\\n     * @notice Creates a new Bucket. Deploys bucket, pToken, debtToken contracts.\\n     * @dev This function can be called by the MEDIUM_TIMELOCK_ADMIN or SMALL_TIMELOCK_ADMIN role\\n     * depending on the specific implementation. Ensure to check the designated admin roles\\n     * in the method of each implementation.\\n     * @param _params The parameters for creating the bucket.\\n     */\\n    function createBucket(CreateBucketParams memory _params) external;\\n\\n    /**\\n     * @notice Set a new pTokens factory contract address.\\n     * @dev This function can only be called by the DEFAULT_ADMIN_ROLE.\\n     * @param _pTokensFactory The address of a new pTokens factory contract to set.\\n     */\\n    function setPTokensFactory(IPTokensFactory _pTokensFactory) external;\\n\\n    /**\\n     * @notice Set a new debtTokens factory contract address.\\n     * @dev This function can only be called by the DEFAULT_ADMIN_ROLE.\\n     * @param _debtTokensFactory The address of a new debtTokens factory contract to set.\\n     */\\n    function setDebtTokensFactory(IDebtTokensFactory _debtTokensFactory) external;\\n\\n    /**\\n     * @dev Returns an array of all deployed bucket addresses.\\n     * @return list of all deployed buckets\\n     */\\n    function allBuckets() external view returns (address[] memory);\\n\\n    function buckets(uint256) external view returns (address);\\n}\\n\",\"keccak256\":\"0x694d048c696adf9d757181b7d88c379e077a4c911e36ba0368d39ab2c9e80651\",\"license\":\"BUSL-1.1\"},\"contracts/Constants.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.26;\\nimport {IArbGasInfo} from \\\"./interfaces/IArbGasInfo.sol\\\";\\nimport {IOVM_GasPriceOracle} from \\\"./interfaces/IOVM_GasPriceOracle.sol\\\";\\n\\n// admin roles\\nbytes32 constant BIG_TIMELOCK_ADMIN = 0x00; // It's primary admin.\\nbytes32 constant MEDIUM_TIMELOCK_ADMIN = keccak256(\\\"MEDIUM_TIMELOCK_ADMIN\\\");\\nbytes32 constant SMALL_TIMELOCK_ADMIN = keccak256(\\\"SMALL_TIMELOCK_ADMIN\\\");\\nbytes32 constant EMERGENCY_ADMIN = keccak256(\\\"EMERGENCY_ADMIN\\\");\\nbytes32 constant GUARDIAN_ADMIN = keccak256(\\\"GUARDIAN_ADMIN\\\");\\nbytes32 constant NFT_MINTER = keccak256(\\\"NFT_MINTER\\\");\\nbytes32 constant TRUSTED_TOLERABLE_LIMIT_ROLE = keccak256(\\\"TRUSTED_TOLERABLE_LIMIT_ROLE\\\");\\n\\n// inter-contract interactions roles\\nbytes32 constant NO_FEE_ROLE = keccak256(\\\"NO_FEE_ROLE\\\");\\nbytes32 constant VAULT_ACCESS_ROLE = keccak256(\\\"VAULT_ACCESS_ROLE\\\");\\nbytes32 constant PM_ROLE = keccak256(\\\"PM_ROLE\\\");\\nbytes32 constant LOM_ROLE = keccak256(\\\"LOM_ROLE\\\");\\nbytes32 constant BATCH_MANAGER_ROLE = keccak256(\\\"BATCH_MANAGER_ROLE\\\");\\nbytes32 constant FLASH_LOAN_MANAGER_ROLE = keccak256(\\\"FLASH_LOAN_MANAGER_ROLE\\\");\\nbytes32 constant FLASH_LOAN_FREE_BORROWER_ROLE = keccak256(\\\"FLASH_LOAN_FREE_BORROWER_ROLE\\\");\\n\\n// token constants\\naddress constant NATIVE_CURRENCY = address(uint160(bytes20(keccak256(\\\"NATIVE_CURRENCY\\\"))));\\naddress constant USD = 0x0000000000000000000000000000000000000348;\\naddress constant NATIVE_CURRENCY_CURVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\nuint256 constant USD_MULTIPLIER = 10 ** (18 - 8); // usd decimals in chainlink is 8\\nuint8 constant MAX_ASSET_DECIMALS = 18;\\n\\n// time constants\\nuint256 constant SECONDS_PER_YEAR = 365 days;\\nuint256 constant SECONDS_PER_DAY = 1 days;\\nuint256 constant HOUR = 1 hours;\\nuint256 constant TEN_WAD = 10 ether;\\n\\n// constants for Arbitrum payment model\\nIArbGasInfo constant ARB_NITRO_ORACLE = IArbGasInfo(0x000000000000000000000000000000000000006C);\\nuint256 constant TRANSACTION_METADATA_BYTES = 140;\\n\\nIOVM_GasPriceOracle constant OVM_GASPRICEORACLE = IOVM_GasPriceOracle(0x420000000000000000000000000000000000000F);\\n\\nuint256 constant GAS_FOR_BYTE = 16;\\n\\n// Magic values\\nuint256 constant TRADER_MAGIC_TIER = uint256(keccak256(\\\"TRADER_MAGIC_TIER\\\"));\\nuint256 constant LENDER_MAGIC_TIER = uint256(keccak256(\\\"LENDER_MAGIC_TIER\\\"));\\nuint256 constant FARMING_MAGIC_TIER = uint256(keccak256(\\\"FARMING_MAGIC_TIER\\\"));\\n\",\"keccak256\":\"0x806aeb2d3007701f19dd16fb2765b3e50c548869ca19310f096059b83ca339b5\",\"license\":\"BUSL-1.1\"},\"contracts/DebtToken/IDebtToken.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\n\\nimport {IDebtTokenStorage, IBucket, IFeeExecutor, IERC20Upgradeable, IActivityRewardDistributor} from \\\"./IDebtTokenStorage.sol\\\";\\n\\ninterface IDebtToken is IDebtTokenStorage {\\n    /**\\n     * @dev Emitted after the mint action\\n     * @param from The address performing the mint\\n     * @param value The amount being\\n     **/\\n    event Mint(address indexed from, uint256 value);\\n\\n    /**\\n     * @dev Emitted after DebtTokens are burned\\n     * @param from The owner of the aTokens, getting them burned\\n     * @param value The amount being burned\\n     **/\\n    event Burn(address indexed from, uint256 value);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param _name The name of the ERC20 token.\\n     * @param _symbol The symbol of the ERC20 token.\\n     * @param _decimals The number of decimals for the ERC20 token.\\n     * @param _bucketsFactory Address of the buckets factory that will call the setBucket fucntion\\n     */\\n    function initialize(string memory _name, string memory _symbol, uint8 _decimals, address _bucketsFactory) external;\\n\\n    /**\\n     * @dev Sets the bucket for the contract.\\n     * @param _bucket The address of the bucket to set.\\n     */\\n    function setBucket(IBucket _bucket) external;\\n\\n    /**\\n     * @dev Sets the FeeDecreaser for current DebtToken.\\n     * @param _feeDecreaser The interest increaser address.\\n     */\\n    function setFeeDecreaser(IFeeExecutor _feeDecreaser) external;\\n\\n    /**\\n     * @dev Sets the trader reward distributor contract address.\\n     * @param _traderRewardDistributor The address of the trader reward distributor contract.\\n     * Only the BIG_TIMELOCK_ADMIN role can call this function.\\n     */\\n    function setTraderRewardDistributor(IActivityRewardDistributor _traderRewardDistributor) external;\\n\\n    /**\\n     * @dev Mints `amount` DebtTokens to `user`\\n     * @param _user The address receiving the minted tokens\\n     * @param _amount The amount of tokens getting minted\\n     * @param _index The current variableBorrowIndex\\n     */\\n    function mint(address _user, uint256 _amount, uint256 _index) external;\\n\\n    /**\\n     * @dev Burns DebtTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n     * @param _user The owner of the DebtTokens, getting them burned\\n     * @param _amount The amount being burned\\n     * @param _index The current variableBorrowIndex\\n     **/\\n    function burn(address _user, uint256 _amount, uint256 _index) external;\\n\\n    /**\\n     * @dev Burns a batch of tokens from multiple users.\\n     * @param _users An array of user addresses whose tokens will be burned.\\n     * @param _amounts An array of token amounts to be burned for each user.\\n     * @param _index The index used to calculate the scaled amounts.\\n     * @param _length The length of the user and amounts arrays.\\n     */\\n    function batchBurn(address[] memory _users, uint256[] memory _amounts, uint256 _index, uint256 _length) external;\\n\\n    /**\\n     * @dev Returns the principal debt balance of the user\\n     * @param _user The address of the user.\\n     * @return The scaled balance of the user.\\n     */\\n    function scaledBalanceOf(address _user) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the scaled total supply of debtToken.\\n     * @return The scaled total supply of the debtToken.\\n     */\\n    function scaledTotalSupply() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xeb40ae51d2d32f11c8db3712dadffb01789ef30e2cb92643f707afcdc2223af1\",\"license\":\"BUSL-1.1\"},\"contracts/DebtToken/IDebtTokenStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport {IBucket, IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IFeeExecutor} from \\\"../BonusExecutor/IFeeExecutor.sol\\\";\\nimport {IActivityRewardDistributor} from \\\"../ActivityRewardDistributor/IActivityRewardDistributor.sol\\\";\\n\\ninterface IDebtTokenStorage is IERC20Upgradeable {\\n    function bucket() external view returns (IBucketV3);\\n\\n    function feeDecreaser() external view returns (IFeeExecutor);\\n\\n    function traderRewardDistributor() external view returns (IActivityRewardDistributor);\\n}\\n\",\"keccak256\":\"0x3839c065a8b034a56bcaf23d06be78df5d042f699944d5435d202eddab39e6ef\",\"license\":\"BUSL-1.1\"},\"contracts/DebtToken/IDebtTokensFactory.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IDebtToken} from \\\"./IDebtToken.sol\\\";\\n\\ninterface IDebtTokensFactory {\\n    /**\\n     * @dev Deploying a new DebtToken contract. Can be called by BucketsFactory only.\\n     * @param _name The name of the new DebtToken.\\n     * @param _symbol The symbol of the new DebtToken.\\n     */\\n    function createDebtToken(string memory _name, string memory _symbol, uint8 _decimals) external returns (IDebtToken);\\n\\n    /**\\n     * @dev Sets the BucketsFactory address. Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param bucketsFactory The BucketsFactory address.\\n     */\\n    function setBucketsFactory(address bucketsFactory) external;\\n\\n    /**\\n     * @dev Gets a BucketsFactory contract address.\\n     */\\n    function bucketsFactory() external view returns (address);\\n\\n    /**\\n     * @dev Gets a Registry contract address.\\n     */\\n    function registry() external view returns (address);\\n}\\n\",\"keccak256\":\"0x2e47d58895aa850d7da6ed171516d6c763bd5f3b2d3820e2a5972267c943a0a8\",\"license\":\"BUSL-1.1\"},\"contracts/KeeperRewardDistributor/IKeeperRewardDistributor.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IKeeperRewardDistributorStorage, IKeeperRewardDistributorStorageV2} from \\\"./IKeeperRewardDistributorStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface IKeeperRewardDistributorV3 is IKeeperRewardDistributorStorageV2, IPausable {\\n    struct DecreasingGasByReasonParams {\\n        DecreasingReason reason;\\n        uint256 amount;\\n    }\\n    struct MaxGasPerPositionParams {\\n        KeeperActionType actionType;\\n        KeeperActionRewardConfig config;\\n    }\\n\\n    /**\\n     * @dev     Params for initialize() function\\n     * @param   priceOracle Address of the PriceOracle contract\\n     * @param   registry Address of the Registry contract\\n     * @param   pmx Address of PMXToken\\n     * @param   treasury Address of the Treasury contract\\n     * @param   pmxPartInReward Percentage of PMX in reward (in WAD)\\n     * @param   nativePartInReward  Percentage of native token in reward (in WAD)\\n     * @param   positionSizeCoefficient The reward param which is needed to calculate rewards, in WAD\\n     * @param   additionalGas Additional gas added to actual gas spent\\n     * @param   defaultMaxGasPrice Max gas price allowed during reward calculation (used when no oracle price found)\\n     * @param   oracleGasPriceTolerance Percentage by which oracle gas price can be exceeded (in WAD)\\n     * @param   paymentModel The model of payment for gas in the network\\n     * @param   maxGasPerPositionParams Parameters for the setMaxGasPerPosition function\\n     * @param   decreasingGasByReasonParams Parameters for the setDecreasingGasByReason function\\n     */\\n    struct InitParams {\\n        address priceOracle;\\n        address registry;\\n        address pmx;\\n        address treasury;\\n        address whiteBlackList;\\n        uint256 pmxPartInReward;\\n        uint256 nativePartInReward;\\n        uint256 positionSizeCoefficient;\\n        uint256 additionalGas;\\n        uint256 defaultMaxGasPrice;\\n        uint256 oracleGasPriceTolerance;\\n        PaymentModel paymentModel;\\n        MaxGasPerPositionParams[] maxGasPerPositionParams;\\n        DecreasingGasByReasonParams[] decreasingGasByReasonParams;\\n    }\\n\\n    event ClaimFees(address indexed keeper, address indexed asset, uint256 amount);\\n    event DefaultMaxGasPriceChanged(uint256 indexed defaultMaxGasPrice);\\n    event OracleGasPriceToleranceChanged(uint256 indexed oracleGasPriceTolerance);\\n    event MaxGasPerPositionChanged(KeeperActionType indexed actionType, KeeperActionRewardConfig config);\\n    event DataLengthRestrictionsChanged(KeeperCallingMethod callingMethod, uint256 maxRoutesLength, uint256 baseLength);\\n    event DecreasingGasByReasonChanged(DecreasingReason indexed reason, uint256 amount);\\n    event PmxPartInRewardChanged(uint256 indexed pmxPartInReward);\\n    event NativePartInRewardChanged(uint256 indexed nativePartInReward);\\n    event PositionSizeCoefficientChanged(uint256 indexed positionSizeCoefficient);\\n    event AdditionalGasChanged(uint256 indexed additionalGas);\\n    event KeeperRewardUpdated(address indexed keeper, uint256 rewardInPmx, uint256 rewardInNativeCurrency);\\n    event MinPositionSizeAddendChanged(uint256 newMinPositionSizeAddend);\\n    event OptimisticGasCoefficientChanged(uint256 newOptimismGasCoefficient);\\n\\n    /**\\n     * @notice Initializes the KeeperRewardDistributor contract.\\n     * @param _params  Parameters for initialization\\n     */\\n    function initialize(InitParams calldata _params) external;\\n\\n    /**\\n     * @dev Params for the updateReward function\\n     * @param keeper  Address of the keeper\\n     * @param positionAsset  Address of the position asset\\n     * @param positionSize  Size of the position\\n     * @param action  The action that was performed by the keeper\\n     * @param numberOfActions  Number of actions performed by the keeper\\n     * @param gasSpent Gas spent on executing transaction\\n     * @param decreasingCounter An array where each index contains the number of decreasing reasons according to the DecreasingReason enum\\n     * @param routesLength  The length of routes provided as input to the protocol function,\\n     * subject to an additional commission in the ARBITRUM payment model.\\n     */\\n\\n    struct UpdateRewardParams {\\n        address keeper;\\n        address positionAsset;\\n        uint256 positionSize;\\n        KeeperActionType action;\\n        uint256 numberOfActions;\\n        uint256 gasSpent;\\n        uint256[] decreasingCounter;\\n        uint256 routesLength;\\n        bytes nativePmxOracleData;\\n        bytes positionNativeAssetOracleData;\\n    }\\n\\n    /**\\n     * @notice Updates reward for keeper for closing position or executing order\\n     * @dev Only callable by the PM_ROLE, LOM_ROLE, BATCH_MANAGER_ROLE roles.\\n     * @param _params The UpdateRewardParams params\\n     */\\n    function updateReward(UpdateRewardParams calldata _params) external;\\n\\n    /**\\n     * @notice Claims earned reward of the keeper\\n     * @param _pmxAmount  Amount of PMX token to claim\\n     * @param _nativeAmount  Amount of native token to claim\\n     */\\n    function claim(uint256 _pmxAmount, uint256 _nativeAmount) external;\\n\\n    /**\\n     * @notice Sets the default maximum gas price allowed.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _defaultMaxGasPrice The new default maximum gas price value.\\n     */\\n    function setDefaultMaxGasPrice(uint256 _defaultMaxGasPrice) external;\\n\\n    /**\\n     * @notice Sets the amount of gas to be removed for the specified reason\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _reason The reason for which an amount is set\\n     * @param _amount Gas amount.\\n     */\\n    function setDecreasingGasByReason(DecreasingReason _reason, uint256 _amount) external;\\n\\n    /**\\n     * @notice Sets the KeeperActionRewardConfig for the specified action type\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _actionType The action type for which the config is set\\n     * @param _config The KeeperActionRewardConfig struct\\n     */\\n\\n    function setMaxGasPerPosition(KeeperActionType _actionType, KeeperActionRewardConfig calldata _config) external;\\n\\n    /**\\n     * @notice Sets the dataLengthRestrictions for the specified KeeperCallingMethod.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _callingMethod The calling method for which dataLengthRestrictions is set\\n     * @param _maxRoutesLength The maximum routes length for which an additional fee will be paid in the ARBITRUM payment model, in bytes\\n     * @param _baseLength The length of the data entering the protocol function including method signature\\n     * and excluding dynamic types(e.g, routesLength), in bytes\\n     */\\n    function setDataLengthRestrictions(\\n        KeeperCallingMethod _callingMethod,\\n        uint256 _maxRoutesLength,\\n        uint256 _baseLength\\n    ) external;\\n\\n    /**\\n     * @notice Sets the tolerance for gas price fluctuations from the oracle price.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _oracleGasPriceTolerance The new oracle gas price tolerance value (percent expressed as WAD).\\n     */\\n    function setOracleGasPriceTolerance(uint256 _oracleGasPriceTolerance) external;\\n\\n    /**\\n     * @notice Sets the PMX token's portion in the reward calculation.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _pmxPartInReward The new PMX token's portion in the reward calculation (percent expressed as WAD).\\n     */\\n    function setPmxPartInReward(uint256 _pmxPartInReward) external;\\n\\n    /**\\n     * @notice Sets the native token's portion in the reward calculation.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _nativePartInReward The new native token's portion in the reward calculation (percent expressed as WAD).\\n     */\\n    function setNativePartInReward(uint256 _nativePartInReward) external;\\n\\n    /**\\n     * @notice Sets the position size coefficients for reward calculations.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _positionSizeCoefficient The new positionSizeCoefficient value (in WAD).\\n     */\\n    function setPositionSizeCoefficient(uint256 _positionSizeCoefficient) external;\\n\\n    /**\\n     * @notice Sets the additional gas value for reward calculations.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _additionalGas The new additionalGas value.\\n     */\\n    function setAdditionalGas(uint256 _additionalGas) external;\\n\\n    /**\\n     * @notice Sets the minPositionSizeAddend for reward calculations.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _minPositionSizeAddend The new minPositionSizeAddend value (in WAD).\\n     */\\n\\n    function setMinPositionSizeAddend(uint256 _minPositionSizeAddend) external;\\n\\n    /**\\n     * @notice Retrieves gas calculation params.\\n     *\\n     * @return oracleGasPriceTolerance The tolerance for gas price fluctuations based on the oracle.\\n     * @return defaultMaxGasPrice The default maximum gas price allowed.\\n     */\\n    function getGasCalculationParams() external view returns (uint256, uint256, uint256, PaymentModel);\\n\\n    /**\\n     * @notice Sets the optimisticGasCoefficient for optimism paymentModel.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _newOptimisticGasCoefficient The new optimisticGasCoefficient value (in WAD).\\n     */\\n    function setOptimisticGasCoefficient(uint256 _newOptimisticGasCoefficient) external;\\n}\\n\",\"keccak256\":\"0xe7e8ed68096946966302efb5863878bf7cc40ae6aa353d995da1f4116efc04b0\",\"license\":\"BUSL-1.1\"},\"contracts/KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IKeeperRewardDistributorStorage {\\n    enum DecreasingReason {\\n        NonExistentIdForLiquidation,\\n        NonExistentIdForSLOrTP,\\n        IncorrectConditionForLiquidation,\\n        IncorrectConditionForSL,\\n        ClosePostionInTheSameBlock\\n    }\\n\\n    enum KeeperActionType {\\n        OpenByOrder,\\n        StopLoss,\\n        TakeProfit,\\n        Liquidation,\\n        BucketDelisted\\n    }\\n\\n    enum KeeperCallingMethod {\\n        ClosePositionByCondition,\\n        OpenPositionByOrder,\\n        CloseBatchPositions\\n    }\\n\\n    /**\\n     * @dev Structure used in the calculation of keeper rewards in the ARBITRUM payment model\\n     * @param maxRoutesLength The maximum length of routes for which will be paid keeper rewards, depending on KeeperCallingMethod\\n     * @param baseLength The static length of the data entering the protocol function, depending on KeeperCallingMethod\\n     */\\n    struct DataLengthRestrictions {\\n        uint256 maxRoutesLength;\\n        uint256 baseLength;\\n    }\\n\\n    /**\\n     * @dev Structure used in the calculation of maximum gas per position\\n     * @param baseMaxGas1 Base gas amount that used to calculate max gas amount\\n     * @param baseMaxGas2 Base gas amount that used to calculate max gas amount when number of keeper actions > inflectionPoint\\n     * @param multiplier2 The multiplier which is multiplied by the number of keeper actions when number of keeper actions > inflectionPoint\\n     * @param inflectionPoint Number of actions after which the multiplier2 takes effect\\n     */\\n    struct KeeperActionRewardConfig {\\n        uint256 baseMaxGas1;\\n        uint256 baseMaxGas2;\\n        uint256 multiplier1;\\n        uint256 multiplier2;\\n        uint256 inflectionPoint;\\n    }\\n\\n    struct KeeperBalance {\\n        uint256 pmxBalance;\\n        uint256 nativeBalance;\\n    }\\n    enum PaymentModel {\\n        DEFAULT,\\n        ARBITRUM,\\n        OPTIMISTIC // not for only optimism mainnet, but also for chains OP-Stack based chains like the Base\\n    }\\n\\n    function priceOracle() external view returns (address);\\n\\n    function registry() external view returns (address);\\n\\n    function pmx() external view returns (address);\\n\\n    function treasury() external view returns (address payable);\\n\\n    function pmxPartInReward() external view returns (uint256);\\n\\n    function nativePartInReward() external view returns (uint256);\\n\\n    function positionSizeCoefficient() external view returns (uint256);\\n\\n    function positionSizeCoefficientB() external view returns (int256);\\n\\n    function additionalGas() external view returns (uint256);\\n\\n    function defaultMaxGasPrice() external view returns (uint256);\\n\\n    function oracleGasPriceTolerance() external view returns (uint256);\\n\\n    function paymentModel() external view returns (PaymentModel);\\n\\n    function keeperBalance(address) external view returns (uint256, uint256);\\n\\n    function maxGasPerPosition(KeeperActionType) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function dataLengthRestrictions(KeeperCallingMethod) external view returns (uint256, uint256);\\n\\n    function decreasingGasByReason(DecreasingReason) external view returns (uint256);\\n\\n    function totalBalance() external view returns (uint256, uint256);\\n}\\n\\ninterface IKeeperRewardDistributorStorageV2 is IKeeperRewardDistributorStorage {\\n    function minPositionSizeAddend() external view returns (uint256);\\n\\n    function optimisticGasCoefficient() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xa0039900733afe2e8403358176a91090383e28f72308b93f2c6d1191e6c10540\",\"license\":\"BUSL-1.1\"},\"contracts/LimitOrderManager/ILimitOrderManager.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\nimport {ILimitOrderManagerStorage} from \\\"./ILimitOrderManagerStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ILimitOrderManager is ILimitOrderManagerStorage, IPausable {\\n    enum LimitOrderType {\\n        Margin,\\n        Spot,\\n        Swap\\n    }\\n\\n    struct UpdateOrderConditionsParams {\\n        uint256 orderId;\\n        LimitOrderLibrary.Condition[] openConditions;\\n        LimitOrderLibrary.Condition[] closeConditions;\\n    }\\n\\n    event CreateLimitOrder(\\n        uint256 indexed orderId,\\n        address indexed trader,\\n        LimitOrderLibrary.LimitOrder order,\\n        LimitOrderLibrary.Condition[] openConditions,\\n        LimitOrderLibrary.Condition[] closeConditions\\n    );\\n\\n    event CloseLimitOrder(\\n        uint256 indexed orderId,\\n        address indexed trader,\\n        address indexed closedBy,\\n        LimitOrderLibrary.CloseReason reason,\\n        uint256 positionId,\\n        // TODO: can delete args below when front be ready for it\\n        string bucket,\\n        address borrowedAsset,\\n        address positionAsset,\\n        uint256 leverage,\\n        address depositAsset,\\n        uint256 depositAmount\\n    );\\n\\n    event UpdateOrder(\\n        uint256 indexed orderId,\\n        address indexed trader,\\n        uint256 depositAmount,\\n        uint256 leverage,\\n        address feeToken\\n    );\\n\\n    event UpdateOrderConditions(\\n        uint256 indexed orderId,\\n        address indexed trader,\\n        LimitOrderLibrary.Condition[] openConditions,\\n        LimitOrderLibrary.Condition[] closeConditions\\n    );\\n\\n    /**\\n     * @notice Initializes the LimitOrderManager contract.\\n     * @param _registry The address of the Registry contract.\\n     * @param _primexDNS The address of the PrimexDNS contract.\\n     * @param _pm The address of the PositionManager contract.\\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\\n     * @param _swapManager The address of the SwapManager contract.\\n     * @param _whiteBlackList The address of the WhiteBlacklist contract.\\n     */\\n    function initialize(\\n        address _registry,\\n        address _primexDNS,\\n        address _pm,\\n        address payable _traderBalanceVault,\\n        address _swapManager,\\n        address _whiteBlackList\\n    ) external;\\n\\n    /**\\n     * @notice Creates a limit order.\\n     * @dev This function allows users to create a limit order and locks the deposit asset in the traderBalanceVault\\n     * @param _params The parameters necessary to create limit order\\n     */\\n    function createLimitOrder(LimitOrderLibrary.CreateLimitOrderParams calldata _params) external payable;\\n\\n    /**\\n     * @notice Cancels the order. Can only be called by the trader\\n     * @param _orderId order id\\n     */\\n    function cancelLimitOrder(uint256 _orderId) external;\\n\\n    /**\\n     * @notice Removes expired limit orders\\n     * @param _orderIds The array of order IDs to remove.\\n     */\\n    function cancelExpiredLimitOrders(uint256[] calldata _orderIds) external;\\n\\n    /**\\n     * @notice Opens a position by an existing order.\\n     * @dev This function is called to open a position based on the given order parameters.\\n     * @param _params The OpenPositionParams struct containing the necessary parameters for opening the position.\\n     */\\n    function openPositionByOrder(LimitOrderLibrary.OpenPositionParams calldata _params) external payable;\\n\\n    /**\\n     * @notice Updates an existing limit order.\\n     * @dev Edits prices on an existing order\\n     * @param _params The parameters for updating the limit order.\\n     */\\n    function updateOrder(LimitOrderLibrary.UpdateLimitOrderParams calldata _params) external payable;\\n\\n    /**\\n     * @notice Updates the open and close conditions of an order.\\n     * @dev Only the trader of the order can update the conditions.\\n     * @param _params The parameters for updating the order conditions.\\n     */\\n    function updateOrderConditions(UpdateOrderConditionsParams memory _params) external;\\n\\n    /**\\n     * @notice Function to set new swapManager.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _swapManager Address of the new swapManager.\\n     */\\n    function setSwapManager(address _swapManager) external;\\n\\n    /**\\n     * @notice Retrieves the details of a limit order based on its ID.\\n     * @param _id The ID of the limit order to retrieve.\\n     * @return The LimitOrder struct representing the limit order.\\n     */\\n    function getOrder(uint256 _id) external view returns (LimitOrderLibrary.LimitOrder memory);\\n\\n    /**\\n     * @notice Retrieves the limit order at the specified index.\\n     * @param _index The index of the limit order to retrieve.\\n     * @return The limit order at the specified index.\\n     */\\n    function getOrderByIndex(uint256 _index) external view returns (LimitOrderLibrary.LimitOrder memory);\\n\\n    /**\\n     * @notice Retrieves the close conditions associated with the given order ID.\\n     * @param _orderId The ID of the order.\\n     * @return An array of Condition representing the close conditions.\\n     */\\n    function getCloseConditions(uint256 _orderId) external view returns (LimitOrderLibrary.Condition[] memory);\\n\\n    /**\\n     * @notice Retrieves the open conditions associated with a given order ID.\\n     * @param _orderId The ID of the order.\\n     * @return An array of Condition structs representing the open conditions.\\n     */\\n    function getOpenConditions(uint256 _orderId) external view returns (LimitOrderLibrary.Condition[] memory);\\n\\n    /**\\n     * @notice Returns the length of the orders array.\\n     * @return The number of orders in the array.\\n     */\\n    function getOrdersLength() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the length of the order array for a specific trader.\\n     * @param _trader The address of the trader.\\n     * @return The length of the order array.\\n     */\\n    function getTraderOrdersLength(address _trader) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns an array of LimitOrder structures representing the orders placed by a specific trader.\\n     * @param _trader The address of the trader.\\n     * @return traderOrders An array of LimitOrder structures representing the orders placed by the trader.\\n     */\\n    function getTraderOrders(address _trader) external view returns (LimitOrderLibrary.LimitOrder[] memory);\\n\\n    /**\\n     * @notice Returns the length of orders in a bucket.\\n     * @param _bucket The address of the bucket.\\n     * @return The number of orders in the bucket.\\n     */\\n    function getBucketOrdersLength(address _bucket) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves all limit orders associated with a given bucket.\\n     * @param _bucket The address of the bucket.\\n     * @return An array of LimitOrder structs representing the bucket's orders.\\n     */\\n    function getBucketOrders(address _bucket) external view returns (LimitOrderLibrary.LimitOrder[] memory);\\n}\\n\\ninterface ILimitOrderManagerV2 is ILimitOrderManager {\\n    event ChangeSwapManager(address swapManager);\\n}\\n\",\"keccak256\":\"0xec3ca8f04600f0ea976100706c9ff8881cea9ea77e987326b667ab7318a01457\",\"license\":\"BUSL-1.1\"},\"contracts/LimitOrderManager/ILimitOrderManagerStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IPositionManagerV2} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {ISwapManager} from \\\"../SwapManager/ISwapManager.sol\\\";\\n\\ninterface ILimitOrderManagerStorage {\\n    function ordersId() external view returns (uint256);\\n\\n    function orderIndexes(uint256) external view returns (uint256);\\n\\n    function traderOrderIndexes(uint256) external view returns (uint256);\\n\\n    function traderOrderIds(address _trader, uint256 _index) external view returns (uint256);\\n\\n    function bucketOrderIndexes(uint256) external view returns (uint256);\\n\\n    function bucketOrderIds(address _bucket, uint256 _index) external view returns (uint256);\\n\\n    function registry() external view returns (IAccessControl);\\n\\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\\n\\n    function primexDNS() external view returns (IPrimexDNSV3);\\n\\n    function pm() external view returns (IPositionManagerV2);\\n\\n    function swapManager() external view returns (ISwapManager);\\n}\\n\",\"keccak256\":\"0x013245257f25e09b29cce44ca82bde8dcc6baa604164d473ba270d486c9037a9\",\"license\":\"BUSL-1.1\"},\"contracts/LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IWhiteBlackList} from \\\"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\\\";\\nimport {ILiquidityMiningRewardDistributorStorage} from \\\"./ILiquidityMiningRewardDistributorStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ILiquidityMiningRewardDistributor is ILiquidityMiningRewardDistributorStorage, IPausable {\\n    struct RewardsInPMX {\\n        uint256 minReward;\\n        uint256 maxReward;\\n        uint256 extraReward;\\n    }\\n\\n    /**\\n     * @notice Emitted when a reward is claimed by a receiver from a specific bucket.\\n     * @param receiver The address of the receiver.\\n     * @param bucket The address of the bucket from which the reward is claimed.\\n     * @param amount The amount of the claimed reward.\\n     */\\n    event ClaimedReward(address indexed receiver, address indexed bucket, uint256 amount);\\n    /**\\n     * @notice Emitted when PMX tokens are withdrawn by an admin.\\n     * @param amount The amount of PMX tokens withdrawn.\\n     */\\n    event WithdrawPmxByAdmin(uint256 indexed amount);\\n\\n    /**\\n     * @notice Initializes the contract with the specified parameters.\\n     * @param _primexDNS The address of the IPrimexDNS contract.\\n     * @param _pmx The address of the PMX token contract.\\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\\n     * @param _registry The address of the registry contract.\\n     * @param _treasury The address of the treasury contract.\\n     * @param _reinvestmentRate The rate at which rewards are reinvested.\\n     * @param _reinvestmentDuration The duration for which rewards are reinvested.\\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\\n     */\\n    function initialize(\\n        IPrimexDNSV3 _primexDNS,\\n        IERC20 _pmx,\\n        ITraderBalanceVault _traderBalanceVault,\\n        address _registry,\\n        address _treasury,\\n        uint256 _reinvestmentRate,\\n        uint256 _reinvestmentDuration,\\n        IWhiteBlackList _whiteBlackList\\n    ) external;\\n\\n    /**\\n     * @notice Updates the reward amount for a specific bucket.\\n     * @dev Only callable by the PrimexDNS contract.\\n     * @param _bucketName The name of the bucket.\\n     * @param _pmxRewardsAmount The amount of PMX rewards to be allocated to the bucket.\\n     */\\n    function updateBucketReward(string memory _bucketName, uint256 _pmxRewardsAmount) external;\\n\\n    /**\\n     * @notice Adds points for a user for future reward distribution.\\n     * @dev Only callable by the Bucket contract.\\n     * @param _bucketName The name of the bucket.\\n     * @param _user The address of the user.\\n     * @param _miningAmount The amount of mining points to be added.\\n     * @param _maxStabilizationPeriodEnd The maximum end timestamp of the stabilization period.\\n     * @param _maxPeriodTime The maximum period time.\\n     * @param _currentTimestamp The current timestamp.\\n     */\\n    function addPoints(\\n        string memory _bucketName,\\n        address _user,\\n        uint256 _miningAmount,\\n        uint256 _maxStabilizationPeriodEnd,\\n        uint256 _maxPeriodTime,\\n        uint256 _currentTimestamp\\n    ) external;\\n\\n    /**\\n     * @notice Removes points for a user.\\n     * @dev Only callable by the Bucket contract.\\n     * @param _name The name of the bucket.\\n     * @param _user The address of the user.\\n     * @param _amount The amount of mining points to be removed.\\n     */\\n    function removePoints(string memory _name, address _user, uint256 _amount) external;\\n\\n    /**\\n     * @notice Claims the accumulated rewards for a specific bucket.\\n     * @param _bucketName The name of the bucket.\\n     */\\n    function claimReward(string memory _bucketName) external;\\n\\n    /**\\n     * @notice Moves rewards from one bucket to another.\\n     * @dev Only callable by the Bucket contract.\\n     * @param _bucketFrom The name of the source bucket.\\n     * @param _bucketTo The name of the destination bucket.\\n     * @param _user The address of the user.\\n     * @param _isBucketLaunched A flag indicating if the destination bucket is launched.\\n     * @param _liquidityMiningDeadline The deadline for liquidity mining\\n     */\\n    function reinvest(\\n        string memory _bucketFrom,\\n        string memory _bucketTo,\\n        address _user,\\n        bool _isBucketLaunched,\\n        uint256 _liquidityMiningDeadline\\n    ) external;\\n\\n    /**\\n     * @dev The function to withdraw PMX from a delisted bucket or a bucket where liquidity mining failed (after reinvesting period).\\n     * Emits WithdrawPmxByAdmin event.\\n     * @param _bucketFrom Name of the bucket with failed liquidity mining event.\\n     */\\n    function withdrawPmxByAdmin(string memory _bucketFrom) external;\\n\\n    /**\\n     * @notice Retrieves information about a lender in a specific bucket.\\n     * @param _bucketName The name of the bucket.\\n     * @param _lender The address of the lender.\\n     * @param _timestamp The timestamp for which the information is queried.\\n     * @return amountInMining The amount of tokens the lender has in mining for the given bucket.\\n     * @return currentPercent The current percentage of rewards the lender is eligible to receive for the given bucket.\\n     * Measured in WAD (1 WAD = 100%).\\n     * @return rewardsInPMX An object containing information about the lender's rewards in PMX for the given bucket.\\n     */\\n    function getLenderInfo(\\n        string calldata _bucketName,\\n        address _lender,\\n        uint256 _timestamp\\n    ) external view returns (uint256 amountInMining, uint256 currentPercent, RewardsInPMX memory rewardsInPMX);\\n\\n    /**\\n     * @notice Retrieves rewards information about a specific bucket.\\n     * @param _bucketName The name of the bucket.\\n     * @return totalPmxReward The total amount of PMX reward in the bucket.\\n     * @return withdrawnRewards The total amount of withdrawn rewards from the bucket.\\n     * @return totalPoints The total number of mining points in the bucket.\\n     */\\n    function getBucketInfo(\\n        string calldata _bucketName\\n    ) external view returns (uint256 totalPmxReward, uint256 withdrawnRewards, uint256 totalPoints);\\n\\n    /**\\n     * @notice Retrieves the amount of tokens a lender has in mining for a specific bucket.\\n     * @param _bucket The name of the bucket.\\n     * @param _lender The address of the lender.\\n     * @return The amount of tokens the lender has in mining for the given bucket.\\n     */\\n    function getLenderAmountInMining(string calldata _bucket, address _lender) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x20c7cd863230da4fc92831e99263814c285a45cc4779525b5433222d2370c264\",\"license\":\"BUSL-1.1\"},\"contracts/LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributorStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\n\\ninterface ILiquidityMiningRewardDistributorStorage {\\n    struct LenderInfo {\\n        uint256 points;\\n        uint256 depositedAmount;\\n    }\\n\\n    struct BucketInfo {\\n        uint256 totalPoints;\\n        uint256 totalPmxReward;\\n        uint256 withdrawnRewards;\\n        mapping(address => LenderInfo) lendersInfo;\\n    }\\n\\n    function primexDNS() external view returns (IPrimexDNSV3);\\n\\n    function pmx() external view returns (IERC20);\\n\\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\\n\\n    function registry() external view returns (address);\\n\\n    function reinvestmentRate() external view returns (uint256);\\n\\n    function reinvestmentDuration() external view returns (uint256);\\n\\n    function extraRewards(address, string calldata) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb89b62cf6cc5c1fdeb7209b86973b46610ff7b48b114c9b0cd850507c45e3c2a\",\"license\":\"BUSL-1.1\"},\"contracts/PToken/IPToken.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\n\\nimport {IPTokenStorage, IBucket, IBucketV3, IFeeExecutor, IERC20MetadataUpgradeable, IActivityRewardDistributor} from \\\"./IPTokenStorage.sol\\\";\\n\\ninterface IPToken is IPTokenStorage {\\n    /**\\n     * @dev Emitted after the mint action\\n     * @param from The address performing the mint\\n     * @param value The amount being\\n     */\\n    event Mint(address indexed from, uint256 value);\\n\\n    /**\\n     * @dev Emitted after pTokens are burned\\n     * @param from The owner of the aTokens, getting them burned\\n     * @param value The amount being burned\\n     */\\n    event Burn(address indexed from, uint256 value);\\n\\n    /**\\n     * @dev Emitted during the transfer action\\n     * @param from The user whose tokens are being transferred\\n     * @param to The recipient\\n     * @param amount The amount being transferred\\n     * @param index The new liquidity index of the reserve\\n     */\\n    event BalanceTransfer(address indexed from, address indexed to, uint256 amount, uint256 index);\\n\\n    event LockDeposit(address indexed user, uint256 indexed id, uint256 deadline, uint256 amount);\\n    event UnlockDeposit(address indexed user, uint256 indexed id);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param _name The name of the ERC20 token.\\n     * @param _symbol The symbol of the ERC20 token.\\n     * @param _decimals The number of decimals for the ERC20 token.\\n     * @param _bucketsFactory Address of the buckets factory that will call the setBucket fucntion\\n     */\\n    function initialize(string memory _name, string memory _symbol, uint8 _decimals, address _bucketsFactory) external;\\n\\n    /**\\n     * @dev Sets the bucket for the contract.\\n     * @param _bucket The address of the bucket to set.\\n     */\\n    function setBucket(IBucket _bucket) external;\\n\\n    /**\\n     * @dev Sets the InterestIncreaser for current PToken.\\n     * @param _interestIncreaser The interest increaser address.\\n     */\\n    function setInterestIncreaser(IFeeExecutor _interestIncreaser) external;\\n\\n    /**\\n     * @dev Sets the lender reward distributor contract address.\\n     * @param _lenderRewardDistributor The address of the lender reward distributor contract.\\n     */\\n    function setLenderRewardDistributor(IActivityRewardDistributor _lenderRewardDistributor) external;\\n\\n    /**\\n     * @notice Locks a deposit for a specified user.\\n     * @param _user The address of the user for whom the deposit is being locked.\\n     * @param _amount The amount to be locked as a deposit.\\n     * @param _duration The duration for which the deposit will be locked.\\n     * @dev This function can only be called externally and overrides the corresponding function in the parent contract.\\n     * @dev The user must not be blacklisted.\\n     */\\n    function lockDeposit(address _user, uint256 _amount, uint256 _duration) external;\\n\\n    /**\\n     * @dev Unlocks a specific deposit.\\n     * @param _depositId The ID of the deposit to be unlocked.\\n     */\\n    function unlockDeposit(uint256 _depositId) external;\\n\\n    /**\\n     * @dev Mints `amount` pTokens to `user`\\n     * @param _user The address receiving the minted tokens\\n     * @param _amount The amount of tokens getting minted\\n     * @param _index The current liquidityIndex\\n     * @return Minted amount of PTokens\\n     */\\n    function mint(address _user, uint256 _amount, uint256 _index) external returns (uint256);\\n\\n    /**\\n     * @dev Mints pTokens to the reserve address\\n     * Compared to the normal mint, we don't revert when the amountScaled is equal to the zero. Additional checks were also removed\\n     * Only callable by the Bucket\\n     * @param _reserve The address of the reserve\\n     * @param _amount The amount of tokens getting minted\\n     * @param _index The current liquidityIndex\\n     */\\n    function mintToReserve(address _reserve, uint256 _amount, uint256 _index) external;\\n\\n    /**\\n     * @dev Burns pTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n     * @param _user The owner of the pTokens, getting them burned\\n     * @param _amount The amount of underlying token being returned to receiver\\n     * @param _index The current liquidityIndex\\n     * @return Burned amount of PTokens\\n     */\\n    function burn(address _user, uint256 _amount, uint256 _index) external returns (uint256);\\n\\n    /**\\n     * @dev Returns the scaled balance of the user.\\n     * @param _user The owner of pToken\\n     * @return The scaled balances of the user\\n     */\\n    function scaledBalanceOf(address _user) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns available balance of the user.\\n     * @param _user The owner of pToken\\n     * @return The available balance of the user\\n     */\\n    function availableBalanceOf(address _user) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns locked deposits and balance of user\\n     * @param _user The owner of locked deposits\\n     * @return Structure with deposits and total locked balance of user\\n     */\\n    function getUserLockedBalance(address _user) external view returns (LockedBalance memory);\\n\\n    /**\\n     * @dev Returns the scaled total supply of pToken.\\n     * @return The scaled total supply of the pToken.\\n     */\\n    function scaledTotalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Function to get a deposit index in user's deposit array.\\n     * @param id Deposit id.\\n     * @return index Deposit index in user's 'deposit' array.\\n     */\\n    function getDepositIndexById(uint256 id) external returns (uint256 index);\\n}\\n\",\"keccak256\":\"0x180185e60157be84a899b0f6201aae3af5e9a98c5f016054658d14fc2559d70e\",\"license\":\"BUSL-1.1\"},\"contracts/PToken/IPTokenStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\nimport {IBucket, IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IFeeExecutor} from \\\"../BonusExecutor/IFeeExecutor.sol\\\";\\nimport {IActivityRewardDistributor} from \\\"../ActivityRewardDistributor/IActivityRewardDistributor.sol\\\";\\n\\ninterface IPTokenStorage is IERC20MetadataUpgradeable {\\n    struct Deposit {\\n        uint256 lockedBalance;\\n        uint256 deadline;\\n        uint256 id;\\n    }\\n\\n    struct LockedBalance {\\n        uint256 totalLockedBalance;\\n        Deposit[] deposits;\\n    }\\n\\n    function bucket() external view returns (IBucketV3);\\n\\n    function interestIncreaser() external view returns (IFeeExecutor);\\n\\n    function lenderRewardDistributor() external view returns (IActivityRewardDistributor);\\n}\\n\",\"keccak256\":\"0xc3156264a851ed48f66e8099fb7595ea9c99c2eaed9ad6790b0d5412dd1fcf69\",\"license\":\"BUSL-1.1\"},\"contracts/PToken/IPTokensFactory.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IPToken} from \\\"./IPToken.sol\\\";\\n\\ninterface IPTokensFactory {\\n    /**\\n     * @dev Deploying a new PToken contract. Can be called by BucketsFactory only.\\n     * @param _name The name of the new PToken.\\n     * @param _symbol The symbol of the new PToken.\\n     */\\n    function createPToken(string memory _name, string memory _symbol, uint8 _decimals) external returns (IPToken);\\n\\n    /**\\n     * @dev Sets the BucketsFactory address. Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param bucketsFactory The BucketsFactory address.\\n     */\\n    function setBucketsFactory(address bucketsFactory) external;\\n\\n    /**\\n     * @dev Gets a BucketsFactory contract address.\\n     */\\n    function bucketsFactory() external view returns (address);\\n\\n    /**\\n     * @dev Gets a Registry contract address.\\n     */\\n    function registry() external view returns (address);\\n}\\n\",\"keccak256\":\"0xca978f6db4e5c7c8784bc86d536785ec5882c8729e43527fe34b743f70ff7069\",\"license\":\"BUSL-1.1\"},\"contracts/PositionManager/IPositionManager.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\n\\nimport {IPositionManagerStorage, IPositionManagerStorageV2, IKeeperRewardDistributorV3} from \\\"./IPositionManagerStorage.sol\\\";\\nimport {IPositionManagerEvents} from \\\"./IPositionManagerEvents.sol\\\";\\nimport {IPrimexDNSStorageV3} from \\\"../PrimexDNS/IPrimexDNSStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface IPositionManagerV2 is IPositionManagerStorageV2, IPositionManagerStorage, IPositionManagerEvents, IPausable {\\n    struct ClosePositionVars {\\n        PositionLibrary.Position position;\\n        bool borrowedAmountIsNotZero;\\n        uint256 oracleTolerableLimit;\\n        bool needOracleTolerableLimitCheck;\\n    }\\n\\n    event ChangePositionManagerExtension(address indexed newPositionManagerExtension);\\n\\n    event IncreaseDeposit(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        uint256 depositDelta,\\n        uint256 scaledDebtAmount\\n    );\\n\\n    struct ClosePositionByConditionParams {\\n        uint256 id;\\n        address keeper;\\n        PrimexPricingLibrary.MegaRoute[] megaRoutes;\\n        uint256 conditionIndex;\\n        bytes ccmAdditionalParams;\\n        PositionLibrary.CloseReason closeReason;\\n        bytes positionSoldAssetOracleData;\\n        bytes nativePmxOracleData;\\n        bytes positionNativeAssetOracleData;\\n        bytes pmxSoldAssetOracleData;\\n        bytes nativeSoldAssetOracleData;\\n        bytes[][] pullOracleData;\\n        uint256[] pullOracleTypes;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract with the specified addresses and initializes inherited contracts.\\n     * @param _registry The address of the Registry contract.\\n     * @param _primexDNS The address of the PrimexDNS contract.\\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\\n     * @param _priceOracle The address of the PriceOracle contract.\\n     * @param _keeperRewardDistributor The address of the KeeperRewardDistributor contract.\\n     * @param _whiteBlackList The address of the WhiteBlacklist contract.\\n     * @param _positionManagerExtension The address of the PositionManagerExtension contract.\\n     */\\n    function initialize(\\n        address _registry,\\n        address _primexDNS,\\n        address payable _traderBalanceVault,\\n        address _priceOracle,\\n        address _keeperRewardDistributor,\\n        address _whiteBlackList,\\n        address _positionManagerExtension\\n    ) external;\\n\\n    /**\\n     * @notice Sets the positionManagerExtension.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _newPositionManagerExtension The address of PositionManagerExtension contract.\\n     */\\n    function setPositionManagerExtension(address _newPositionManagerExtension) external;\\n\\n    /**\\n     * @notice Sets protocol parameters through an administrative delegatecall.\\n     * @dev This function allows an admin to update protocol parameters using a delegatecall to the PositionManagerExtension contract.\\n     * @param _data The data containing the encoded function call to be executed by the delegatecall.\\n     */\\n    function setProtocolParamsByAdmin(bytes calldata _data) external;\\n\\n    /**\\n     * @notice Opens a position based on the provided order parameters.\\n     * @dev Only callable by the LOM_ROLE role.\\n     * @param _params The parameters for opening a position.\\n     * @return The total borrowed amount, position amount, position ID, and entry price of the new position.\\n     */\\n    function openPositionByOrder(\\n        LimitOrderLibrary.OpenPositionByOrderParams calldata _params\\n    ) external returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    /**\\n     * @notice Opens margin position.\\n     * @dev Locks trader's collateral in TraderBalanceVault. Takes loan from bucket for deal.\\n     * Makes swap bucket borrowedAsset amount on '_dex'. Updates rates and indexes in the '_bucket'.\\n     * Mints debtToken for trader (msg.sender)\\n     * @param _params The parameters required to open a position.\\n     */\\n    function openPosition(PositionLibrary.OpenPositionParams calldata _params) external payable;\\n\\n    /**\\n     * @notice Close trader's active position or liquidate risky position.\\n     * @dev Protocol will fall down (revert) if two conditions occur both:\\n     * 1. (token1Price + position.depositedAmount).wdiv(positionDebt) will become lower than 1,\\n     * so position will make loss for Protocol.\\n     * 2. Not enough liquidity in bucket to pay that loss.\\n     * @param _id Position id for `msg.sender`.\\n     * @param _dealReceiver The receiver of the rest of trader's deposit.\\n     * @param _megaRoutes swap routes on dexes\\n     * @param _amountOutMin minimum allowed amount out for position\\n     */\\n    function closePosition(\\n        uint256 _id,\\n        address _dealReceiver,\\n        PrimexPricingLibrary.MegaRoute[] calldata _megaRoutes,\\n        uint256 _amountOutMin,\\n        bytes calldata _positionSoldAssetOracleData,\\n        bytes calldata _pmxSoldAssetOracleData,\\n        bytes calldata _nativeSoldAssetOracleData,\\n        bytes[][] calldata _pullOracleData,\\n        uint256[] calldata _pullOracleTypes\\n    ) external payable;\\n\\n    // /**\\n    //  * @notice Closes trader's active position by closing condition\\n    //  * @param _id Position id.\\n    //  * @param _keeper The address of the keeper or the recipient of the reward.\\n    //  * @param _megaRoutes An array of routes for executing trades, swap routes on dexes.\\n    //  * @param _conditionIndex The index of the condition to be used for closing the position.\\n    //  * @param _ccmAdditionalParams Additional params needed for canBeClosedAfterSwap of the ConditionalClosingManager.\\n    //  * @param _closeReason The reason for closing the position.\\n    //  */\\n    function closePositionByCondition(ClosePositionByConditionParams calldata _params) external payable;\\n\\n    /**\\n     * @notice Updates the position with the given position ID by setting new close conditions.\\n     * @param _positionId The ID of the position to update.\\n     * @param _closeConditions An array of close conditions for the position.\\n     * @dev The caller of this function must be the trader who owns the position.\\n     * @dev Emits an `UpdatePositionConditions` event upon successful update.\\n     */\\n    function updatePositionConditions(\\n        uint256 _positionId,\\n        LimitOrderLibrary.Condition[] calldata _closeConditions\\n    ) external;\\n\\n    /**\\n     * @notice Increases the deposit amount for a given position.\\n     * @param _positionId The ID of the position to increase the deposit for.\\n     * @param _amount The amount to increase the deposit by.\\n     * @param _asset The address of the asset to deposit.\\n     * @param _takeDepositFromWallet A flag indicating whether to make the deposit immediately.\\n     * @param _megaRoutes An array of routes to use for trading.\\n     * @param _amountOutMin The minimum amount of the output asset to receive from trading.\\n     */\\n    function increaseDeposit(\\n        uint256 _positionId,\\n        uint256 _amount,\\n        address _asset,\\n        bool _takeDepositFromWallet,\\n        PrimexPricingLibrary.MegaRoute[] calldata _megaRoutes,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /**\\n     * @notice Decreases the deposit amount for a given position.\\n     * @param _positionId The ID of the position.\\n     * @param _amount The amount to decrease the deposit by.\\n     */\\n    function decreaseDeposit(\\n        uint256 _positionId,\\n        uint256 _amount,\\n        bytes calldata _positionSoldAssetOracleData,\\n        bytes calldata _nativeSoldAssetOracleData,\\n        bytes[][] calldata _pullOracleData,\\n        uint256[] calldata _pullOracleTypes\\n    ) external payable;\\n\\n    /**\\n     * @notice Deletes a positions by their IDs from a specific bucket for a given traders.\\n     * @param _ids The IDs of the positions to be deleted.\\n     * @param _traders The addresses of the traders who owns the position.\\n     * @param _length The length of the traders array.\\n     * @param _bucket The address of the bucket from which the position is to be deleted.\\n     */\\n    function deletePositions(\\n        uint256[] calldata _ids,\\n        address[] calldata _traders,\\n        uint256 _length,\\n        address _bucket\\n    ) external;\\n\\n    /**\\n     * @notice Allows the trader to partially close a position.\\n     * @param _positionId The ID of the position to be partially closed.\\n     * @param _amount The amount of the position asset to be closed from the position.\\n     * @param _depositReceiver The address where the remaining deposit will be sent.\\n     * @param _megaRoutes The routing information for swapping assets.\\n     * @param _amountOutMin The minimum amount to be received after swapping, measured in the same decimal format as the position's asset.\\n     */\\n    function partiallyClosePosition(\\n        uint256 _positionId,\\n        uint256 _amount,\\n        address _depositReceiver,\\n        PrimexPricingLibrary.MegaRoute[] calldata _megaRoutes,\\n        uint256 _amountOutMin,\\n        bytes calldata _positionSoldAssetOracleData,\\n        bytes calldata _nativePositionAssetOracleData,\\n        bytes calldata _nativeSoldAssetOracleData,\\n        bytes calldata _pmxSoldAssetOracleData,\\n        bytes[][] calldata _pullOracleData,\\n        uint256[] calldata _pullOracleTypes\\n    ) external payable;\\n\\n    /**\\n     * @notice Transfers a specified amount of tokens from the contract to a specified address.\\n     * @dev Only callable by the BATCH_MANAGER_ROLE role.\\n     * @param _token The address of the token to be transferred.\\n     * @param _to The address to which the tokens will be transferred.\\n     * @param _amount The amount of tokens to be transferred.\\n     */\\n    function doTransferOut(address _token, address _to, uint256 _amount) external;\\n\\n    /**\\n     * @notice Returns the oracle tolerable limit for the given asset pair.\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @return The oracle tolerable limit in WAD format (1 WAD = 100%) for the asset pair.\\n     */\\n    function getOracleTolerableLimit(address assetA, address assetB) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the position information for a given ID.\\n     * @param _id The ID of the position to retrieve.\\n     * @return position The position information associated with the given ID.\\n     */\\n    function getPosition(uint256 _id) external view returns (PositionLibrary.Position memory);\\n\\n    /**\\n     * @notice Retrieves the position at the specified index.\\n     * @param _index The index of the position to retrieve.\\n     * @return The Position struct at the specified index.\\n     */\\n    function getPositionByIndex(uint256 _index) external view returns (PositionLibrary.Position memory);\\n\\n    /**\\n     * @notice Returns the length of the positions array.\\n     * @return The length of the positions array.\\n     */\\n    function getAllPositionsLength() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the length of the array containing the positions of a specific trader.\\n     * @param _trader The address of the trader.\\n     * @return The number of positions the trader has.\\n     */\\n    function getTraderPositionsLength(address _trader) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the length of the array containing the positions of a specific bucket.\\n     * @param _bucket The address of the bucket.\\n     * @return The number of positions the bucket has.\\n     */\\n    function getBucketPositionsLength(address _bucket) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the debt of a position with the given ID.\\n     * @param _id The ID of the position.\\n     * @return The debt of the position, measured in the same decimal format as debtTokens.\\n     */\\n    function getPositionDebt(uint256 _id) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the close conditions for a specific position.\\n     * @param _positionId The ID of the position.\\n     * @return An array of close conditions associated with the position.\\n     */\\n    function getCloseConditions(uint256 _positionId) external view returns (LimitOrderLibrary.Condition[] memory);\\n\\n    /**\\n     * @notice Retrieves the close condition for a given position and index.\\n     * @param _positionId The identifier of the position.\\n     * @param _index The index of the close condition.\\n     * @return The close condition at the specified position and index.\\n     */\\n    function getCloseCondition(\\n        uint256 _positionId,\\n        uint256 _index\\n    ) external view returns (LimitOrderLibrary.Condition memory);\\n\\n    /**\\n     * @notice Checks if a position with the given ID is delisted.\\n     * @param _id The ID of the position.\\n     * @return A boolean indicating whether the position is delisted or not.\\n     */\\n    function isDelistedPosition(uint256 _id) external view returns (bool);\\n}\\n\\ninterface IPositionManager is IPositionManagerStorage, IPausable {\\n    struct ClosePositionVars {\\n        PositionLibrary.Position position;\\n        bool borrowedAmountIsNotZero;\\n        uint256 oracleTolerableLimit;\\n        bool needOracleTolerableLimitCheck;\\n    }\\n\\n    event SetMaxPositionSize(address token0, address token1, uint256 amountInToken0, uint256 amountInToken1);\\n    event SetDefaultOracleTolerableLimit(uint256 indexed oracleTolerableLimit);\\n    event SecurityBufferChanged(uint256 indexed securityBuffer);\\n    event MaintenanceBufferChanged(uint256 indexed maintenanceBuffer);\\n    event SetOracleTolerableLimit(address indexed assetA, address indexed assetB, uint256 oracleTolerableLimit);\\n    event KeeperRewardDistributorChanged(address indexed _keeperRewardDistributor);\\n    event MinPositionSizeAndAssetChanged(uint256 indexed _minPositionSize, address indexed _minPositionAsset);\\n    event OracleTolerableLimitMultiplierChanged(uint256 indexed newMultiplier);\\n\\n    event OpenPosition(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        address indexed openedBy,\\n        PositionLibrary.Position position,\\n        address feeToken,\\n        uint256 protocolFee,\\n        uint256 entryPrice,\\n        uint256 leverage,\\n        LimitOrderLibrary.Condition[] closeConditions\\n    );\\n\\n    event PartialClosePosition(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        address bucketAddress,\\n        address soldAsset,\\n        address positionAsset,\\n        uint256 decreasePositionAmount,\\n        uint256 depositedAmount,\\n        uint256 scaledDebtAmount,\\n        int256 profit,\\n        uint256 positionDebt,\\n        uint256 amountOut\\n    );\\n\\n    event IncreaseDeposit(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        uint256 depositDelta,\\n        uint256 scaledDebtAmount\\n    );\\n\\n    event DecreaseDeposit(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        uint256 depositDelta,\\n        uint256 scaledDebtAmount\\n    );\\n\\n    event UpdatePositionConditions(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        LimitOrderLibrary.Condition[] closeConditions\\n    );\\n\\n    /**\\n     * @notice Initializes the contract with the specified addresses and initializes inherited contracts.\\n     * @param _registry The address of the Registry contract.\\n     * @param _primexDNS The address of the PrimexDNS contract.\\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\\n     * @param _priceOracle The address of the PriceOracle contract.\\n     * @param _keeperRewardDistributor The address of the KeeperRewardDistributor contract.\\n     * @param _whiteBlackList The address of the WhiteBlacklist contract.\\n     */\\n    function initialize(\\n        address _registry,\\n        address _primexDNS,\\n        address payable _traderBalanceVault,\\n        address _priceOracle,\\n        address _keeperRewardDistributor,\\n        address _whiteBlackList\\n    ) external;\\n\\n    /**\\n     * @notice Sets the maximum position size for a pair of tokens.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _token0 The address of the first token in the pair.\\n     * @param _token1 The address of the second token in the pair.\\n     * @param _amountInToken0 The maximum amount of token0 allowed in the position.\\n     * @param _amountInToken1 The maximum amount of token1 allowed in the position.\\n     */\\n    function setMaxPositionSize(\\n        address _token0,\\n        address _token1,\\n        uint256 _amountInToken0,\\n        uint256 _amountInToken1\\n    ) external;\\n\\n    /**\\n     * @notice Sets the default oracle tolerable limit for the protocol.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _percent The new value for the default oracle tolerable limit. Measured in WAD (1 WAD = 100%).\\n     */\\n    function setDefaultOracleTolerableLimit(uint256 _percent) external;\\n\\n    /**\\n     * @notice Sets the oracle tolerable limit between two assets.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _assetA The address of the first asset.\\n     * @param _assetB The address of the second asset.\\n     * @param _percent The new value for the oracle tolerable limit between two assets. Measured in WAD (1 WAD = 100%).\\n     */\\n    function setOracleTolerableLimit(address _assetA, address _assetB, uint256 _percent) external;\\n\\n    /**\\n     * @notice Function to set oracleTolerableLimitMultiplier.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param newMultiplier New multiplier in WAD format.\\n     */\\n    function setOracleTolerableLimitMultiplier(uint256 newMultiplier) external;\\n\\n    /**\\n     * @notice Sets the security buffer value.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * 0 <= newSecurityBuffer < 1.\\n     * Buffer security parameter is used in calculating the liquidation conditions\\n     * https://docs.google.com/document/d/1kR8eaqV4289MAbLKgIfKsZ2NgjFpeC0vpVL7jVUTvho/edit#bookmark=id.i9v508hvrv42\\n     * @param newSecurityBuffer The new value of the security buffer in WAD format.\\n     */\\n    function setSecurityBuffer(uint256 newSecurityBuffer) external;\\n\\n    /**\\n     * @notice Sets the maintenance buffer value.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * The new maintenance buffer value should be greater than zero and less than one.\\n     * Maintenance buffer is used in calculating the maximum leverage\\n     * https://docs.google.com/document/d/1kR8eaqV4289MAbLKgIfKsZ2NgjFpeC0vpVL7jVUTvho/edit#bookmark=id.87oc1j1s9z21\\n     * @param newMaintenanceBuffer The new value of the maintenance buffer in WAD format.\\n     */\\n    function setMaintenanceBuffer(uint256 newMaintenanceBuffer) external;\\n\\n    /**\\n     * @notice Sets the address of the SpotTradingRewardDistributor contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _spotTradingRewardDistributor The address of the SpotTradingRewardDistributor contract.\\n     */\\n    function setSpotTradingRewardDistributor(address _spotTradingRewardDistributor) external;\\n\\n    /**\\n     * @notice Sets the KeeperRewardDistributor contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _keeperRewardDistributor The address of the KeeperRewardDistributor contract.\\n     */\\n    function setKeeperRewardDistributor(IKeeperRewardDistributorV3 _keeperRewardDistributor) external;\\n\\n    /**\\n     * @notice Opens a position based on the provided order parameters.\\n     * @dev Only callable by the LOM_ROLE role.\\n     * @param _params The parameters for opening a position.\\n     * @return The total borrowed amount, position amount, position ID, and entry price of the new position.\\n     */\\n    function openPositionByOrder(\\n        LimitOrderLibrary.OpenPositionByOrderParams calldata _params\\n    ) external returns (uint256, uint256, uint256, uint256);\\n\\n    /**\\n     * @notice Opens margin position.\\n     * @dev Locks trader's collateral in TraderBalanceVault. Takes loan from bucket for deal.\\n     * Makes swap bucket borrowedAsset amount on '_dex'. Updates rates and indexes in the '_bucket'.\\n     * Mints debtToken for trader (msg.sender)\\n     * @param _params The parameters required to open a position.\\n     */\\n    function openPosition(PositionLibrary.OpenPositionParams calldata _params) external payable;\\n\\n    /**\\n     * @notice Close trader's active position or liquidate risky position.\\n     * @dev Protocol will fall down (revert) if two conditions occur both:\\n     * 1. (token1Price + position.depositedAmount).wdiv(positionDebt) will become lower than 1,\\n     * so position will make loss for Protocol.\\n     * 2. Not enough liquidity in bucket to pay that loss.\\n     * @param _id Position id for `msg.sender`.\\n     * @param _dealReceiver The receiver of the rest of trader's deposit.\\n     * @param _megaRoutes swap routes on dexes\\n     * @param _amountOutMin minimum allowed amount out for position\\n     */\\n    function closePosition(\\n        uint256 _id,\\n        address _dealReceiver,\\n        PrimexPricingLibrary.MegaRoute[] memory _megaRoutes,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /**\\n     * @notice Closes trader's active position by closing condition\\n     * @param _id Position id.\\n     * @param _keeper The address of the keeper or the recipient of the reward.\\n     * @param _megaRoutes An array of routes for executing trades, swap routes on dexes.\\n     * @param _conditionIndex The index of the condition to be used for closing the position.\\n     * @param _ccmAdditionalParams Additional params needed for canBeClosedAfterSwap of the ConditionalClosingManager.\\n     * @param _closeReason The reason for closing the position.\\n     */\\n    function closePositionByCondition(\\n        uint256 _id,\\n        address _keeper,\\n        PrimexPricingLibrary.MegaRoute[] calldata _megaRoutes,\\n        uint256 _conditionIndex,\\n        bytes calldata _ccmAdditionalParams,\\n        PositionLibrary.CloseReason _closeReason\\n    ) external;\\n\\n    /**\\n     * @notice Allows the trader to partially close a position.\\n     * @param _positionId The ID of the position to be partially closed.\\n     * @param _amount The amount of the position asset to be closed from the position.\\n     * @param _depositReceiver The address where the remaining deposit will be sent.\\n     * @param _megaRoutes The routing information for swapping assets.\\n     * @param _amountOutMin The minimum amount to be received after swapping, measured in the same decimal format as the position's asset.\\n     */\\n    function partiallyClosePosition(\\n        uint256 _positionId,\\n        uint256 _amount,\\n        address _depositReceiver,\\n        PrimexPricingLibrary.MegaRoute[] calldata _megaRoutes,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /**\\n     * @notice Updates the position with the given position ID by setting new close conditions.\\n     * @param _positionId The ID of the position to update.\\n     * @param _closeConditions An array of close conditions for the position.\\n     * @dev The caller of this function must be the trader who owns the position.\\n     * @dev Emits an `UpdatePositionConditions` event upon successful update.\\n     */\\n    function updatePositionConditions(\\n        uint256 _positionId,\\n        LimitOrderLibrary.Condition[] calldata _closeConditions\\n    ) external;\\n\\n    /**\\n     * @notice Increases the deposit amount for a given position.\\n     * @param _positionId The ID of the position to increase the deposit for.\\n     * @param _amount The amount to increase the deposit by.\\n     * @param _asset The address of the asset to deposit.\\n     * @param _takeDepositFromWallet A flag indicating whether to make the deposit immediately.\\n     * @param _megaRoutes An array of routes to use for trading.\\n     * @param _amountOutMin The minimum amount of the output asset to receive from trading.\\n     */\\n    function increaseDeposit(\\n        uint256 _positionId,\\n        uint256 _amount,\\n        address _asset,\\n        bool _takeDepositFromWallet,\\n        PrimexPricingLibrary.MegaRoute[] calldata _megaRoutes,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /**\\n     * @notice Decreases the deposit amount for a given position.\\n     * @param _positionId The ID of the position.\\n     * @param _amount The amount to decrease the deposit by.\\n     */\\n    function decreaseDeposit(uint256 _positionId, uint256 _amount) external;\\n\\n    /**\\n     * @notice Sets the minimum position size and the corresponding asset for positions.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _minPositionSize The new minimum position size.\\n     * @param _minPositionAsset The address of the asset associated with the minimum position size.\\n     */\\n    function setMinPositionSize(uint256 _minPositionSize, address _minPositionAsset) external;\\n\\n    /**\\n     * @notice Deletes a positions by their IDs from a specific bucket for a given traders.\\n     * @param _ids The IDs of the positions to be deleted.\\n     * @param _traders The addresses of the traders who owns the position.\\n     * @param _length The length of the traders array.\\n     * @param _bucket The address of the bucket from which the position is to be deleted.\\n     */\\n    function deletePositions(\\n        uint256[] calldata _ids,\\n        address[] calldata _traders,\\n        uint256 _length,\\n        address _bucket\\n    ) external;\\n\\n    /**\\n     * @notice Transfers a specified amount of tokens from the contract to a specified address.\\n     * @dev Only callable by the BATCH_MANAGER_ROLE role.\\n     * @param _token The address of the token to be transferred.\\n     * @param _to The address to which the tokens will be transferred.\\n     * @param _amount The amount of tokens to be transferred.\\n     */\\n    function doTransferOut(address _token, address _to, uint256 _amount) external;\\n\\n    /**\\n     * @notice Returns the oracle tolerable limit for the given asset pair.\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @return The oracle tolerable limit in WAD format (1 WAD = 100%) for the asset pair.\\n     */\\n    function getOracleTolerableLimit(address assetA, address assetB) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the position information for a given ID.\\n     * @param _id The ID of the position to retrieve.\\n     * @return position The position information associated with the given ID.\\n     */\\n    function getPosition(uint256 _id) external view returns (PositionLibrary.Position memory);\\n\\n    /**\\n     * @notice Retrieves the position at the specified index.\\n     * @param _index The index of the position to retrieve.\\n     * @return The Position struct at the specified index.\\n     */\\n    function getPositionByIndex(uint256 _index) external view returns (PositionLibrary.Position memory);\\n\\n    /**\\n     * @notice Returns the length of the positions array.\\n     * @return The length of the positions array.\\n     */\\n    function getAllPositionsLength() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the length of the array containing the positions of a specific trader.\\n     * @param _trader The address of the trader.\\n     * @return The number of positions the trader has.\\n     */\\n    function getTraderPositionsLength(address _trader) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the length of the array containing the positions of a specific bucket.\\n     * @param _bucket The address of the bucket.\\n     * @return The number of positions the bucket has.\\n     */\\n    function getBucketPositionsLength(address _bucket) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the debt of a position with the given ID.\\n     * @param _id The ID of the position.\\n     * @return The debt of the position, measured in the same decimal format as debtTokens.\\n     */\\n    function getPositionDebt(uint256 _id) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the close conditions for a specific position.\\n     * @param _positionId The ID of the position.\\n     * @return An array of close conditions associated with the position.\\n     */\\n    function getCloseConditions(uint256 _positionId) external view returns (LimitOrderLibrary.Condition[] memory);\\n\\n    /**\\n     * @notice Retrieves the close condition for a given position and index.\\n     * @param _positionId The identifier of the position.\\n     * @param _index The index of the close condition.\\n     * @return The close condition at the specified position and index.\\n     */\\n    function getCloseCondition(\\n        uint256 _positionId,\\n        uint256 _index\\n    ) external view returns (LimitOrderLibrary.Condition memory);\\n\\n    /**\\n     * @notice Checks if a position with the given ID is delisted.\\n     * @param _id The ID of the position.\\n     * @return A boolean indicating whether the position is delisted or not.\\n     */\\n    function isDelistedPosition(uint256 _id) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xb1069a961bc115256679dcc62a7870c70163ebeb2269bf9e1ab9486a45484ee1\",\"license\":\"BUSL-1.1\"},\"contracts/PositionManager/IPositionManagerEvents.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\n\\ninterface IPositionManagerEvents {\\n    event SetMaxPositionSize(address token0, address token1, uint256 amountInToken0, uint256 amountInToken1);\\n    event SetDefaultOracleTolerableLimit(uint256 indexed oracleTolerableLimit);\\n    event SecurityBufferChanged(uint256 indexed securityBuffer);\\n    event MaintenanceBufferChanged(uint256 indexed maintenanceBuffer);\\n    event SetOracleTolerableLimit(address indexed assetA, address indexed assetB, uint256 oracleTolerableLimit);\\n    event KeeperRewardDistributorChanged(address indexed _keeperRewardDistributor);\\n    event OracleTolerableLimitMultiplierChanged(uint256 indexed newMultiplier);\\n\\n    event OpenPosition(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        address indexed openedBy,\\n        PositionLibrary.Position position,\\n        uint256 entryPrice,\\n        uint256 leverage,\\n        LimitOrderLibrary.Condition[] closeConditions\\n    );\\n\\n    event PartialClosePosition(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        address bucketAddress,\\n        address soldAsset,\\n        address positionAsset,\\n        uint256 decreasePositionAmount,\\n        uint256 depositedAmount,\\n        uint256 scaledDebtAmount,\\n        int256 profit,\\n        uint256 positionDebt,\\n        uint256 amountOut\\n    );\\n\\n    event DecreaseDeposit(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        uint256 depositDelta,\\n        uint256 scaledDebtAmount\\n    );\\n\\n    event UpdatePositionConditions(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        LimitOrderLibrary.Condition[] closeConditions\\n    );\\n}\\n\",\"keccak256\":\"0x568630183883e5b6bee9e1d3ee6fba6f707dc33496111a4892cca839ad6a9f05\",\"license\":\"BUSL-1.1\"},\"contracts/PositionManager/IPositionManagerStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\n\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IPriceOracleV2} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IKeeperRewardDistributorV3} from \\\"../KeeperRewardDistributor/IKeeperRewardDistributor.sol\\\";\\nimport {ISpotTradingRewardDistributorV2} from \\\"../SpotTradingRewardDistributor/ISpotTradingRewardDistributor.sol\\\";\\n\\ninterface IPositionManagerStorage {\\n    function maxPositionSize(address, address) external returns (uint256);\\n\\n    function defaultOracleTolerableLimit() external returns (uint256);\\n\\n    function securityBuffer() external view returns (uint256);\\n\\n    function maintenanceBuffer() external view returns (uint256);\\n\\n    function positionsId() external view returns (uint256);\\n\\n    function traderPositionIds(address _trader, uint256 _index) external view returns (uint256);\\n\\n    function bucketPositionIds(address _bucket, uint256 _index) external view returns (uint256);\\n\\n    function registry() external view returns (IAccessControl);\\n\\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\\n\\n    function primexDNS() external view returns (IPrimexDNSV3);\\n\\n    function priceOracle() external view returns (IPriceOracleV2);\\n\\n    function keeperRewardDistributor() external view returns (IKeeperRewardDistributorV3);\\n\\n    function spotTradingRewardDistributor() external view returns (ISpotTradingRewardDistributorV2);\\n\\n    function minPositionSize() external view returns (uint256);\\n\\n    function minPositionAsset() external view returns (address);\\n}\\n\\ninterface IPositionManagerStorageV2 {\\n    function positionManagerExtension() external view returns (address);\\n}\\n\",\"keccak256\":\"0x01ffe4757883c6cb129e22d7cfd1b40fe0191f498c28eff60a4d7ca14e774acb\",\"license\":\"BUSL-1.1\"},\"contracts/PriceOracle/IPriceOracle.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IPriceOracleStorage, IPriceOracleStorageV3, IPriceOracleStorageV4} from \\\"./IPriceOracleStorage.sol\\\";\\n\\ninterface IPriceOracleV2 is IPriceOracleStorageV3 {\\n    event ChainlinkPriceFeedUpdated(address indexed token, address indexed priceFeed);\\n    event PairPriceDropChanged(address indexed assetA, address indexed assetB, uint256 pairPriceDrop);\\n    event PriceFeedUpdated(address indexed assetA, address indexed assetB, address indexed priceFeed);\\n    event PriceDropFeedUpdated(address indexed assetA, address indexed assetB, address indexed priceDropFeed);\\n    event GasPriceFeedChanged(address priceFeed);\\n    event PythPairIdUpdated(address indexed token, bytes32 indexed priceFeedId);\\n    event Univ3OracleUpdated(uint256 indexed oracleType, address indexed oracle);\\n    event TimeToleranceUpdated(uint256 timeTolerance);\\n    event SupraDataFeedUpdated(address indexed tokenA, address indexed tokenB, uint256 id);\\n\\n    event Univ3TrustedPairUpdated(\\n        uint256 indexed oracleType,\\n        address indexed tokenA,\\n        address indexed tokenB,\\n        bool isTrusted\\n    );\\n\\n    struct UpdateUniv3TrustedPairParams {\\n        uint256 oracleType;\\n        address tokenA;\\n        address tokenB;\\n        bool isTrusted;\\n    }\\n\\n    enum UpdatePullOracle {\\n        Pyth,\\n        Supra,\\n        Orally\\n    }\\n\\n    struct UpdateSupraDataFeedParams {\\n        address tokenA;\\n        address tokenB;\\n        SupraDataFeedId feedData;\\n    }\\n\\n    /**\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @param priceDropFeed The chain link priceDrop feed address for the pair assetA/assetB\\n     */\\n    struct UpdatePriceDropFeedsParams {\\n        address assetA;\\n        address assetB;\\n        address priceDropFeed;\\n    }\\n\\n    /**\\n     * @param _registry The address of PrimexRegistry contract\\n     * @param _eth Weth address if eth isn't native token of network. Otherwise set to zero address.\\n     * @param _usdt Address of the USDT token\\n     * @param _treasury Address of the Treasury\\n     */\\n    function initialize(address _registry, address _eth, address _usdt, address _treasury) external;\\n\\n    /**\\n     * @notice Function to set (change) the pair priceDrop of the trading assets\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN.\\n     * @param _assetA The address of position asset\\n     * @param _assetB The address of borrowed asset\\n     * @param _pairPriceDrop The pair priceDrop (in wad)\\n     */\\n    function setPairPriceDrop(address _assetA, address _assetB, uint256 _pairPriceDrop) external;\\n\\n    /**\\n     * @notice Increases the priceDrop of a pair of assets in the system.\\n     * @dev Only callable by the EMERGENCY_ADMIN role.\\n     * The _pairPriceDrop value must be greater than the current priceDrop value for the pair\\n     * and less than the maximum allowed priceDrop (WadRayMath.WAD / 2).\\n     * @param _assetA The address of position asset\\n     * @param _assetB The address of borrowed asset\\n     * @param _pairPriceDrop The new priceDrop value for the pair (in wad)\\n     */\\n    function increasePairPriceDrop(address _assetA, address _assetB, uint256 _pairPriceDrop) external;\\n\\n    /**\\n     * @notice Sets the gas price feed contract address.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param priceFeed The address of the gas price feed contract.\\n     */\\n    function setGasPriceFeed(address priceFeed) external;\\n\\n    /**\\n     * @notice Updates the priceDrop feed for a specific pair of assets.\\n     * @dev Add or update priceDrop feed for assets pair.\\n     * Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _updateParams The array of the UpdatePriceDropFeedsParams structs\\n     */\\n    function updatePriceDropFeeds(UpdatePriceDropFeedsParams[] calldata _updateParams) external;\\n\\n    /**\\n     * @notice Updates the priceDrop feed for a specific pair of assets.\\n     * @dev Add or update priceDrop feed for assets pair.\\n     * Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @param priceDropFeed The chain link priceDrop feed address for the pair assetA/assetB\\n     */\\n    function updatePriceDropFeed(address assetA, address assetB, address priceDropFeed) external;\\n\\n    /**\\n     * @notice Retrieves the current gas price from the specified gas price feed.\\n     * @return The current gas price.\\n     */\\n    function getGasPrice() external view returns (int256);\\n\\n    /**\\n     * @notice For a given asset pair retrieves the priceDrop rate which is the higher\\n     * of the oracle pair priceDrop and the historical pair priceDrop.\\n     * @param _assetA The address of asset A.\\n     * @param _assetB The address of asset B.\\n     * @return The priceDrop rate.\\n     */\\n    function getPairPriceDrop(address _assetA, address _assetB) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the priceDrop rate between two assets based on the oracle pair priceDrop.\\n     * @param assetA The address of the first asset.\\n     * @param assetB The address of the second asset.\\n     * @return The priceDrop rate as a uint256 value.\\n     */\\n    function getOraclePriceDrop(address assetA, address assetB) external view returns (uint256);\\n\\n    /**\\n     * @notice Retreives a priceDrop feed address from the oraclePriceDropFeeds mapping\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @return priceDropFeed The address of the priceDrop feed associated with the asset pair.\\n     */\\n    function getOraclePriceDropFeed(address assetA, address assetB) external view returns (address);\\n\\n    /**\\n     * @notice Calculates exchange rate of one token to another according to the specific oracle route\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @param oracleData The list of oracles to use for price calculations\\n     * @return exchangeRate for assetA/assetB in 10**18 decimality\\n     */\\n    function getExchangeRate(\\n        address assetA,\\n        address assetB,\\n        bytes calldata oracleData\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Sets or updates the Chainlink price feed for the list of tokens to usd.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _tokens Array of token addresses.\\n     * @param _feeds Array of price feeds.\\n     */\\n    function updateChainlinkPriceFeedsUsd(address[] calldata _tokens, address[] calldata _feeds) external;\\n\\n    /**\\n     * @notice Sets or updates the Pyth pair ids for the list of tokens.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _tokens Array of token addresses.\\n     * @param _priceFeedIds Array of pair ids.\\n     */\\n    function updatePythPairId(address[] calldata _tokens, bytes32[] calldata _priceFeedIds) external;\\n\\n    /**\\n     * @notice Sets or updates the Supra price feeds for the list of tokens.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _params Array of token pairs and Supra ids.\\n     */\\n\\n    function updateSupraDataFeed(UpdateSupraDataFeedParams[] calldata _params) external;\\n\\n    /**\\n     * @notice Sets Uni v3-based TWAP price oracle contracts.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _oracleTypes Array of ids of TWAP contracts.\\n     * @param _oracles Array of TWAP contract addresses.\\n     */\\n    function updateUniv3TypeOracle(uint256[] calldata _oracleTypes, address[] calldata _oracles) external;\\n\\n    /**\\n     * @notice Sets or updates the Supra price feeds for the list of tokens.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _updateParams Array of token pairs, their DEXs and new trusted status.\\n     */\\n    function updateUniv3TrustedPair(UpdateUniv3TrustedPairParams[] calldata _updateParams) external;\\n\\n    /**\\n     * @notice Sets the Pyth address\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _pyth the address of the Pyth oracle\\n     */\\n\\n    function setPyth(address _pyth) external;\\n\\n    /**\\n     * @notice Sets the Supra pull oracle address\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _supraPullOracle the address of the Supra pull oracle\\n     */\\n\\n    function setSupraPullOracle(address _supraPullOracle) external;\\n\\n    /**\\n     * @notice Sets the Supra storage address\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _supraStorageOracle the address of the Supra storage\\n     */\\n    function setSupraStorageOracle(address _supraStorageOracle) external;\\n\\n    /**\\n     * @notice Updates pull oracle data for passed oracle types\\n     * @param _data An array of update data for passed oracles\\n     * @param _pullOracleTypes An array of oracle types  (Must conform to the UpdatePullOracle struct)\\n     */\\n\\n    function updatePullOracle(bytes[][] calldata _data, uint256[] calldata _pullOracleTypes) external payable;\\n\\n    /**\\n     * @notice Sets the time tolerance\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _timeTolerance Time tolerance in seconds\\n     */\\n\\n    function setTimeTolerance(uint256 _timeTolerance) external;\\n\\n    /**\\n     * @notice Sets the usdt address\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _usdt the address of the USDT\\n     */\\n\\n    function setUSDT(address _usdt) external;\\n\\n    /**\\n     * @notice Sets the treasury address\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _treasury the address of the treasury\\n     */\\n    function setTreasury(address _treasury) external;\\n}\\n\\ninterface IPriceOracle is IPriceOracleStorage {\\n    event PairPriceDropChanged(address indexed assetA, address indexed assetB, uint256 pairPriceDrop);\\n    event PriceFeedUpdated(address indexed assetA, address indexed assetB, address indexed priceFeed);\\n    event PriceDropFeedUpdated(address indexed assetA, address indexed assetB, address indexed priceDropFeed);\\n    event GasPriceFeedChanged(address priceFeed);\\n\\n    /**\\n     * @param _registry The address of PrimexRegistry contract\\n     * @param _eth Weth address if eth isn't native token of network. Otherwise set to zero address.\\n     */\\n    function initialize(address _registry, address _eth) external;\\n\\n    /**\\n     * @notice Function to set (change) the pair priceDrop of the trading assets\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN.\\n     * @param _assetA The address of position asset\\n     * @param _assetB The address of borrowed asset\\n     * @param _pairPriceDrop The pair priceDrop (in wad)\\n     */\\n    function setPairPriceDrop(address _assetA, address _assetB, uint256 _pairPriceDrop) external;\\n\\n    /**\\n     * @notice Increases the priceDrop of a pair of assets in the system.\\n     * @dev Only callable by the EMERGENCY_ADMIN role.\\n     * The _pairPriceDrop value must be greater than the current priceDrop value for the pair\\n     * and less than the maximum allowed priceDrop (WadRayMath.WAD / 2).\\n     * @param _assetA The address of position asset\\n     * @param _assetB The address of borrowed asset\\n     * @param _pairPriceDrop The new priceDrop value for the pair (in wad)\\n     */\\n    function increasePairPriceDrop(address _assetA, address _assetB, uint256 _pairPriceDrop) external;\\n\\n    /**\\n     * @notice Add or update price feed for assets pair. For only the admin role.\\n     * @param assetA The first currency within the currency pair quotation (the base currency).\\n     * @param assetB The second currency within the currency pair quotation (the quote currency).\\n     * @param priceFeed The chain link price feed address for the pair assetA/assetB\\n     */\\n    function updatePriceFeed(address assetA, address assetB, address priceFeed) external;\\n\\n    /**\\n     * @notice Sets the gas price feed contract address.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param priceFeed The address of the gas price feed contract.\\n     */\\n    function setGasPriceFeed(address priceFeed) external;\\n\\n    /**\\n     * @notice Updates the priceDrop feed for a specific pair of assets.\\n     * @dev Add or update priceDrop feed for assets pair.\\n     * Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @param priceDropFeed The chain link priceDrop feed address for the pair assetA/assetB\\n     */\\n    function updatePriceDropFeed(address assetA, address assetB, address priceDropFeed) external;\\n\\n    /**\\n     * @notice Requests two priceFeeds - assetA/ETH and assetB/ETH (or assetA/USD and assetB/USD).\\n     * @dev If there is no price feed found, the code will return a message that no price feed found.\\n     * @param baseAsset The first currency within the currency pair quotation (the base currency).\\n     * @param quoteAsset The second currency within the currency pair quotation (the quote currency).\\n     * @return A tuple of basePriceFeed and quotePriceFeed. The addresses of the price feed for the base asset and quote asset respectively.\\n     */\\n    function getPriceFeedsPair(address baseAsset, address quoteAsset) external view returns (address, address);\\n\\n    /**\\n     * @notice Requests priceFeed for the actual exchange rate for an assetA/assetB pair.\\n     * @dev If no price feed for the pair found, USD and ETH are used as intermediate tokens.\\n     * A price for assetA/assetB can be derived if two data feeds exist:\\n     * assetA/ETH and assetB/ETH (or assetA/USD and assetB/USD).\\n     * If there is no price feed found, the code will return a message that no price feed found.\\n     * @param assetA The first currency within the currency pair quotation (the base currency).\\n     * @param assetB The second currency within the currency pair quotation (the quote currency).\\n     * @return exchangeRate for assetA/assetB in 10**18 decimality which will be recalucaled in PrimexPricingLibrary.\\n     * @return direction of a pair as it stored in chainLinkPriceFeeds (i.e. returns 'true' for assetA/assetB, and 'false' for assetB/assetA).\\n     * Throws if priceFeed wasn't found or priceFeed hasn't answer is 0.\\n     */\\n    function getExchangeRate(address assetA, address assetB) external view returns (uint256, bool);\\n\\n    /**\\n     * @notice Retrieves the direct price feed for the given asset pair.\\n     * @param assetA The address of the first asset.\\n     * @param assetB The address of the second asset.\\n     * @return priceFeed The address of the direct price feed.\\n     */\\n    function getDirectPriceFeed(address assetA, address assetB) external view returns (address);\\n\\n    /**\\n     * @notice Retrieves the current gas price from the specified gas price feed.\\n     * @return The current gas price.\\n     */\\n    function getGasPrice() external view returns (int256);\\n\\n    /**\\n     * @notice For a given asset pair retrieves the priceDrop rate which is the higher\\n     * of the oracle pair priceDrop and the historical pair priceDrop.\\n     * @param _assetA The address of asset A.\\n     * @param _assetB The address of asset B.\\n     * @return The priceDrop rate.\\n     */\\n    function getPairPriceDrop(address _assetA, address _assetB) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the priceDrop rate between two assets based on the oracle pair priceDrop.\\n     * @param assetA The address of the first asset.\\n     * @param assetB The address of the second asset.\\n     * @return The priceDrop rate as a uint256 value.\\n     */\\n    function getOraclePriceDrop(address assetA, address assetB) external view returns (uint256);\\n\\n    /**\\n     * @notice Retreives a priceDrop feed address from the oraclePriceDropFeeds mapping\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @return priceDropFeed The address of the priceDrop feed associated with the asset pair.\\n     */\\n    function getOraclePriceDropFeed(address assetA, address assetB) external view returns (address);\\n}\\n\\ninterface IPriceOracleV3 is IPriceOracleV2 {\\n    struct UpdateOrallySymbolsParams {\\n        string symbol; // string(\\\"tokenA/tokenB\\\")\\n        address[2] tokens; // [addressA, addressB]\\n    }\\n\\n    struct UpdateStorkPairIdsParams {\\n        string pair; // string(\\\"BTCUSD\\\")\\n        address[2] tokens; // [btc address, usd address]\\n    }\\n    event OrallySymbolUpdated(address indexed tokenA, address indexed tokenB, string symbol);\\n    event OrallyTimeToleranceUpdated(uint256 timeTolerance);\\n    event StorkPairIdUpdated(address indexed tokenA, address indexed tokenB, string pairId);\\n    event CurveOracleUpdated(IPriceOracleStorageV4.CurveOracleKind indexed oracleType, address indexed oracle);\\n    event EIP4626TokenToUnderlyingAssetUpdated(address indexed token, address underlyingAsset);\\n    event AddUniswapV2LPToken(address indexed uniswapV2Token);\\n    event RemoveUniswapV2LPToken(address indexed uniswapV2Token);\\n\\n    /**\\n     * @notice Sets or updates the Orally token symbol for the list of tokens (tokens order MATTERS)\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param params Array of UpdateOrallySymbolsParams struct\\n     */\\n\\n    function updateOrallySymbols(UpdateOrallySymbolsParams[] calldata params) external;\\n\\n    /**\\n     * @notice Sets the time tolerance specially for the orally\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _orallyTimeTolerance Time tolerance in seconds\\n     */\\n\\n    function setOrallyTimeTolerance(uint256 _orallyTimeTolerance) external;\\n\\n    /**\\n     * @notice Sets the orally oracle address\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _orally the address of the Orally oracle\\n     */\\n    function setOrallyOracle(address _orally) external;\\n\\n    /**\\n     * @notice Sets or updates the Stork Pair Ids\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param params Array of UpdateStorkPairIdsParams struct\\n     */\\n\\n    function updateStorkPairIds(UpdateStorkPairIdsParams[] calldata params) external;\\n\\n    /**\\n     * @notice Sets the stork verify address\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _storkVerify the Stork verify address\\n     */\\n\\n    function setStorkVerify(address _storkVerify) external;\\n\\n    /**\\n     * @notice Sets the stork public key (address)\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _storkPublicKey the Stork public key address\\n     */\\n\\n    function setStorkPublicKey(address _storkPublicKey) external;\\n\\n    function updateCurveTypeOracle(\\n        IPriceOracleStorageV4.CurveOracleKind[] calldata _oracleTypes,\\n        address[] calldata _oracles\\n    ) external;\\n\\n    function updateEIP4626TokenToUnderlyingAsset(\\n        address[] calldata _rebaseTokens,\\n        address[] calldata _underlyingAssets\\n    ) external;\\n\\n    /**\\n     * @notice Sets the flag to true for the passed tokens\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _lpTokens the addresses of lp tokens\\n     */\\n\\n    function addUniswapV2LPTokens(address[] calldata _lpTokens) external;\\n\\n    /**\\n     * @notice Sets the flag to false for the passed tokens\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _lpTokens the addresses of lp tokens\\n     */\\n\\n    function removeUniswapV2LPTokens(address[] calldata _lpTokens) external;\\n\\n    /**\\n     * @notice Sets the UniswapV2LP oracle\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _uniswapV2LPOracle the UniswapV2LP oracle address\\n     */\\n\\n    function setUniswapV2LPOracle(address _uniswapV2LPOracle) external;\\n}\\n\",\"keccak256\":\"0xc325d610885e86499c1c1444c3f5e45ec3751158ca84f3ad5ea7a72bb31db921\",\"license\":\"BUSL-1.1\"},\"contracts/PriceOracle/IPriceOracleStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\nimport {IPyth} from \\\"@pythnetwork/pyth-sdk-solidity/IPyth.sol\\\";\\nimport {ISupraOraclePull} from \\\"../interfaces/ISupraOraclePull.sol\\\";\\nimport {ISupraSValueFeed} from \\\"../interfaces/ISupraSValueFeed.sol\\\";\\nimport {IOrallyVerifierOracle} from \\\"@orally-network/solidity-sdk/IOrallyVerifierOracle.sol\\\";\\nimport {IStorkVerify} from \\\"../interfaces/IStorkVerify.sol\\\";\\nimport {IUniswapV2LPOracle} from \\\"../UniswapV2LPOracle/IUniswapV2LPOracle.sol\\\";\\n\\ninterface IPriceOracleStorage {\\n    function registry() external view returns (address);\\n\\n    function eth() external view returns (address);\\n\\n    function gasPriceFeed() external view returns (address);\\n\\n    function pairPriceDrops(address, address) external view returns (uint256);\\n}\\n\\ninterface IPriceOracleStorageV2 is IPriceOracleStorage {\\n    enum OracleType {\\n        Pyth,\\n        Chainlink,\\n        Uniswapv3,\\n        Supra,\\n        Orally,\\n        Stork,\\n        CurveLPOracle,\\n        EIP4626,\\n        UniswapV2LP\\n    }\\n\\n    struct OracleRoute {\\n        address tokenTo;\\n        OracleType oracleType;\\n        bytes oracleData;\\n    }\\n\\n    function pyth() external view returns (IPyth);\\n\\n    function timeTolerance() external view returns (uint256);\\n\\n    function chainlinkPriceFeedsUsd(address) external view returns (address);\\n\\n    function pythPairIds(address) external view returns (bytes32);\\n\\n    function univ3TypeOracles(uint256) external view returns (address);\\n\\n    function univ3TrustedPairs(uint256, address, address) external view returns (bool);\\n}\\n\\ninterface IPriceOracleStorageV3 is IPriceOracleStorageV2 {\\n    struct SupraDataFeedId {\\n        uint256 id;\\n        bool initialize;\\n    }\\n\\n    function supraPullOracle() external view returns (ISupraOraclePull);\\n\\n    function supraStorageOracle() external view returns (ISupraSValueFeed);\\n\\n    function supraDataFeedID(address, address) external view returns (uint256, bool);\\n\\n    function usdt() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n}\\n\\ninterface IPriceOracleStorageV4 is IPriceOracleStorageV3 {\\n    enum CurveOracleKind {\\n        STABLE,\\n        TRICRYPTO,\\n        VOLATILE\\n    }\\n\\n    function orallySymbol(address, address) external view returns (string memory);\\n\\n    function orallyOracle() external view returns (IOrallyVerifierOracle);\\n\\n    function orallyTimeTolerance() external view returns (uint256);\\n\\n    function storkVerify() external view returns (IStorkVerify);\\n\\n    function storkPublicKey() external view returns (address);\\n\\n    function storkAssetPairId(address, address) external view returns (string memory);\\n\\n    function curveTypeOracles(CurveOracleKind) external view returns (address);\\n\\n    function eip4626TokenToUnderlyingAsset(address) external view returns (address);\\n\\n    function isUniswapV2LP(address) external view returns (bool);\\n\\n    function uniswapV2LPOracle() external view returns (IUniswapV2LPOracle);\\n}\\n\",\"keccak256\":\"0x186e0f61de8f99cbaa7819d984f1b6b61ce4608d0a8f5102b493eb7234921d56\",\"license\":\"BUSL-1.1\"},\"contracts/PrimexDNS/IPrimexDNS.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IPrimexDNSStorage, IPrimexDNSStorageV3, IPrimexDNSStorageV4} from \\\"./IPrimexDNSStorage.sol\\\";\\n\\ninterface IPrimexDNSV3 is IPrimexDNSStorageV4 {\\n    event AddNewBucket(BucketData newBucketData);\\n    event BucketDeprecated(address bucketAddress, uint256 delistingTime);\\n    event AddNewDex(DexData newDexData);\\n    event ConditionalManagerChanged(uint256 indexed cmType, address indexed cmAddress);\\n    event PMXchanged(address indexed pmx);\\n    event TiersManagerchanged(address indexed tiersManager);\\n    event AavePoolChanged(address indexed aavePool);\\n    event BucketActivated(address indexed bucketAddress);\\n    event BucketFrozen(address indexed bucketAddress);\\n    event DexAdapterChanged(address indexed newAdapterAddress);\\n    event DexActivated(address indexed routerAddress);\\n    event DexFrozen(address indexed routerAddress);\\n\\n    event ChangeProtocolFeeRate(FeeRateType indexed feeRateType, uint256 indexed tier, uint256 feeRate);\\n    event ChangeAverageGasPerAction(TradingOrderType indexed tradingOrderType, uint256 indexed averageGasPerAction);\\n    event ChangeMaxProtocolFee(uint256 indexed maxProtocolFee);\\n    event ChangeProtocolFeeCoefficient(uint256 indexed protocolFeeCoefficient);\\n    event ChangeLiquidationGasAmount(uint256 indexed liquidationGasAmount);\\n    event ChangePmxDiscountMultiplier(uint256 indexed pmxDiscountMultiplier);\\n    event ChangeAdditionalGasSpent(uint256 indexed additionalGasSpent);\\n    event ChangeGasPriceBuffer(uint256 indexed gasPriceBuffer);\\n    event ChangeMinFeeRestrictions(CallingMethod indexed callingMethod, MinFeeRestrictions minFeeRestrictions);\\n    event ChangeLeverageTolerance(uint256 leverageTolerance);\\n\\n    /**\\n     * @param feeRateType The order type for which the rate is set\\n     * @param tier The tier for which the rate is set\\n     * @param feeRate Setting rate in WAD format (1 WAD = 100%)\\n     */\\n    struct FeeRateParams {\\n        FeeRateType feeRateType;\\n        uint256 tier;\\n        uint256 feeRate;\\n    }\\n\\n    struct AverageGasPerActionParams {\\n        TradingOrderType tradingOrderType;\\n        uint256 averageGasPerAction;\\n    }\\n\\n    /**\\n     * @dev Params for initialize() function\\n     * @param registry The address of the PrimexRegistry contract.\\n     * @param pmx The address of the PMX token contract.\\n     * @param treasury The address of the Treasury contract.\\n     * @param delistingDelay The time (in seconds) between deprecation and delisting of a bucket.\\n     * @param adminWithdrawalDelay The time (in seconds) between delisting of a bucket and an adminDeadline.\\n     * @param feeRateParams An array of structs to set protocol fee rate on the corresponding\\n     * @param averageGasPerActionParams An array of structs to set average amount of gas spent by Keeper on the corresponding action\\n     * @param maxProtocolFee MaxProtocolFee that can be charged. Measured in NATIVE_CURRENCY\\n     * @param liquidationGasAmount Average gas amount spent for a single liquidation, measured in wei.\\n     * @param protocolFeeCoefficient Additional coefficient to calculate minProtocolFee, measured in wei.\\n     * @param additionalGasSpent Gas that will be additionally spend after gasSpent calculation.\\n     * @param pmxDiscountMultiplier Multiplier for PMX discount calculation\\n     * @param gasPriceBuffer Multiplier which protects position from immediate liquidation after gas price changed\\n     */\\n    struct InitParams {\\n        address registry;\\n        address pmx;\\n        address treasury;\\n        uint256 delistingDelay;\\n        uint256 adminWithdrawalDelay;\\n        FeeRateParams[] feeRateParams;\\n        AverageGasPerActionParams[] averageGasPerActionParams;\\n        uint256 maxProtocolFee;\\n        uint256 liquidationGasAmount;\\n        uint256 protocolFeeCoefficient;\\n        uint256 additionalGasSpent;\\n        uint256 pmxDiscountMultiplier;\\n        uint256 gasPriceBuffer;\\n        uint256 leverageTolerance;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract with the specified parameters.\\n     */\\n    function initialize(InitParams calldata _params) external;\\n\\n    /**\\n     * @notice Deprecates a bucket.\\n     * @dev This function is used to deprecate a bucket by changing its current status to \\\"Deprecated\\\".\\n     * Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _bucket The name of the bucket to deprecate.\\n     * Emits a BucketDeprecated event with the bucket address and the delisting time.\\n     */\\n    function deprecateBucket(string memory _bucket) external;\\n\\n    /**\\n     * @notice This function is used to set the address of the Aave pool contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _aavePool The address of the Aave pool contract to be set.\\n     */\\n    function setAavePool(address _aavePool) external;\\n\\n    /**\\n     * @notice Sets the address of the PMX token contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _pmx The address of the PMX token contract.\\n     */\\n    function setPMX(address _pmx) external;\\n\\n    /**\\n     * @notice Sets the address of the TiersManager contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _tiersManager The address of the TiersManager token contract.\\n     */\\n    function setTiersManager(address _tiersManager) external;\\n\\n    /**\\n     * @notice Activates a bucket by changing its status from inactive to active.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _bucket The bucket to activate.\\n     */\\n    function activateBucket(string memory _bucket) external;\\n\\n    /**\\n     * @notice Freezes a bucket, preventing further operations on it,\\n     * by changing its status from active to inactive.\\n     * @dev Only callable by the EMERGENCY_ADMIN role.\\n     * @param _bucket The bucket to be frozen.\\n     */\\n    function freezeBucket(string memory _bucket) external;\\n\\n    /**\\n     * @notice Adds a new bucket.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _newBucket The address of the new bucket to be added.\\n     * @param _pmxRewardAmount The amount of PMX tokens to be rewarded from the bucket.\\n     * Emits a AddNewBucket event with the struct BucketData of the newly added bucket.\\n     */\\n    function addBucket(address _newBucket, uint256 _pmxRewardAmount) external;\\n\\n    /**\\n     * @notice Activates a DEX by changing flag isActive on to true.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _dex The name of the DEX to activate.\\n     */\\n    function activateDEX(string memory _dex) external;\\n\\n    /**\\n     * @notice Freezes a DEX by changing flag isActive to false.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _dex The name of the DEX to be frozen.\\n     */\\n    function freezeDEX(string memory _dex) external;\\n\\n    /**\\n     * @notice Adds a new DEX to the protocol.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _name The name of the DEX.\\n     * @param _routerAddress The address of the DEX router.\\n     */\\n    function addDEX(string memory _name, address _routerAddress) external;\\n\\n    /**\\n     * @notice Sets the address of the DEX adapter.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param newAdapterAddress The address of the new DEX adapter.\\n     */\\n    function setDexAdapter(address newAdapterAddress) external;\\n\\n    /**\\n     * @notice Set min protocol fee restrictions for different calling method.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     */\\n    function setMinFeeRestrictions(\\n        CallingMethod _callingMethod,\\n        MinFeeRestrictions calldata _minFeeRestrictions\\n    ) external;\\n\\n    /**\\n     * @dev The function to specify the address of conditional manager of some type\\n     * 1 => LimitPriceCOM\\n     * 2 => TakeProfitStopLossCCM\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _address Address to be set for a conditional manager\\n     * @param _cmType The type of a conditional manager\\n     */\\n    function setConditionalManager(uint256 _cmType, address _address) external;\\n\\n    /**\\n     * @notice Retrieves the address of a bucket by its name.\\n     * @param _name The name of the bucket.\\n     * @return The address of the bucket.\\n     */\\n    function getBucketAddress(string memory _name) external view returns (address);\\n\\n    /**\\n     * @notice Retrieves the address of the DEX router based on the given DEX name.\\n     * @param _name The name of the DEX.\\n     * @return The address of the DEX router.\\n     */\\n    function getDexAddress(string memory _name) external view returns (address);\\n\\n    /**\\n     * @notice Retrieves the names of Dexes registered in the protocol.\\n     * @return An array of strings containing the names of all Dexes.\\n     */\\n    function getAllDexes() external view returns (string[] memory);\\n\\n    /**\\n     * @notice Set the protocol fee rate for one type of order.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     */\\n    function setProtocolFeeRate(FeeRateParams[] calldata _feeRateType) external;\\n\\n    /**\\n     * @notice Set average gas amount of gas spent by Keeper on the corresponding action.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     */\\n    function setAverageGasPerAction(AverageGasPerActionParams calldata _averageGasPerActionParams) external;\\n\\n    /**\\n     * @notice Set the max protocol fee.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _maxProtocolFee The new max protocol fee.\\n     */\\n    function setMaxProtocolFee(uint256 _maxProtocolFee) external;\\n\\n    /**\\n     * @notice Set protocol fee coefficient. Used to calculate the minProtocol fee\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     */\\n    function setProtocolFeeCoefficient(uint256 _maxProtocolFee) external;\\n\\n    /**\\n     * @notice Set liquidation gas amount (average gas amount spent for a single liquidation).\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     */\\n    function setLiquidationGasAmount(uint256 _maxProtocolFee) external;\\n\\n    /**\\n     * @notice Set pmxDiscountMultiplier.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     */\\n    function setPmxDiscountMultiplier(uint256 _pmxDiscountMultiplier) external;\\n\\n    /**\\n     * @notice Set new additionalGas. Used to calculate the minProtocol fee\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     */\\n    function setAdditionalGasSpent(uint256 _additionalGasSpent) external;\\n\\n    /**\\n     * @notice Set new gasPriceBuffer.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     */\\n    function setGasPriceBuffer(uint256 _gasPriceBuffer) external;\\n\\n    /**\\n     * @notice Set new leverageTolerance.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     */\\n    function setLeverageTolerance(uint256 _leverageTolerance) external;\\n\\n    /**\\n     * @notice Retrieves pmx, treasury, feeRateType, maxProtocolFee, pmxDiscountMultiplier\\n     */\\n    function getPrimexDNSParams() external view returns (address, address, address, uint256, uint256);\\n\\n    /**\\n     * @notice Retrieves protocolFeeRateByTier by the feeRateType and the user tier\\n     */\\n    function getProtocolFeeRateByTier(FeeRateType _feeRateType, uint256 _tier) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves an array of protocolFeeRateByTier by the feeRateType\\n     */\\n\\n    function getProtocolFeeRatesByTier(\\n        FeeRateType _feeRateType,\\n        uint256[] calldata _tiers\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @notice Retrieves liquidationGasAmount, protocolFeeCoefficient, additionalGasSpent, maxGasAmount and baseLength\\n     */\\n    function getParamsForMinProtocolFee(\\n        CallingMethod _callingMethod\\n    ) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    /**\\n     * @notice Retrieves baseLength, averageGasPerAction, protocolFeeCoefficient and gasPriceBuffer\\n     */\\n    function getParamsForMinPositionSize(\\n        TradingOrderType _tradingOrderType\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    /**\\n     * @notice Retrieves baseLength for L2 chain payment model depending from tradingOrderType\\n     */\\n    function getL1BaseLengthForTradingOrderType(TradingOrderType _tradingOrderType) external view returns (uint256);\\n}\\n\\ninterface IPrimexDNS is IPrimexDNSStorage {\\n    event AddNewBucket(BucketData newBucketData);\\n    event BucketDeprecated(address bucketAddress, uint256 delistingTime);\\n    event AddNewDex(DexData newDexData);\\n    event ChangeFeeRate(OrderType orderType, address token, uint256 rate);\\n    event ConditionalManagerChanged(uint256 indexed cmType, address indexed cmAddress);\\n    event PMXchanged(address indexed pmx);\\n    event AavePoolChanged(address indexed aavePool);\\n    event BucketActivated(address indexed bucketAddress);\\n    event BucketFrozen(address indexed bucketAddress);\\n    event DexAdapterChanged(address indexed newAdapterAddress);\\n    event DexActivated(address indexed routerAddress);\\n    event DexFrozen(address indexed routerAddress);\\n\\n    /**\\n     * @param orderType The order type for which the rate is set\\n     * @param feeToken The token address for which the rate is set\\n     * @param rate Setting rate in WAD format (1 WAD = 100%)\\n     */\\n    struct FeeRateParams {\\n        OrderType orderType;\\n        address feeToken;\\n        uint256 rate;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract with the specified parameters.\\n     * @param _registry The address of the PrimexRegistry contract.\\n     * @param _pmx The address of the PMX token contract.\\n     * @param _treasury The address of the Treasury contract.\\n     * @param _delistingDelay The time (in seconds) between deprecation and delisting of a bucket.\\n     * @param _adminWithdrawalDelay The time (in seconds) between delisting of a bucket and an adminDeadline.\\n     * @param _feeRateParams Initial fee params\\n     */\\n    function initialize(\\n        address _registry,\\n        address _pmx,\\n        address _treasury,\\n        uint256 _delistingDelay,\\n        uint256 _adminWithdrawalDelay,\\n        FeeRateParams[] calldata _feeRateParams\\n    ) external;\\n\\n    /**\\n     * @notice Deprecates a bucket.\\n     * @dev This function is used to deprecate a bucket by changing its current status to \\\"Deprecated\\\".\\n     * Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _bucket The name of the bucket to deprecate.\\n     * Emits a BucketDeprecated event with the bucket address and the delisting time.\\n     */\\n    function deprecateBucket(string memory _bucket) external;\\n\\n    /**\\n     * @notice This function is used to set the address of the Aave pool contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _aavePool The address of the Aave pool contract to be set.\\n     */\\n    function setAavePool(address _aavePool) external;\\n\\n    /**\\n     * @notice Sets the protocol rate in PMX.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     */\\n    function setFeeRate(FeeRateParams calldata _feeRateParams) external;\\n\\n    /**\\n     * @notice Sets the address of the PMX token contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _pmx The address of the PMX token contract.\\n     */\\n    function setPMX(address _pmx) external;\\n\\n    /**\\n     * @notice Activates a bucket by changing its status from inactive to active.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _bucket The bucket to activate.\\n     */\\n    function activateBucket(string memory _bucket) external;\\n\\n    /**\\n     * @notice Freezes a bucket, preventing further operations on it,\\n     * by changing its status from active to inactive.\\n     * @dev Only callable by the EMERGENCY_ADMIN role.\\n     * @param _bucket The bucket to be frozen.\\n     */\\n    function freezeBucket(string memory _bucket) external;\\n\\n    /**\\n     * @notice Adds a new bucket.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _newBucket The address of the new bucket to be added.\\n     * @param _pmxRewardAmount The amount of PMX tokens to be rewarded from the bucket.\\n     * Emits a AddNewBucket event with the struct BucketData of the newly added bucket.\\n     */\\n    function addBucket(address _newBucket, uint256 _pmxRewardAmount) external;\\n\\n    /**\\n     * @notice Activates a DEX by changing flag isActive on to true.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _dex The name of the DEX to activate.\\n     */\\n    function activateDEX(string memory _dex) external;\\n\\n    /**\\n     * @notice Freezes a DEX by changing flag isActive to false.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _dex The name of the DEX to be frozen.\\n     */\\n    function freezeDEX(string memory _dex) external;\\n\\n    /**\\n     * @notice Adds a new DEX to the protocol.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _name The name of the DEX.\\n     * @param _routerAddress The address of the DEX router.\\n     */\\n    function addDEX(string memory _name, address _routerAddress) external;\\n\\n    /**\\n     * @notice Sets the address of the DEX adapter.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param newAdapterAddress The address of the new DEX adapter.\\n     */\\n    function setDexAdapter(address newAdapterAddress) external;\\n\\n    /**\\n     * @dev The function to specify the address of conditional manager of some type\\n     * 1 => LimitPriceCOM\\n     * 2 => TakeProfitStopLossCCM\\n     * @param _address Address to be set for a conditional manager\\n     * @param _cmType The type of a conditional manager\\n     */\\n    function setConditionalManager(uint256 _cmType, address _address) external;\\n\\n    /**\\n     * @notice Retrieves the address of a bucket by its name.\\n     * @param _name The name of the bucket.\\n     * @return The address of the bucket.\\n     */\\n    function getBucketAddress(string memory _name) external view returns (address);\\n\\n    /**\\n     * @notice Retrieves the address of the DEX router based on the given DEX name.\\n     * @param _name The name of the DEX.\\n     * @return The address of the DEX router.\\n     */\\n    function getDexAddress(string memory _name) external view returns (address);\\n\\n    /**\\n     * @notice Retrieves the names of Dexes registered in the protocol.\\n     * @return An array of strings containing the names of all Dexes.\\n     */\\n    function getAllDexes() external view returns (string[] memory);\\n}\\n\",\"keccak256\":\"0xcc4385cbb7d2c105887593e8c7a2db1145b27d5665b821b55ac6a17e9ba53a47\",\"license\":\"BUSL-1.1\"},\"contracts/PrimexDNS/IPrimexDNSStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\nimport {ITiersManager} from \\\"../TiersManager/ITiersManager.sol\\\";\\n\\ninterface IPrimexDNSStorage {\\n    enum Status {\\n        Inactive,\\n        Active,\\n        Deprecated\\n    }\\n\\n    enum OrderType {\\n        MARKET_ORDER,\\n        LIMIT_ORDER,\\n        SWAP_MARKET_ORDER,\\n        SWAP_LIMIT_ORDER\\n    }\\n\\n    struct BucketData {\\n        address bucketAddress;\\n        Status currentStatus;\\n        uint256 delistingDeadline;\\n        // The deadline is for the admin to call Bucket.withdrawAfterDelisting().\\n        uint256 adminDeadline;\\n    }\\n    struct DexData {\\n        address routerAddress;\\n        bool isActive;\\n    }\\n\\n    struct AdapterData {\\n        string[] dexes;\\n        bool isAdded;\\n    }\\n\\n    function registry() external view returns (address);\\n\\n    function delistingDelay() external view returns (uint256);\\n\\n    function adminWithdrawalDelay() external view returns (uint256);\\n\\n    function buckets(string memory) external view returns (address, Status, uint256, uint256);\\n\\n    function dexes(string memory) external view returns (address, bool);\\n\\n    function cmTypeToAddress(uint256 cmType) external view returns (address);\\n\\n    function dexAdapter() external view returns (address);\\n\\n    function pmx() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function aavePool() external view returns (address);\\n\\n    function feeRates(OrderType _orderType, address _token) external view returns (uint256);\\n}\\n\\ninterface IPrimexDNSStorageV2 is IPrimexDNSStorage {\\n    struct FeeRestrictions {\\n        uint256 minProtocolFee;\\n        uint256 maxProtocolFee;\\n    }\\n\\n    function feeRestrictions(\\n        OrderType _orderType\\n    ) external view returns (uint256 minProtocolFee, uint256 maxProtocolFee);\\n}\\n\\ninterface IPrimexDNSStorageV3 is IPrimexDNSStorageV2 {\\n    enum FeeRateType {\\n        MarginPositionClosedByTrader,\\n        SpotPositionClosedByTrader,\\n        MarginPositionClosedByKeeper,\\n        SpotPositionClosedByKeeper,\\n        MarginLimitOrderExecuted,\\n        SpotLimitOrderExecuted,\\n        SwapLimitOrderExecuted,\\n        SwapMarketOrder\\n    }\\n\\n    enum TradingOrderType {\\n        MarginMarketOrder,\\n        SpotMarketOrder,\\n        MarginLimitOrder,\\n        MarginLimitOrderDepositInThirdAsset,\\n        SpotLimitOrder,\\n        SwapLimitOrder\\n    }\\n\\n    enum CallingMethod {\\n        OpenPositionByOrder,\\n        ClosePositionByCondition\\n    }\\n    struct MinFeeRestrictions {\\n        uint256 maxGasAmount;\\n        uint256 baseLength;\\n    }\\n\\n    function protocolFeeRates(FeeRateType _feeRateType) external view returns (uint256);\\n\\n    function averageGasPerAction(TradingOrderType _tradingOrderType) external view returns (uint256);\\n\\n    function minFeeRestrictions(\\n        CallingMethod _callingMethod\\n    ) external view returns (uint256 maxGasAmount, uint256 baseLength);\\n\\n    function maxProtocolFee() external view returns (uint256);\\n\\n    function protocolFeeCoefficient() external view returns (uint256);\\n\\n    function liquidationGasAmount() external view returns (uint256);\\n\\n    function additionalGasSpent() external view returns (uint256);\\n\\n    function pmxDiscountMultiplier() external view returns (uint256);\\n\\n    function gasPriceBuffer() external view returns (uint256);\\n\\n    function leverageTolerance() external view returns (uint256);\\n}\\n\\ninterface IPrimexDNSStorageV4 is IPrimexDNSStorageV3 {\\n    function protocolFeeRatesByTier(FeeRateType _feeRateType, uint256 _tier) external view returns (uint256);\\n\\n    function tiersManager() external view returns (ITiersManager);\\n}\\n\",\"keccak256\":\"0x7ed019ece2b07bc517166ff58f9365105deb46f399e66309085508324593e54f\",\"license\":\"BUSL-1.1\"},\"contracts/PrimexDNS/PrimexDNS.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.26;\\n\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\nimport \\\"../libraries/Errors.sol\\\";\\n\\nimport \\\"./PrimexDNSStorage.sol\\\";\\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \\\"../Constants.sol\\\";\\nimport {IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {WadRayMath} from \\\"../libraries/utils/WadRayMath.sol\\\";\\nimport {IPrimexDNSV3, IPrimexDNS} from \\\"./IPrimexDNS.sol\\\";\\nimport {IDexAdapter} from \\\"../interfaces/IDexAdapter.sol\\\";\\nimport {ILiquidityMiningRewardDistributor} from \\\"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\\\";\\nimport {ITreasury} from \\\"../Treasury/ITreasury.sol\\\";\\nimport {IConditionalClosingManager} from \\\"../interfaces/IConditionalClosingManager.sol\\\";\\nimport {IConditionalOpeningManager} from \\\"../interfaces/IConditionalOpeningManager.sol\\\";\\nimport {ITiersManager} from \\\"../TiersManager/ITiersManager.sol\\\";\\n\\ncontract PrimexDNS is IPrimexDNSV3, PrimexDNSStorageV4 {\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @dev Modifier that checks if the caller has a specific role.\\n     * @param _role The role identifier to check.\\n     */\\n    modifier onlyRole(bytes32 _role) {\\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\\n        _;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function initialize(InitParams calldata _params) public override initializer {\\n        _require(\\n            IERC165Upgradeable(_params.pmx).supportsInterface(type(IERC20).interfaceId) &&\\n                IERC165Upgradeable(_params.registry).supportsInterface(type(IAccessControl).interfaceId) &&\\n                IERC165Upgradeable(_params.treasury).supportsInterface(type(ITreasury).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        _setMaxProtocolFee(_params.maxProtocolFee);\\n        _setLiquidationGasAmount(_params.liquidationGasAmount);\\n        _setProtocolFeeCoefficient(_params.protocolFeeCoefficient);\\n        _setAdditionalGasSpent(_params.additionalGasSpent);\\n        _setPmxDiscountMultiplier(_params.pmxDiscountMultiplier);\\n        _setGasPriceBuffer(_params.gasPriceBuffer);\\n        _setLeverageTolerance(_params.leverageTolerance);\\n\\n        for (uint256 i; i < _params.feeRateParams.length; i++) {\\n            _setProtocolFeeRate(_params.feeRateParams[i]);\\n        }\\n\\n        for (uint256 i; i < _params.averageGasPerActionParams.length; i++) {\\n            _setAverageGasPerAction(_params.averageGasPerActionParams[i]);\\n        }\\n\\n        pmx = _params.pmx;\\n        registry = _params.registry;\\n        treasury = _params.treasury;\\n        delistingDelay = _params.delistingDelay;\\n        adminWithdrawalDelay = _params.adminWithdrawalDelay;\\n        __ERC165_init();\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setConditionalManager(uint256 _cmType, address _address) external override onlyRole(BIG_TIMELOCK_ADMIN) {\\n        _require(\\n            IERC165Upgradeable(_address).supportsInterface(type(IConditionalOpeningManager).interfaceId) ||\\n                IERC165Upgradeable(_address).supportsInterface(type(IConditionalClosingManager).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        cmTypeToAddress[_cmType] = _address;\\n        emit ConditionalManagerChanged(_cmType, _address);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setPMX(address _pmx) external override onlyRole(BIG_TIMELOCK_ADMIN) {\\n        _require(\\n            IERC165Upgradeable(_pmx).supportsInterface(type(IERC20).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        pmx = _pmx;\\n        emit PMXchanged(_pmx);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setAavePool(address _aavePool) external override onlyRole(BIG_TIMELOCK_ADMIN) {\\n        aavePool = _aavePool;\\n        emit AavePoolChanged(_aavePool);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setMaxProtocolFee(uint256 _maxProtocolFee) external override onlyRole(BIG_TIMELOCK_ADMIN) {\\n        _setMaxProtocolFee(_maxProtocolFee);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setMinFeeRestrictions(\\n        CallingMethod _callingMethod,\\n        MinFeeRestrictions calldata _minFeeRestrictions\\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        minFeeRestrictions[_callingMethod] = _minFeeRestrictions;\\n        emit ChangeMinFeeRestrictions(_callingMethod, _minFeeRestrictions);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setLiquidationGasAmount(uint256 _liquidationGasAmount) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        _setLiquidationGasAmount(_liquidationGasAmount);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setProtocolFeeRate(\\n        FeeRateParams[] calldata _feeRateParams\\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        for (uint256 i; i < _feeRateParams.length; i++) {\\n            _setProtocolFeeRate(_feeRateParams[i]);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setTiersManager(address _tiersManager) external override onlyRole(BIG_TIMELOCK_ADMIN) {\\n        _require(\\n            IERC165Upgradeable(_tiersManager).supportsInterface(type(ITiersManager).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        tiersManager = ITiersManager(_tiersManager);\\n        emit TiersManagerchanged(_tiersManager);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setAverageGasPerAction(\\n        AverageGasPerActionParams calldata _averageGasPerActionParams\\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        _setAverageGasPerAction(_averageGasPerActionParams);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setProtocolFeeCoefficient(uint256 _protocolFeeCoefficient) external override onlyRole(BIG_TIMELOCK_ADMIN) {\\n        _setProtocolFeeCoefficient(_protocolFeeCoefficient);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setAdditionalGasSpent(uint256 _additionalGasSpent) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        _setAdditionalGasSpent(_additionalGasSpent);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setPmxDiscountMultiplier(uint256 _pmxDiscountMultiplier) external override onlyRole(SMALL_TIMELOCK_ADMIN) {\\n        _setPmxDiscountMultiplier(_pmxDiscountMultiplier);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setGasPriceBuffer(uint256 _gasPriceBuffer) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        _setGasPriceBuffer(_gasPriceBuffer);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setLeverageTolerance(uint256 _leverageTolerance) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        _setLeverageTolerance(_leverageTolerance);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function getPrimexDNSParams() external view override returns (address, address, address, uint256, uint256) {\\n        return (pmx, treasury, address(tiersManager), maxProtocolFee, pmxDiscountMultiplier);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n\\n    function getProtocolFeeRateByTier(\\n        FeeRateType _feeRateType,\\n        uint256 _tier\\n    ) external view override returns (uint256) {\\n        return protocolFeeRatesByTier[_feeRateType][_tier];\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n\\n    function getProtocolFeeRatesByTier(\\n        FeeRateType _feeRateType,\\n        uint256[] calldata _tiers\\n    ) external view override returns (uint256[] memory) {\\n        uint256[] memory rates = new uint256[](_tiers.length);\\n        for (uint256 i; i < _tiers.length; i++) {\\n            rates[i] = protocolFeeRatesByTier[_feeRateType][_tiers[i]];\\n        }\\n        return rates;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function getParamsForMinProtocolFee(\\n        CallingMethod _callingMethod\\n    ) external view override returns (uint256, uint256, uint256, uint256, uint256) {\\n        MinFeeRestrictions memory restrictions = minFeeRestrictions[_callingMethod];\\n        return (\\n            liquidationGasAmount,\\n            protocolFeeCoefficient,\\n            additionalGasSpent,\\n            restrictions.maxGasAmount,\\n            restrictions.baseLength\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function getParamsForMinPositionSize(\\n        TradingOrderType _tradingOrderType\\n    ) external view override returns (uint256, uint256, uint256, uint256) {\\n        uint256 baseLength = this.getL1BaseLengthForTradingOrderType(_tradingOrderType);\\n        return (baseLength, averageGasPerAction[_tradingOrderType], protocolFeeCoefficient, gasPriceBuffer);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function getL1BaseLengthForTradingOrderType(\\n        TradingOrderType _tradingOrderType\\n    ) external view override returns (uint256) {\\n        if (\\n            _tradingOrderType == TradingOrderType.MarginMarketOrder ||\\n            _tradingOrderType == TradingOrderType.SpotMarketOrder\\n        ) {\\n            return minFeeRestrictions[CallingMethod.ClosePositionByCondition].baseLength;\\n        } else {\\n            return minFeeRestrictions[CallingMethod.OpenPositionByOrder].baseLength;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function deprecateBucket(string memory _bucket) external override onlyRole(BIG_TIMELOCK_ADMIN) {\\n        BucketData storage bucket = buckets[_bucket];\\n        _require(bucket.currentStatus != Status.Deprecated, Errors.BUCKET_IS_ALREADY_DEPRECATED.selector);\\n        bucket.currentStatus = Status.Deprecated;\\n        uint256 delistingDeadline = block.timestamp + delistingDelay;\\n        bucket.delistingDeadline = delistingDeadline;\\n        bucket.adminDeadline = delistingDeadline + adminWithdrawalDelay;\\n        emit BucketDeprecated(bucket.bucketAddress, delistingDeadline);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function activateBucket(string memory _bucket) external override onlyRole(SMALL_TIMELOCK_ADMIN) {\\n        BucketData storage bucket = buckets[_bucket];\\n        _require(bucket.currentStatus == Status.Inactive, Errors.BUCKET_ALREADY_ACTIVATED.selector);\\n        _require(bucket.bucketAddress != address(0), Errors.BUCKET_NOT_ADDED.selector);\\n        bucket.currentStatus = Status.Active;\\n        emit BucketActivated(bucket.bucketAddress);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function freezeBucket(string memory _bucket) external override onlyRole(EMERGENCY_ADMIN) {\\n        _require(buckets[_bucket].currentStatus == Status.Active, Errors.BUCKET_ALREADY_FROZEN.selector);\\n        buckets[_bucket].currentStatus = Status.Inactive;\\n        emit BucketFrozen(buckets[_bucket].bucketAddress);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function addBucket(address _newBucket, uint256 _pmxRewardAmount) external override onlyRole(SMALL_TIMELOCK_ADMIN) {\\n        _require(\\n            IERC165Upgradeable(_newBucket).supportsInterface(type(IBucketV3).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        string memory name = IBucketV3(_newBucket).name();\\n        _require(buckets[name].bucketAddress == address(0), Errors.BUCKET_IS_ALREADY_ADDED.selector);\\n\\n        IBucketV3.LiquidityMiningParams memory params = IBucketV3(_newBucket).getLiquidityMiningParams();\\n        if (params.accumulatingAmount != 0) {\\n            // can be changed on transferAsset in traderBalanceVault to moving untransferable token\\n            IERC20(pmx).transferFrom(msg.sender, address(params.liquidityMiningRewardDistributor), _pmxRewardAmount);\\n            params.liquidityMiningRewardDistributor.updateBucketReward(name, _pmxRewardAmount);\\n        }\\n\\n        BucketData memory newBucket = BucketData(_newBucket, Status.Active, 0, 0);\\n        buckets[name] = newBucket;\\n        emit AddNewBucket(newBucket);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function activateDEX(string memory _dex) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        _require(!dexes[_dex].isActive, Errors.DEX_IS_ALREADY_ACTIVATED.selector);\\n        dexes[_dex].isActive = true;\\n        emit DexActivated(dexes[_dex].routerAddress);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function freezeDEX(string memory _dex) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        _require(dexes[_dex].isActive, Errors.DEX_IS_ALREADY_FROZEN.selector);\\n        dexes[_dex].isActive = false;\\n        emit DexFrozen(dexes[_dex].routerAddress);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function addDEX(string memory _name, address _routerAddress) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\\n        _require(dexes[_name].routerAddress == address(0), Errors.DEX_IS_ALREADY_ADDED.selector);\\n        _require(_routerAddress != address(0), Errors.CAN_NOT_ADD_WITH_ZERO_ADDRESS.selector);\\n        dexesNames.push(_name);\\n        DexData memory newDEX = DexData(_routerAddress, true);\\n        dexes[_name] = newDEX;\\n        emit AddNewDex(newDEX);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function setDexAdapter(address _newAdapterAddress) external override onlyRole(BIG_TIMELOCK_ADMIN) {\\n        _require(\\n            IERC165Upgradeable(_newAdapterAddress).supportsInterface(type(IDexAdapter).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        dexAdapter = _newAdapterAddress;\\n        emit DexAdapterChanged(_newAdapterAddress);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function getAllDexes() external view override returns (string[] memory) {\\n        return dexesNames;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function getBucketAddress(string memory _name) external view override returns (address) {\\n        BucketData memory bucket = buckets[_name];\\n        _require(bucket.bucketAddress != address(0), Errors.BUCKET_NOT_ADDED.selector);\\n        _require(bucket.currentStatus == Status.Active, Errors.BUCKET_IS_INACTIVE.selector);\\n        return bucket.bucketAddress;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexDNSV3\\n     */\\n    function getDexAddress(string memory _name) external view override returns (address) {\\n        DexData memory dex = dexes[_name];\\n        return dex.routerAddress;\\n    }\\n\\n    /**\\n     * @notice Interface checker\\n     * @param interfaceId The interface id to check\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IPrimexDNSV3).interfaceId ||\\n            interfaceId == type(IPrimexDNS).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function _setMaxProtocolFee(uint256 _maxProtocolFee) internal {\\n        maxProtocolFee = _maxProtocolFee;\\n        emit ChangeMaxProtocolFee(_maxProtocolFee);\\n    }\\n\\n    function _setLiquidationGasAmount(uint256 _liquidationGasAmount) internal {\\n        liquidationGasAmount = _liquidationGasAmount;\\n        emit ChangeLiquidationGasAmount(_liquidationGasAmount);\\n    }\\n\\n    function _setProtocolFeeCoefficient(uint256 _protocolFeeCoefficient) internal {\\n        protocolFeeCoefficient = _protocolFeeCoefficient;\\n        emit ChangeProtocolFeeCoefficient(_protocolFeeCoefficient);\\n    }\\n\\n    function _setProtocolFeeRate(FeeRateParams calldata _feeRateParams) internal {\\n        protocolFeeRatesByTier[_feeRateParams.feeRateType][_feeRateParams.tier] = _feeRateParams.feeRate;\\n        emit ChangeProtocolFeeRate(_feeRateParams.feeRateType, _feeRateParams.tier, _feeRateParams.feeRate);\\n    }\\n\\n    function _setAverageGasPerAction(AverageGasPerActionParams calldata _averageGasPerActionParams) internal {\\n        averageGasPerAction[_averageGasPerActionParams.tradingOrderType] = _averageGasPerActionParams\\n            .averageGasPerAction;\\n        emit ChangeAverageGasPerAction(\\n            _averageGasPerActionParams.tradingOrderType,\\n            _averageGasPerActionParams.averageGasPerAction\\n        );\\n    }\\n\\n    function _setAdditionalGasSpent(uint256 _additionalGasSpent) internal {\\n        additionalGasSpent = _additionalGasSpent;\\n        emit ChangeAdditionalGasSpent(_additionalGasSpent);\\n    }\\n\\n    function _setPmxDiscountMultiplier(uint256 _pmxDiscountMultiplier) internal {\\n        pmxDiscountMultiplier = _pmxDiscountMultiplier;\\n        emit ChangePmxDiscountMultiplier(_pmxDiscountMultiplier);\\n    }\\n\\n    function _setGasPriceBuffer(uint256 _gasPriceBuffer) internal {\\n        gasPriceBuffer = _gasPriceBuffer;\\n        emit ChangeGasPriceBuffer(_gasPriceBuffer);\\n    }\\n\\n    function _setLeverageTolerance(uint256 _leverageTolerance) internal {\\n        _require(_leverageTolerance <= WadRayMath.WAD / 5, Errors.LEVERAGE_TOLERANCE_IS_NOT_CORRECT.selector); // <= 20%\\n        leverageTolerance = _leverageTolerance;\\n        emit ChangeLeverageTolerance(_leverageTolerance);\\n    }\\n}\\n\",\"keccak256\":\"0x4a2043eefcdf91c727d4bf8743ef971d3108bb309df97352b7027f01e766021a\",\"license\":\"BUSL-1.1\"},\"contracts/PrimexDNS/PrimexDNSStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.26;\\n\\nimport {ERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\\\";\\n\\nimport {IPrimexDNSStorage, IPrimexDNSStorageV2, IPrimexDNSStorageV3, IPrimexDNSStorageV4} from \\\"./IPrimexDNSStorage.sol\\\";\\nimport {ITiersManager} from \\\"../TiersManager/ITiersManager.sol\\\";\\n\\nabstract contract PrimexDNSStorage is IPrimexDNSStorage, ERC165Upgradeable {\\n    address public override registry;\\n\\n    /**\\n     * @notice check the scheme below for additional info\\n     */\\n    uint256 public override delistingDelay;\\n    uint256 public override adminWithdrawalDelay;\\n\\n    /* solhint-disable max-line-length */\\n    //                                          =========================================================\\n    //                                            \\\"delistingDelay\\\" and \\\"adminWithdrawalDelay\\\" explained\\n    //                                          =========================================================\\n\\n    //                  * Lenders can\\u2019t add liquidity to Bucket.         * Keepers can close all positions opened                * Admin can withdraw all funds from the bucket to Treasury.\\n    //                  * New positions or orders can\\u2019t be opened          through this Bucket.                                  * Admin can withdraw to Treasury all PMX rewards granted to\\n    //                    in this Bucket.\\u00a0                               * Lenders can withdraw their funds, which became          this bucket for liquidity mining (except already withdrawn amount).\\n    //                  * Lenders can withdraw existing deposits,          available after all positions were closed by\\n    //                    traders can close existing positions.            keepers.\\n    //\\n    //                |----------------delistingDelay------------------|---------------adminWithdrawalDelay------------------|---------------------------------------------------------------\\n    //                |                                                |                                                     |\\n    //      ----------|------------------------------------------------|-----------------------------------------------------|---------------------------------------------------------------\\n    //                |                                        delistingDeadline                                        adminDeadline\\n    //      -= bucket is DEPRECATED =-                      -= bucket is DELISTED =-\\n    //\\n    //\\n    /* solhint-enable max-line-length */\\n\\n    address public override pmx;\\n    address public override treasury;\\n    mapping(string => BucketData) public override buckets;\\n    mapping(string => DexData) public override dexes;\\n    mapping(uint256 => address) public override cmTypeToAddress;\\n    address public override dexAdapter;\\n    address public override aavePool;\\n\\n    // action to token to fee amount\\n    mapping(OrderType => mapping(address => uint256)) public override feeRates;\\n\\n    string[] internal dexesNames;\\n}\\n\\nabstract contract PrimexDNSStorageV2 is IPrimexDNSStorageV2, PrimexDNSStorage {\\n    mapping(OrderType => FeeRestrictions) public override feeRestrictions;\\n}\\n\\nabstract contract PrimexDNSStorageV3 is IPrimexDNSStorageV3, PrimexDNSStorageV2 {\\n    mapping(FeeRateType => uint256) public override protocolFeeRates;\\n    // Mapping to store average gas per action for different trading order types\\n    mapping(TradingOrderType => uint256) public override averageGasPerAction;\\n    // Mapping to store min protocol fee restrictions for different calling method\\n    mapping(CallingMethod => MinFeeRestrictions) public override minFeeRestrictions;\\n    // measured in NATIVE_CURRENCY\\n    uint256 public override maxProtocolFee;\\n    // additional coefficient to calculate minProtocolFee, measured in wei\\n    uint256 public override protocolFeeCoefficient;\\n    // average gas amount spent for a single liquidation, measured in wei\\n    uint256 public override liquidationGasAmount;\\n    // gas that will be additionally spend after gasSpent calculation\\n    uint256 public override additionalGasSpent;\\n    uint256 public override pmxDiscountMultiplier;\\n    // protects position from immediate liquidation after gas price changed\\n    uint256 public override gasPriceBuffer;\\n    // the limits of available deviation of the actual leverage from the leverage of an order\\n    uint256 public override leverageTolerance;\\n}\\n\\nabstract contract PrimexDNSStorageV4 is IPrimexDNSStorageV4, PrimexDNSStorageV3 {\\n    ITiersManager public override tiersManager;\\n    // RateType => Tier => Rate\\n    mapping(FeeRateType => mapping(uint256 => uint256)) public override protocolFeeRatesByTier;\\n}\\n\",\"keccak256\":\"0xb252056181e7def88403b07a3a632a680543b09f442ca20b7757e58da775f0b1\",\"license\":\"BUSL-1.1\"},\"contracts/Reserve/IReserve.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IReserveStorage} from \\\"./IReserveStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface IReserve is IReserveStorage, IPausable {\\n    event BurnAmountCalculated(uint256 burnAmount);\\n    event TransferRestrictionsChanged(address indexed pToken, TransferRestrictions newTransferRestrictions);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param dns The address of PrimexDNS contract\\n     * @param registry The address of Registry contract\\n     */\\n    function initialize(IPrimexDNSV3 dns, address registry) external;\\n\\n    /**\\n     * @dev Burns the permanent loss amount (presented in pTokens) from the Reserve for a particular bucket\\n     * @param bucket The address of a bucket\\n     * Emits BurnAmountCalculated(burnAmount) event\\n     */\\n    function paybackPermanentLoss(IBucketV3 bucket) external;\\n\\n    /**\\n     * @dev Transfers some bonus in pTokens to receiver from Reserve\\n     * Can be called by executor only\\n     * @param _bucketName The bucket where the msg.sender should be a fee decreaser (for debtToken) or\\n     * interest increaser (for pToken)\\n     * @param _to The receiver of bonus pTokens\\n     * @param _amount The amount of bonus pTokens to transfer\\n     */\\n    function payBonus(string memory _bucketName, address _to, uint256 _amount) external;\\n\\n    /**\\n     * @dev Function to transfer tokens to the Treasury. Only MEDIUM_TIMELOCK_ADMIN can call it.\\n     * @param bucket The bucket from which to transfer pTokens\\n     * @param amount The amount of pTokens to transfer\\n     */\\n    function transferToTreasury(address bucket, uint256 amount) external;\\n\\n    /**\\n     * @dev Function to set transfer restrictions for a token.\\n     * @notice Only MEDIUM_TIMELOCK_ADMIN can call it.\\n     * @param pToken pToken to set restrictions for\\n     * @param transferRestrictions Min amount to be left in the Reserve\\n     */\\n    function setTransferRestrictions(address pToken, TransferRestrictions calldata transferRestrictions) external;\\n}\\n\",\"keccak256\":\"0xddae0dbd32d6082d11bb5d6205847b9b919badc8b775584c4a1b7774541f9d5e\",\"license\":\"BUSL-1.1\"},\"contracts/Reserve/IReserveStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IReserveStorage {\\n    struct TransferRestrictions {\\n        uint256 minAmountToBeLeft;\\n        uint256 minPercentOfTotalSupplyToBeLeft;\\n    }\\n\\n    event TransferFromReserve(address pToken, address to, uint256 amount);\\n\\n    function transferRestrictions(address pToken) external view returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0x2817b7fb7470ca4af938ffe1485caa0b96dd22ac399d22c463f15efd9d6484cc\",\"license\":\"BUSL-1.1\"},\"contracts/SpotTradingRewardDistributor/ISpotTradingRewardDistributor.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {ISpotTradingRewardDistributorStorage} from \\\"./ISpotTradingRewardDistributorStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ISpotTradingRewardDistributorV2 is ISpotTradingRewardDistributorStorage, IPausable {\\n    event SpotTradingClaimReward(address indexed trader, uint256 amount);\\n    event RewardPerPeriodDecreased(uint256 indexed rewardPerPeriod);\\n    event TopUpUndistributedPmxBalance(uint256 indexed amount);\\n    event RewardPerPeriodChanged(uint256 indexed rewardPerPeriod);\\n    event PmxWithdrawn(uint256 indexed amount);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param registry The address of Registry contract\\n     * @param periodDuration The duration of a reward period\\n     * @param priceOracle The address of PriceOracle contract\\n     * @param pmx The address of PMX token\\n     * @param traderBalanceVault The address of TraderBalanceVault contract\\n     * @param treasury The address of Treasury contract\\n     */\\n    function initialize(\\n        address registry,\\n        uint256 periodDuration,\\n        address priceOracle,\\n        address pmx,\\n        address payable traderBalanceVault,\\n        address treasury\\n    ) external;\\n\\n    /**\\n     * @dev Function to update spot trader activity. Only PM_ROLE can call it.\\n     * @param trader Address of a trader\\n     * @param positionAsset Address of a position asset\\n     * @param positionAmount Amount of a position asset\\n     */\\n    function updateTraderActivity(\\n        address trader,\\n        address positionAsset,\\n        uint256 positionAmount,\\n        bytes calldata positionUsdOracleDataoracleData\\n    ) external;\\n\\n    /**\\n     * @dev Function to claim reward for spot trading activity.\\n     * Transfer rewards on the balance in traderBalanceVault\\n     * Emits SpotTradingClaimReward(address trader, uint256 amount)\\n     */\\n    function claimReward() external;\\n\\n    /**\\n     * @dev Function to set new reward per period. Only MEDIUM_TIMELOCK_ADMIN can call it.\\n     * @param rewardPerPeriod New value for reward per period\\n     */\\n    function setRewardPerPeriod(uint256 rewardPerPeriod) external;\\n\\n    /**\\n     * @dev Function to decrease reward per period. Only EMERGENCY_ADMIN can call it.\\n     * @param _rewardPerPeriod New value for reward per period, must be less than the current value\\n     */\\n    function decreaseRewardPerPeriod(uint256 _rewardPerPeriod) external;\\n\\n    /**\\n     * @dev Function to topUp the contract PMX balance\\n     * @param amount PMX amount to add to the contract balance\\n     */\\n    function topUpUndistributedPmxBalance(uint256 amount) external;\\n\\n    /**\\n     * @dev Function to withdraw PMX from the contract to treasury\\n     * @dev Only BIG_TIMELOCK_ADMIN can call it.\\n     * @param amount Amount of PMX to withdraw from the contract\\n     */\\n    function withdrawPmx(uint256 amount) external;\\n\\n    /**\\n     * @dev Function to get SpotTraderActivity\\n     * @param periodNumber Period number\\n     * @param traderAddress Address of a trader\\n     * @return A struct with activity and hasClaimed members\\n     */\\n    function getSpotTraderActivity(uint256 periodNumber, address traderAddress) external view returns (uint256);\\n\\n    /**\\n     * @dev Get information for the period corresponding to the given timestamp\\n     * @param timestamp The timestamp to get information about\\n     * @return totalReward Total reward for the corresponding period\\n     * @return totalActivity Total activity for the corresponding period\\n     */\\n    function getPeriodInfo(uint256 timestamp) external view returns (uint256, uint256);\\n\\n    /**\\n     * @dev Function to get an array of period numbers when trader had any activity\\n     * @param trader Address of a trader\\n     * @return An array of period numbers with trader activity\\n     */\\n    function getPeriodsWithTraderActivity(address trader) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Function to calculate trader's reward for her activities during periods\\n     * @param trader Address of a trader\\n     * @return reward Amount of reward\\n     * @return currentPeriod The current period\\n     */\\n    function calculateReward(address trader) external view returns (uint256 reward, uint256 currentPeriod);\\n}\\n\",\"keccak256\":\"0x72645c477fa1dd8d809814cab55a09daef3d0171df99dc95205e134f1b40cf7c\",\"license\":\"BUSL-1.1\"},\"contracts/SpotTradingRewardDistributor/ISpotTradingRewardDistributorStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface ISpotTradingRewardDistributorStorage {\\n    struct PeriodInfo {\\n        uint256 totalReward;\\n        // map trader address to her activity\\n        mapping(address => uint256) traderActivity;\\n        uint256 totalActivity;\\n    }\\n\\n    function registry() external view returns (address);\\n\\n    function dns() external view returns (address);\\n\\n    function periodDuration() external view returns (uint256);\\n\\n    function initialPeriodTimestamp() external view returns (uint256);\\n\\n    function rewardPerPeriod() external view returns (uint256);\\n\\n    function pmx() external view returns (address);\\n\\n    function priceOracle() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function traderBalanceVault() external view returns (address payable);\\n\\n    function undistributedPMX() external view returns (uint256);\\n\\n    function periods(uint256 periodNumber) external view returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0xe6dc6a5ae48f0cacf886e84c42238f9c7cff42dd4e0e11dd35124ff79bfb87bd\",\"license\":\"BUSL-1.1\"},\"contracts/SwapManager/ISwapManager.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\nimport {IPrimexDNSV3, IPrimexDNSStorageV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ISwapManager is IPausable {\\n    event SpotSwap(\\n        address indexed trader,\\n        address indexed receiver,\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountSold,\\n        uint256 amountBought\\n    );\\n    event PaidProtocolFee(\\n        address indexed trader,\\n        address indexed boughtAsset,\\n        IPrimexDNSStorageV3.FeeRateType indexed feeRateType,\\n        uint256 feeInPositionAsset,\\n        uint256 feeInPmx\\n    );\\n\\n    /**\\n     * @param tokenA The address of the asset to be swapped from.\\n     * @param tokenB The address of the asset to be received in the swap.\\n     * @param amountTokenA The amount of tokenA to be swapped.\\n     * @param amountOutMin The minimum amount of tokenB expected to receive.\\n     * @param routes An array of PrimexPricingLibrary.Route structs representing the routes for the swap.\\n     * @param receiver The address where the swapped tokens will be received.\\n     * @param deadline The deadline for the swap transaction.\\n     * @param isSwapFromWallet A flag indicating whether the swap is perfomed from a wallet or a protocol balance.\\n     * @param isSwapToWallet A flag indicating whether the swapped tokens will be sent to a wallet or a protocol balance.\\n     * @param isSwapFeeInPmx A flag indicating whether the swap fee is paid in PMX or in native token.\\n     */\\n    struct SwapParams {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amountTokenA;\\n        uint256 amountOutMin;\\n        PrimexPricingLibrary.MegaRoute[] megaRoutes;\\n        address receiver;\\n        uint256 deadline;\\n        bool isSwapFromWallet;\\n        bool isSwapToWallet;\\n        bool isSwapFeeInPmx;\\n        bytes tokenAtokenBOracleData;\\n        bytes pmxPositionAssetOracleData;\\n        bytes nativePositionAssetOracleData;\\n        bytes[][] pullOracleData;\\n        uint256[] pullOracleTypes;\\n    }\\n\\n    /**\\n     * @param depositAsset The address of the deposited asset.\\n     * @param positionAsset The address of the position asset.\\n     * @param depositAmount Amount of tokens in a deposit asset.\\n     * @param megaRoutes An array of PrimexPricingLibrary.Route structs representing the routes for the swap.\\n     * @param trader The trader address, who has created the order.\\n     * @param deadline The deadline for the swap transaction.\\n     * @param feeToken An asset in which the fee will be paid. At this point it could be the pmx, the epmx or a positionAsset\\n     * @param keeperRewardDistributor The address of KeeperRewardDistributor contract.\\n     * @param gasSpent Gas spent on executing transaction.\\n     */\\n    struct SwapInLimitOrderParams {\\n        address depositAsset;\\n        address positionAsset;\\n        uint256 depositAmount;\\n        PrimexPricingLibrary.MegaRoute[] megaRoutes;\\n        address trader;\\n        uint256 deadline;\\n        address feeToken;\\n        address keeperRewardDistributor;\\n        uint256 gasSpent;\\n        bytes depositPositionAssetOracleData;\\n        bytes pmxPositionAssetOracleData;\\n        bytes nativePositionAssetOracleData;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract with the specified parameters.\\n     * @param _registry The address of the PrimexRegistry contract.\\n     */\\n    function initialize(address _registry) external;\\n\\n    /**\\n     * @notice Re-initializes the contract with the specified parameters.\\n     * @dev Only BIG_TIMELOCK_ADMIN can call it.\\n     * @param _primexDNS The address of the PrimexDNS contract.\\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\\n     * @param _priceOracle The address of the PriceOracle contract.\\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\\n     */\\n    function initializeAfterUpgrade(\\n        address _primexDNS,\\n        address payable _traderBalanceVault,\\n        address _priceOracle,\\n        address _whiteBlackList\\n    ) external;\\n\\n    /**\\n     * @notice Executes a swap on dexes defined in routes\\n     * @param params The SwapParams struct containing the details of the swap transaction.\\n     * @param maximumOracleTolerableLimit The maximum tolerable limit in WAD format (1 WAD = 100%)\\n     * @param needOracleTolerableLimitCheck Flag indicating whether to perform an oracle tolerable limit check.\\n     * @return The resulting amount after the swap.\\n     */\\n    function swap(\\n        SwapParams calldata params,\\n        uint256 maximumOracleTolerableLimit,\\n        bool needOracleTolerableLimitCheck\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Executes a swap on dexes defined in routes\\n     * @dev Only callable by the LOM_ROLE role.\\n     * @param params The SwapInLimitOrderParams struct containing the details of the swap transaction.\\n     * @param maximumOracleTolerableLimit The maximum tolerable limit in WAD format (1 WAD = 100%)\\n     * @return The resulting amount after the swap and feeInPositionAsset.\\n     */\\n    function swapInLimitOrder(\\n        SwapInLimitOrderParams calldata params,\\n        uint256 maximumOracleTolerableLimit\\n    ) external returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0xd37aefb58f805f2e97681c83ca409569fe2551ddb3716c8fb9e5e94739a95dac\",\"license\":\"BUSL-1.1\"},\"contracts/TiersManager/ITiersManager.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface ITiersManager {\\n    function initialize(\\n        address _pmx,\\n        address _registry,\\n        address _lendingNFT,\\n        address _tradingNFT,\\n        address _farmingNFT,\\n        uint256[] calldata _tiers,\\n        uint256[] calldata _thresholds\\n    ) external;\\n\\n    function initializeAfterUpgrade(address payable _traderBalanceVault) external;\\n\\n    function getTraderTierForAddress(address _userAddress) external view returns (uint256);\\n\\n    function getLenderTierForAddress(address _userAddress) external view returns (uint256);\\n\\n    function addTiers(uint256[] calldata _tiers, uint256[] calldata _thresholds, bool _clearTiers) external;\\n\\n    function changeThresholdForTier(uint256[] calldata _indexes, uint256[] calldata _newThresholds) external;\\n\\n    function getTiers() external view returns (uint256[] memory);\\n\\n    function setPMX(address _pmx) external;\\n\\n    function getTraderTiersForAddresses(address[] memory _userAddresses) external view returns (uint256[] memory);\\n}\\n\",\"keccak256\":\"0x8bddf9a904e067ef36232630e1a6761ae420328df55882c5b251d055b7adb08d\",\"license\":\"BUSL-1.1\"},\"contracts/TraderBalanceVault/ITraderBalanceVault.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {ITraderBalanceVaultStorage} from \\\"./ITraderBalanceVaultStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ITraderBalanceVault is ITraderBalanceVaultStorage, IPausable {\\n    /**\\n     * Types of way to open a position or order\\n     */\\n    enum OpenType {\\n        OPEN_BY_ORDER,\\n        OPEN,\\n        CREATE_LIMIT_ORDER\\n    }\\n\\n    /**\\n     * @param trader The trader, who opens margin deal\\n     * @param depositReceiver the address to which the deposit is transferred when blocked.\\n     * This happens because the trader's deposit is involved in the position\\n     * @param borrowedAsset The token to lock for deal in a borrowed asset\\n     * @param depositAsset The token is a deposit asset\\n     * (it is blocked when creating a limit order\\n     * For others, the operations is transferred to the account of the receiver of the deposit and is swapped )\\n     * @param depositAmount Amount of tokens in a deposit asset\\n     * @param depositInBorrowedAmount Amount of tokens to lock for deal in a borrowed asset\\n     * @param openType Corresponds to the purpose of locking\\n     */\\n    struct LockAssetParams {\\n        address trader;\\n        address depositReceiver;\\n        address depositAsset;\\n        uint256 depositAmount;\\n        OpenType openType;\\n    }\\n\\n    /**\\n     * @param trader The trader who opened the position\\n     * @param receiver The receiver of the rest of trader deposit.\\n     * @param asset Borrowed asset of the position being closed (the need for accrual of profit).\\n     * @param unlockAmount The amount of unlocked collateral for deal\\n     * @param returnToTrader The returned to trader amount when position was closed.\\n     */\\n    struct UnlockAssetParams {\\n        address trader;\\n        address receiver;\\n        address asset;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @param traders An array of traders for which available balance should be increased\\n     * @param amounts An array of amounts corresponding to traders' addresses that should be added to their available balances\\n     * @param asset Asset address which amount will be increased\\n     * @param length The amount of traders in an array\\n     */\\n    struct BatchTopUpAvailableBalanceParams {\\n        address[] traders;\\n        uint256[] amounts;\\n        address asset;\\n        uint256 length;\\n    }\\n\\n    event Deposit(address indexed depositer, address indexed asset, uint256 amount);\\n    event Withdraw(address indexed withdrawer, address asset, uint256 amount);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param _registry The address of Registry contract\\n     * @param _whiteBlackList The address of WhiteBlackList contract\\n     */\\n    function initialize(address _registry, address _whiteBlackList) external;\\n\\n    receive() external payable;\\n\\n    /**\\n     * @dev Deposits trader collateral for margin deal\\n     * @param _asset The collateral asset for deal\\n     * @param _amount The amount of '_asset' to deposit\\n     */\\n    function deposit(address _asset, uint256 _amount) external payable;\\n\\n    /**\\n     * @dev Withdraws the rest of trader's deposit after closing deal\\n     * @param _asset The collateral asset for withdraw\\n     * @param _amount The amount of '_asset' to withdraw\\n     */\\n    function withdraw(address _asset, uint256 _amount) external;\\n\\n    /**\\n     * @dev Traders lock their collateral for the limit order.\\n     * @param _trader The owner of collateral\\n     * @param _asset The collateral asset for deal\\n     * @param _amount The amount of '_asset' to deposit\\n     */\\n    function increaseLockedBalance(address _trader, address _asset, uint256 _amount) external payable;\\n\\n    /**\\n     * @dev Locks deposited trader's assets as collateral for orders.\\n     * Decreases the available balance when opening position.\\n     * Transfers deposited amount to the deposit receiver.\\n     * @param _params parameters necessary to lock asset\\n     */\\n    function useTraderAssets(LockAssetParams calldata _params) external;\\n\\n    /**\\n     * @dev Unlocks trader's collateral when open position by order or update deposit.\\n     * @param _params parameters necessary to unlock asset\\n     */\\n    function unlockAsset(UnlockAssetParams calldata _params) external;\\n\\n    /**\\n     * The function to increase available balance for several traders\\n     * @param _params A struct containing BatchTopUpAvailableBalanceParams\\n     */\\n    function batchTopUpAvailableBalance(BatchTopUpAvailableBalanceParams calldata _params) external;\\n\\n    /**\\n     * Withdraws an asset amount from an asset holder to a receiver\\n     * @param _from Withdraw from address\\n     * @param _to Withdraw to address\\n     * @param _asset Address of an asset\\n     * @param _amount Amount of an asset\\n     * @param fromLocked True if withdraw from locked balance\\n     */\\n    function withdrawFrom(address _from, address _to, address _asset, uint256 _amount, bool fromLocked) external;\\n\\n    /**\\n     * Increases available balance of a receiver in the protocol\\n     * @param receiver The address of an asset receiver\\n     * @param asset The asset address for which available balance will be increased\\n     * @param amount The amount of an asset\\n     */\\n    function topUpAvailableBalance(address receiver, address asset, uint256 amount) external payable;\\n}\\n\\ninterface ITraderBalanceVaultV2 is ITraderBalanceVault {\\n    function getBalancesForAddresses(\\n        address[] calldata _traders,\\n        address _asset\\n    ) external view returns (uint256[] memory availableBalances, uint256[] memory lockedBalances);\\n}\\n\",\"keccak256\":\"0x417b707256772a2304e45ff18a6489f1fe3a4a0d73b6a189d04e322d743ccfdd\",\"license\":\"BUSL-1.1\"},\"contracts/TraderBalanceVault/ITraderBalanceVaultStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface ITraderBalanceVaultStorage {\\n    struct TraderBalance {\\n        uint256 availableBalance;\\n        uint256 lockedBalance;\\n    }\\n\\n    function registry() external view returns (address);\\n\\n    /**\\n     *\\n     * @param trader Trader's address\\n     * @param asset Asset address\\n     * @return availableBalance availableBalance\\n     * @return lockedBalance lockedBalance\\n     */\\n    function balances(\\n        address trader,\\n        address asset\\n    ) external view returns (uint256 availableBalance, uint256 lockedBalance);\\n}\\n\",\"keccak256\":\"0xc0579c182c55abcfcda0e8092e30b04b13e8a8700d0c92914d086fe482673dec\",\"license\":\"BUSL-1.1\"},\"contracts/Treasury/ITreasury.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {ITreasuryStorage} from \\\"./ITreasuryStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ITreasury is ITreasuryStorage, IPausable {\\n    event MaxSpendingLimitChanged(address indexed spender, address indexed token, SpendingLimits newSpendingLimits);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param registry The address of Registry contract\\n     */\\n    function initialize(address registry) external;\\n\\n    receive() external payable;\\n\\n    /**\\n     * @notice Transfers an amount of ERC20 or native token from the contract treasury to\\n     *  a receiver address, subject to certain restrictions imposed by the spender.\\n     * @dev The function checks the spender's transfer restrictions per transaction and per timeframe.\\n     * @param amount The amount of tokens to transfer.\\n     * @param token The address of the token to transfer. Use the address NATIVE_TOKEN_ADDRESS for native token.\\n     * @param receiver The address of the receiver\\n     */\\n    function transferFromTreasury(uint256 amount, address token, address receiver) external;\\n\\n    /**\\n     * @notice Sets the maximum spending limit and other restrictions for a given spender and token.\\n     * @dev This function can only be called by an address with the BIG_TIMELOCK_ADMIN role.\\n     * @param spender The address of the spender for whom to set the new spending limit.\\n     * @param token The address of the token for which to set the new spending limit.\\n     * @param newSpendingLimits The new spending limits and restrictions to set for the spender and token.\\n     */\\n    function setMaxSpendingLimit(address spender, address token, SpendingLimits calldata newSpendingLimits) external;\\n\\n    /**\\n     * @notice Decreases Spending limits for a spender for a specific token.\\n     * @dev This function can only be called by an address with the SMALL_TIMELOCK_ADMIN role.\\n     * @param spender The address of the spender for whom to decrease the maximum transfer amounts and total amount.\\n     * @param token The address of the token for which to decrease the maximum transfer amounts and total amount.\\n     * @param newSpendingLimits The new spending limits and restrictions to set for the spender and token.\\n     */\\n    function decreaseLimits(address spender, address token, SpendingLimits calldata newSpendingLimits) external;\\n\\n    /**\\n     * @notice Checks whether a spender can transfer tokens based on the minimum time between transfers imposed by the spending restrictions.\\n     * @param spender The address of the spender to check for.\\n     * @param token The address of the token for which to check the time restrictions.\\n     * @return A boolean indicating whether the spender can transfer tokens based on the minimum time between transfers.\\n     */\\n    function canTransferByTime(address spender, address token) external returns (bool);\\n}\\n\",\"keccak256\":\"0xd7aded330c00ef654ee0dc462b2f8ac8c6904d39ea0d492a61449408cef33fe0\",\"license\":\"BUSL-1.1\"},\"contracts/Treasury/ITreasuryStorage.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ITreasuryStorage {\\n    struct SpendingLimits {\\n        //transfer settings\\n        uint256 maxTotalAmount;\\n        uint256 maxAmountPerTransfer;\\n        uint256 maxPercentPerTransfer;\\n        uint256 minTimeBetweenTransfers;\\n        // timeframe settings\\n        uint256 timeframeDuration;\\n        uint256 maxAmountDuringTimeframe;\\n    }\\n    struct SpendingInfo {\\n        bool isSpenderExist;\\n        SpendingLimits limits;\\n        uint256 lastWithdrawalTimestamp;\\n        uint256 withdrawnDuringTimeframe;\\n    }\\n\\n    event TransferFromTreasury(\\n        address indexed spender,\\n        address indexed receiver,\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    function spenders(\\n        address spender,\\n        address token\\n    ) external returns (bool, SpendingLimits calldata, uint256, uint256);\\n\\n    function initialTimestamp() external returns (uint256);\\n\\n    function registry() external returns (IAccessControl);\\n}\\n\",\"keccak256\":\"0x95cf210b879cf7510bc35da0306a7c229cb5f90f842c97f341cb5794095e6276\",\"license\":\"BUSL-1.1\"},\"contracts/UniswapV2LPOracle/IUniswapV2LPOracle.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\nimport {IUniswapV2Pair} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\ninterface IUniswapV2LPOracle {\\n    function getQuoteInUsd(\\n        address lpToken,\\n        uint256 amount,\\n        bytes calldata token0UsdOracleData,\\n        bytes calldata token1UsdOracleData\\n    ) external returns (uint256);\\n\\n    function getLPExchangeRate(\\n        IUniswapV2Pair pair,\\n        bytes calldata token0UsdOracleData,\\n        bytes calldata token1UsdOracleData\\n    ) external returns (uint256);\\n}\\n\",\"keccak256\":\"0xf1d234b20d5ed0b581aa6c696639c3473287929667ad5f256bfaaf88e509951a\",\"license\":\"BUSL-1.1\"},\"contracts/WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IWhiteBlackList {\\n    enum AccessType {\\n        UNLISTED,\\n        WHITELISTED,\\n        BLACKLISTED\\n    }\\n    event WhitelistedAddressAdded(address indexed addr);\\n    event WhitelistedAddressRemoved(address indexed addr);\\n    event BlacklistedAddressAdded(address indexed addr);\\n    event BlacklistedAddressRemoved(address indexed addr);\\n\\n    function addAddressToWhitelist(address _address) external;\\n\\n    function addAddressesToWhitelist(address[] calldata _addresses) external;\\n\\n    function removeAddressFromWhitelist(address _address) external;\\n\\n    function removeAddressesFromWhitelist(address[] calldata _addresses) external;\\n\\n    function addAddressToBlacklist(address _address) external;\\n\\n    function addAddressesToBlacklist(address[] calldata _addresses) external;\\n\\n    function removeAddressFromBlacklist(address _address) external;\\n\\n    function removeAddressesFromBlacklist(address[] calldata _addresses) external;\\n\\n    function getAccessType(address _address) external view returns (AccessType);\\n\\n    function isBlackListed(address _address) external view returns (bool);\\n\\n    function registry() external view returns (address);\\n}\\n\",\"keccak256\":\"0x785da3d3b2de11abd60ed414f778047d6b216232dbbe6e06d4c1e907805aac85\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/EIP20NonStandardInterface.sol\":{\"content\":\"// Copyright 2020 Compound Labs, Inc.\\n// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface EIP20NonStandardInterface {\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     */\\n    function transfer(address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `approve` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved\\n     */\\n    function approve(address spender, uint256 amount) external;\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return remaining The number of tokens allowed to be spent\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\",\"keccak256\":\"0xd8ed07c2eb87e6e0e774ef1a92e62e6a3bf1e99d1a3cd365efc21011843688a9\",\"license\":\"BSD-3-Clause\"},\"contracts/interfaces/IArbGasInfo.sol\":{\"content\":\"pragma solidity ^0.8.18;\\n\\n/// Precompiled contract that exists in every Arbitrum Nitro chain at 0x000000000000000000000000000000000000006c.\\ninterface IArbGasInfo {\\n    // get ArbOS's estimate of the L1 gas price in wei\\n    function getL1BaseFeeEstimate() external view returns (uint256);\\n\\n    /// @notice Get gas prices. Uses the caller's preferred aggregator, or the default if the caller doesn't have a preferred one.\\n    /// @return return gas prices in wei\\n    ///        (\\n    ///            per L2 tx,\\n    ///            per L1 calldata byte\\n    ///            per storage allocation,\\n    ///            per ArbGas base,\\n    ///            per ArbGas congestion,\\n    ///            per ArbGas total\\n    ///        )\\n    function getPricesInWei() external view returns (uint256, uint256, uint256, uint256, uint256, uint256);\\n}\\n\",\"keccak256\":\"0xec7f78ef81a1aee6f7cf835a6dd75313e8f02fc2ef4e4044871bf1ee8fe02080\"},\"contracts/interfaces/IConditionalClosingManager.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\ninterface IConditionalClosingManager {\\n    /**\\n     * @notice Checks if a position can be closed.\\n     * @param _position The position details.\\n     * @param _params The encoded parameters for closing the position.\\n     * @param _additionalParams Additional encoded parameters (not used).\\n     * @param _closeAmount The amount of the position to be closed, measured in the same decimal format as the position's asset.\\n     * @param _borowedAssetAmount The amount of borrowed asset.\\n     * @return A boolean indicating whether the position can be closed.\\n     */\\n    function canBeClosedAfterSwap(\\n        PositionLibrary.Position calldata _position,\\n        bytes calldata _params,\\n        bytes calldata _additionalParams,\\n        uint256 _closeAmount,\\n        uint256 _borowedAssetAmount,\\n        bytes calldata _positionSoldAssetOracleData\\n    ) external payable returns (bool);\\n}\\n\",\"keccak256\":\"0xc1b4d9a1792ea41bae949d409e212722349967a0bd1af18eaa95cb10867f9358\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IConditionalOpeningManager.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\ninterface IConditionalOpeningManager {\\n    /**\\n     * @notice Checks if a limit order can be filled based on the exchange rate.\\n     * @dev This function compares the exchange rate with the limit price.\\n     * @param _order The limit order details.\\n     * @param _params Open condition parameters for the order.\\n     * @param _additionalParams Additional parameters for the order.\\n     * @param _exchangeRate The exchange rate in WAD format to compare with the limit price.\\n     * @return A boolean value indicating if the limit order can be filled based on the exchange rate.\\n     */\\n    function canBeFilledAfterSwap(\\n        LimitOrderLibrary.LimitOrder calldata _order,\\n        bytes calldata _params,\\n        bytes calldata _additionalParams,\\n        uint256 _exchangeRate\\n    ) external pure returns (bool);\\n}\\n\",\"keccak256\":\"0xcc5d4576d24044a7f45c85b33350a0383fd899aa5a5be1089f2777b1114c0f66\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDexAdapter.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IQuoter} from \\\"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\\\";\\n\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {ICurveCalc} from \\\"./routers/ICurveCalc.sol\\\";\\nimport {ICurveRegistry} from \\\"./routers/ICurveRegistry.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\ninterface IDexAdapter {\\n    /**\\n     * @notice Possible dex types\\n     */\\n    enum DexType {\\n        none, // 0\\n        UniswapV2, // 1  \\\"uniswap\\\", \\\"sushiswap\\\", \\\"quickswap\\\" (v2)\\n        UniswapV3, // 2\\n        Curve, // 3\\n        Balancer, // 4\\n        AlgebraV3, // 5\\n        Meshswap, // 6\\n        Paraswap, //7\\n        Enso //8\\n    }\\n\\n    /*\\n     * @param encodedPath Swap path encoded in bytes\\n     * Encoded differently for different dexes:\\n     * Uniswap v2 - just encoded array of asset addresses\\n     * Uniswap v3 - swap path is a sequence of bytes. In Solidity, a path can be built like that:\\n     *      bytes.concat(bytes20(address(weth)), bytes3(uint24(pool1Fee)), bytes20(address(usdc)), bytes3(uint24(pool2Fee)) ...)\\n     * Quickswap - swap path is a sequence of bytes. In Solidity, a path can be built like that:\\n     *      bytes.concat(bytes20(address(weth)), bytes20(address(usdc)), bytes20(address(usdt) ...)\\n     * Curve - encoded array of asset addresses and pool addresses\\n     * Balancer - encoded array of asset addresses, pool ids and asset limits\\n     * @param _amountIn TokenA amount in\\n     * @param _amountOutMin Min tokenB amount out\\n     * @param _to Destination address for swap\\n     * @param _deadline Timestamp deadline for swap\\n     * @param _dexRouter Dex router address\\n     */\\n    struct SwapParams {\\n        bytes encodedPath;\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n        address to;\\n        uint256 deadline;\\n        address dexRouter;\\n    }\\n\\n    /*\\n     * @param encodedPath Swap path encoded in bytes\\n     * @param _amountIn TokenA amount in\\n     * @param _dexRouter Dex router address\\n     */\\n    struct GetAmountsParams {\\n        bytes encodedPath;\\n        uint256 amount; // amountIn or amountOut\\n        address dexRouter;\\n    }\\n\\n    struct AmountParams {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amount;\\n        PrimexPricingLibrary.MegaRoute[] megaRoutes;\\n    }\\n\\n    struct MegaSwapVars {\\n        uint256 sumOfShares;\\n        uint256 amountOnMegaRoute;\\n        uint256 totalAmount;\\n        uint256 remainder;\\n    }\\n\\n    event QuoterChanged(address indexed dexRouter, address indexed quoter);\\n    event DexTypeChanged(address indexed dexRouter, uint256 indexed dexType);\\n\\n    /**\\n     * @param _dexRouter The router address for which the quoter is set\\n     * @param _quoter The quoter address to set\\n     */\\n    function setQuoter(address _dexRouter, address _quoter) external;\\n\\n    /**\\n     * @notice Set a dex type for a dex router\\n     * @param _dexRouter The dex router address\\n     * @param _dexType The dex type from enum DexType\\n     */\\n    function setDexType(address _dexRouter, uint256 _dexType) external;\\n\\n    /**\\n     * @notice Swap ERC20 tokens\\n     * @param _params SwapParams struct\\n     */\\n    function swapExactTokensForTokens(SwapParams memory _params) external payable returns (uint256[3] memory);\\n\\n    /**\\n     * @notice Performs chained getAmountOut calculations\\n     * @notice given an input amount of an asset, returns the maximum output amount of the other asset\\n     * @param _params GetAmountsParams struct\\n     */\\n    function getAmountsOut(GetAmountsParams memory _params) external returns (uint256[3] memory);\\n\\n    /**\\n     * @notice Performs chained getAmountIn calculations\\n     * @notice given an output amount of an asset, returns the maximum input amount of the other asset\\n     * @param _params GetAmountsParams struct\\n     */\\n    function getAmountsIn(GetAmountsParams memory _params) external returns (uint256[3] memory);\\n\\n    /**\\n     * @notice Dex type mapping dexRouter => dex type\\n     */\\n    function dexType(address) external view returns (DexType);\\n\\n    /**\\n     * @notice Mapping from the dexRouter to its quoter\\n     */\\n    function quoters(address) external view returns (address);\\n\\n    /**\\n     * @return The address of the Registry contract\\n     */\\n    function registry() external view returns (address);\\n\\n    /**\\n     * @notice Gets the average amount of gas that is required for the swap on some dex\\n     * @param dexRouter The address of a router\\n     */\\n    function getGas(address dexRouter) external view returns (uint256);\\n\\n    /**\\n     * @notice perform swap of ERC20 tokens by Path structs\\n     * @param tokenIn source token\\n     * @param tokenOut destination token\\n     * @param amountIn amount in the source token\\n     * @param receiver destination address for swap\\n     * @param paths Array of Path structs\\n     */\\n    function performPathsSwap(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        address receiver,\\n        PrimexPricingLibrary.Path[] calldata paths\\n    ) external payable returns (uint256);\\n\\n    /**\\n      @notice Performs chained getAmountOut calculations by Path structs\\n      @dev The function may not support some types of dex, e.g. the Paraswap\\n     * @param amountIn amount in the source token\\n     * @param paths Array of Path structs\\n     */\\n\\n    function getAmountsOutByPaths(\\n        uint256 amountIn,\\n        PrimexPricingLibrary.Path[] calldata paths\\n    ) external returns (uint256);\\n\\n    /**\\n      @notice Performs chained getAmountsIn calculations by Path structs\\n      @dev The function may not support some types of dex, e.g. the Paraswap\\n     * @param amountOut amount in the destination token\\n     * @param paths Array of Path structs\\n     */\\n\\n    function getAmountsInByPaths(\\n        uint256 amountOut,\\n        PrimexPricingLibrary.Path[] calldata paths\\n    ) external returns (uint256);\\n\\n    /**\\n       @notice perform swap of ERC20 tokens by MegaRoute structs\\n     * @param _params MegaSwapParams struct\\n     */\\n    function performMegaRoutesSwap(\\n        PrimexPricingLibrary.MegaSwapParams calldata _params\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice perform swap of ERC20 tokens by Route structs\\n     * @param tokenIn source token\\n     * @param amountIn amount in the source token\\n     * @param receiver destination address for swap\\n     * @param routes Array of Route structs\\n     */\\n    function performRoutesSwap(\\n        address tokenIn,\\n        uint256 amountIn,\\n        address receiver,\\n        PrimexPricingLibrary.Route[] calldata routes\\n    ) external payable returns (uint256);\\n\\n    /**\\n    @notice Performs chained getAmountsOut calculations by Route structs\\n      @dev The function may not support some types of dex, e.g. the Paraswap\\n     * @param amountIn amount in the source token\\n     * @param routes Array of Route structs\\n     */\\n\\n    function getAmountsOutByRoutes(\\n        uint256 amountIn,\\n        PrimexPricingLibrary.Route[] calldata routes\\n    ) external returns (uint256);\\n\\n    /**\\n       @notice Performs chained getAmountsOut calculations by MegaRoute structs\\n       @dev The function may not support some types of dex, e.g. the Paraswap\\n     * @param _params AmountParams struct\\n     */\\n    function getAmountOutByMegaRoutes(AmountParams calldata _params) external returns (uint256);\\n\\n    /**\\n      @notice Performs chained  getAmountsIn calculations by Route structs\\n      @dev The function may not support some types of dex, e.g. the Paraswap\\n     * @param amountOut amountin the destination token\\n     * @param routes Array of Route structs\\n     */\\n\\n    function getAmountsInByRoutes(\\n        uint256 amountOut,\\n        PrimexPricingLibrary.Route[] calldata routes\\n    ) external returns (uint256);\\n\\n    /**\\n       @notice Performs chained getAmountsIn calculations by MegaRoute structs\\n       @dev The function may not support some types of dex, e.g. the Paraswap\\n     * @param _params AmountParams struct\\n     */\\n    function getAmountInByMegaRoutes(AmountParams calldata _params) external returns (uint256);\\n\\n    receive() external payable;\\n\\n    /**\\n     * @notice  Initializes the DexAdapter contract.\\n     * @dev This function should only be called once during the initial setup of the contract.\\n     * @param _primexDNS The address of the PrimexDNS contract.\\n     */\\n    function initialize(address _primexDNS) external;\\n}\\n\",\"keccak256\":\"0x07ae2fa31b315ebbddf4cc3d6f2f700b1e49a704de17b42bf1e2f3875a1ce440\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IInterestRateStrategy.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IInterestRateStrategy {\\n    /**\\n     * @dev parameters for BAR calculation - they differ depending on bucket's underlying asset\\n     */\\n    struct BarCalculationParams {\\n        uint256 urOptimal;\\n        uint256 k0;\\n        uint256 k1;\\n        uint256 b0;\\n        int256 b1;\\n    }\\n\\n    event BarCalculationParamsChanged(\\n        address indexed bucket,\\n        uint256 urOptimal,\\n        uint256 k0,\\n        uint256 k1,\\n        uint256 b0,\\n        int256 b1\\n    );\\n\\n    /**\\n     * @dev Updates bucket's BAR and LAR.\\n     * Calculates using utilization ratio (UR):\\n     * BAR = UR <= URoptimal ? (k0 * UR + b0) : (k1 * UR + b1), where 'b1' may be < 0,\\n     * LAR = BAR * UR,\\n     * if reserveRate != 0, then LAR = LAR * (1 - reserveRate)\\n     * @param ur Utilization ratio\\n     * @param reserveRate The reserve portion of the interest that goes to the Primex reserve\\n     * @return tuple containing BAR and LAR\\n     */\\n\\n    function calculateInterestRates(uint256 ur, uint256 reserveRate) external returns (uint128, uint128);\\n\\n    /**\\n     * @dev Set parameters for BAR calculation.\\n     * @param _params parameters are represented in byte string\\n     */\\n\\n    function setBarCalculationParams(bytes memory _params) external;\\n\\n    /**\\n     * @dev Retrieves the calculation parameters for the Bar calculation.\\n     * @param _address an address of the bucket\\n     * @return BarCalculationParams struct containing the parameters.\\n     */\\n    function getBarCalculationParams(address _address) external view returns (BarCalculationParams memory);\\n}\\n\",\"keccak256\":\"0xaffa1ce1d9ea17874bd325829c32f6313ac98f1fc1b15a1e0f739aed02caea3c\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IOVM_GasPriceOracle.sol\":{\"content\":\"pragma solidity ^0.8.18;\\n\\n/// Precompiled contract that exist on opBNB chain at 0x420000000000000000000000000000000000000F.\\ninterface IOVM_GasPriceOracle {\\n    /// @notice returns an upper bound for the L1 fee for a given transaction size.\\n    /// It is provided for callers who wish to estimate L1 transaction costs in the\\n    /// write path, and is much more gas efficient than `getL1Fee`.\\n    /// It assumes the worst case of fastlz upper-bound which covers %99.99 txs.\\n    /// @param _unsignedTxSize Unsigned fully RLP-encoded transaction size to get the L1 fee for.\\n    /// @return L1 estimated upper-bound fee that should be paid for the tx\\n    function getL1FeeUpperBound(uint256 _unsignedTxSize) external view returns (uint256);\\n\\n    /// @notice Retrieves the current gas price (base fee).\\n    /// @return Current L2 gas price (base fee).\\n    function gasPrice() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x1fc2611c6c185d738d5370fb217f04ecc60b07c299abbc0b04130eb2b085ccce\"},\"contracts/interfaces/IPausable.sol\":{\"content\":\"// Copyright (c) 2016-2024 zOS Global Limited and contributors\\n// SPDX-License-Identifier: MIT\\n\\n// Interface for OpenZeppelin's Pausable contract from https://github.com/OpenZeppelin/openzeppelin-contracts/\\npragma solidity ^0.8.18;\\n\\ninterface IPausable {\\n    /**\\n     * @dev Triggers stopped state.\\n     * This function can only be called by an address with the EMERGENCY_ADMIN role.\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @dev Returns to normal state.\\n     * This function can only be called by an address with the SMALL_TIMELOCK_ADMIN or MEDIUM_TIMELOCK_ADMIN role depending on the contract.\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function unpause() external;\\n}\\n\",\"keccak256\":\"0xd36ff25b5efe39529dd92bec8aab8fba396c7fc7fed936e64a1de358e52ad2e4\",\"license\":\"MIT\"},\"contracts/interfaces/IPrimexLens.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\n\\nimport {IPositionManagerV2} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IInterestRateStrategy} from \\\"./IInterestRateStrategy.sol\\\";\\nimport {ILiquidityMiningRewardDistributor} from \\\"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\\\";\\nimport {IPrimexDNSStorageV3} from \\\"../PrimexDNS/PrimexDNS.sol\\\";\\n\\ninterface IPrimexLens {\\n    /**\\n     * @dev A struct to store metadata information of a token.\\n     * @param tokenAddress The address of the token contract.\\n     * @param symbol The symbol of the token.\\n     * @param name The name of the token.\\n     * @param decimals  The decimal places of the token.\\n     * @param balance The balance of the token.\\n     */\\n    struct TokenMetadata {\\n        address tokenAddress;\\n        string symbol;\\n        string name;\\n        uint256 decimals;\\n        uint256 balance;\\n    }\\n\\n    /**\\n     * @param id Id of the asset.\\n     * @param isSupported Flag indicating if the asset supported in the bucket.\\n     * @param pairPriceDrop PriceDrop of the trading asset relative to borrowed asset, in WAD format.\\n     * @param maxLeverage maxAssetLeverage allowed for the trading asset in the bucket, in WAD format.\\n     */\\n    struct BucketTokenMetadata {\\n        uint256 id;\\n        bool isSupported;\\n        uint256 pairPriceDrop;\\n        uint256 maxLeverage;\\n    }\\n\\n    /**\\n     * @param asset Metadata of the asset token as a struct TokenMetadata\\n     * @param properties Metadata of the bucket token properties as a struct BucketTokenMetadata\\n     */\\n    struct SupportedAsset {\\n        TokenMetadata asset;\\n        BucketTokenMetadata properties;\\n    }\\n\\n    /**\\n     * @param amountInMining The amount of tokens provided by the lender for mining.\\n     * @param currentPercent The current percentage of rewards allocated to the lender, in WAD format (1 WAD = 100%)\\n     * @param rewardsInPMX The expected rewards for the lender in PMX tokens.\\n     */\\n    struct LenderInfo {\\n        uint256 amountInMining;\\n        uint256 currentPercent;\\n        ILiquidityMiningRewardDistributor.RewardsInPMX rewardsInPMX;\\n    }\\n\\n    /**\\n     * @dev Struct representing info about a liquidity mining in the bucket.\\n     * @param pmxAmount Total reward of PMX for liquidity mining in the bucket.\\n     * @param withdrawnRewards Total reward of PMX amount already withdrawn from the bucket.\\n     * @param totalPoints Total points accumulated by users in the bucket.\\n     */\\n    struct LiquidityMiningBucketInfo {\\n        uint256 pmxAmount;\\n        uint256 withdrawnRewards;\\n        uint256 totalPoints;\\n    }\\n\\n    /**\\n     * @dev Struct representing info about bucket.\\n     * @param bucketAddress The bucket address.\\n     * @param name The bucket name.\\n     * @param asset TokenMetadata of borrowed asset of the bucket.\\n     * @param bar Borrowing annual rate of the bucket, expressed in RAY.\\n     * @param lar Lending annual rate of the bucket, expressed in RAY.\\n     * @param supply Sum of availableLiquidity and demand, in borrowed asset.\\n     * @param demand Total supply of the debtToken, in borrowed asset.\\n     * @param availableLiquidity Balance of borrowed asset on the bucket, in borrowed asset.\\n     * @param utilizationRatio Percentage of the bucket funds used in the loan, in in RAY format (1 RAY = 100%).\\n     * @param supportedAssets Assets with which you can open a position in the bucket.\\n     * @param pToken TokenMetadata of pToken of the bucket.\\n     * @param debtToken TokenMetadata of debtToken of the bucket.\\n     * @param feeBuffer The fee buffer of the bucket, in WAD format.\\n     * @param withdrawalFeeRate Percentage of withdrawal that is redirected to the treasury, in WAD format (1 WAD = 100%)\\n     * @param miningParams Parameters of the bucket liquidity mining.\\n     * @param lenderInfo Liquidity mining lender information.\\n     * @param lmBucketInfo Liquidity mining the bucket information.\\n     * @param estimatedBar Expected value of bar, expressed in RAY\\n     * @param estimatedLar Expected value of lar., expressed in RAY\\n     * @param isDeprecated Indicates whether the bucket is outdated and deprecated.\\n     * @param isDelisted Indicates whether the bucket is delisted.\\n     * @param barCalcParams The BarCalculationParams struct containing the parameters for calculating bar and lar.\\n     * @param maxTotalDeposit Max amount of borrowed asset that can be deposited in bucket, in borrowed asset.\\n     */\\n    struct BucketMetaData {\\n        address bucketAddress;\\n        string name;\\n        TokenMetadata asset;\\n        uint128 bar;\\n        uint128 lar;\\n        uint256 supply;\\n        uint256 demand;\\n        uint256 availableLiquidity;\\n        uint256 utilizationRatio;\\n        SupportedAsset[] supportedAssets;\\n        TokenMetadata pToken;\\n        TokenMetadata debtToken;\\n        uint256 feeBuffer;\\n        uint256 withdrawalFeeRate;\\n        IBucketV3.LiquidityMiningParams miningParams;\\n        LenderInfo lenderInfo;\\n        LiquidityMiningBucketInfo lmBucketInfo;\\n        uint128 estimatedBar;\\n        uint128 estimatedLar;\\n        bool isDeprecated;\\n        bool isDelisted;\\n        IInterestRateStrategy.BarCalculationParams barCalcParams;\\n        uint256 maxTotalDeposit;\\n    }\\n\\n    /**\\n     * @dev Struct representing the data of a round in an chainlink oracle contract.\\n     * @param roundId Id of the round.\\n     * @param answer The answer provided for the round.\\n     * @param startedAt The timestamp when the round started.\\n     * @param updatedAt The timestamp when the round was last updated.\\n     * @param answeredInRound The round in which the answer was provided.\\n     */\\n    struct RoundData {\\n        uint80 roundId;\\n        int256 answer;\\n        uint256 startedAt;\\n        uint256 updatedAt;\\n        uint80 answeredInRound;\\n    }\\n\\n    /**\\n     * @dev Structure of open position parameters\\n     * @param bucket The domain name of the bucket where the position was opened\\n     * @param borrowedAsset The address of the borrowed asset of this `bucket`\\n     * @param positionAsset the address of the bought asset of open position\\n     * @param borrowedAmount the amount of borrowed token in this position\\n     * @param debt the debt on an open position consists of the loan body and accumulated interest\\n     * @param depositAmount The amount of deposit trader funds of open position\\n     * @param healthPosition The parameter determining the riskiness of the position (is averaged to 1).\\n     * If it is greater than 1, then the position is not risky, if it is less than 1 risky.\\n     * The decimals of this parameter is determined by the decimals `borrowedAsset`.\\n     * @param profit An integer showing the profit/loss for open position.\\n     * @param extraParams byte-encoded params, utilized for the feeToken address\\n     */\\n    struct OpenPositionData {\\n        uint256 id;\\n        BucketMetaData bucket;\\n        TokenMetadata[2] pair;\\n        uint256 positionSize;\\n        uint256 liquidationPrice;\\n        uint256 stopLossPrice;\\n        uint256 takeProfitPrice;\\n        uint256 debt;\\n        uint256 depositAmount;\\n        uint256 createdAt;\\n        bytes extraParams;\\n    }\\n    /**\\n     * @dev Structure for the getOpenPositionsWithConditions function\\n     * @param positionData Open position data\\n     * @param conditionsData Conditions data for corresponding position\\n     */\\n    struct OpenPositionWithConditions {\\n        PositionLibrary.Position positionData;\\n        LimitOrderLibrary.Condition[] conditionsData;\\n    }\\n\\n    /**\\n     * @dev Structure for the getLimitOrdersWithConditions function\\n     * @param limitOrderData Limit order data\\n     * @param openConditionsData Open conditions data for corresponding order\\n     */\\n    struct LimitOrderWithConditions {\\n        LimitOrderLibrary.LimitOrder limitOrderData;\\n        LimitOrderLibrary.Condition[] openConditionsData;\\n    }\\n\\n    /**\\n     * @notice Retrieves open position data based on the provided position manager and id.\\n     * @param _positionManager The address of the PositionManager where the position is stored\\n     * @param _id Position id to show the parameters position\\n     * @return openPositionData The open position data including various details.\\n     */\\n    function getOpenPositionData(address _positionManager, uint256 _id) external returns (OpenPositionData memory);\\n\\n    /**\\n     * @notice The function shows the parameters for all open positions of the `_trader` with the best dex for each position\\n     * @param _positionManager The address of the PositionManager where the positions is stored\\n     * @param _trader The address, information about all positions of which will be displayed\\n     * @param _cursor The cursor value for pagination.\\n     * @param _count The number of positions to retrieve.\\n     */\\n    function getArrayOpenPositionDataByTrader(\\n        address _positionManager,\\n        address _trader,\\n        uint256 _cursor,\\n        uint256 _count\\n    ) external returns (OpenPositionData[] memory, uint256);\\n\\n    /**\\n     * @notice The function shows the parameters for all open positions of the `_trader` with the best dex for each position\\n     * @param _positionManager The address of the PositionManager where the positions is stored\\n     * @param _bucket The address of the bucket positions are related to\\n     * @param _cursor The cursor value for pagination.\\n     * @param _count The number of positions to retrieve.\\n     */\\n    function getArrayOpenPositionDataByBucket(\\n        address _positionManager,\\n        address _bucket,\\n        uint256 _cursor,\\n        uint256 _count\\n    ) external returns (OpenPositionData[] memory, uint256);\\n\\n    /**\\n     * @notice The function returns the limit orders with corresponding conditions\\n     * @param _limitOrderManager The address of the LimitOrderManager where the order is stored.\\n     * @param _cursor The cursor value for pagination.\\n     * @param _count The number of positions to retrieve.\\n     * @return limitOrderWithConditions An array of LimitOrderWithConditions structs representing open positions with conditions.\\n     * @return newCursor The new cursor value for pagination.\\n     */\\n    function getLimitOrdersWithConditions(\\n        address _limitOrderManager,\\n        uint256 _cursor,\\n        uint256 _count\\n    ) external view returns (LimitOrderWithConditions[] memory, uint256 newCursor);\\n\\n    /**\\n     * @notice The function returns the positions with corresponding conditions.\\n     * @param _positionManager The address of the PositionManager where the position is stored.\\n     * @param _cursor The cursor value for pagination.\\n     * @param _count The number of positions to retrieve.\\n     * @return openPositionsWithConditionsArray An array of OpenPositionWithConditions structs representing open positions with conditions.\\n     * @return newCursor The new cursor value for pagination.\\n     */\\n    function getOpenPositionsWithConditions(\\n        address _positionManager,\\n        uint256 _cursor,\\n        uint256 _count\\n    ) external view returns (OpenPositionWithConditions[] memory, uint256 newCursor);\\n\\n    /**\\n     * @notice Retrieves the metadata of a token for a given trader.\\n     * @param _token The address of the token.\\n     * @param _trader The address of the trader.\\n     * @return metadata The metadata of the token.\\n     */\\n    function getTokenMetadata(address _token, address _trader) external view returns (TokenMetadata memory);\\n\\n    /**\\n     * @notice Retrieves the metadata of an array of tokens for a given trader.\\n     * @param _tokens The array of token addresses.\\n     * @param _trader The address of the trader.\\n     * @return res The array of token metadata.\\n     */\\n    function getTokenArrayMetadata(\\n        address[] calldata _tokens,\\n        address _trader\\n    ) external view returns (TokenMetadata[] memory);\\n\\n    /**\\n     * @notice Retrieves the metadata of an asset within a bucket.\\n     * @param _bucket The address of the Bucket contract.\\n     * @param _asset The address of the asset to retrieve metadata for.\\n     * @return metadata The metadata of the asset within the bucket.\\n     */\\n    function getAssetMetadata(address _bucket, address _asset) external view returns (BucketTokenMetadata memory);\\n\\n    /**\\n     * @notice Retrieves information about a supported asset.\\n     * @param _bucket The address of the Bucket where the asset is supported.\\n     * @param _asset The address of the asset for which information is requested.\\n     * @param _trader The address of the Trader requesting the information.\\n     * @return supportedAsset The SupportedAsset struct containing the asset and its properties.\\n     */\\n    function getSupportedAsset(\\n        address _bucket,\\n        address _asset,\\n        address _trader\\n    ) external view returns (SupportedAsset memory);\\n\\n    /**\\n     * @notice Retrieves an array of SupportedAsset structs for the given bucket, assets, and trader.\\n     * @param _bucket The address of the Bucket.\\n     * @param _assets An array of asset addresses.\\n     * @param _trader The address of the trader.\\n     * @return res An array of SupportedAsset structs representing the supported assets.\\n     */\\n    function getSupportedAssetArray(\\n        address _bucket,\\n        address[] memory _assets,\\n        address _trader\\n    ) external view returns (SupportedAsset[] memory);\\n\\n    /**\\n     * @notice Retrieves the metadata of a bucket.\\n     * @param _bucket The address of the Bucket contract.\\n     * @param _trader The address of the trader.\\n     * @return The metadata of the bucket.\\n     */\\n    function getBucket(address _bucket, address _trader) external view returns (BucketMetaData memory);\\n\\n    /**\\n     * @notice Retrieves an array of `BucketMetaData` for the given `_user`.\\n     * @param _buckets The array of bucket addresses.\\n     * @param _trader The address of the trader.\\n     * @param _positionManager The address of the PositionManager contract.\\n     * @param _showDeprecated Flag to determine whether deprecated buckets should be included.\\n     * @return An array of `BucketMetaData` objects.\\n     */\\n    function getBucketsArray(\\n        address[] memory _buckets,\\n        address _trader,\\n        address _positionManager,\\n        bool _showDeprecated\\n    ) external view returns (BucketMetaData[] memory);\\n\\n    /**\\n     * @notice Retrieves all bucket metadata from a bucket factory contract.\\n     * @param _bucketFactories An array of the BucketFactory contracts addresses.\\n     * @param _trader The address of the trader for whom the buckets are retrieved.\\n     * @param _positionManager The address of the PositionManager contract.\\n     * @param _showDeprecated A boolean flag indicating whether to include deprecated buckets in the result.\\n     * @return An array of BucketMetaData structs representing the bucket metadata.\\n     */\\n    function getAllBucketsFactory(\\n        address[] calldata _bucketFactories,\\n        address _trader,\\n        address _positionManager,\\n        bool _showDeprecated\\n    ) external view returns (BucketMetaData[] memory);\\n\\n    /**\\n     * @notice Retrieves the latest round data for multiple Chainlink feeds.\\n     * @param _feeds An array of feed addresses.\\n     * @return res An array of RoundData structs containing the latest round data for each feed.\\n     */\\n    function getChainlinkLatestRoundData(address[] calldata _feeds) external view returns (RoundData[] memory);\\n\\n    /**\\n     * @notice Calculates the liquidation price for a given position.\\n     * @dev The liquidation price is the price at which a position can be liquidated (i.e., its collateral can cover the borrowed amount).\\n     * @param _positionManager The address of the PositionManager contract.\\n     * @param _bucket The name of the bucket associated with the position.\\n     * @param _borrowedAmount The amount borrowed in the position.\\n     * @param _positionAsset The address of the asset held in the position.\\n     * @param _positionAmount The amount of the asset held in the position.\\n     * @return The liquidation price in borrowed asset for the position.\\n     */\\n    function getLiquidationPrice(\\n        address _positionManager,\\n        string memory _bucket,\\n        uint256 _borrowedAmount,\\n        address _positionAsset,\\n        uint256 _positionAmount\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the liquidation price of a position.\\n     * @param _positionManager The address of the PositionManager contract.\\n     * @param _id The ID of the position.\\n     * @return The liquidation price in borrowed asset of the position.\\n     */\\n    function getLiquidationPrice(address _positionManager, uint256 _id) external view returns (uint256);\\n\\n    /**\\n     * @notice Checks if the stop loss condition of a position is reached.\\n     * @param _positionManager The address of the PositionManager contract.\\n     * @param _id The ID of the position to check.\\n     * @return A boolean indicating whether the stop loss condition is reached.\\n     */\\n    function isStopLossReached(\\n        address _positionManager,\\n        uint256 _id,\\n        bytes calldata _positionSoldAssetOracleData,\\n        bytes[][] calldata _pullOracleData,\\n        uint256[] calldata _pullOracleTypes\\n    ) external payable returns (bool);\\n\\n    /**\\n     * @notice Retrieves the maximum decrease in position value for a given position ID.\\n     * @dev maxDecrease = (1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - pricedrop) * positionAmountInBorrowedAsset /\\n     * (feeBuffer * (1 + maintenanceBuffer)) - position.bucket.getNormalizedVariableDebt() * position.scaledDebtAmount\\n     * @param _pm The instance of the PositionManager contract.\\n     * @param _id The ID of the position.\\n     * @return The maximum decrease in position value.\\n     */\\n    function getPositionMaxDecrease(\\n        IPositionManagerV2 _pm,\\n        uint256 _id,\\n        bytes calldata _positionSoldAssetOracleData,\\n        bytes[][] calldata _pullOracleData,\\n        uint256[] calldata _pullOracleTypes\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Retrieves information about a lender from the LiquidityMiningRewardDistributor contract.\\n     * @param liquidityMiningRewardDistributor The instance of the LiquidityMiningRewardDistributor contract.\\n     * @param bucketName The name of the lending bucket.\\n     * @param user The address of the lender.\\n     * @return info The lender information.\\n     */\\n    function getLenderInfo(\\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor,\\n        string memory bucketName,\\n        address user\\n    ) external view returns (LenderInfo memory);\\n\\n    /**\\n     * @notice Retrieves information about a liquidity mining bucket.\\n     * @param liquidityMiningRewardDistributor The instance of the LiquidityMiningRewardDistributor contract.\\n     * @param _bucketName The name of the liquidity mining bucket.\\n     * @return info The liquidity mining bucket information.\\n     */\\n    function getLMBucketInfo(\\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor,\\n        string memory _bucketName\\n    ) external view returns (LiquidityMiningBucketInfo memory);\\n\\n    /**\\n     * @notice Calculate an approximate min protocol fee based on averageGasPerAction,\\n     * which represents the typical amount of gas expended by the Keeper for the relevant action.\\n     * @param _tradingOrderType Represents the type of trading order in enum TradingOrderType (IPrimexDNSStorageV3)\\n     * @param _pm The instance of the PositionManager contract.\\n     */\\n    function getEstimatedMinProtocolFee(\\n        IPrimexDNSStorageV3.TradingOrderType _tradingOrderType,\\n        IPositionManagerV2 _pm\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x95c8d57627ec6280a56607adc627d8eb618348ff2ac95d902f000ef758bba721\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IStorkVerify.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\n/* solhint-disable */\\n\\ninterface IStorkVerify {\\n    function verifySignature(\\n        address oracle_pubkey,\\n        string memory asset_pair_id,\\n        uint256 timestamp,\\n        uint256 price,\\n        bytes32 r,\\n        bytes32 s,\\n        uint8 v\\n    ) external pure returns (bool);\\n}\\n\",\"keccak256\":\"0xd37f0c3c2f7862f9a55579ef13c4a5af4e541c935586b05aeca3799de8b0d3d0\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ISupraOraclePull.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface ISupraOraclePull {\\n    //Verified price data\\n    struct PriceData {\\n        // List of pairs\\n        uint256[] pairs;\\n        // List of prices\\n        // prices[i] is the price of pairs[i]\\n        uint256[] prices;\\n        // List of decimals\\n        // decimals[i] is the decimals of pairs[i]\\n        uint256[] decimals;\\n    }\\n\\n    function verifyOracleProof(bytes calldata _bytesproof) external returns (PriceData memory);\\n}\\n\",\"keccak256\":\"0xf38fcd53bef093ff9dee4914a2ac0ccbe383d624ed6a13ee079c0545cae69198\",\"license\":\"MIT\"},\"contracts/interfaces/ISupraSValueFeed.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/* solhint-disable var-name-mixedcase */\\ninterface ISupraSValueFeed {\\n    struct derivedData {\\n        int256 roundDifference;\\n        uint256 derivedPrice;\\n        uint256 decimals;\\n    }\\n\\n    struct priceFeed {\\n        uint256 round;\\n        uint256 decimals;\\n        uint256 time;\\n        uint256 price;\\n    }\\n\\n    function getDerivedSvalue(\\n        uint256 pair_id_1,\\n        uint256 pair_id_2,\\n        uint256 operation\\n    ) external view returns (derivedData memory);\\n\\n    function getSvalue(uint256 _pairIndex) external view returns (priceFeed memory);\\n}\\n\",\"keccak256\":\"0x7b4e9eaabfd4e929d1006ddb1c01684875eeb95a2c64ac8a848e61b91a8ee21f\",\"license\":\"MIT\"},\"contracts/interfaces/ITakeProfitStopLossCCM.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\ninterface ITakeProfitStopLossCCM {\\n    struct CanBeClosedParams {\\n        uint256 takeProfitPrice;\\n        uint256 stopLossPrice;\\n    }\\n\\n    /**\\n     * @notice Checks if the take profit has been reached based on the given parameters.\\n     * @dev Used in closeBatchPositions() function.\\n     * @param _params The encoded parameters.\\n     * @param exchangeRate The exchange rate in WAD format.\\n     * @return A boolean indicating whether the take profit has been reached.\\n     */\\n    function isTakeProfitReached(bytes calldata _params, uint256 exchangeRate) external view returns (bool);\\n\\n    /**\\n     * @notice Checks if the stop loss price has been reached for a given position.\\n     * @param _position The position details.\\n     * @param _stopLossPrice The stop loss price in WAD format to compare against.\\n     * @return True if the stop loss price is reached, false otherwise.\\n     */\\n    function isStopLossReached(\\n        PositionLibrary.Position calldata _position,\\n        uint256 _stopLossPrice,\\n        bytes calldata _positionSoldAssetOracleData\\n    ) external returns (bool);\\n\\n    /**\\n     * @notice Checks if the stop loss price has been reached on the given parameters.\\n     * @dev The takeProfitPrice and stopLossPrice values can be obtained from the encoded data via CanBeClosedParams struct.\\n     * @param _params The encoded closing condition parameters containing stop loss price.\\n     * @param oracleExchangeRate The current exchange rate from the oracle in WAD format.\\n     * @return True if the stop loss price is reached, false otherwise.\\n     */\\n    function isStopLossReached(bytes calldata _params, uint256 oracleExchangeRate) external view returns (bool);\\n\\n    /**\\n     * @notice Retrieves the take profit and stop loss prices from the given parameters.\\n     * @param _params The encoded parameters for closing a position.\\n     * @return takeProfitPrice The take profit price.\\n     * @return stopLossPrice The stop loss price.\\n     */\\n    function getTakeProfitStopLossPrices(bytes calldata _params) external view returns (uint256, uint256);\\n\\n    /**\\n     * @notice Initializes the TakeProfitStopLossCCM contract.\\n     * @dev This function should only be called once during the initial setup of the contract.\\n     * @param _primexDNS The address of the PrimexDNS contract.\\n     * @param _priceOracle The address of the PriceOracle contract.\\n     */\\n    function initialize(address _primexDNS, address _priceOracle) external;\\n}\\n\",\"keccak256\":\"0xc7e14c2e085662f84b2ba41f2918a7722ffcf8d58891e6086add249b65b3ea8d\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/routers/ICurveCalc.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface ICurveCalc {\\n    // solhint-disable func-name-mixedcase\\n    function get_dx(\\n        // solhint-disable-next-line var-name-mixedcase\\n        int128 n_coins,\\n        uint256[8] memory balances,\\n        uint256 amp,\\n        uint256 fee,\\n        uint256[8] memory rates,\\n        uint256[8] memory precisions,\\n        bool underlying,\\n        int128 i,\\n        int128 j,\\n        uint256 dy\\n    ) external pure returns (uint256);\\n}\\n\",\"keccak256\":\"0xbfe602662763db3d67993fe2d667086526dbed94a52a0ca931a712f47e611507\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/routers/ICurveRegistry.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface ICurveRegistry {\\n    // solhint-disable func-name-mixedcase\\n    function get_n_coins(address _pool) external view returns (uint256[2] memory);\\n\\n    function get_rates(address _pool) external view returns (uint256[8] memory);\\n\\n    function get_coin_indices(address _pool, address _from, address _to) external view returns (int128, int128, bool);\\n}\\n\",\"keccak256\":\"0xa27a21ef0c8beef0855a9ecd5f3ca42833fea9f5123562a3b390169f2c139ca2\",\"license\":\"BUSL-1.1\"},\"contracts/lens/PrimexLens.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.26;\\n\\nimport {ERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport {WadRayMath} from \\\"../libraries/utils/WadRayMath.sol\\\";\\n\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\nimport \\\"./../libraries/Errors.sol\\\";\\n\\nimport {IPrimexLens} from \\\"../interfaces/IPrimexLens.sol\\\";\\nimport {IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IBucketsFactory} from \\\"../Bucket/IBucketsFactory.sol\\\";\\nimport {IPositionManagerV2} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {ILimitOrderManager} from \\\"../LimitOrderManager/ILimitOrderManager.sol\\\";\\nimport {ITakeProfitStopLossCCM} from \\\"../interfaces/ITakeProfitStopLossCCM.sol\\\";\\nimport {ILiquidityMiningRewardDistributor} from \\\"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\\\";\\nimport {IInterestRateStrategy} from \\\"../interfaces/IInterestRateStrategy.sol\\\";\\nimport {IPrimexDNSV3, IPrimexDNSStorage, IPrimexDNSStorageV3} from \\\"../PrimexDNS/PrimexDNS.sol\\\";\\nimport {IKeeperRewardDistributorStorage} from \\\"../KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\\\";\\nimport {ARB_NITRO_ORACLE, GAS_FOR_BYTE, OVM_GASPRICEORACLE, TRANSACTION_METADATA_BYTES} from \\\"../Constants.sol\\\";\\n\\n/**\\n * @dev  All functions in this contract are intended to be called off-chain. Do not call functions from other contracts to avoid an out-of-gas error.\\n */\\n\\ncontract PrimexLens is IPrimexLens, ERC165 {\\n    using WadRayMath for uint256;\\n    using PositionLibrary for PositionLibrary.Position;\\n\\n    address public immutable takeProfitStopLossCCM;\\n\\n    constructor(address _takeProfitStopLossCCM) {\\n        _require(\\n            IERC165(_takeProfitStopLossCCM).supportsInterface(type(ITakeProfitStopLossCCM).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        takeProfitStopLossCCM = _takeProfitStopLossCCM;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getOpenPositionsWithConditions(\\n        address _positionManager,\\n        uint256 _cursor,\\n        uint256 _count\\n    )\\n        external\\n        view\\n        override\\n        returns (OpenPositionWithConditions[] memory openPositionsWithConditions, uint256 newCursor)\\n    {\\n        _require(\\n            IERC165(_positionManager).supportsInterface(type(IPositionManagerV2).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        uint256 positionsLength = IPositionManagerV2(_positionManager).getAllPositionsLength();\\n        if (_cursor >= positionsLength) {\\n            return (openPositionsWithConditions, 0);\\n        }\\n        if (_cursor + _count >= positionsLength) {\\n            _count = positionsLength - _cursor;\\n        } else {\\n            newCursor = _cursor + _count;\\n        }\\n\\n        openPositionsWithConditions = new OpenPositionWithConditions[](_count);\\n        for (uint256 i; i < _count; i++) {\\n            openPositionsWithConditions[i].positionData = IPositionManagerV2(_positionManager).getPositionByIndex(\\n                _cursor + i\\n            );\\n            openPositionsWithConditions[i].conditionsData = IPositionManagerV2(_positionManager).getCloseConditions(\\n                openPositionsWithConditions[i].positionData.id\\n            );\\n        }\\n        return (openPositionsWithConditions, newCursor);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getArrayOpenPositionDataByTrader(\\n        address _positionManager,\\n        address _trader,\\n        uint256 _cursor,\\n        uint256 _count\\n    ) external view override returns (OpenPositionData[] memory positionsData, uint256 newCursor) {\\n        _require(\\n            IERC165(_positionManager).supportsInterface(type(IPositionManagerV2).interfaceId) && _trader != address(0),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n\\n        uint256 positionsLength = IPositionManagerV2(_positionManager).getTraderPositionsLength(_trader);\\n        if (_cursor >= positionsLength) {\\n            return (positionsData, 0);\\n        }\\n        if (_cursor + _count >= positionsLength) {\\n            _count = positionsLength - _cursor;\\n        } else {\\n            newCursor = _cursor + _count;\\n        }\\n\\n        positionsData = new OpenPositionData[](_count);\\n        for (uint256 i; i < _count; i++) {\\n            uint256 positionId = IPositionManagerV2(_positionManager).traderPositionIds(_trader, _cursor + i);\\n            positionsData[i] = getOpenPositionData(_positionManager, positionId);\\n        }\\n        return (positionsData, newCursor);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getArrayOpenPositionDataByBucket(\\n        address _positionManager,\\n        address _bucket,\\n        uint256 _cursor,\\n        uint256 _count\\n    ) external view override returns (OpenPositionData[] memory positionsData, uint256 newCursor) {\\n        _require(\\n            IERC165(_positionManager).supportsInterface(type(IPositionManagerV2).interfaceId) && _bucket != address(0),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n\\n        uint256 positionsLength = IPositionManagerV2(_positionManager).getBucketPositionsLength(_bucket);\\n        if (_cursor >= positionsLength) {\\n            return (positionsData, 0);\\n        }\\n        if (_cursor + _count >= positionsLength) {\\n            _count = positionsLength - _cursor;\\n        } else {\\n            newCursor = _cursor + _count;\\n        }\\n\\n        positionsData = new OpenPositionData[](_count);\\n        for (uint256 i; i < _count; i++) {\\n            uint256 positionId = IPositionManagerV2(_positionManager).bucketPositionIds(_bucket, _cursor + i);\\n            positionsData[i] = getOpenPositionData(_positionManager, positionId);\\n        }\\n        return (positionsData, newCursor);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getAllBucketsFactory(\\n        address[] calldata _bucketFactories,\\n        address _user,\\n        address _positionManager,\\n        bool _showDeprecated\\n    ) external view override returns (BucketMetaData[] memory) {\\n        address[][] memory allBucketsArray = new address[][](_bucketFactories.length);\\n        for (uint256 i; i < _bucketFactories.length; i++) {\\n            allBucketsArray[i] = IBucketsFactory(_bucketFactories[i]).allBuckets();\\n        }\\n        uint256 totalBucketsCount;\\n        for (uint256 i; i < allBucketsArray.length; i++) {\\n            totalBucketsCount += allBucketsArray[i].length;\\n        }\\n        address[] memory buckets = new address[](totalBucketsCount);\\n        uint256 index;\\n        for (uint256 i; i < allBucketsArray.length; i++) {\\n            for (uint256 j; j < allBucketsArray[i].length; j++) {\\n                buckets[index] = allBucketsArray[i][j];\\n                index++;\\n            }\\n        }\\n\\n        return getBucketsArray(buckets, _user, _positionManager, _showDeprecated);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getChainlinkLatestRoundData(\\n        address[] calldata _feeds\\n    ) external view override returns (RoundData[] memory) {\\n        uint256 feedCount = _feeds.length;\\n        RoundData[] memory res = new RoundData[](feedCount);\\n\\n        uint80 roundId;\\n        int256 answer;\\n        uint256 startedAt;\\n        uint256 updatedAt;\\n        uint80 answeredInRound;\\n\\n        for (uint256 i; i < feedCount; i++) {\\n            _require(_feeds[i] != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\\n            (roundId, answer, startedAt, updatedAt, answeredInRound) = AggregatorV3Interface(_feeds[i])\\n                .latestRoundData();\\n            res[i].roundId = roundId;\\n            res[i].answer = answer;\\n            res[i].startedAt = startedAt;\\n            res[i].updatedAt = updatedAt;\\n            res[i].answeredInRound = answeredInRound;\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    // getLiquidationPrice for openable positions\\n    // in an ideal situation this liquidationPrice is equal getLiquidationPrice for opened positions\\n    function getLiquidationPrice(\\n        address _positionManager,\\n        string memory _bucket,\\n        uint256 _borrowedAmount,\\n        address _positionAsset,\\n        uint256 _positionAmount\\n    ) external view override returns (uint256) {\\n        _require(\\n            IERC165(address(_positionManager)).supportsInterface(type(IPositionManagerV2).interfaceId) &&\\n                _positionAsset != address(0),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        IPrimexDNSV3 primexDNS = IPositionManagerV2(_positionManager).primexDNS();\\n        address bucket = primexDNS.getBucketAddress(_bucket);\\n        return\\n            PrimexPricingLibrary.getLiquidationPrice(\\n                bucket,\\n                _positionAsset,\\n                _positionAmount,\\n                _borrowedAmount,\\n                address(primexDNS)\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getLimitOrdersWithConditions(\\n        address _limitOrderManager,\\n        uint256 _cursor,\\n        uint256 _count\\n    ) external view override returns (LimitOrderWithConditions[] memory limitOrdersWithConditions, uint256 newCursor) {\\n        _require(\\n            IERC165(_limitOrderManager).supportsInterface(type(ILimitOrderManager).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        uint256 ordersLength = ILimitOrderManager(_limitOrderManager).getOrdersLength();\\n        if (_cursor >= ordersLength) {\\n            return (limitOrdersWithConditions, 0);\\n        }\\n        if (_cursor + _count >= ordersLength) {\\n            _count = ordersLength - _cursor;\\n        } else {\\n            newCursor = _cursor + _count;\\n        }\\n        limitOrdersWithConditions = new LimitOrderWithConditions[](_count);\\n        for (uint256 i; i < _count; i++) {\\n            limitOrdersWithConditions[i].limitOrderData = ILimitOrderManager(_limitOrderManager).getOrderByIndex(\\n                _cursor + i\\n            );\\n            limitOrdersWithConditions[i].openConditionsData = ILimitOrderManager(_limitOrderManager).getOpenConditions(\\n                limitOrdersWithConditions[i].limitOrderData.id\\n            );\\n        }\\n        return (limitOrdersWithConditions, newCursor);\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getTokenArrayMetadata(\\n        address[] calldata _tokens,\\n        address _trader\\n    ) external view override returns (TokenMetadata[] memory) {\\n        uint256 tokenCount = _tokens.length;\\n        TokenMetadata[] memory res = new TokenMetadata[](tokenCount);\\n\\n        for (uint256 i; i < tokenCount; i++) {\\n            res[i] = getTokenMetadata(_tokens[i], _trader);\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getOpenPositionData(\\n        address _positionManager,\\n        uint256 _id\\n    ) public view override returns (OpenPositionData memory) {\\n        _require(\\n            IERC165(_positionManager).supportsInterface(type(IPositionManagerV2).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n\\n        PositionLibrary.Position memory position = IPositionManagerV2(_positionManager).getPosition(_id);\\n\\n        bool isSpot = address(position.bucket) == address(0);\\n        uint256 debt = IPositionManagerV2(_positionManager).getPositionDebt(_id);\\n        BucketMetaData memory bucket;\\n        if (!isSpot) bucket = getBucket(address(position.bucket), position.trader);\\n\\n        LimitOrderLibrary.Condition[] memory closeConditions = IPositionManagerV2(_positionManager).getCloseConditions(\\n            _id\\n        );\\n        ITakeProfitStopLossCCM.CanBeClosedParams memory params;\\n        for (uint256 i; i < closeConditions.length; i++) {\\n            if (\\n                IERC165(\\n                    IPositionManagerV2(_positionManager).primexDNS().cmTypeToAddress(closeConditions[i].managerType)\\n                ).supportsInterface(type(ITakeProfitStopLossCCM).interfaceId) && closeConditions[i].params.length != 0\\n            ) {\\n                params = abi.decode(closeConditions[i].params, (ITakeProfitStopLossCCM.CanBeClosedParams));\\n                break;\\n            }\\n        }\\n        return\\n            OpenPositionData({\\n                id: position.id,\\n                bucket: bucket,\\n                pair: [\\n                    isSpot ? getTokenMetadata(position.soldAsset, position.trader) : bucket.asset,\\n                    getTokenMetadata(position.positionAsset, position.trader)\\n                ],\\n                positionSize: position.positionAmount,\\n                liquidationPrice: getLiquidationPrice(_positionManager, _id),\\n                stopLossPrice: params.stopLossPrice,\\n                takeProfitPrice: params.takeProfitPrice,\\n                debt: debt,\\n                depositAmount: position.depositAmountInSoldAsset,\\n                createdAt: position.createdAt,\\n                extraParams: position.extraParams\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function isStopLossReached(\\n        address _positionManager,\\n        uint256 _id,\\n        bytes calldata _positionSoldAssetOracleData,\\n        bytes[][] calldata _pullOracleData,\\n        uint256[] calldata _pullOracleTypes\\n    ) public payable override returns (bool) {\\n        _require(\\n            IERC165(_positionManager).supportsInterface(type(IPositionManagerV2).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        IPositionManagerV2 pm = IPositionManagerV2(_positionManager);\\n        PositionLibrary.Position memory position = pm.getPosition(_id);\\n        LimitOrderLibrary.Condition[] memory closeConditions = pm.getCloseConditions(_id);\\n        pm.priceOracle().updatePullOracle{value: msg.value}(_pullOracleData, _pullOracleTypes);\\n\\n        if (closeConditions.length == 0) return false;\\n\\n        ITakeProfitStopLossCCM.CanBeClosedParams memory params;\\n\\n        for (uint256 i; i < closeConditions.length; i++) {\\n            if (\\n                IERC165(pm.primexDNS().cmTypeToAddress(closeConditions[i].managerType)).supportsInterface(\\n                    type(ITakeProfitStopLossCCM).interfaceId\\n                )\\n            ) {\\n                params = abi.decode(closeConditions[i].params, (ITakeProfitStopLossCCM.CanBeClosedParams));\\n                break;\\n            }\\n        }\\n        return\\n            ITakeProfitStopLossCCM(takeProfitStopLossCCM).isStopLossReached(\\n                position,\\n                params.stopLossPrice,\\n                _positionSoldAssetOracleData\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getTokenMetadata(address _token, address _trader) public view override returns (TokenMetadata memory) {\\n        _require(_token != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\\n        return\\n            TokenMetadata({\\n                tokenAddress: _token,\\n                symbol: IERC20Metadata(_token).symbol(),\\n                name: IERC20Metadata(_token).name(),\\n                decimals: IERC20Metadata(_token).decimals(),\\n                balance: _trader != address(0) ? IERC20Metadata(_token).balanceOf(_trader) : 0\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getAssetMetadata(\\n        address _bucket,\\n        address _asset\\n    ) public view override returns (BucketTokenMetadata memory) {\\n        _require(\\n            IERC165(_bucket).supportsInterface(type(IBucketV3).interfaceId) && _asset != address(0),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        IPositionManagerV2 pm = IBucketV3(_bucket).positionManager();\\n        uint256 pairPriceDrop = pm.priceOracle().pairPriceDrops(_asset, address(IBucketV3(_bucket).borrowedAsset()));\\n\\n        (uint256 id, bool isSupported) = IBucketV3(_bucket).allowedAssets(_asset);\\n        return\\n            BucketTokenMetadata({\\n                id: id,\\n                isSupported: isSupported,\\n                pairPriceDrop: pairPriceDrop,\\n                // TODO: what FeeRateType should be used here?\\n                maxLeverage: IBucketV3(_bucket).maxAssetLeverage(\\n                    _asset,\\n                    pm.primexDNS().getProtocolFeeRateByTier(\\n                        IPrimexDNSStorageV3.FeeRateType.MarginPositionClosedByKeeper,\\n                        0\\n                    )\\n                )\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getSupportedAsset(\\n        address _bucket,\\n        address _asset,\\n        address _trader\\n    ) public view override returns (SupportedAsset memory) {\\n        return\\n            SupportedAsset({asset: getTokenMetadata(_asset, _trader), properties: getAssetMetadata(_bucket, _asset)});\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getSupportedAssetArray(\\n        address _bucket,\\n        address[] memory _assets,\\n        address _trader\\n    ) public view override returns (SupportedAsset[] memory) {\\n        uint256 assetCount = _assets.length;\\n        SupportedAsset[] memory res = new SupportedAsset[](assetCount);\\n\\n        for (uint256 i; i < assetCount; i++) {\\n            res[i] = getSupportedAsset(_bucket, _assets[i], _trader);\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getBucket(address _bucket, address _user) public view override returns (BucketMetaData memory) {\\n        _require(\\n            IERC165(_bucket).supportsInterface(type(IBucketV3).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        uint256 availableLiquidity = IBucketV3(_bucket).availableLiquidity();\\n        uint256 demand = IBucketV3(_bucket).debtToken().totalSupply();\\n        uint256 supply = demand + availableLiquidity;\\n        uint256 ur = supply > 0 ? demand.rdiv(supply) : 0;\\n\\n        address[] memory allowedAssets = IBucketV3(_bucket).getAllowedAssets();\\n        SupportedAsset[] memory supportedAssets = getSupportedAssetArray(_bucket, allowedAssets, _user);\\n        // solhint-disable-next-line var-name-mixedcase\\n        IBucketV3.LiquidityMiningParams memory LMparams = IBucketV3(_bucket).getLiquidityMiningParams();\\n        IInterestRateStrategy.BarCalculationParams memory barCalcParams = IBucketV3(_bucket)\\n            .interestRateStrategy()\\n            .getBarCalculationParams(_bucket);\\n        return\\n            BucketMetaData({\\n                bucketAddress: _bucket,\\n                name: IBucketV3(_bucket).name(),\\n                asset: getTokenMetadata(address(IBucketV3(_bucket).borrowedAsset()), _user),\\n                bar: IBucketV3(_bucket).bar(),\\n                lar: IBucketV3(_bucket).lar(),\\n                supply: supply,\\n                demand: demand,\\n                availableLiquidity: availableLiquidity,\\n                utilizationRatio: ur,\\n                supportedAssets: supportedAssets,\\n                pToken: getTokenMetadata(address(IBucketV3(_bucket).pToken()), _user),\\n                debtToken: getTokenMetadata(address(IBucketV3(_bucket).debtToken()), _user),\\n                feeBuffer: IBucketV3(_bucket).feeBuffer(),\\n                withdrawalFeeRate: IBucketV3(_bucket).withdrawalFeeRate(),\\n                miningParams: LMparams,\\n                lenderInfo: getLenderInfo(LMparams.liquidityMiningRewardDistributor, IBucketV3(_bucket).name(), _user),\\n                lmBucketInfo: getLMBucketInfo(LMparams.liquidityMiningRewardDistributor, IBucketV3(_bucket).name()),\\n                estimatedBar: IBucketV3(_bucket).estimatedBar(),\\n                estimatedLar: IBucketV3(_bucket).estimatedLar(),\\n                isDeprecated: IBucketV3(_bucket).isDeprecated(),\\n                isDelisted: IBucketV3(_bucket).isDelisted(),\\n                barCalcParams: barCalcParams,\\n                maxTotalDeposit: IBucketV3(_bucket).maxTotalDeposit()\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getLenderInfo(\\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor,\\n        string memory bucketName,\\n        address user\\n    ) public view override returns (LenderInfo memory) {\\n        LenderInfo memory info;\\n        if (address(liquidityMiningRewardDistributor) == address(0)) return info;\\n        (info.amountInMining, info.currentPercent, info.rewardsInPMX) = liquidityMiningRewardDistributor.getLenderInfo(\\n            bucketName,\\n            user,\\n            block.timestamp\\n        );\\n        return info;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getLMBucketInfo(\\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor,\\n        string memory bucketName\\n    ) public view override returns (LiquidityMiningBucketInfo memory) {\\n        LiquidityMiningBucketInfo memory info;\\n        if (address(liquidityMiningRewardDistributor) == address(0)) return info;\\n        (info.pmxAmount, info.withdrawnRewards, info.totalPoints) = liquidityMiningRewardDistributor.getBucketInfo(\\n            bucketName\\n        );\\n        return info;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getBucketsArray(\\n        address[] memory _buckets,\\n        address _user,\\n        address _positionManager,\\n        bool _showDeprecated\\n    ) public view override returns (BucketMetaData[] memory) {\\n        _require(\\n            IERC165(_positionManager).supportsInterface(type(IPositionManagerV2).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        uint256 bucketCount;\\n        for (uint256 i; i < _buckets.length; i++) {\\n            IBucketV3 bucket = IBucketV3(_buckets[i]);\\n            (address bucketAddress, IPrimexDNSStorage.Status currentStatus, , ) = IPositionManagerV2(_positionManager)\\n                .primexDNS()\\n                .buckets(bucket.name());\\n            if (\\n                (_showDeprecated ||\\n                    !(currentStatus == IPrimexDNSStorage.Status.Deprecated && bucket.pToken().balanceOf(_user) == 0)) &&\\n                bucketAddress == _buckets[i]\\n            ) {\\n                _buckets[bucketCount] = _buckets[i];\\n                bucketCount++;\\n            }\\n        }\\n        BucketMetaData[] memory res = new BucketMetaData[](bucketCount);\\n        for (uint256 i; i < bucketCount; i++) {\\n            res[i] = getBucket(_buckets[i], _user);\\n        }\\n        return res;\\n    }\\n\\n    /**\\n     * @notice Interface checker\\n     * @param interfaceId The interface id to check\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IPrimexLens).interfaceId || interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getLiquidationPrice(address _positionManager, uint256 _id) public view override returns (uint256) {\\n        _require(\\n            IERC165(_positionManager).supportsInterface(type(IPositionManagerV2).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n\\n        PositionLibrary.Position memory position = IPositionManagerV2(_positionManager).getPosition(_id);\\n        if (position.scaledDebtAmount == 0) return 0;\\n\\n        uint256 positionDebt = IPositionManagerV2(_positionManager).getPositionDebt(_id);\\n        return\\n            PrimexPricingLibrary.getLiquidationPrice(\\n                address(position.bucket),\\n                position.positionAsset,\\n                position.positionAmount,\\n                positionDebt,\\n                address(IPositionManagerV2(_positionManager).primexDNS())\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getPositionMaxDecrease(\\n        IPositionManagerV2 _pm,\\n        uint256 _id,\\n        bytes calldata _positionSoldAssetOracleData,\\n        bytes[][] calldata _pullOracleData,\\n        uint256[] calldata _pullOracleTypes\\n    ) public payable override returns (uint256) {\\n        _pm.priceOracle().updatePullOracle{value: msg.value}(_pullOracleData, _pullOracleTypes);\\n        PositionLibrary.Position memory position = _pm.getPosition(_id);\\n        uint256 pairPriceDrop = _pm.priceOracle().getPairPriceDrop(position.positionAsset, address(position.soldAsset));\\n        uint256 securityBuffer = _pm.securityBuffer();\\n        uint256 maintenanceBuffer = _pm.maintenanceBuffer();\\n\\n        uint256 oracleTolerableLimit = _pm.getOracleTolerableLimit(position.positionAsset, address(position.soldAsset));\\n\\n        uint256 feeBuffer = position.bucket.feeBuffer();\\n        uint256 positionAmountInBorrowedAsset = PrimexPricingLibrary.getOracleAmountsOut(\\n            position.positionAsset,\\n            position.soldAsset,\\n            position.positionAmount,\\n            address(_pm.priceOracle()),\\n            _positionSoldAssetOracleData\\n        );\\n        uint256 maxDecrease = (WadRayMath.WAD - securityBuffer)\\n            .wmul(WadRayMath.WAD - oracleTolerableLimit)\\n            .wmul(WadRayMath.WAD - pairPriceDrop)\\n            .wmul(positionAmountInBorrowedAsset)\\n            .wdiv(feeBuffer.wmul(WadRayMath.WAD + maintenanceBuffer)) -\\n            position.bucket.getNormalizedVariableDebt().rmul(position.scaledDebtAmount);\\n\\n        return maxDecrease <= position.depositAmountInSoldAsset ? maxDecrease : position.depositAmountInSoldAsset;\\n    }\\n\\n    /**\\n     * @inheritdoc IPrimexLens\\n     */\\n    function getEstimatedMinProtocolFee(\\n        IPrimexDNSStorageV3.TradingOrderType _tradingOrderType,\\n        IPositionManagerV2 _pm\\n    ) public view override returns (uint256) {\\n        uint256 restrictedGasPrice = PrimexPricingLibrary.calculateRestrictedGasPrice(\\n            address(_pm.priceOracle()),\\n            _pm.keeperRewardDistributor()\\n        );\\n        (, , uint256 optimisticGasCoefficient, IKeeperRewardDistributorStorage.PaymentModel paymentModel) = _pm\\n            .keeperRewardDistributor()\\n            .getGasCalculationParams();\\n        uint256 protocolFeeCoefficient = _pm.primexDNS().protocolFeeCoefficient();\\n        uint256 l1CostWei;\\n        if (paymentModel != IKeeperRewardDistributorStorage.PaymentModel.DEFAULT) {\\n            if (paymentModel == IKeeperRewardDistributorStorage.PaymentModel.ARBITRUM) {\\n                l1CostWei =\\n                    ARB_NITRO_ORACLE.getL1BaseFeeEstimate() *\\n                    GAS_FOR_BYTE *\\n                    (_pm.primexDNS().getL1BaseLengthForTradingOrderType(_tradingOrderType) +\\n                        TRANSACTION_METADATA_BYTES);\\n            }\\n            if (paymentModel == IKeeperRewardDistributorStorage.PaymentModel.OPTIMISTIC) {\\n                l1CostWei = OVM_GASPRICEORACLE\\n                    .getL1FeeUpperBound(_pm.primexDNS().getL1BaseLengthForTradingOrderType(_tradingOrderType))\\n                    .wmul(optimisticGasCoefficient);\\n                // because we can't consider l2 a gas on the OPTIMISTIC chains\\n                return l1CostWei + protocolFeeCoefficient;\\n            }\\n        }\\n        uint256 estimatedMinProtocolFeeInNativeAsset = _pm.primexDNS().averageGasPerAction(_tradingOrderType) *\\n            restrictedGasPrice +\\n            l1CostWei +\\n            protocolFeeCoefficient;\\n        return estimatedMinProtocolFeeInNativeAsset;\\n    }\\n}\\n\",\"keccak256\":\"0x2b600bbdf3536fe88eb2ff7ae4c90a7f6b093db1b17ce618c6e5c41c53156f09\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/Errors.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.26;\\n\\n// solhint-disable-next-line func-visibility\\nfunction _require(bool condition, bytes4 selector) pure {\\n    if (!condition) _revert(selector);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction _revert(bytes4 selector) pure {\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly (\\\"memory-safe\\\") {\\n        let free_mem_ptr := mload(64)\\n        mstore(free_mem_ptr, selector)\\n        revert(free_mem_ptr, 4)\\n    }\\n}\\n\\nlibrary Errors {\\n    event Log(bytes4 error);\\n\\n    //common\\n    error ADDRESS_NOT_SUPPORTED();\\n    error FORBIDDEN();\\n    error AMOUNT_IS_0();\\n    error CALLER_IS_NOT_TRADER();\\n    error CONDITION_INDEX_IS_OUT_OF_BOUNDS();\\n    error INVALID_PERCENT_NUMBER();\\n    error INVALID_SECURITY_BUFFER();\\n    error INVALID_MAINTENANCE_BUFFER();\\n    error TOKEN_ADDRESS_IS_ZERO();\\n    error IDENTICAL_TOKEN_ADDRESSES();\\n    error ASSET_DECIMALS_EXCEEDS_MAX_VALUE();\\n    error CAN_NOT_ADD_WITH_ZERO_ADDRESS();\\n    error SHOULD_BE_DIFFERENT_ASSETS_IN_SPOT();\\n    error TOKEN_NOT_SUPPORTED();\\n    error INSUFFICIENT_DEPOSIT();\\n    error SHOULD_NOT_HAVE_DUPLICATES();\\n    error SWAP_DEADLINE_PASSED();\\n    // error LIMIT_PRICE_IS_ZERO();\\n    error BUCKET_IS_NOT_ACTIVE();\\n    error DIFFERENT_DATA_LENGTH();\\n    error RECIPIENT_OR_SENDER_MUST_BE_ON_WHITE_LIST();\\n    error SLIPPAGE_TOLERANCE_EXCEEDED();\\n    error OPERATION_NOT_SUPPORTED();\\n    error SENDER_IS_BLACKLISTED();\\n    error NATIVE_CURRENCY_CANNOT_BE_ASSET();\\n    error INVALID_AMOUNT();\\n    error POOL_CALL_FAILED();\\n\\n    // bonus executor\\n    error CALLER_IS_NOT_NFT();\\n    error BONUS_FOR_BUCKET_ALREADY_ACTIVATED();\\n    error WRONG_LENGTH();\\n    error BONUS_DOES_NOT_EXIST();\\n    error CALLER_IS_NOT_DEBT_TOKEN();\\n    error CALLER_IS_NOT_P_TOKEN();\\n    error MAX_BONUS_COUNT_EXCEEDED();\\n    error TIER_IS_NOT_ACTIVE();\\n    error BONUS_PERCENT_IS_ZERO();\\n\\n    // bucket\\n    error INCORRECT_LIQUIDITY_MINING_PARAMS();\\n    error PAIR_PRICE_DROP_IS_NOT_CORRECT();\\n    error ASSET_IS_NOT_SUPPORTED();\\n    error BUCKET_OUTSIDE_PRIMEX_PROTOCOL();\\n    error DEADLINE_IS_PASSED();\\n    error DEADLINE_IS_NOT_PASSED();\\n    error BUCKET_IS_NOT_LAUNCHED();\\n    error BURN_AMOUNT_EXCEEDS_PROTOCOL_DEBT();\\n    error LIQUIDITY_INDEX_OVERFLOW();\\n    error BORROW_INDEX_OVERFLOW();\\n    error BAR_OVERFLOW();\\n    error LAR_OVERFLOW();\\n    error UR_IS_MORE_THAN_1();\\n    error ASSET_ALREADY_SUPPORTED();\\n    error DEPOSIT_IS_MORE_AMOUNT_PER_USER();\\n    error DEPOSIT_EXCEEDS_MAX_TOTAL_DEPOSIT();\\n    error MINING_AMOUNT_WITHDRAW_IS_LOCKED_ON_STABILIZATION_PERIOD();\\n    error WITHDRAW_RATE_IS_MORE_10_PERCENT();\\n    error INVALID_FEE_BUFFER();\\n    error RESERVE_RATE_SHOULD_BE_LESS_THAN_1();\\n    error MAX_TOTAL_DEPOSIT_IS_ZERO();\\n    error AMOUNT_SCALED_SHOULD_BE_GREATER_THAN_ZERO();\\n    error NOT_ENOUGH_LIQUIDITY_IN_THE_BUCKET();\\n\\n    // p/debt token, PMXToken\\n    error BUCKET_IS_IMMUTABLE();\\n    error INVALID_MINT_AMOUNT();\\n    error INVALID_BURN_AMOUNT();\\n    error TRANSFER_NOT_SUPPORTED();\\n    error APPROVE_NOT_SUPPORTED();\\n    error CALLER_IS_NOT_BUCKET();\\n    error CALLER_IS_NOT_A_BUCKET_FACTORY();\\n    error CALLER_IS_NOT_P_TOKEN_RECEIVER();\\n    error DURATION_MUST_BE_MORE_THAN_0();\\n    error INCORRECT_ID();\\n    error THERE_ARE_NO_LOCK_DEPOSITS();\\n    error LOCK_TIME_IS_NOT_EXPIRED();\\n    error TRANSFER_AMOUNT_EXCEED_ALLOWANCE();\\n    error CALLER_IS_NOT_A_MINTER();\\n    error ACTION_ONLY_WITH_AVAILABLE_BALANCE();\\n    error FEE_DECREASER_CALL_FAILED();\\n    error TRADER_REWARD_DISTRIBUTOR_CALL_FAILED();\\n    error INTEREST_INCREASER_CALL_FAILED();\\n    error LENDER_REWARD_DISTRIBUTOR_CALL_FAILED();\\n    error DEPOSIT_DOES_NOT_EXIST();\\n    error RECIPIENT_IS_BLACKLISTED();\\n\\n    //LOM\\n    error ORDER_CAN_NOT_BE_FILLED();\\n    error ORDER_DOES_NOT_EXIST();\\n    error ORDER_IS_NOT_SPOT();\\n    error LEVERAGE_MUST_BE_MORE_THAN_1();\\n    error CANNOT_CHANGE_SPOT_ORDER_TO_MARGIN();\\n    error SHOULD_HAVE_OPEN_CONDITIONS();\\n    error INCORRECT_LEVERAGE();\\n    error INCORRECT_DEADLINE();\\n    error LEVERAGE_SHOULD_BE_1();\\n    error LEVERAGE_EXCEEDS_MAX_LEVERAGE();\\n    error SHOULD_OPEN_POSITION();\\n    error IS_SPOT_ORDER();\\n    error SHOULD_NOT_HAVE_CLOSE_CONDITIONS();\\n    error ORDER_HAS_EXPIRED();\\n    error INCORRECT_BORROWED_AMOUNT();\\n\\n    // LiquidityMiningRewardDistributor\\n    error BUCKET_IS_NOT_STABLE();\\n    error ATTEMPT_TO_WITHDRAW_MORE_THAN_DEPOSITED();\\n    error WITHDRAW_PMX_BY_ADMIN_FORBIDDEN();\\n\\n    // nft\\n    error TOKEN_IS_BLOCKED();\\n    error ONLY_MINTERS();\\n    error PROGRAM_IS_NOT_ACTIVE();\\n    error CALLER_IS_NOT_OWNER();\\n    error TOKEN_IS_ALREADY_ACTIVATED();\\n    error WRONG_NETWORK();\\n    error WRONG_DEADLINE();\\n    error ID_DOES_NOT_EXIST();\\n    error WRONG_URIS_LENGTH();\\n\\n    // PM\\n    error ASSET_ADDRESS_NOT_SUPPORTED();\\n    error IDENTICAL_ASSET_ADDRESSES();\\n    error POSITION_DOES_NOT_EXIST();\\n    error AMOUNT_IS_MORE_THAN_POSITION_AMOUNT();\\n    error BORROWED_AMOUNT_IS_ZERO();\\n    error IS_SPOT_POSITION();\\n    error AMOUNT_IS_MORE_THAN_DEPOSIT();\\n    error DECREASE_AMOUNT_IS_ZERO();\\n    error INSUFFICIENT_DEPOSIT_SIZE();\\n    error IS_NOT_RISKY_OR_CANNOT_BE_CLOSED();\\n    error BUCKET_SHOULD_BE_UNDEFINED();\\n    error DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0();\\n    error POSITION_CANNOT_BE_CLOSED_FOR_THIS_REASON();\\n    error ADDRESS_IS_ZERO();\\n    error WRONG_TRUSTED_MULTIPLIER();\\n    error POSITION_SIZE_EXCEEDED();\\n    error POSITION_BUCKET_IS_INCORRECT();\\n    error THERE_MUST_BE_AT_LEAST_ONE_POSITION();\\n    error NOTHING_TO_CLOSE();\\n\\n    // BatchManager\\n    error PARAMS_LENGTH_MISMATCH();\\n    error BATCH_CANNOT_BE_CLOSED_FOR_THIS_REASON();\\n    error CLOSE_CONDITION_IS_NOT_CORRECT();\\n    error SOLD_ASSET_IS_INCORRECT();\\n\\n    // Price Oracle\\n    error THERE_IS_DIRECT_ROUTE();\\n    error ZERO_EXCHANGE_RATE();\\n    error NO_PRICEFEED_FOUND();\\n    error NO_PRICE_DROP_FEED_FOUND();\\n    error WRONG_ORACLE_ROUTES_LENGTH();\\n    error WRONG_ASSET_B();\\n    error INCORRECT_ROUTE_SEQUENCE();\\n    error INCORRECT_PYTH_PRICE();\\n    error INCORRECT_ORALLY_PRICE();\\n    error TOKEN_PAIR_IS_NOT_TRUSTED();\\n    error INCORRECT_TOKEN_TO();\\n    error INCORRECT_PYTH_ROUTE();\\n    error INCORRECT_CHAINLINK_ROUTE();\\n    error INCORRECT_CURVELP_ROUTE();\\n    error INCORRECT_UNISWAPV2LP_ROUTE();\\n    error ADDRESS_IS_NOT_UNISWAPV2LP_TOKEN();\\n    error NOT_ENOUGH_MSG_VALUE();\\n    error PUBLISH_TIME_EXCEEDS_THRESHOLD_TIME();\\n    error STORK_VERIFY_FAILED();\\n    error NO_TOKEN_SYMBOL_FOUND();\\n    error NO_TOKEN_PAIR_FOUND();\\n    error INCORRECT_EIP4626_ROUTE();\\n    error NO_UNDERLYING_TOKEN_FOUND();\\n    //DNS\\n    error INCORRECT_FEE_RATE();\\n    error INCORRECT_RESTRICTIONS();\\n    error BUCKET_ALREADY_FROZEN();\\n    error BUCKET_IS_ALREADY_ADDED();\\n    error DEX_IS_ALREADY_ACTIVATED();\\n    error DEX_IS_ALREADY_FROZEN();\\n    error DEX_IS_ALREADY_ADDED();\\n    error BUCKET_NOT_ADDED();\\n    error BUCKET_ALREADY_ACTIVATED();\\n    error DEX_NOT_ADDED();\\n    error BUCKET_IS_INACTIVE();\\n    error WITHDRAWAL_NOT_ALLOWED();\\n    error BUCKET_IS_ALREADY_DEPRECATED();\\n    error LEVERAGE_TOLERANCE_IS_NOT_CORRECT();\\n\\n    // Primex upkeep\\n    error NUMBER_IS_0();\\n\\n    //referral program, WhiteBlackList\\n    error CALLER_ALREADY_REGISTERED();\\n    error MISMATCH();\\n    error PARENT_NOT_WHITELISTED();\\n    error ADDRESS_ALREADY_WHITELISTED();\\n    error ADDRESS_ALREADY_BLACKLISTED();\\n    error ADDRESS_NOT_BLACKLISTED();\\n    error ADDRESS_NOT_WHITELISTED();\\n    error ADDRESS_NOT_UNLISTED();\\n    error ADDRESS_IS_WHITELISTED();\\n    error ADDRESS_IS_NOT_CONTRACT();\\n\\n    //Reserve\\n    error BURN_AMOUNT_IS_ZERO();\\n    error CALLER_IS_NOT_EXECUTOR();\\n    error ADDRESS_NOT_PRIMEX_BUCKET();\\n    error NOT_SUFFICIENT_RESERVE_BALANCE();\\n    error INCORRECT_TRANSFER_RESTRICTIONS();\\n\\n    //Vault\\n    error AMOUNT_EXCEEDS_AVAILABLE_BALANCE();\\n    error INSUFFICIENT_FREE_ASSETS();\\n    error CALLER_IS_NOT_SPENDER();\\n\\n    //Pricing Library\\n    error IDENTICAL_ASSETS();\\n    error SUM_OF_SHARES_SHOULD_BE_GREATER_THAN_ZERO();\\n    error DIFFERENT_PRICE_DEX_AND_ORACLE();\\n    error LEVERAGE_TOLERANCE_EXCEEDED();\\n    error TAKE_PROFIT_IS_LTE_LIMIT_PRICE();\\n    error STOP_LOSS_IS_GTE_LIMIT_PRICE();\\n    error STOP_LOSS_IS_LTE_LIQUIDATION_PRICE();\\n    error INSUFFICIENT_POSITION_SIZE();\\n    error INCORRECT_PATH();\\n    error DEPOSITED_TO_BORROWED_ROUTES_LENGTH_SHOULD_BE_0();\\n    error INCORRECT_CM_TYPE();\\n    error FEE_RATE_IN_NATIVE_IS_ZERO();\\n    error MIN_PROTOCOL_FEE_IS_GREATER_THAN_PAYMENT_AMOUNT();\\n\\n    // Token transfers\\n    error TOKEN_TRANSFER_IN_FAILED();\\n    error TOKEN_TRANSFER_IN_OVERFLOW();\\n    error TOKEN_TRANSFER_OUT_FAILED();\\n    error TOKEN_APPROVE_FAILED();\\n    error NATIVE_TOKEN_TRANSFER_FAILED();\\n\\n    // Conditional Managers\\n    error LOW_PRICE_ROUND_IS_LESS_HIGH_PRICE_ROUND();\\n    error TRAILING_DELTA_IS_INCORRECT();\\n    error DATA_FOR_ROUND_DOES_NOT_EXIST();\\n    error HIGH_PRICE_TIMESTAMP_IS_INCORRECT();\\n    error NO_PRICE_FEED_INTERSECTION();\\n    error SHOULD_BE_CCM();\\n    error SHOULD_BE_COM();\\n\\n    //Lens\\n    error DEPOSITED_AMOUNT_IS_0();\\n    error SPOT_DEPOSITED_ASSET_SHOULD_BE_EQUAL_BORROWED_ASSET();\\n    error ZERO_ASSET_ADDRESS();\\n    error ASSETS_SHOULD_BE_DIFFERENT();\\n    error ZERO_SHARES();\\n    error SHARES_AMOUNT_IS_GREATER_THAN_AMOUNT_TO_SELL();\\n    error NO_ACTIVE_DEXES();\\n\\n    //Bots\\n    error WRONG_BALANCES();\\n    error INVALID_INDEX();\\n    error INVALID_DIVIDER();\\n    error ARRAYS_LENGTHS_IS_NOT_EQUAL();\\n    error DENOMINATOR_IS_0();\\n\\n    //DexAdapter\\n    error ZERO_AMOUNT_IN();\\n    error ZERO_AMOUNT();\\n    error UNKNOWN_DEX_TYPE();\\n    error REVERTED_WITHOUT_A_STRING_TRY_TO_CHECK_THE_ANCILLARY_DATA();\\n    error DELTA_OF_TOKEN_OUT_HAS_POSITIVE_VALUE();\\n    error DELTA_OF_TOKEN_IN_HAS_NEGATIVE_VALUE();\\n    error QUOTER_IS_NOT_PROVIDED();\\n    error DEX_ROUTER_NOT_SUPPORTED();\\n    error QUOTER_NOT_SUPPORTED();\\n\\n    //SpotTradingRewardDistributor\\n    error PERIOD_DURATION_IS_ZERO();\\n    error REWARD_AMOUNT_IS_ZERO();\\n    error REWARD_PER_PERIOD_IS_NOT_CORRECT();\\n\\n    //ActivityRewardDistributor\\n    error TOTAL_REWARD_AMOUNT_IS_ZERO();\\n    error REWARD_PER_DAY_IS_NOT_CORRECT();\\n    error ZERO_BUCKET_ADDRESS();\\n    //KeeperRewardDistributor\\n    error INCORRECT_PART_IN_REWARD();\\n    error INCORRECT_MULTIPLIER();\\n    error INCORRECT_OPTIMISM_GAS_COEFFICIENT();\\n\\n    //Treasury\\n    error TRANSFER_RESTRICTIONS_NOT_MET();\\n    error INSUFFICIENT_NATIVE_TOKEN_BALANCE();\\n    error INSUFFICIENT_TOKEN_BALANCE();\\n    error EXCEEDED_MAX_AMOUNT_DURING_TIMEFRAME();\\n    error EXCEEDED_MAX_SPENDING_LIMITS();\\n    error SPENDING_LIMITS_ARE_INCORRECT();\\n    error SPENDER_IS_NOT_EXIST();\\n\\n    //FlashLoan\\n    error INCONSISTENT_FLASHLOAN_PARAMS();\\n    error INVALID_FLASHLOAN_EXECUTOR_RETURN();\\n    error FLASH_LOAN_FEE_RATE_IS_MORE_10_PERCENT();\\n    error FLASH_LOAN_PROTOCOL_RATE_IS_MORE_50_PERCENT();\\n\\n    // DepositManager\\n    error REWARD_PERCENT_SHOULD_BE_GREATER_THAN_ZERO();\\n    error TOKEN_CANNOT_BE_P_TOKEN();\\n    //Curve oracle\\n    error ORACLE_NOT_SUPPORT_LP();\\n    error ZERO_ADDRESS();\\n    error REENTRANCY_RISK();\\n    error ORACLE_DATA_AND_TOKENS_LENGTH_MISMATCH();\\n    error INCORRECT_LIMITS();\\n    error INCORRECT_ORACLE_DATA();\\n    error VALUE_OUT_OF_RANGE();\\n    //UniswapV2LPOracle\\n    error INVALID_RESERVES();\\n    error INVALID_PRICES();\\n\\n    // TiersManager\\n    error INCORRECT_TIERS_ORDER();\\n    error INCORRECT_TIER();\\n}\\n\",\"keccak256\":\"0xa994f6418d472a072bf4cb0e4c124e01a8a89847cc275a0793e474e68484087d\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/LimitOrderLibrary.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.26;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport {WadRayMath} from \\\"./utils/WadRayMath.sol\\\";\\n\\nimport {PrimexPricingLibrary} from \\\"./PrimexPricingLibrary.sol\\\";\\nimport {TokenTransfersLibrary} from \\\"./TokenTransfersLibrary.sol\\\";\\n\\nimport {NATIVE_CURRENCY} from \\\"../Constants.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IPrimexDNSStorageV3} from \\\"../PrimexDNS/IPrimexDNSStorage.sol\\\";\\nimport {IPriceOracleV2} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IConditionalOpeningManager} from \\\"../interfaces/IConditionalOpeningManager.sol\\\";\\nimport {IConditionalClosingManager} from \\\"../interfaces/IConditionalClosingManager.sol\\\";\\nimport {IPositionManagerV2} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {ISwapManager} from \\\"../SwapManager/ISwapManager.sol\\\";\\n\\nimport \\\"./Errors.sol\\\";\\n\\nlibrary LimitOrderLibrary {\\n    using WadRayMath for uint256;\\n\\n    enum CloseReason {\\n        FilledMargin,\\n        FilledSpot,\\n        FilledSwap,\\n        Cancelled\\n    }\\n\\n    struct Condition {\\n        uint256 managerType;\\n        bytes params;\\n    }\\n\\n    /**\\n     * @dev Creates a limit order and locks the deposit asset in the traderBalanceVault\\n     * @param bucket The bucket, from which the loan will be taken\\n     * @param positionAsset The address of output token for exchange\\n     * @param depositAsset The address of the deposit token\\n     * @param depositAmount The amount of deposit trader funds for deal\\n     * @param feeToken An asset in which the fee will be paid. At this point it could be the pmx, the epmx or a positionAsset\\n     * @param trader The trader, who has created the order\\n     * @param deadline Unix timestamp after which the order will not be filled\\n     * @param id The unique id of the order\\n     * @param leverage leverage for trading\\n     * @param shouldOpenPosition The flag to indicate whether position should be opened\\n     * @param createdAt The timeStamp when the order was created\\n     * @param updatedConditionsAt The timestamp when the open condition was updated\\n     */\\n    struct LimitOrder {\\n        IBucketV3 bucket;\\n        address positionAsset;\\n        address depositAsset;\\n        uint256 depositAmount;\\n        address feeToken;\\n        uint256 protocolFee;\\n        address trader;\\n        uint256 deadline;\\n        uint256 id;\\n        uint256 leverage;\\n        bool shouldOpenPosition;\\n        uint256 createdAt;\\n        uint256 updatedConditionsAt;\\n        // The byte-encoded params, can be used for future updates\\n        bytes extraParams;\\n    }\\n\\n    /**\\n     * @dev Structure for the \\u0441reateLimitOrder with parameters necessary to create limit order\\n     * @param bucket The bucket, from which the loan will be taken\\n     * @param depositAsset The address of the deposit token (collateral for margin trade or\\n     * locked funds for spot)\\n     * @param depositAmount The amount of deposit funds for deal\\n     * @param positionAsset The address output token for exchange\\n     * @param deadline Unix timestamp after which the order will not be filled\\n     * @param takeDepositFromWallet Bool, add a collateral deposit within the current transaction\\n     * @param leverage leverage for trading\\n     * @param shouldOpenPosition Bool, indicate whether position should be opened\\n     * @param openingManagerAddresses Array of contract addresses that will be called in canBeFilled\\n     * @param openingManagerParams Array of bytes representing params for contracts in openingManagerAddresses\\n     * @param closingManagerAddresses Array of contract addresses that will be called in canBeClosed\\n     * @param closingManagerParams Array of bytes representing params for contracts in closingManagerAddresses\\n     */\\n    struct CreateLimitOrderParams {\\n        string bucket;\\n        uint256 depositAmount;\\n        address depositAsset;\\n        address positionAsset;\\n        uint256 deadline;\\n        bool takeDepositFromWallet;\\n        uint256 leverage;\\n        bool shouldOpenPosition;\\n        Condition[] openConditions;\\n        Condition[] closeConditions;\\n        bool isProtocolFeeInPmx;\\n        bytes nativeDepositAssetOracleData;\\n        bytes[][] pullOracleData;\\n        uint256[] pullOracleTypes;\\n    }\\n\\n    struct CreateLimitOrderVars {\\n        bool isSpot;\\n        IBucketV3 bucket;\\n        uint256 positionSize;\\n        address priceOracle;\\n        uint256 rate;\\n        IPrimexDNSStorageV3.TradingOrderType tradingOrderType;\\n        bool isThirdAsset;\\n    }\\n\\n    /**\\n     * @dev Opens a position on an existing order\\n     * @param orderId order id\\n     * @param com address of ConditionalOpeningManager\\n     * @param comAdditionalParams  params needed for ConditionalOpeningManager to calc canBeFilled\\n     * @param firstAssetMegaRoutes routes to swap first asset\\n     * @param depositInThirdAssetMegaRoutes routes to swap deposit asset\\n     */\\n    struct OpenPositionParams {\\n        uint256 orderId;\\n        uint256 conditionIndex;\\n        bytes comAdditionalParams;\\n        PrimexPricingLibrary.MegaRoute[] firstAssetMegaRoutes;\\n        PrimexPricingLibrary.MegaRoute[] depositInThirdAssetMegaRoutes;\\n        address keeper;\\n        bytes firstAssetOracleData;\\n        bytes thirdAssetOracleData;\\n        bytes depositSoldAssetOracleData;\\n        bytes nativePmxOracleData;\\n        bytes positionNativeAssetOracleData;\\n        bytes nativePositionAssetOracleData;\\n        bytes pmxPositionAssetOracleData;\\n        bytes positionUsdOracleData;\\n        bytes nativeSoldAssetOracleData;\\n        bytes[][] pullOracleData;\\n        uint256[] pullOracleTypes;\\n        uint256 borrowedAmount;\\n    }\\n\\n    struct OpenPositionByOrderVars {\\n        address assetIn;\\n        address assetOut;\\n        uint256 amountIn;\\n        uint256 amountOut;\\n        CloseReason closeReason;\\n        uint256 newPositionId;\\n        uint256 exchangeRate;\\n        uint256 feeInPositionAsset;\\n        uint256 feeInPmx;\\n    }\\n\\n    /**\\n     * @dev Params for PositionManager to open position\\n     * @param order order\\n     * @param firstAssetMegaRoutes routes to swap first asset on dex\\n     * (borrowedAmount + depositAmount if deposit in borrowedAsset)\\n     * @param depositInThirdAssetMegaRoutes routes to swap deposit in third asset on dex\\n     */\\n    struct OpenPositionByOrderParams {\\n        address sender;\\n        LimitOrder order;\\n        Condition[] closeConditions;\\n        PrimexPricingLibrary.MegaRoute[] firstAssetMegaRoutes;\\n        PrimexPricingLibrary.MegaRoute[] depositInThirdAssetMegaRoutes;\\n        bytes firstAssetOracleData;\\n        bytes thirdAssetOracleData;\\n        bytes depositSoldAssetOracleData;\\n        bytes positionUsdOracleData;\\n        bytes nativePositionAssetOracleData;\\n        bytes pmxPositionAssetOracleData;\\n        bytes nativeSoldAssetOracleData;\\n        uint256 borrowedAmount;\\n    }\\n\\n    /**\\n     * @dev Structure for the updateOrder with parameters necessary to update limit order\\n     * @param orderId order id to update\\n     * @param depositAmount The amount of deposit funds for deal\\n     * @param makeDeposit Bool, add a collateral deposit within the current transaction\\n     * @param leverage leverage for trading\\n     * @param takeDepositFromWallet Bool, add a collateral deposit within the current transaction\\n     */\\n    struct UpdateLimitOrderParams {\\n        uint256 orderId;\\n        uint256 depositAmount;\\n        uint256 leverage;\\n        bool isProtocolFeeInPmx;\\n        bool takeDepositFromWallet;\\n        bytes nativeDepositOracleData;\\n        bytes[][] pullOracleData;\\n        uint256[] pullOracleTypes;\\n    }\\n\\n    /**\\n     * @notice Updates the leverage of a limit order.\\n     * @param _order The limit order to update.\\n     * @param _leverage The new leverage value in WAD format for the order.\\n     * @param _primexDNS The instance of the PrimexDNS contract\\n     */\\n    function updateLeverage(LimitOrder storage _order, uint256 _leverage, IPrimexDNSV3 _primexDNS) public {\\n        _require(_leverage > WadRayMath.WAD, Errors.LEVERAGE_MUST_BE_MORE_THAN_1.selector);\\n        _require(_order.leverage != WadRayMath.WAD, Errors.CANNOT_CHANGE_SPOT_ORDER_TO_MARGIN.selector);\\n\\n        _require(\\n            _leverage <\\n                _order.bucket.maxAssetLeverage(\\n                    _order.positionAsset,\\n                    _primexDNS.getProtocolFeeRateByTier(IPrimexDNSStorageV3.FeeRateType.MarginLimitOrderExecuted, 0) // do not consider the tier here\\n                ),\\n            Errors.LEVERAGE_EXCEEDS_MAX_LEVERAGE.selector\\n        );\\n        _order.leverage = _leverage;\\n    }\\n\\n    /**\\n     * @notice Updates the deposit details of a LimitOrder.\\n     * @param _order The LimitOrder to update.\\n     * @param _amount The amount of the asset being deposited.\\n     * @param _takeDepositFromWallet Boolean indicating whether to make a deposit or unlock the deposited asset.\\n     * @param traderBalanceVault The instance of ITraderBalanceVault used for deposit and unlock operations.\\n     */\\n    function updateDeposit(\\n        LimitOrderLibrary.LimitOrder storage _order,\\n        uint256 _amount,\\n        bool _takeDepositFromWallet,\\n        ITraderBalanceVault traderBalanceVault\\n    ) public {\\n        depositLockOrUnlock(\\n            traderBalanceVault,\\n            _order.depositAsset,\\n            (_amount > _order.depositAmount) ? _amount - _order.depositAmount : _order.depositAmount - _amount,\\n            _takeDepositFromWallet,\\n            _amount > _order.depositAmount\\n        );\\n        _order.depositAmount = _amount;\\n    }\\n\\n    /**\\n     * @notice Sets the open conditions for a LimitOrder.\\n     * @param _order The limit order.\\n     * @param openConditionsMap The mapping of order IDs to open conditions.\\n     * @param openConditions The array of open conditions.\\n     * @param primexDNS The instance of the Primex DNS contract.\\n     */\\n    function setOpenConditions(\\n        LimitOrderLibrary.LimitOrder memory _order,\\n        mapping(uint256 => Condition[]) storage openConditionsMap,\\n        Condition[] memory openConditions,\\n        IPrimexDNSV3 primexDNS\\n    ) public {\\n        _require(hasNoConditionManagerTypeDuplicates(openConditions), Errors.SHOULD_NOT_HAVE_DUPLICATES.selector);\\n        _require(openConditions.length > 0, Errors.SHOULD_HAVE_OPEN_CONDITIONS.selector);\\n        if (openConditionsMap[_order.id].length > 0) {\\n            delete openConditionsMap[_order.id];\\n        }\\n        Condition memory condition;\\n        for (uint256 i; i < openConditions.length; i++) {\\n            condition = openConditions[i];\\n            _require(\\n                IERC165Upgradeable(primexDNS.cmTypeToAddress(condition.managerType)).supportsInterface(\\n                    type(IConditionalOpeningManager).interfaceId\\n                ),\\n                Errors.SHOULD_BE_COM.selector\\n            );\\n            openConditionsMap[_order.id].push(condition);\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the close conditions for a LimitOrder.\\n     * @param _order The limit order.\\n     * @param closeConditionsMap The mapping of order IDs to close conditions.\\n     * @param closeConditions The array of close conditions to set.\\n     * @param primexDNS The Primex DNS contract address.\\n     */\\n    function setCloseConditions(\\n        LimitOrderLibrary.LimitOrder memory _order,\\n        mapping(uint256 => Condition[]) storage closeConditionsMap,\\n        Condition[] memory closeConditions,\\n        IPrimexDNSV3 primexDNS\\n    ) public {\\n        _require(hasNoConditionManagerTypeDuplicates(closeConditions), Errors.SHOULD_NOT_HAVE_DUPLICATES.selector);\\n        _require(\\n            _order.shouldOpenPosition || closeConditions.length == 0,\\n            Errors.SHOULD_NOT_HAVE_CLOSE_CONDITIONS.selector\\n        );\\n\\n        if (closeConditionsMap[_order.id].length > 0) {\\n            delete closeConditionsMap[_order.id];\\n        }\\n        Condition memory condition;\\n        for (uint256 i; i < closeConditions.length; i++) {\\n            condition = closeConditions[i];\\n            _require(\\n                IERC165Upgradeable(primexDNS.cmTypeToAddress(condition.managerType)).supportsInterface(\\n                    type(IConditionalClosingManager).interfaceId\\n                ),\\n                Errors.SHOULD_BE_CCM.selector\\n            );\\n            closeConditionsMap[_order.id].push(condition);\\n        }\\n    }\\n\\n    /**\\n     * @notice Creates a limit order.\\n     * @param _params The struct containing the order parameters.\\n     * @param pm The instance of the PositionManager contract.\\n     * @param traderBalanceVault The instance of the TraderBalanceVault contract.\\n     * @param primexDNS The instance of the PrimexDNS contract.\\n     * @return The created limit order.\\n     */\\n    function createLimitOrder(\\n        CreateLimitOrderParams calldata _params,\\n        IPositionManagerV2 pm,\\n        ITraderBalanceVault traderBalanceVault,\\n        IPrimexDNSV3 primexDNS\\n    ) public returns (LimitOrder memory) {\\n        _require(_params.leverage >= WadRayMath.WAD, Errors.INCORRECT_LEVERAGE.selector);\\n        _require(_params.deadline > block.timestamp, Errors.INCORRECT_DEADLINE.selector);\\n\\n        CreateLimitOrderVars memory vars;\\n        vars.isSpot = bytes(_params.bucket).length == 0;\\n        vars.positionSize = _params.depositAmount.wmul(_params.leverage);\\n        vars.priceOracle = address(pm.priceOracle());\\n        if (vars.isSpot) {\\n            _require(_params.leverage == WadRayMath.WAD, Errors.LEVERAGE_SHOULD_BE_1.selector);\\n            _require(_params.depositAsset != _params.positionAsset, Errors.SHOULD_BE_DIFFERENT_ASSETS_IN_SPOT.selector);\\n            vars.tradingOrderType = _params.shouldOpenPosition\\n                ? IPrimexDNSStorageV3.TradingOrderType.SpotLimitOrder\\n                : IPrimexDNSStorageV3.TradingOrderType.SwapLimitOrder;\\n        } else {\\n            _require(_params.shouldOpenPosition, Errors.SHOULD_OPEN_POSITION.selector);\\n            _require(_params.leverage > WadRayMath.WAD, Errors.LEVERAGE_MUST_BE_MORE_THAN_1.selector);\\n            vars.bucket = IBucketV3(primexDNS.getBucketAddress(_params.bucket));\\n            _require(vars.bucket.getLiquidityMiningParams().isBucketLaunched, Errors.BUCKET_IS_NOT_LAUNCHED.selector);\\n\\n            (, bool tokenAllowed) = vars.bucket.allowedAssets(_params.positionAsset);\\n            _require(tokenAllowed, Errors.TOKEN_NOT_SUPPORTED.selector);\\n            _require(\\n                _params.leverage <\\n                    vars.bucket.maxAssetLeverage(\\n                        _params.positionAsset,\\n                        primexDNS.getProtocolFeeRateByTier(IPrimexDNSStorageV3.FeeRateType.MarginLimitOrderExecuted, 0)\\n                    ),\\n                Errors.LEVERAGE_EXCEEDS_MAX_LEVERAGE.selector\\n            );\\n            vars.isThirdAsset =\\n                _params.depositAsset != address(vars.bucket.borrowedAsset()) &&\\n                _params.depositAsset != _params.positionAsset;\\n            vars.tradingOrderType = vars.isThirdAsset\\n                ? IPrimexDNSStorageV3.TradingOrderType.MarginLimitOrderDepositInThirdAsset\\n                : IPrimexDNSStorageV3.TradingOrderType.MarginLimitOrder;\\n        }\\n        LimitOrder memory order = LimitOrder({\\n            bucket: IBucketV3(address(0)),\\n            positionAsset: _params.positionAsset,\\n            depositAsset: _params.depositAsset,\\n            depositAmount: _params.depositAmount,\\n            feeToken: _params.isProtocolFeeInPmx ? primexDNS.pmx() : _params.positionAsset,\\n            protocolFee: 0,\\n            trader: msg.sender,\\n            deadline: _params.deadline,\\n            id: 0,\\n            leverage: _params.leverage,\\n            shouldOpenPosition: _params.shouldOpenPosition,\\n            createdAt: block.timestamp,\\n            updatedConditionsAt: block.timestamp,\\n            extraParams: \\\"\\\"\\n        });\\n        order.bucket = vars.bucket;\\n\\n        PrimexPricingLibrary.validateMinPositionSize(\\n            vars.positionSize,\\n            order.depositAsset,\\n            vars.priceOracle,\\n            pm.keeperRewardDistributor(),\\n            primexDNS,\\n            vars.tradingOrderType,\\n            _params.nativeDepositAssetOracleData\\n        );\\n\\n        // deposit locking\\n        depositLockOrUnlock(\\n            traderBalanceVault,\\n            order.depositAsset,\\n            order.depositAmount,\\n            _params.takeDepositFromWallet,\\n            true\\n        );\\n\\n        return order;\\n    }\\n\\n    /**\\n     * @notice Opens a position by order.\\n     * @param order The LimitOrder storage containing order details.\\n     * @param _params The OpenPositionParams calldata containing additional position parameters.\\n     * @param _closeConditions The Condition array containing close conditions for the position.\\n     * @param pm The instance of the PositionManager contract.\\n     * @param traderBalanceVault The instance of the TraderBalanceVault contract.\\n     * @param swapManager The instance of the SwapManager contract.\\n     * @return vars The OpenPositionByOrderVars struct containing the result of the open position operation.\\n     */\\n    function openPositionByOrder(\\n        LimitOrder storage order,\\n        OpenPositionParams calldata _params,\\n        Condition[] memory _closeConditions,\\n        IPositionManagerV2 pm,\\n        ITraderBalanceVault traderBalanceVault,\\n        ISwapManager swapManager,\\n        uint256 _initialGasLeft\\n    ) public returns (OpenPositionByOrderVars memory) {\\n        OpenPositionByOrderVars memory vars;\\n        bool isSpot = address(order.bucket) == address(0);\\n\\n        if (order.protocolFee != 0) {\\n            traderBalanceVault.unlockAsset(\\n                ITraderBalanceVault.UnlockAssetParams({\\n                    trader: order.trader,\\n                    receiver: order.trader,\\n                    asset: order.feeToken,\\n                    amount: order.protocolFee\\n                })\\n            );\\n            order.protocolFee = 0;\\n            order.feeToken = order.positionAsset;\\n        }\\n\\n        if (order.shouldOpenPosition) {\\n            vars.closeReason = isSpot ? CloseReason.FilledSpot : CloseReason.FilledMargin;\\n            (vars.amountIn, vars.amountOut, vars.newPositionId, vars.exchangeRate, vars.feeInPositionAsset) = pm\\n                .openPositionByOrder(\\n                    OpenPositionByOrderParams({\\n                        sender: msg.sender,\\n                        order: order,\\n                        closeConditions: _closeConditions,\\n                        firstAssetMegaRoutes: _params.firstAssetMegaRoutes,\\n                        depositInThirdAssetMegaRoutes: _params.depositInThirdAssetMegaRoutes,\\n                        firstAssetOracleData: _params.firstAssetOracleData,\\n                        thirdAssetOracleData: _params.thirdAssetOracleData,\\n                        depositSoldAssetOracleData: _params.depositSoldAssetOracleData,\\n                        positionUsdOracleData: _params.positionUsdOracleData,\\n                        nativePositionAssetOracleData: _params.nativePositionAssetOracleData,\\n                        pmxPositionAssetOracleData: _params.pmxPositionAssetOracleData,\\n                        nativeSoldAssetOracleData: _params.nativeSoldAssetOracleData,\\n                        borrowedAmount: _params.borrowedAmount\\n                    })\\n                );\\n        } else {\\n            _require(\\n                _params.depositInThirdAssetMegaRoutes.length == 0,\\n                Errors.DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0.selector\\n            );\\n            vars.closeReason = CloseReason.FilledSwap;\\n            vars.amountIn = order.depositAmount;\\n            traderBalanceVault.unlockAsset(\\n                ITraderBalanceVault.UnlockAssetParams({\\n                    trader: order.trader,\\n                    receiver: address(this),\\n                    asset: order.depositAsset,\\n                    amount: order.depositAmount\\n                })\\n            );\\n\\n            (vars.amountOut, vars.feeInPositionAsset) = swapManager.swapInLimitOrder(\\n                ISwapManager.SwapInLimitOrderParams({\\n                    depositAsset: order.depositAsset,\\n                    positionAsset: order.positionAsset,\\n                    depositAmount: order.depositAmount,\\n                    megaRoutes: _params.firstAssetMegaRoutes,\\n                    trader: order.trader,\\n                    deadline: order.deadline,\\n                    feeToken: order.feeToken,\\n                    keeperRewardDistributor: address(pm.keeperRewardDistributor()),\\n                    gasSpent: _initialGasLeft - gasleft(),\\n                    depositPositionAssetOracleData: _params.firstAssetOracleData,\\n                    pmxPositionAssetOracleData: _params.pmxPositionAssetOracleData,\\n                    nativePositionAssetOracleData: _params.nativePositionAssetOracleData\\n                }),\\n                pm.getOracleTolerableLimit(order.depositAsset, order.positionAsset)\\n            );\\n\\n            uint256 multiplierDepositAsset = 10 ** (18 - IERC20Metadata(order.depositAsset).decimals());\\n            uint256 multiplierPositionAsset = 10 ** (18 - IERC20Metadata(order.positionAsset).decimals());\\n            vars.exchangeRate =\\n                (vars.amountIn * multiplierDepositAsset).wdiv(\\n                    (vars.amountOut + vars.feeInPositionAsset) * multiplierPositionAsset\\n                ) /\\n                multiplierDepositAsset;\\n        }\\n\\n        vars.assetIn = isSpot ? order.depositAsset : address(order.bucket.borrowedAsset());\\n        vars.assetOut = order.positionAsset;\\n        return vars;\\n    }\\n\\n    /**\\n     * @notice Checks if an array of Condition structs has no duplicate manager types.\\n     * @param conditions The array of Condition structs to be checked.\\n     * @return bool Boolean value indicating whether the array has no duplicate manager types.\\n     */\\n    function hasNoConditionManagerTypeDuplicates(Condition[] memory conditions) public pure returns (bool) {\\n        if (conditions.length == 0) {\\n            return true;\\n        }\\n        for (uint256 i; i < conditions.length - 1; i++) {\\n            for (uint256 j = i + 1; j < conditions.length; j++) {\\n                if (conditions[i].managerType == conditions[j].managerType) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice This function is used to either deposit or unlock assets in the trader balance vault.\\n     * @param traderBalanceVault The instance of the trader balance vault.\\n     * @param _depositAsset The address of the asset to be deposited or unlocked.\\n     * @param _amount The amount of the asset to be deposited or unlocked.\\n     * @param _takeDepositFromWallet Boolean indicating whether to make a deposit or not.\\n     * @param _isAdd Boolean indicating whether to lock or unlock asset. Should lock asset, if true.\\n     */\\n    function depositLockOrUnlock(\\n        ITraderBalanceVault traderBalanceVault,\\n        address _depositAsset,\\n        uint256 _amount,\\n        bool _takeDepositFromWallet,\\n        bool _isAdd\\n    ) internal {\\n        if (!_isAdd) {\\n            traderBalanceVault.unlockAsset(\\n                ITraderBalanceVault.UnlockAssetParams(msg.sender, msg.sender, _depositAsset, _amount)\\n            );\\n            return;\\n        }\\n        if (_takeDepositFromWallet) {\\n            if (_depositAsset == NATIVE_CURRENCY) {\\n                _require(msg.value >= _amount, Errors.INSUFFICIENT_DEPOSIT.selector);\\n                traderBalanceVault.increaseLockedBalance{value: _amount}(msg.sender, _depositAsset, _amount);\\n                if (msg.value > _amount) {\\n                    uint256 rest = msg.value - _amount;\\n                    traderBalanceVault.topUpAvailableBalance{value: rest}(msg.sender, NATIVE_CURRENCY, rest);\\n                }\\n                return;\\n            }\\n            TokenTransfersLibrary.doTransferFromTo(_depositAsset, msg.sender, address(traderBalanceVault), _amount);\\n            traderBalanceVault.increaseLockedBalance(msg.sender, _depositAsset, _amount);\\n            return;\\n        }\\n        traderBalanceVault.useTraderAssets(\\n            ITraderBalanceVault.LockAssetParams(\\n                msg.sender,\\n                address(0),\\n                _depositAsset,\\n                _amount,\\n                ITraderBalanceVault.OpenType.CREATE_LIMIT_ORDER\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x5dd250e91ba2a26d813ebd44c817278a478c380aafc577aa25d29089fab5b196\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/PositionLibrary.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.26;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport {WadRayMath} from \\\"./utils/WadRayMath.sol\\\";\\n\\nimport {PrimexPricingLibrary} from \\\"./PrimexPricingLibrary.sol\\\";\\nimport {TokenTransfersLibrary} from \\\"./TokenTransfersLibrary.sol\\\";\\nimport {LimitOrderLibrary} from \\\"./LimitOrderLibrary.sol\\\";\\nimport \\\"./Errors.sol\\\";\\n\\nimport {NATIVE_CURRENCY} from \\\"../Constants.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IPrimexDNSV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IPrimexDNSStorageV3} from \\\"../PrimexDNS/IPrimexDNSStorage.sol\\\";\\nimport {IPriceOracleV2} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IConditionalClosingManager} from \\\"../interfaces/IConditionalClosingManager.sol\\\";\\nimport {ITakeProfitStopLossCCM} from \\\"../interfaces/ITakeProfitStopLossCCM.sol\\\";\\nimport {IKeeperRewardDistributorStorage, IKeeperRewardDistributorV3} from \\\"../KeeperRewardDistributor/IKeeperRewardDistributor.sol\\\";\\nimport {ITiersManager} from \\\"../TiersManager/ITiersManager.sol\\\";\\n\\nlibrary PositionLibrary {\\n    using WadRayMath for uint256;\\n\\n    event ClosePosition(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        address indexed closedBy,\\n        address bucketAddress,\\n        address soldAsset,\\n        address positionAsset,\\n        uint256 decreasePositionAmount,\\n        int256 profit,\\n        uint256 positionDebt,\\n        uint256 amountOut,\\n        PositionLibrary.CloseReason reason\\n    );\\n\\n    event PaidProtocolFee(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        address paymentAsset,\\n        IPrimexDNSStorageV3.FeeRateType indexed feeRateType,\\n        uint256 feeInPaymentAsset,\\n        uint256 feeInPmx\\n    );\\n\\n    /**\\n     * @notice This struct represents a trading position\\n     * @param id unique identifier for the position\\n     * @param scaledDebtAmount scaled debt amount associated with the position\\n     * @param bucket instance of the Bucket associated for trading\\n     * @param soldAsset bucket asset in the case of margin trading or deposit asset in the case of spot trading\\n     * @param depositAmountInSoldAsset equivalent of trader deposit size (this deposit can be in any asset) in the sold asset\\n     * or just deposit amount for spot trading\\n     * @param positionAsset asset of the trading position\\n     * @param positionAmount amount of the trading position\\n     * @param trader address of the trader holding the position\\n     * @param openBorrowIndex variable borrow index when position was opened\\n     * @param createdAt timestamp when the position was created\\n     * @param updatedConditionsAt timestamp when the close condition was updated\\n     * @param extraParams byte-encoded params, utilized for the feeToken address\\n     */\\n    struct Position {\\n        uint256 id;\\n        uint256 scaledDebtAmount;\\n        IBucketV3 bucket;\\n        address soldAsset;\\n        uint256 depositAmountInSoldAsset;\\n        address positionAsset;\\n        uint256 positionAmount;\\n        address trader;\\n        uint256 openBorrowIndex;\\n        uint256 createdAt;\\n        uint256 updatedConditionsAt;\\n        bytes extraParams;\\n    }\\n\\n    struct IncreaseDepositParams {\\n        uint256 amount;\\n        address asset;\\n        bool takeDepositFromWallet;\\n        PrimexPricingLibrary.MegaRoute[] megaRoutes;\\n        IPrimexDNSV3 primexDNS;\\n        IPriceOracleV2 priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n        uint256 amountOutMin;\\n    }\\n\\n    struct DecreaseDepositParams {\\n        uint256 amount;\\n        IPrimexDNSV3 primexDNS;\\n        IPriceOracleV2 priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n        uint256 pairPriceDrop;\\n        uint256 securityBuffer;\\n        uint256 oracleTolerableLimit;\\n        uint256 maintenanceBuffer;\\n        address keeperRewardDistributor;\\n        bytes positionSoldAssetOracleData;\\n        bytes nativeSoldAssetOracleData;\\n    }\\n\\n    struct MegaSwapParams {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amountTokenA;\\n        PrimexPricingLibrary.MegaRoute[] megaRoutes;\\n        address receiver;\\n        uint256 deadline;\\n        bool takeDepositFromWallet;\\n        IPrimexDNSV3 primexDNS;\\n        IPriceOracleV2 priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n    }\\n\\n    struct ClosePositionParams {\\n        uint256 closeAmount;\\n        uint256 depositDecrease;\\n        uint256 scaledDebtAmount;\\n        address depositReceiver;\\n        PrimexPricingLibrary.MegaRoute[] megaRoutes;\\n        uint256 amountOutMin;\\n        uint256 oracleTolerableLimit;\\n        IPrimexDNSV3 primexDNS;\\n        IPriceOracleV2 priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n        LimitOrderLibrary.Condition closeCondition;\\n        bytes ccmAdditionalParams;\\n        bool borrowedAmountIsNotZero;\\n        uint256 pairPriceDrop;\\n        uint256 securityBuffer;\\n        bool needOracleTolerableLimitCheck;\\n        uint256 initialGasLeft;\\n        address keeperRewardDistributor;\\n        bytes positionSoldAssetOracleData;\\n        bytes pmxSoldAssetOracleData;\\n        bytes nativeSoldAssetOracleData;\\n    }\\n\\n    struct ClosePositionVars {\\n        address payable dexAdapter;\\n        uint256 borowedAssetAmount;\\n        uint256 amountToReturn;\\n        uint256 permanentLoss;\\n        uint256 fee;\\n        uint256 gasSpent;\\n    }\\n\\n    struct ClosePositionEventData {\\n        int256 profit;\\n        uint256 debtAmount;\\n        uint256 amountOut;\\n        uint256 amountOutAfterFee;\\n        IKeeperRewardDistributorStorage.KeeperActionType actionType;\\n        address trader;\\n        address paymentAsset;\\n        IPrimexDNSStorageV3.FeeRateType feeRateType;\\n        uint256 feeInPaymentAsset;\\n        uint256 feeInPmx;\\n    }\\n\\n    struct OpenPositionVars {\\n        PrimexPricingLibrary.MegaRoute[] firstAssetMegaRoutes;\\n        PrimexPricingLibrary.MegaRoute[] depositInThirdAssetMegaRoutes;\\n        PrimexPricingLibrary.DepositData depositData;\\n        uint256 borrowedAmount;\\n        uint256 amountOutMin;\\n        uint256 deadline;\\n        bool isSpot;\\n        bool isThirdAsset;\\n        bool takeDepositFromWallet;\\n        bool byOrder;\\n        uint256 orderLeverage;\\n        address sender;\\n        LimitOrderLibrary.Condition[] closeConditions;\\n        bool needOracleTolerableLimitCheck;\\n        bytes firstAssetOracleData;\\n        bytes thirdAssetOracleData;\\n        bytes positionUsdOracleData;\\n        bytes nativePositionAssetOracleData;\\n        bytes pmxPositionAssetOracleData;\\n        bytes nativeSoldAssetOracleData;\\n    }\\n\\n    struct OpenPositionEventData {\\n        uint256 feeInPositionAsset;\\n        uint256 feeInPmx;\\n        uint256 entryPrice;\\n        uint256 leverage;\\n        IPrimexDNSStorageV3.FeeRateType feeRateType;\\n    }\\n\\n    /**\\n     * The struct for openPosition function local vars\\n     */\\n    struct OpenPositionLocalData {\\n        uint256 amountToTransfer;\\n        address payable dexAdapter;\\n        address depositReceiver;\\n        uint256 depositInPositionAsset;\\n        bool isSpot;\\n        IPrimexDNSStorageV3.TradingOrderType tradingOrderType;\\n        uint256 positionAmountAfterFeeInSoldAsset;\\n        uint256 borrowedAmountInPositionAsset;\\n        uint256 leverage;\\n        uint256 multiplierBorrowedAsset;\\n        uint256 multiplierPositionAsset;\\n        address positionAsset;\\n        uint256 positionAmount;\\n    }\\n\\n    /**\\n     * @dev Structure for the OpenPositionParams when margin trading is activated\\n     * @param bucket The bucket, from which the loan will be taken\\n     * @param borrowedAmount The amount of tokens borrowed to be exchanged\\n     * @param depositInThirdAssetMegaRoutes routes to swap deposit in third asset on dex\\n     */\\n    struct OpenPositionMarginParams {\\n        string bucket;\\n        uint256 borrowedAmount;\\n        PrimexPricingLibrary.MegaRoute[] depositInThirdAssetMegaRoutes;\\n    }\\n\\n    /**\\n     * @dev Structure for the openPosition with parameters necessary to open a position\\n     * @param marginParams margin trading related params\\n     * @param firstAssetMegaRoutes routes to swap first asset on dex\\n     * (borrowedAmount + depositAmount if deposit in borrowedAsset)\\n     * @param depositAsset The address of the deposit token (collateral for margin trade or\\n     * locked funds for spot)\\n     * @param depositAmount The amount of deposit funds for deal\\n     * @param positionAsset The address output token for exchange\\n     * @param amountOutMin The minimum amount of output tokens\\n     * that must be received for the transaction not to revert.\\n     * @param deadline Unix timestamp after which the transaction will revert.\\n     * @param takeDepositFromWallet Bool, add a deposit within the current transaction\\n     * @param closeConditions Array of conditions that position can be closed by\\n     */\\n    struct OpenPositionParams {\\n        OpenPositionMarginParams marginParams;\\n        PrimexPricingLibrary.MegaRoute[] firstAssetMegaRoutes;\\n        address depositAsset;\\n        uint256 depositAmount;\\n        address positionAsset;\\n        uint256 amountOutMin;\\n        uint256 deadline;\\n        bool takeDepositFromWallet;\\n        bool isProtocolFeeInPmx;\\n        LimitOrderLibrary.Condition[] closeConditions;\\n        bytes firstAssetOracleData;\\n        bytes thirdAssetOracleData;\\n        bytes depositSoldAssetOracleData;\\n        bytes positionUsdOracleData;\\n        bytes nativePositionAssetOracleData;\\n        bytes pmxPositionAssetOracleData;\\n        bytes nativeSoldAssetOracleData;\\n        bytes[][] pullOracleData;\\n        uint256[] pullOracleTypes;\\n    }\\n    struct PositionManagerParams {\\n        IPrimexDNSV3 primexDNS;\\n        IPriceOracleV2 priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n        uint256 oracleTolerableLimit;\\n        uint256 oracleTolerableLimitForThirdAsset;\\n        uint256 maxPositionSize;\\n        uint256 initialGasLeft;\\n        address keeperRewardDistributor;\\n    }\\n\\n    struct ScaledParams {\\n        uint256 decreasePercent;\\n        uint256 scaledDebtAmount;\\n        uint256 depositDecrease;\\n        bool borrowedAmountIsNotZero;\\n    }\\n\\n    enum CloseReason {\\n        CLOSE_BY_TRADER,\\n        RISKY_POSITION,\\n        BUCKET_DELISTED,\\n        LIMIT_CONDITION,\\n        BATCH_LIQUIDATION,\\n        BATCH_STOP_LOSS,\\n        BATCH_TAKE_PROFIT\\n    }\\n\\n    /**\\n     * @dev Increases the deposit amount for a position.\\n     * @param position The storage reference to the position.\\n     * @param params The parameters for increasing the deposit.\\n     * @return The amount of trader debtTokens burned.\\n     */\\n    function increaseDeposit(Position storage position, IncreaseDepositParams memory params) public returns (uint256) {\\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\\n        _require(position.scaledDebtAmount != 0, Errors.BORROWED_AMOUNT_IS_ZERO.selector);\\n        address borrowedAsset = position.soldAsset;\\n\\n        uint256 depositAmountInBorrowed;\\n        address depositReceiver = params.primexDNS.dexAdapter();\\n        if (params.asset == borrowedAsset) {\\n            depositReceiver = address(position.bucket);\\n            depositAmountInBorrowed = params.amount;\\n        }\\n\\n        if (params.takeDepositFromWallet) {\\n            TokenTransfersLibrary.doTransferFromTo(params.asset, msg.sender, depositReceiver, params.amount);\\n        } else {\\n            params.traderBalanceVault.useTraderAssets(\\n                ITraderBalanceVault.LockAssetParams(\\n                    msg.sender,\\n                    depositReceiver,\\n                    params.asset,\\n                    params.amount,\\n                    ITraderBalanceVault.OpenType.OPEN\\n                )\\n            );\\n        }\\n\\n        if (params.asset != borrowedAsset) {\\n            depositAmountInBorrowed = PrimexPricingLibrary.megaSwap(\\n                PrimexPricingLibrary.MegaSwapParams({\\n                    tokenA: params.asset,\\n                    tokenB: borrowedAsset,\\n                    amountTokenA: params.amount,\\n                    megaRoutes: params.megaRoutes,\\n                    receiver: address(position.bucket),\\n                    deadline: block.timestamp\\n                }),\\n                0,\\n                payable(params.primexDNS.dexAdapter()),\\n                address(params.priceOracle),\\n                false,\\n                new bytes(0)\\n            );\\n            _require(depositAmountInBorrowed >= params.amountOutMin, Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector);\\n        }\\n\\n        uint256 debt = getDebt(position);\\n        uint256 amountToTrader;\\n        uint256 debtToBurn = depositAmountInBorrowed;\\n\\n        if (depositAmountInBorrowed >= debt) {\\n            amountToTrader = depositAmountInBorrowed - debt;\\n            debtToBurn = debt;\\n            position.scaledDebtAmount = 0;\\n            if (amountToTrader > 0)\\n                params.traderBalanceVault.topUpAvailableBalance(position.trader, borrowedAsset, amountToTrader);\\n        } else {\\n            position.scaledDebtAmount =\\n                position.scaledDebtAmount -\\n                debtToBurn.rdiv(position.bucket.getNormalizedVariableDebt());\\n        }\\n\\n        position.depositAmountInSoldAsset += debtToBurn;\\n\\n        position.bucket.decreaseTraderDebt(\\n            position.trader,\\n            debtToBurn,\\n            address(params.traderBalanceVault),\\n            amountToTrader,\\n            0\\n        );\\n        return debtToBurn;\\n    }\\n\\n    /**\\n     * @dev Decreases the deposit amount for a position.\\n     * @param position The storage reference to the position.\\n     * @param params The parameters for the decrease deposit operation.\\n     */\\n    function decreaseDeposit(Position storage position, DecreaseDepositParams memory params) public {\\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\\n        _require(position.bucket != IBucketV3(address(0)), Errors.IS_SPOT_POSITION.selector);\\n        _require(position.bucket.isActive(), Errors.BUCKET_IS_NOT_ACTIVE.selector);\\n        _require(params.amount > 0, Errors.DECREASE_AMOUNT_IS_ZERO.selector);\\n        _require(params.amount <= position.depositAmountInSoldAsset, Errors.AMOUNT_IS_MORE_THAN_DEPOSIT.selector);\\n        position.depositAmountInSoldAsset -= params.amount;\\n        position.scaledDebtAmount =\\n            position.scaledDebtAmount +\\n            params.amount.rdiv(position.bucket.getNormalizedVariableDebt());\\n\\n        params.traderBalanceVault.topUpAvailableBalance(position.trader, position.soldAsset, params.amount);\\n\\n        uint256 feeInPaymentAsset;\\n        if (decodeFeeTokenAddress(position.extraParams) == address(0)) {\\n            feeInPaymentAsset = 0;\\n        } else {\\n            (, , address tierManager, uint256 maxProtocolFee, ) = params.primexDNS.getPrimexDNSParams();\\n            feeInPaymentAsset = PrimexPricingLibrary.calculateFeeInPaymentAsset(\\n                PrimexPricingLibrary.CalculateFeeInPaymentAssetParams({\\n                    primexDNS: params.primexDNS,\\n                    priceOracle: address(params.priceOracle),\\n                    feeRateType: IPrimexDNSStorageV3.FeeRateType.MarginPositionClosedByKeeper,\\n                    paymentAsset: position.soldAsset,\\n                    paymentAmount: params.amount,\\n                    keeperRewardDistributor: params.keeperRewardDistributor,\\n                    gasSpent: 0,\\n                    isFeeProhibitedInPmx: true,\\n                    nativePaymentAssetOracleData: params.nativeSoldAssetOracleData,\\n                    tierManager: ITiersManager(tierManager),\\n                    maxProtocolFee: maxProtocolFee,\\n                    trader: position.trader\\n                })\\n            );\\n        }\\n        _require(\\n            health(\\n                position,\\n                params.priceOracle,\\n                params.pairPriceDrop,\\n                params.securityBuffer,\\n                params.oracleTolerableLimit,\\n                feeInPaymentAsset,\\n                params.positionSoldAssetOracleData\\n            ) >= WadRayMath.WAD + params.maintenanceBuffer,\\n            Errors.INSUFFICIENT_DEPOSIT_SIZE.selector\\n        );\\n        position.bucket.increaseDebt(position.trader, params.amount, address(params.traderBalanceVault));\\n    }\\n\\n    /**\\n     * @notice Closes a position.\\n     * @param position The position to be closed.\\n     * @param params The parameters for closing the position.\\n     * @param reason The reason for closing the position.\\n     * @return posEventData The event data for the closed position.\\n     */\\n    function closePosition(\\n        Position memory position,\\n        ClosePositionParams memory params,\\n        CloseReason reason\\n    ) public returns (ClosePositionEventData memory) {\\n        ClosePositionEventData memory posEventData;\\n        ClosePositionVars memory vars;\\n\\n        if (params.borrowedAmountIsNotZero) {\\n            posEventData.debtAmount = params.scaledDebtAmount.rmul(position.bucket.getNormalizedVariableDebt());\\n        }\\n\\n        vars.dexAdapter = payable(params.primexDNS.dexAdapter());\\n\\n        TokenTransfersLibrary.doTransferOut(position.positionAsset, vars.dexAdapter, params.closeAmount);\\n        posEventData.amountOut = PrimexPricingLibrary.megaSwap(\\n            PrimexPricingLibrary.MegaSwapParams({\\n                tokenA: position.positionAsset,\\n                tokenB: position.soldAsset,\\n                amountTokenA: params.closeAmount,\\n                megaRoutes: params.megaRoutes,\\n                receiver: address(this),\\n                deadline: block.timestamp\\n            }),\\n            params.oracleTolerableLimit,\\n            vars.dexAdapter,\\n            address(params.priceOracle),\\n            params.needOracleTolerableLimitCheck,\\n            params.positionSoldAssetOracleData\\n        );\\n\\n        posEventData.paymentAsset = decodeFeeTokenAddress(position.extraParams);\\n\\n        if (reason == CloseReason.CLOSE_BY_TRADER) {\\n            posEventData.feeRateType = params.borrowedAmountIsNotZero\\n                ? IPrimexDNSStorageV3.FeeRateType.MarginPositionClosedByTrader\\n                : IPrimexDNSStorageV3.FeeRateType.SpotPositionClosedByTrader;\\n            vars.gasSpent = 0;\\n        } else {\\n            posEventData.feeRateType = params.borrowedAmountIsNotZero\\n                ? IPrimexDNSStorageV3.FeeRateType.MarginPositionClosedByKeeper\\n                : IPrimexDNSStorageV3.FeeRateType.SpotPositionClosedByKeeper;\\n            vars.gasSpent = params.initialGasLeft - gasleft();\\n        }\\n\\n        (posEventData.feeInPaymentAsset, posEventData.feeInPmx) = PrimexPricingLibrary.payProtocolFee(\\n            PrimexPricingLibrary.ProtocolFeeParams({\\n                feeToken: posEventData.paymentAsset,\\n                trader: position.trader,\\n                priceOracle: address(params.priceOracle),\\n                feeRateType: posEventData.feeRateType,\\n                traderBalanceVault: params.traderBalanceVault,\\n                swapManager: address(0),\\n                keeperRewardDistributor: params.keeperRewardDistributor,\\n                primexDNS: params.primexDNS,\\n                paymentAsset: position.soldAsset,\\n                paymentAmount: posEventData.amountOut,\\n                gasSpent: vars.gasSpent,\\n                isFeeProhibitedInPmx: reason == CloseReason.RISKY_POSITION,\\n                pmxPaymentAssetOracleData: params.pmxSoldAssetOracleData,\\n                nativePaymentAssetOracleData: params.nativeSoldAssetOracleData\\n            })\\n        );\\n\\n        posEventData.amountOutAfterFee = posEventData.amountOut - posEventData.feeInPaymentAsset;\\n\\n        TokenTransfersLibrary.doTransferOut({\\n            token: position.soldAsset,\\n            to: params.borrowedAmountIsNotZero ? address(position.bucket) : address(params.traderBalanceVault),\\n            amount: posEventData.amountOutAfterFee\\n        });\\n\\n        _require(\\n            posEventData.amountOut >= params.amountOutMin && posEventData.amountOut > 0,\\n            Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector\\n        );\\n\\n        bool canBeClosed;\\n        if (reason == CloseReason.CLOSE_BY_TRADER) {\\n            canBeClosed = position.trader == msg.sender;\\n        } else if (reason == CloseReason.RISKY_POSITION) {\\n            canBeClosed =\\n                health(\\n                    position,\\n                    params.priceOracle,\\n                    params.pairPriceDrop,\\n                    params.securityBuffer,\\n                    params.oracleTolerableLimit,\\n                    posEventData.feeInPaymentAsset,\\n                    params.positionSoldAssetOracleData\\n                ) <\\n                WadRayMath.WAD;\\n            posEventData.actionType = IKeeperRewardDistributorStorage.KeeperActionType.Liquidation;\\n        } else if (reason == CloseReason.LIMIT_CONDITION) {\\n            address cm = params.primexDNS.cmTypeToAddress(params.closeCondition.managerType);\\n            _require(cm != address(0), Errors.INCORRECT_CM_TYPE.selector);\\n\\n            canBeClosed = IConditionalClosingManager(cm).canBeClosedAfterSwap(\\n                position,\\n                params.closeCondition.params,\\n                params.ccmAdditionalParams,\\n                params.closeAmount,\\n                posEventData.amountOut,\\n                params.positionSoldAssetOracleData\\n            );\\n            posEventData.actionType = IKeeperRewardDistributorStorage.KeeperActionType.StopLoss;\\n        } else if (reason == CloseReason.BUCKET_DELISTED) {\\n            canBeClosed = position.bucket != IBucketV3(address(0)) && position.bucket.isDelisted();\\n            posEventData.actionType = IKeeperRewardDistributorStorage.KeeperActionType.BucketDelisted;\\n        }\\n        _require(canBeClosed, Errors.POSITION_CANNOT_BE_CLOSED_FOR_THIS_REASON.selector);\\n\\n        if (posEventData.amountOutAfterFee > posEventData.debtAmount) {\\n            unchecked {\\n                vars.amountToReturn = posEventData.amountOutAfterFee - posEventData.debtAmount;\\n            }\\n        } else {\\n            unchecked {\\n                vars.permanentLoss = posEventData.debtAmount - posEventData.amountOutAfterFee;\\n            }\\n        }\\n\\n        posEventData.profit = -int256(params.depositDecrease);\\n\\n        if (reason != CloseReason.RISKY_POSITION) {\\n            if (vars.amountToReturn > 0) {\\n                posEventData.profit += int256(vars.amountToReturn);\\n                params.traderBalanceVault.topUpAvailableBalance(\\n                    reason == CloseReason.CLOSE_BY_TRADER ? params.depositReceiver : position.trader,\\n                    position.soldAsset,\\n                    vars.amountToReturn\\n                );\\n            }\\n        }\\n\\n        if (params.borrowedAmountIsNotZero) {\\n            position.bucket.decreaseTraderDebt(\\n                position.trader,\\n                posEventData.debtAmount,\\n                reason == CloseReason.RISKY_POSITION ? params.primexDNS.treasury() : address(params.traderBalanceVault),\\n                vars.amountToReturn,\\n                vars.permanentLoss\\n            );\\n        }\\n\\n        // to avoid stack to deep\\n        CloseReason _reason = reason;\\n        if (params.closeAmount == position.positionAmount) {\\n            emit ClosePosition({\\n                positionId: position.id,\\n                trader: position.trader,\\n                closedBy: msg.sender,\\n                bucketAddress: address(position.bucket),\\n                soldAsset: position.soldAsset,\\n                positionAsset: position.positionAsset,\\n                decreasePositionAmount: position.positionAmount,\\n                profit: posEventData.profit,\\n                positionDebt: posEventData.debtAmount,\\n                amountOut: posEventData.amountOutAfterFee,\\n                reason: _reason\\n            });\\n        }\\n        posEventData.trader = position.trader;\\n        return posEventData;\\n    }\\n\\n    /**\\n     * @dev Sets the close conditions for a given position.\\n     * @param position The position for which to set the close conditions.\\n     * @param closeConditionsMap The storage mapping of close conditions for each position ID.\\n     * @param closeConditions The array of close conditions to be set.\\n     * @param primexDNS The address of the IPrimexDNS contract.\\n     */\\n    function setCloseConditions(\\n        Position memory position,\\n        mapping(uint256 => LimitOrderLibrary.Condition[]) storage closeConditionsMap,\\n        LimitOrderLibrary.Condition[] memory closeConditions,\\n        IPrimexDNSV3 primexDNS\\n    ) public {\\n        _require(\\n            LimitOrderLibrary.hasNoConditionManagerTypeDuplicates(closeConditions),\\n            Errors.SHOULD_NOT_HAVE_DUPLICATES.selector\\n        );\\n        if (closeConditionsMap[position.id].length > 0) {\\n            delete closeConditionsMap[position.id];\\n        }\\n        LimitOrderLibrary.Condition memory condition;\\n        for (uint256 i; i < closeConditions.length; i++) {\\n            condition = closeConditions[i];\\n            _require(\\n                IERC165Upgradeable(primexDNS.cmTypeToAddress(condition.managerType)).supportsInterface(\\n                    type(IConditionalClosingManager).interfaceId\\n                ),\\n                Errors.SHOULD_BE_CCM.selector\\n            );\\n\\n            closeConditionsMap[position.id].push(condition);\\n        }\\n    }\\n\\n    /**\\n     * @notice Opens a position by depositing assets and borrowing funds (except when the position is spot)\\n     * @param _position The position to be opened\\n     * @param _vars Variables related to the position opening\\n     * @param _pmParams Parameters for the PositionManager contract\\n     * @return The updated position and event data\\n     */\\n    function openPosition(\\n        Position memory _position,\\n        OpenPositionVars memory _vars,\\n        PositionManagerParams memory _pmParams\\n    ) public returns (Position memory, OpenPositionEventData memory) {\\n        OpenPositionLocalData memory data;\\n        if (_vars.isSpot) {\\n            data.tradingOrderType = _vars.byOrder\\n                ? IPrimexDNSStorageV3.TradingOrderType.SpotLimitOrder\\n                : IPrimexDNSStorageV3.TradingOrderType.SpotMarketOrder;\\n        } else {\\n            if (_vars.byOrder) {\\n                data.tradingOrderType = _vars.isThirdAsset\\n                    ? IPrimexDNSStorageV3.TradingOrderType.MarginLimitOrderDepositInThirdAsset\\n                    : IPrimexDNSStorageV3.TradingOrderType.MarginLimitOrder;\\n            } else {\\n                data.tradingOrderType = IPrimexDNSStorageV3.TradingOrderType.MarginMarketOrder;\\n            }\\n        }\\n        PrimexPricingLibrary.validateMinPositionSize(\\n            _vars.borrowedAmount + _position.depositAmountInSoldAsset,\\n            _position.soldAsset,\\n            address(_pmParams.priceOracle),\\n            IKeeperRewardDistributorV3(_pmParams.keeperRewardDistributor),\\n            _pmParams.primexDNS,\\n            data.tradingOrderType,\\n            _vars.nativeSoldAssetOracleData\\n        );\\n        data.amountToTransfer = _vars.borrowedAmount;\\n        data.dexAdapter = payable(_pmParams.primexDNS.dexAdapter());\\n        data.depositReceiver = data.dexAdapter;\\n        if (_vars.depositData.depositAsset == _position.positionAsset) {\\n            _position.positionAmount = _vars.depositData.depositAmount;\\n            data.depositInPositionAsset = _vars.depositData.depositAmount;\\n            data.depositReceiver = address(this);\\n        } else if (_vars.depositData.depositAsset == _position.soldAsset) {\\n            data.amountToTransfer += _vars.depositData.depositAmount;\\n        }\\n\\n        data.isSpot = _vars.borrowedAmount == 0;\\n        if (data.isSpot) _vars.depositData.depositAsset = _position.soldAsset;\\n\\n        if (_vars.takeDepositFromWallet) {\\n            TokenTransfersLibrary.doTransferFromTo(\\n                _vars.depositData.depositAsset,\\n                msg.sender,\\n                data.depositReceiver,\\n                _vars.depositData.depositAmount\\n            );\\n        } else {\\n            _pmParams.traderBalanceVault.useTraderAssets(\\n                ITraderBalanceVault.LockAssetParams({\\n                    trader: _position.trader,\\n                    depositReceiver: data.depositReceiver,\\n                    depositAsset: _vars.depositData.depositAsset,\\n                    depositAmount: _vars.depositData.depositAmount,\\n                    openType: _vars.byOrder\\n                        ? ITraderBalanceVault.OpenType.OPEN_BY_ORDER\\n                        : ITraderBalanceVault.OpenType.OPEN\\n                })\\n            );\\n        }\\n\\n        if (!data.isSpot) {\\n            _position.bucket.increaseDebt(_position.trader, _vars.borrowedAmount, data.dexAdapter);\\n            // @note You need to write index only after opening a position in bucket.\\n            // Since when opening position in the bucket, index becomes relevant (containing accumulated profit)\\n            _position.openBorrowIndex = _position.bucket.variableBorrowIndex();\\n            _position.scaledDebtAmount = _vars.borrowedAmount.rdiv(_position.openBorrowIndex);\\n        }\\n        if (_vars.isThirdAsset) {\\n            data.depositInPositionAsset = PrimexPricingLibrary.megaSwap(\\n                PrimexPricingLibrary.MegaSwapParams({\\n                    tokenA: _vars.depositData.depositAsset,\\n                    tokenB: _position.positionAsset,\\n                    amountTokenA: _vars.depositData.depositAmount,\\n                    megaRoutes: _vars.depositInThirdAssetMegaRoutes,\\n                    receiver: address(this),\\n                    deadline: _vars.deadline\\n                }),\\n                _pmParams.oracleTolerableLimitForThirdAsset,\\n                data.dexAdapter,\\n                address(_pmParams.priceOracle),\\n                true,\\n                _vars.thirdAssetOracleData\\n            );\\n            _position.positionAmount += data.depositInPositionAsset;\\n        } else {\\n            _require(\\n                _vars.depositInThirdAssetMegaRoutes.length == 0,\\n                Errors.DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0.selector\\n            );\\n        }\\n\\n        data.borrowedAmountInPositionAsset = PrimexPricingLibrary.megaSwap(\\n            PrimexPricingLibrary.MegaSwapParams({\\n                tokenA: _position.soldAsset,\\n                tokenB: _position.positionAsset,\\n                amountTokenA: data.isSpot ? _vars.depositData.depositAmount : data.amountToTransfer,\\n                megaRoutes: _vars.firstAssetMegaRoutes,\\n                receiver: address(this),\\n                deadline: _vars.deadline\\n            }),\\n            _pmParams.oracleTolerableLimit,\\n            data.dexAdapter,\\n            address(_pmParams.priceOracle),\\n            _vars.needOracleTolerableLimitCheck,\\n            _vars.firstAssetOracleData\\n        );\\n        _position.positionAmount += data.borrowedAmountInPositionAsset;\\n\\n        OpenPositionEventData memory posEventData;\\n\\n        if (_vars.byOrder) {\\n            posEventData.feeRateType = data.isSpot\\n                ? IPrimexDNSStorageV3.FeeRateType.SpotLimitOrderExecuted\\n                : IPrimexDNSStorageV3.FeeRateType.MarginLimitOrderExecuted;\\n            (posEventData.feeInPositionAsset, posEventData.feeInPmx) = PrimexPricingLibrary.payProtocolFee(\\n                PrimexPricingLibrary.ProtocolFeeParams({\\n                    feeToken: decodeFeeTokenAddress(_position.extraParams),\\n                    trader: _position.trader,\\n                    priceOracle: address(_pmParams.priceOracle),\\n                    feeRateType: posEventData.feeRateType,\\n                    traderBalanceVault: _pmParams.traderBalanceVault,\\n                    swapManager: address(0),\\n                    keeperRewardDistributor: _pmParams.keeperRewardDistributor,\\n                    primexDNS: _pmParams.primexDNS,\\n                    paymentAsset: _position.positionAsset,\\n                    paymentAmount: _position.positionAmount,\\n                    gasSpent: _pmParams.initialGasLeft - gasleft(),\\n                    isFeeProhibitedInPmx: false,\\n                    pmxPaymentAssetOracleData: _vars.pmxPositionAssetOracleData,\\n                    nativePaymentAssetOracleData: _vars.nativePositionAssetOracleData\\n                })\\n            );\\n            _position.positionAmount -= posEventData.feeInPositionAsset;\\n        }\\n        _require(_position.positionAmount >= _vars.amountOutMin, Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector);\\n\\n        data.leverage = WadRayMath.WAD;\\n        if (!data.isSpot) {\\n            _require(_pmParams.maxPositionSize >= _position.positionAmount, Errors.POSITION_SIZE_EXCEEDED.selector);\\n            if (_vars.depositData.depositAsset == _position.soldAsset) {\\n                data.positionAmountAfterFeeInSoldAsset =\\n                    (data.amountToTransfer * _position.positionAmount) /\\n                    (_position.positionAmount + posEventData.feeInPositionAsset);\\n                _require(\\n                    data.positionAmountAfterFeeInSoldAsset > _vars.borrowedAmount,\\n                    Errors.INSUFFICIENT_DEPOSIT.selector\\n                );\\n                data.leverage = data.positionAmountAfterFeeInSoldAsset.wdiv(\\n                    data.positionAmountAfterFeeInSoldAsset - _vars.borrowedAmount\\n                );\\n            } else {\\n                _require(\\n                    data.depositInPositionAsset > posEventData.feeInPositionAsset,\\n                    Errors.INSUFFICIENT_DEPOSIT.selector\\n                );\\n                data.leverage = _position.positionAmount.wdiv(\\n                    data.depositInPositionAsset - posEventData.feeInPositionAsset\\n                );\\n            }\\n\\n            // to avoid stack to deep\\n            data.positionAsset = _position.positionAsset;\\n            data.positionAmount = _position.positionAmount;\\n\\n            // protocolFee calculated in position Asset\\n            (, , address tierManager, uint256 maxProtocolFee, ) = _pmParams.primexDNS.getPrimexDNSParams();\\n            _require(\\n                data.leverage <=\\n                    _position.bucket.maxAssetLeverage(\\n                        _position.positionAsset,\\n                        PrimexPricingLibrary\\n                            .calculateFeeInPaymentAsset(\\n                                PrimexPricingLibrary.CalculateFeeInPaymentAssetParams({\\n                                    primexDNS: _pmParams.primexDNS,\\n                                    priceOracle: address(_pmParams.priceOracle),\\n                                    feeRateType: IPrimexDNSStorageV3.FeeRateType.MarginPositionClosedByKeeper,\\n                                    paymentAsset: data.positionAsset,\\n                                    paymentAmount: data.positionAmount,\\n                                    keeperRewardDistributor: _pmParams.keeperRewardDistributor,\\n                                    gasSpent: 0,\\n                                    isFeeProhibitedInPmx: true,\\n                                    nativePaymentAssetOracleData: _vars.nativePositionAssetOracleData,\\n                                    tierManager: ITiersManager(tierManager),\\n                                    maxProtocolFee: maxProtocolFee,\\n                                    trader: _position.trader\\n                                })\\n                            )\\n                            .wdiv(data.positionAmount)\\n                    ),\\n                Errors.INSUFFICIENT_DEPOSIT.selector\\n            );\\n            if (_vars.byOrder) {\\n                uint256 leverageTolerance = _pmParams.primexDNS.leverageTolerance();\\n                _require(\\n                    data.leverage <= _vars.orderLeverage.wmul(WadRayMath.WAD + leverageTolerance) &&\\n                        data.leverage >= _vars.orderLeverage.wmul(WadRayMath.WAD - leverageTolerance),\\n                    Errors.LEVERAGE_TOLERANCE_EXCEEDED.selector\\n                );\\n            }\\n        }\\n\\n        if (!_vars.byOrder) {\\n            _vars.depositData.leverage = data.leverage;\\n        }\\n\\n        data.multiplierBorrowedAsset = 10 ** (18 - IERC20Metadata(_position.soldAsset).decimals());\\n        data.multiplierPositionAsset = 10 ** (18 - IERC20Metadata(_position.positionAsset).decimals());\\n        posEventData.entryPrice =\\n            ((_vars.borrowedAmount + _position.depositAmountInSoldAsset) * data.multiplierBorrowedAsset).wdiv(\\n                (_position.positionAmount + posEventData.feeInPositionAsset) * data.multiplierPositionAsset\\n            ) /\\n            data.multiplierBorrowedAsset;\\n        posEventData.leverage = _vars.depositData.leverage;\\n        return (_position, posEventData);\\n    }\\n\\n    /**\\n     * @dev Retrieves the debt amount for a given position.\\n     * @param position The Position struct representing the position to get the debt amount for.\\n     * @return The debt amount in debtTokens.\\n     */\\n    function getDebt(Position memory position) public view returns (uint256) {\\n        if (position.scaledDebtAmount == 0) return 0;\\n        return position.scaledDebtAmount.rmul(position.bucket.getNormalizedVariableDebt());\\n    }\\n\\n    /**\\n     * @dev Calculates the health of a position.\\n     * @dev health = ((1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - priceDrop) * positionAmountInBorrowedAsset) /\\n     (feeBuffer * debt)\\n     * @param position The position object containing relevant information.\\n     * @param priceOracle The price oracle contract used for obtaining asset prices.\\n     * @param pairPriceDrop The priceDrop in WAD format of the asset pair.\\n     * @param securityBuffer The security buffer in WAD format for the position.\\n     * @param oracleTolerableLimit The tolerable limit in WAD format for the price oracle.\\n     * @return The health value in WAD format of the position.\\n     */\\n    function health(\\n        Position memory position,\\n        IPriceOracleV2 priceOracle,\\n        uint256 pairPriceDrop,\\n        uint256 securityBuffer,\\n        uint256 oracleTolerableLimit,\\n        uint256 feeInPaymentAsset,\\n        bytes memory positionSoldAssetOracleData\\n    ) public returns (uint256) {\\n        if (position.scaledDebtAmount == 0) return WadRayMath.WAD;\\n        return\\n            health(\\n                PrimexPricingLibrary.getOracleAmountsOut(\\n                    position.positionAsset,\\n                    position.soldAsset,\\n                    position.positionAmount,\\n                    address(priceOracle),\\n                    positionSoldAssetOracleData\\n                ) - feeInPaymentAsset,\\n                pairPriceDrop,\\n                securityBuffer,\\n                oracleTolerableLimit,\\n                getDebt(position),\\n                position.bucket.feeBuffer()\\n            );\\n    }\\n\\n    /**\\n     * @dev Creates a new position based on the given parameters.\\n     * @param _params The input parameters for creating the position.\\n     * @param primexDNS The address of the PrimexDNS contract.\\n     * @param priceOracle The address of the PriceOracle contract.\\n     * @return position The created Position struct.\\n     * @return vars The OpenPositionVars struct.\\n     */\\n    function createPosition(\\n        OpenPositionParams calldata _params,\\n        IPrimexDNSV3 primexDNS,\\n        IPriceOracleV2 priceOracle\\n    ) public returns (Position memory, OpenPositionVars memory) {\\n        OpenPositionVars memory vars = OpenPositionVars({\\n            firstAssetMegaRoutes: _params.firstAssetMegaRoutes,\\n            depositInThirdAssetMegaRoutes: _params.marginParams.depositInThirdAssetMegaRoutes,\\n            depositData: PrimexPricingLibrary.DepositData({\\n                depositAsset: address(0),\\n                depositAmount: _params.depositAmount,\\n                leverage: 0\\n            }),\\n            borrowedAmount: _params.marginParams.borrowedAmount,\\n            amountOutMin: _params.amountOutMin,\\n            deadline: _params.deadline,\\n            isSpot: _params.marginParams.borrowedAmount == 0,\\n            isThirdAsset: false,\\n            takeDepositFromWallet: _params.takeDepositFromWallet,\\n            byOrder: false,\\n            orderLeverage: 0,\\n            sender: address(0),\\n            closeConditions: _params.closeConditions,\\n            needOracleTolerableLimitCheck: _params.marginParams.borrowedAmount > 0,\\n            firstAssetOracleData: _params.firstAssetOracleData,\\n            thirdAssetOracleData: _params.thirdAssetOracleData,\\n            positionUsdOracleData: _params.positionUsdOracleData,\\n            nativePositionAssetOracleData: _params.nativePositionAssetOracleData,\\n            pmxPositionAssetOracleData: _params.pmxPositionAssetOracleData,\\n            nativeSoldAssetOracleData: _params.nativeSoldAssetOracleData\\n        });\\n\\n        PositionLibrary.Position memory position = PositionLibrary.Position({\\n            id: 0,\\n            scaledDebtAmount: 0,\\n            bucket: IBucketV3(address(0)),\\n            soldAsset: address(0),\\n            depositAmountInSoldAsset: 0,\\n            positionAsset: _params.positionAsset,\\n            positionAmount: 0,\\n            trader: msg.sender,\\n            openBorrowIndex: 0,\\n            createdAt: block.timestamp,\\n            updatedConditionsAt: block.timestamp,\\n            extraParams: \\\"\\\"\\n        });\\n\\n        if (vars.isSpot) {\\n            _require(_params.depositAsset != _params.positionAsset, Errors.SHOULD_BE_DIFFERENT_ASSETS_IN_SPOT.selector);\\n            _require(bytes(_params.marginParams.bucket).length == 0, Errors.BUCKET_SHOULD_BE_UNDEFINED.selector);\\n            position.soldAsset = _params.depositAsset;\\n            position.depositAmountInSoldAsset = vars.depositData.depositAmount;\\n            vars.depositData.leverage = WadRayMath.WAD;\\n        } else {\\n            position.bucket = IBucketV3(primexDNS.getBucketAddress(_params.marginParams.bucket));\\n            position.soldAsset = address(position.bucket.borrowedAsset());\\n            vars.depositData.depositAsset = _params.depositAsset;\\n            (, bool tokenAllowed) = position.bucket.allowedAssets(_params.positionAsset);\\n            _require(tokenAllowed, Errors.TOKEN_NOT_SUPPORTED.selector);\\n\\n            vars.isThirdAsset =\\n                _params.depositAsset != position.soldAsset &&\\n                _params.depositAsset != _params.positionAsset;\\n\\n            position.depositAmountInSoldAsset = PrimexPricingLibrary.getOracleAmountsOut(\\n                _params.depositAsset,\\n                position.soldAsset,\\n                _params.depositAmount,\\n                address(priceOracle),\\n                _params.depositSoldAssetOracleData\\n            );\\n        }\\n        address feeToken = _params.isProtocolFeeInPmx ? primexDNS.pmx() : position.soldAsset;\\n        position.extraParams = abi.encode(feeToken);\\n\\n        return (position, vars);\\n    }\\n\\n    /**\\n     * @notice Creates a position based on the provided order parameters.\\n     * @dev This function calculates and returns a Position and OpenPositionVars struct.\\n     * @param _params The OpenPositionByOrderParams struct containing the order parameters.\\n     * @param priceOracle The price oracle contract used for retrieving asset prices.\\n     * @return position The Position struct representing the created position.\\n     * @return vars The OpenPositionVars struct containing additional variables related to the position.\\n     */\\n    function createPositionByOrder(\\n        LimitOrderLibrary.OpenPositionByOrderParams calldata _params,\\n        IPriceOracleV2 priceOracle,\\n        IPrimexDNSV3 primexDNS\\n    ) public returns (Position memory, OpenPositionVars memory) {\\n        OpenPositionVars memory vars = OpenPositionVars({\\n            firstAssetMegaRoutes: _params.firstAssetMegaRoutes,\\n            depositInThirdAssetMegaRoutes: _params.depositInThirdAssetMegaRoutes,\\n            depositData: PrimexPricingLibrary.DepositData({\\n                depositAsset: address(0),\\n                depositAmount: _params.order.depositAmount,\\n                leverage: _params.order.leverage\\n            }),\\n            borrowedAmount: _params.borrowedAmount,\\n            amountOutMin: 0,\\n            orderLeverage: _params.order.leverage,\\n            deadline: _params.order.deadline,\\n            isSpot: _params.order.leverage == WadRayMath.WAD,\\n            isThirdAsset: false,\\n            takeDepositFromWallet: false,\\n            byOrder: true,\\n            sender: _params.sender,\\n            closeConditions: _params.closeConditions,\\n            needOracleTolerableLimitCheck: address(_params.order.bucket) != address(0),\\n            firstAssetOracleData: _params.firstAssetOracleData,\\n            thirdAssetOracleData: _params.thirdAssetOracleData,\\n            positionUsdOracleData: _params.positionUsdOracleData,\\n            nativePositionAssetOracleData: _params.nativePositionAssetOracleData,\\n            pmxPositionAssetOracleData: _params.pmxPositionAssetOracleData,\\n            nativeSoldAssetOracleData: _params.nativeSoldAssetOracleData\\n        });\\n\\n        Position memory position = Position({\\n            id: 0,\\n            scaledDebtAmount: 0,\\n            bucket: IBucketV3(address(0)),\\n            soldAsset: address(0),\\n            depositAmountInSoldAsset: 0,\\n            positionAsset: _params.order.positionAsset,\\n            positionAmount: 0,\\n            trader: _params.order.trader,\\n            openBorrowIndex: 0,\\n            createdAt: block.timestamp,\\n            updatedConditionsAt: block.timestamp,\\n            extraParams: \\\"\\\"\\n        });\\n\\n        if (vars.isSpot) {\\n            position.soldAsset = _params.order.depositAsset;\\n            position.depositAmountInSoldAsset = vars.depositData.depositAmount;\\n        } else {\\n            position.bucket = _params.order.bucket;\\n            position.soldAsset = address(position.bucket.borrowedAsset());\\n            vars.depositData.depositAsset = _params.order.depositAsset;\\n            vars.isThirdAsset =\\n                _params.order.depositAsset != position.soldAsset &&\\n                _params.order.depositAsset != _params.order.positionAsset;\\n\\n            position.depositAmountInSoldAsset = PrimexPricingLibrary.getOracleAmountsOut(\\n                _params.order.depositAsset,\\n                position.soldAsset,\\n                _params.order.depositAmount,\\n                address(priceOracle),\\n                _params.depositSoldAssetOracleData\\n            );\\n            if (_params.order.depositAsset == position.soldAsset) {\\n                _require(\\n                    vars.borrowedAmount == _params.order.depositAmount.wmul(_params.order.leverage - WadRayMath.WAD),\\n                    Errors.INCORRECT_BORROWED_AMOUNT.selector\\n                );\\n            }\\n        }\\n        address feeToken = _params.order.feeToken == primexDNS.pmx() ? primexDNS.pmx() : position.soldAsset;\\n        position.extraParams = abi.encode(feeToken);\\n\\n        return (position, vars);\\n    }\\n\\n    /**\\n     * @notice Decodes a fee token address from the provided encoded data.\\n     * @param data The encoded data containing the fee token address.\\n     * @return The decoded fee token address.\\n     */\\n    function decodeFeeTokenAddress(bytes memory data) public pure returns (address) {\\n        // Check if there is data in the bytes extraParams\\n        if (data.length == 0) {\\n            // If there is no data, return address(0)\\n            return address(0);\\n        } else {\\n            // Decode the data into an address and return the result\\n            return abi.decode(data, (address));\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates the health score for a position.\\n     * @param positionAmountInBorrowedAsset The position size in borrow asset.\\n     * @param pairPriceDrop The priceDrop in WAD format of the pair.\\n     * @param securityBuffer The security buffer in WAD format.\\n     * @param oracleTolerableLimit The tolerable limit in WAD format for the oracle.\\n     * @param positionDebt The debt of the position.\\n     * @param feeBuffer The buffer for fees.\\n     * @return The health score of the position.\\n     */\\n    function health(\\n        uint256 positionAmountInBorrowedAsset,\\n        uint256 pairPriceDrop,\\n        uint256 securityBuffer,\\n        uint256 oracleTolerableLimit,\\n        uint256 positionDebt,\\n        uint256 feeBuffer\\n    ) public pure returns (uint256) {\\n        return\\n            (\\n                (WadRayMath.WAD - securityBuffer)\\n                    .wmul(WadRayMath.WAD - oracleTolerableLimit)\\n                    .wmul(WadRayMath.WAD - pairPriceDrop)\\n                    .wmul(positionAmountInBorrowedAsset)\\n            ).wdiv(feeBuffer.wmul(positionDebt));\\n    }\\n}\\n\",\"keccak256\":\"0x66ed4afea278a9f28affad420d9fee4fd8122c7547fcdaf4729610a9e62c6301\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/PrimexPricingLibrary.sol\":{\"content\":\"// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.26;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {BytesLib} from \\\"./utils/BytesLib.sol\\\";\\nimport {WadRayMath} from \\\"./utils/WadRayMath.sol\\\";\\n\\nimport {NATIVE_CURRENCY, USD, USD_MULTIPLIER, ARB_NITRO_ORACLE, OVM_GASPRICEORACLE, GAS_FOR_BYTE, TRANSACTION_METADATA_BYTES} from \\\"../Constants.sol\\\";\\nimport {IDexAdapter} from \\\"../interfaces/IDexAdapter.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IKeeperRewardDistributorStorage, IKeeperRewardDistributorV3} from \\\"../KeeperRewardDistributor/IKeeperRewardDistributor.sol\\\";\\nimport {IPrimexDNSV3, IPrimexDNSStorageV3} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IBucketV3} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IPositionManagerV2} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {TokenTransfersLibrary} from \\\"./TokenTransfersLibrary.sol\\\";\\nimport {IPriceOracleStorageV2} from \\\"../PriceOracle/IPriceOracleStorage.sol\\\";\\nimport {IPriceOracleV2} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {ITiersManager} from \\\"../TiersManager/ITiersManager.sol\\\";\\nimport \\\"./Errors.sol\\\";\\n\\nlibrary PrimexPricingLibrary {\\n    using WadRayMath for uint256;\\n    using BytesLib for bytes;\\n\\n    /**\\n     * @param dexName The name of the DEX.\\n     * @param shares the share that will be allocated from the total amount for the route\\n     * @param payload payload data encoded in bytes\\n     */\\n\\n    struct Path {\\n        string dexName;\\n        uint256 shares;\\n        bytes payload;\\n    }\\n\\n    /**\\n     * @param to the destination token of the route\\n     * @param paths path array through which the swap will be made up to the destination token this the route\\n     */\\n\\n    struct Route {\\n        address to;\\n        Path[] paths;\\n    }\\n\\n    /**\\n     * @param shares the share that will be allocated from the total amount for this MegaRoute\\n     * @param routes array of routes through which the swap will be made up to TokenB\\n     */\\n    struct MegaRoute {\\n        uint256 shares;\\n        Route[] routes;\\n    }\\n\\n    struct MegaSwapParams {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amountTokenA;\\n        MegaRoute[] megaRoutes;\\n        address receiver;\\n        uint256 deadline;\\n    }\\n\\n    struct AmountParams {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amount;\\n        MegaRoute[] megaRoutes;\\n        address dexAdapter;\\n        address primexDNS;\\n    }\\n\\n    struct DepositData {\\n        address depositAsset;\\n        uint256 depositAmount;\\n        uint256 leverage;\\n    }\\n\\n    /**\\n     * @param feeToken An asset in which the fee will be paid.\\n     * @param trader The trader address\\n     * @param priceOracle PriceOracle contract address\\n     * @param orderType Type of possible order in Primex protocol\\n     * @param traderBalanceVault TraderBalanceVault contract address\\n     * @param primexDNS PrimexDNS contract address\\n     */\\n    struct ProtocolFeeParams {\\n        address feeToken;\\n        address trader;\\n        address priceOracle;\\n        IPrimexDNSStorageV3.FeeRateType feeRateType;\\n        ITraderBalanceVault traderBalanceVault;\\n        address swapManager;\\n        address keeperRewardDistributor;\\n        IPrimexDNSV3 primexDNS;\\n        address paymentAsset;\\n        uint256 paymentAmount;\\n        uint256 gasSpent;\\n        bool isFeeProhibitedInPmx;\\n        bytes pmxPaymentAssetOracleData;\\n        bytes nativePaymentAssetOracleData;\\n    }\\n\\n    struct ProtocolFeeParamsBatchClose {\\n        uint256 numberOfPositions;\\n        address[] feeTokens;\\n        address[] traders;\\n        uint256[] paymentAmounts;\\n        address paymentAsset;\\n        address priceOracle;\\n        IPrimexDNSStorageV3.FeeRateType feeRateType;\\n        ITraderBalanceVault traderBalanceVault;\\n        address keeperRewardDistributor;\\n        IPrimexDNSV3 primexDNS;\\n        uint256 estimatedGasAmount;\\n        bool isFeeProhibitedInPmx;\\n        uint256 estimatedBaseLength;\\n        bytes nativePaymentAssetOracleData;\\n        bytes pmxPaymentAssetOracleData;\\n    }\\n\\n    struct CalculateFeeInPaymentAssetParams {\\n        IPrimexDNSV3 primexDNS;\\n        address priceOracle;\\n        IPrimexDNSStorageV3.FeeRateType feeRateType;\\n        address paymentAsset;\\n        uint256 paymentAmount;\\n        address keeperRewardDistributor;\\n        uint256 gasSpent;\\n        bool isFeeProhibitedInPmx;\\n        bytes nativePaymentAssetOracleData;\\n        ITiersManager tierManager;\\n        uint256 maxProtocolFee;\\n        address trader;\\n    }\\n\\n    struct MinProtocolFeeParams {\\n        uint256 restrictedGasSpent;\\n        address paymentAsset;\\n        address priceOracle;\\n        IKeeperRewardDistributorV3 keeperRewardDistributor;\\n        IPrimexDNSV3 primexDNS;\\n        bool isFeeProhibitedInPmx;\\n        IPrimexDNSStorageV3.FeeRateType feeRateType;\\n        bytes nativePaymentAssetOracleData;\\n    }\\n\\n    /**\\n     * The struct for payProtocolFee function\\n     */\\n    struct ProtocolFeeVars {\\n        address pmx;\\n        address treasury;\\n        address tierManager;\\n        uint256 feeInPaymentAssetWithDiscount;\\n        uint256 pmxTraderBalance;\\n        uint256 pmxTraderBalanceInPaymentAsset;\\n        uint256 pmxDiscountMultiplier;\\n        uint256 maxProtocolFee;\\n    }\\n\\n    /**\\n     * The struct for calculateFeeInPaymentAssetVars function\\n     */\\n    struct FeeInPaymentAssetVars {\\n        uint256 protocolFeeRate;\\n        uint256 feeInPaymentAsset;\\n        uint256 maxProtocolFeeInPaymentAsset;\\n        uint256 minProtocolFeeInPaymentAsset;\\n    }\\n\\n    /**\\n     * The struct for minProtocolFee function\\n     */\\n    struct MinProtocolFeeVars {\\n        uint256 maxGasAmount;\\n        uint256 restrictedGasPrice;\\n        uint256 l1CostWei;\\n        uint256 liquidationGasAmount;\\n        uint256 protocolFeeCoefficient;\\n        uint256 additionalGasSpent;\\n        uint256 minProtocolFeeInNativeAsset;\\n        uint256 totalGasSpent;\\n        uint256 baseLength;\\n        uint256 optimisticGasCoefficient;\\n        IPrimexDNSStorageV3.CallingMethod callingMethod;\\n        IKeeperRewardDistributorStorage.PaymentModel paymentModel;\\n    }\\n\\n    /**\\n     * The struct for calculateFeeInPaymentAssetBatchClose function\\n     */\\n    struct CalculateFeeInPaymentAssetBatchCloseVars {\\n        uint256[] feeInPaymentAsset;\\n        uint256 protocolFeeRate;\\n        uint256 maxProtocolFeeInPaymentAsset;\\n        uint256 minProtocolFeeInPaymentAsset;\\n    }\\n\\n    struct CalculateFeeInPaymentAssetBatchCloseParams {\\n        uint256 numberOfPositions;\\n        IPrimexDNSV3 primexDNS;\\n        address priceOracle;\\n        IPrimexDNSStorageV3.FeeRateType feeRateType;\\n        address paymentAsset;\\n        uint256[] paymentAmounts;\\n        address keeperRewardDistributor;\\n        uint256 estimatedGasAmount;\\n        uint256 estimatedBaseLength;\\n        ITiersManager tierManager;\\n        uint256 maxProtocolFee;\\n        bool isFeeProhibitedInPmx;\\n    }\\n\\n    /**\\n     * The struct for calculateRestrictedGasPrice function\\n     */\\n    struct RestrictedGasPriceVars {\\n        int256 oracleGasPrice;\\n        uint256 maxGasPrice;\\n        uint256 defaultMaxGasPrice;\\n        uint256 oracleGasPriceTolerance;\\n    }\\n\\n    /**\\n     * The struct for getLiquidationPrice and getLiquidationPriceByOrder functions\\n     */\\n    struct LiquidationPriceData {\\n        IBucketV3 bucket;\\n        IPositionManagerV2 positionManager;\\n        IPriceOracleV2 priceOracle;\\n        IERC20Metadata borrowedAsset;\\n    }\\n\\n    event Withdraw(\\n        address indexed withdrawer,\\n        address borrowAssetReceiver,\\n        address borrowedAsset,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Encodes the given parameters into a bytes array based on the specified DEX type.\\n     * @param path The token path for the swap.\\n     * @param dexRouter The address of the DEX router.\\n     * @param ancillaryData Additional data required for certain DEX types.\\n     * @param dexAdapter The address of the DEX adapter.\\n     * @param isAmountToBuy A flag indicating whether it is the path for the swap with fixed amountIn or amountOut.\\n     * Swap with fixed amountIn, if true.\\n     * @return The encoded bytes array.\\n     */\\n    function encodePath(\\n        address[] memory path,\\n        address dexRouter,\\n        bytes32 ancillaryData,\\n        address payable dexAdapter,\\n        bool isAmountToBuy\\n    ) external view returns (bytes memory) {\\n        IDexAdapter.DexType type_ = IDexAdapter(dexAdapter).dexType(dexRouter);\\n\\n        if (type_ == IDexAdapter.DexType.UniswapV2 || type_ == IDexAdapter.DexType.Meshswap) {\\n            return abi.encode(path);\\n        }\\n        if (type_ == IDexAdapter.DexType.UniswapV3) {\\n            if (isAmountToBuy)\\n                return bytes.concat(bytes20(path[1]), bytes3(uint24(uint256(ancillaryData))), bytes20(path[0]));\\n            return bytes.concat(bytes20(path[0]), bytes3(uint24(uint256(ancillaryData))), bytes20(path[1]));\\n        }\\n        if (type_ == IDexAdapter.DexType.AlgebraV3) {\\n            if (isAmountToBuy) return bytes.concat(bytes20(path[1]), bytes20(path[0]));\\n            return bytes.concat(bytes20(path[0]), bytes20(path[1]));\\n        }\\n        if (type_ == IDexAdapter.DexType.Curve) {\\n            address[] memory pools = new address[](1);\\n            pools[0] = address(uint160(uint256(ancillaryData)));\\n            return abi.encode(path, pools);\\n        }\\n        if (type_ == IDexAdapter.DexType.Balancer) {\\n            int256[] memory limits = new int256[](2);\\n            limits[0] = type(int256).max;\\n            bytes32[] memory pools = new bytes32[](1);\\n            pools[0] = ancillaryData;\\n            return abi.encode(path, pools, limits);\\n        }\\n        _revert(Errors.UNKNOWN_DEX_TYPE.selector);\\n    }\\n\\n    /**\\n     * @notice Calculates the amount of deposit assets in borrowed assets.\\n     * @param _params The parameters for the calculation.\\n     * @param _isThirdAsset A flag indicating if deposit is in a third asset.\\n     * @param _priceOracle The address of the price oracle.\\n     * @return The amount of deposit assets is measured in borrowed assets.\\n     */\\n    function getDepositAmountInBorrowed(\\n        IDexAdapter.AmountParams calldata _params,\\n        bool _isThirdAsset,\\n        address payable _dexAdapter,\\n        address _priceOracle,\\n        bytes calldata _oracleData\\n    ) public returns (uint256) {\\n        _require(\\n            IERC165(_priceOracle).supportsInterface(type(IPriceOracleV2).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        if (_params.tokenA == _params.tokenB) {\\n            _require(_params.megaRoutes.length == 0, Errors.DEPOSITED_TO_BORROWED_ROUTES_LENGTH_SHOULD_BE_0.selector);\\n            return _params.amount;\\n        }\\n\\n        uint256 depositAmountInBorrowed = IDexAdapter(_dexAdapter).getAmountOutByMegaRoutes(_params);\\n        if (_isThirdAsset) {\\n            uint256 oracleDepositAmountOut = getOracleAmountsOut(\\n                _params.tokenA,\\n                _params.tokenB,\\n                _params.amount,\\n                _priceOracle,\\n                _oracleData\\n            );\\n            if (depositAmountInBorrowed > oracleDepositAmountOut) depositAmountInBorrowed = oracleDepositAmountOut;\\n        }\\n\\n        return depositAmountInBorrowed;\\n    }\\n\\n    /**\\n     * @notice Performs a multi-hop swap transaction using the specified parameters.\\n     * @dev This function executes a series of token swaps on different DEXs based on the provided routes.\\n     * @param _params The struct containing all the necessary parameters for the multi-hop swap.\\n     * @param _maximumOracleTolerableLimit The maximum tolerable limit in WAD format (1 WAD = 100%)\\n     * for the price difference between DEX and the oracle.\\n     * @param _dexAdapter The address of the Dex adapter contract.\\n     * @param _priceOracle The address of the price oracle contract.\\n     * @param _needOracleTolerableLimitCheck Flag indicating whether to perform an oracle tolerable limit check.\\n     * @return The final balance of the _params.tokenB in the receiver's address after the multi-hop swap.\\n     */\\n    function megaSwap(\\n        MegaSwapParams calldata _params,\\n        uint256 _maximumOracleTolerableLimit,\\n        address payable _dexAdapter,\\n        address _priceOracle,\\n        bool _needOracleTolerableLimitCheck,\\n        bytes calldata _oracleData\\n    ) public returns (uint256) {\\n        uint256 balance = IERC20Metadata(_params.tokenB).balanceOf(_params.receiver);\\n        IDexAdapter(_dexAdapter).performMegaRoutesSwap(_params);\\n\\n        balance = IERC20Metadata(_params.tokenB).balanceOf(_params.receiver) - balance;\\n        if (_needOracleTolerableLimitCheck) {\\n            _require(\\n                balance >=\\n                    getOracleAmountsOut(_params.tokenA, _params.tokenB, _params.amountTokenA, _priceOracle, _oracleData)\\n                        .wmul(WadRayMath.WAD - _maximumOracleTolerableLimit),\\n                Errors.DIFFERENT_PRICE_DEX_AND_ORACLE.selector\\n            );\\n        }\\n\\n        return balance;\\n    }\\n\\n    /**\\n     * @notice Pays the protocol fee.\\n     * @dev This function transfers the protocol fee from the trader to the protocol treasury.\\n     * @param params The parameters for paying the protocol fee.\\n     * @return feeInPaymentAsset The amount of the protocol fee in a payment asset\\n     * (position asset for the limit order execution, sold asset when the position is closed.)\\n     * @return feeInPmx The amount of the protocol fee in pmx asset paid.\\n     */\\n    function payProtocolFee(\\n        ProtocolFeeParams memory params\\n    ) public returns (uint256 feeInPaymentAsset, uint256 feeInPmx) {\\n        // This is done to ensure that after upgrading the contracts, positions that have already been opened\\n        // and had fees paid for them will not incur additional fees upon closure\\n        if (params.feeToken == address(0)) {\\n            return (0, 0);\\n        }\\n\\n        ProtocolFeeVars memory vars;\\n        (vars.pmx, vars.treasury, vars.tierManager, vars.maxProtocolFee, vars.pmxDiscountMultiplier) = params\\n            .primexDNS\\n            .getPrimexDNSParams();\\n        feeInPaymentAsset = calculateFeeInPaymentAsset(\\n            CalculateFeeInPaymentAssetParams({\\n                primexDNS: params.primexDNS,\\n                priceOracle: params.priceOracle,\\n                feeRateType: params.feeRateType,\\n                paymentAsset: params.paymentAsset,\\n                paymentAmount: params.paymentAmount,\\n                keeperRewardDistributor: params.keeperRewardDistributor,\\n                gasSpent: params.gasSpent,\\n                isFeeProhibitedInPmx: params.isFeeProhibitedInPmx,\\n                nativePaymentAssetOracleData: params.nativePaymentAssetOracleData,\\n                tierManager: ITiersManager(vars.tierManager),\\n                maxProtocolFee: vars.maxProtocolFee,\\n                trader: params.trader\\n            })\\n        );\\n        (vars.pmxTraderBalance, ) = params.traderBalanceVault.balances(params.trader, vars.pmx);\\n        if (params.feeToken == vars.pmx && vars.pmxTraderBalance > 0 && !params.isFeeProhibitedInPmx) {\\n            // pmx => payment asset data\\n            uint256 pmxTraderBalanceInPaymentAsset = getOracleAmountsOut(\\n                vars.pmx,\\n                params.paymentAsset,\\n                vars.pmxTraderBalance,\\n                params.priceOracle,\\n                params.pmxPaymentAssetOracleData\\n            );\\n\\n            uint256 feeInPaymentAssetWithDiscount = feeInPaymentAsset.wmul(vars.pmxDiscountMultiplier);\\n\\n            feeInPmx = (feeInPaymentAssetWithDiscount * vars.pmxTraderBalance) / pmxTraderBalanceInPaymentAsset;\\n\\n            if (pmxTraderBalanceInPaymentAsset >= feeInPaymentAssetWithDiscount) {\\n                feeInPaymentAsset = 0;\\n                params.traderBalanceVault.withdrawFrom(params.trader, vars.treasury, vars.pmx, feeInPmx, false);\\n            } else {\\n                feeInPmx = vars.pmxTraderBalance;\\n                feeInPaymentAsset -= pmxTraderBalanceInPaymentAsset.wdiv(vars.pmxDiscountMultiplier);\\n                params.traderBalanceVault.withdrawFrom(\\n                    params.trader,\\n                    vars.treasury,\\n                    vars.pmx,\\n                    vars.pmxTraderBalance,\\n                    false\\n                );\\n                TokenTransfersLibrary.doTransferOut(params.paymentAsset, vars.treasury, feeInPaymentAsset);\\n            }\\n        } else {\\n            TokenTransfersLibrary.doTransferOut(params.paymentAsset, vars.treasury, feeInPaymentAsset);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate and return protocol fee\\n     * @return The amount of the protocol fee in '_feeToken' which needs to be paid according to the specified deposit parameters.\\n     */\\n    function calculateFeeInPaymentAsset(CalculateFeeInPaymentAssetParams memory params) public returns (uint256) {\\n        FeeInPaymentAssetVars memory vars;\\n\\n        vars.protocolFeeRate = params.primexDNS.getProtocolFeeRateByTier(\\n            params.feeRateType,\\n            params.isFeeProhibitedInPmx ? 0 : params.tierManager.getTraderTierForAddress(params.trader)\\n        );\\n\\n        // Calculate protocol fee in position asset\\n        vars.feeInPaymentAsset = params.paymentAmount.wmul(vars.protocolFeeRate);\\n\\n        // Calculate max protocol fee in position asset\\n        vars.maxProtocolFeeInPaymentAsset = params.maxProtocolFee == type(uint256).max\\n            ? type(uint256).max\\n            : getOracleAmountsOut(\\n                NATIVE_CURRENCY,\\n                params.paymentAsset,\\n                params.maxProtocolFee,\\n                params.priceOracle,\\n                params.nativePaymentAssetOracleData\\n            );\\n\\n        // The minProtocolFee is applied only if the order/position is processed by Keepers\\n\\n        if (\\n            params.feeRateType == IPrimexDNSStorageV3.FeeRateType.MarginPositionClosedByTrader ||\\n            params.feeRateType == IPrimexDNSStorageV3.FeeRateType.SpotPositionClosedByTrader ||\\n            params.feeRateType == IPrimexDNSStorageV3.FeeRateType.SwapMarketOrder\\n        ) {\\n            vars.feeInPaymentAsset = min(vars.feeInPaymentAsset, vars.maxProtocolFeeInPaymentAsset);\\n        } else {\\n            vars.minProtocolFeeInPaymentAsset = minProtocolFee(\\n                MinProtocolFeeParams({\\n                    restrictedGasSpent: params.gasSpent,\\n                    paymentAsset: params.paymentAsset,\\n                    priceOracle: params.priceOracle,\\n                    keeperRewardDistributor: IKeeperRewardDistributorV3(params.keeperRewardDistributor),\\n                    primexDNS: params.primexDNS,\\n                    isFeeProhibitedInPmx: params.isFeeProhibitedInPmx,\\n                    feeRateType: params.feeRateType,\\n                    nativePaymentAssetOracleData: params.nativePaymentAssetOracleData\\n                })\\n            );\\n            _require(\\n                vars.minProtocolFeeInPaymentAsset < params.paymentAmount,\\n                Errors.MIN_PROTOCOL_FEE_IS_GREATER_THAN_PAYMENT_AMOUNT.selector\\n            );\\n\\n            vars.feeInPaymentAsset = min(\\n                max(vars.feeInPaymentAsset, vars.minProtocolFeeInPaymentAsset),\\n                vars.maxProtocolFeeInPaymentAsset\\n            );\\n        }\\n        return vars.feeInPaymentAsset;\\n    }\\n\\n    function payProtocolFeeBatchClose(\\n        ProtocolFeeParamsBatchClose calldata params\\n    ) public returns (uint256[] memory, uint256[] memory) {\\n        ProtocolFeeVars memory vars;\\n        uint256[] memory feeInPaymentAsset = new uint256[](params.numberOfPositions);\\n        uint256[] memory feeInPmx = new uint256[](params.numberOfPositions);\\n\\n        (vars.pmx, vars.treasury, vars.tierManager, vars.maxProtocolFee, vars.pmxDiscountMultiplier) = params\\n            .primexDNS\\n            .getPrimexDNSParams();\\n\\n        feeInPaymentAsset = calculateFeeInPaymentAssetBatchClose(\\n            CalculateFeeInPaymentAssetBatchCloseParams({\\n                numberOfPositions: params.numberOfPositions,\\n                primexDNS: params.primexDNS,\\n                priceOracle: params.priceOracle,\\n                feeRateType: params.feeRateType,\\n                paymentAsset: params.paymentAsset,\\n                paymentAmounts: params.paymentAmounts,\\n                keeperRewardDistributor: params.keeperRewardDistributor,\\n                estimatedGasAmount: params.estimatedGasAmount,\\n                estimatedBaseLength: params.estimatedBaseLength,\\n                tierManager: ITiersManager(vars.tierManager),\\n                maxProtocolFee: vars.maxProtocolFee,\\n                isFeeProhibitedInPmx: params.isFeeProhibitedInPmx\\n            }),\\n            // to keep calldata\\n            params.nativePaymentAssetOracleData,\\n            params.traders\\n        );\\n        for (uint256 i; i < params.numberOfPositions; i++) {\\n            // This is done to ensure that after upgrading the contracts, positions that have already been opened\\n            // and had fees paid for them will not incur additional fees upon closure\\n            if (params.feeTokens[i] == address(0)) {\\n                feeInPaymentAsset[i] = 0;\\n                feeInPmx[i] = 0;\\n                continue;\\n            }\\n\\n            (vars.pmxTraderBalance, ) = params.traderBalanceVault.balances(params.traders[i], vars.pmx);\\n\\n            if (!params.isFeeProhibitedInPmx && params.feeTokens[i] == vars.pmx && vars.pmxTraderBalance > 0) {\\n                vars.pmxTraderBalanceInPaymentAsset = getOracleAmountsOut(\\n                    vars.pmx,\\n                    params.paymentAsset,\\n                    vars.pmxTraderBalance,\\n                    params.priceOracle,\\n                    params.pmxPaymentAssetOracleData\\n                );\\n\\n                vars.feeInPaymentAssetWithDiscount = feeInPaymentAsset[i].wmul(vars.pmxDiscountMultiplier);\\n                feeInPmx[i] =\\n                    (vars.feeInPaymentAssetWithDiscount * vars.pmxTraderBalance) /\\n                    vars.pmxTraderBalanceInPaymentAsset;\\n                if (vars.pmxTraderBalanceInPaymentAsset >= vars.feeInPaymentAssetWithDiscount) {\\n                    feeInPaymentAsset[i] = 0;\\n                    params.traderBalanceVault.withdrawFrom(\\n                        params.traders[i],\\n                        vars.treasury,\\n                        vars.pmx,\\n                        feeInPmx[i],\\n                        false\\n                    );\\n                } else {\\n                    feeInPmx[i] = vars.pmxTraderBalance;\\n                    feeInPaymentAsset[i] -= vars.pmxTraderBalanceInPaymentAsset.wdiv(vars.pmxDiscountMultiplier);\\n                    params.traderBalanceVault.withdrawFrom(\\n                        params.traders[i],\\n                        vars.treasury,\\n                        vars.pmx,\\n                        vars.pmxTraderBalance,\\n                        false\\n                    );\\n                }\\n            }\\n        }\\n        return (feeInPaymentAsset, feeInPmx);\\n    }\\n\\n    /**\\n     * @notice Calculate and return protocol fee\\n     * @return The amount of the protocol fee in '_feeToken' which needs to be paid according to the specified deposit parameters.\\n     */\\n    function calculateFeeInPaymentAssetBatchClose(\\n        CalculateFeeInPaymentAssetBatchCloseParams memory _params,\\n        bytes calldata _nativePaymentAssetOracleData,\\n        address[] calldata _traders\\n    ) public returns (uint256[] memory) {\\n        CalculateFeeInPaymentAssetBatchCloseVars memory vars;\\n        // Calculate max protocol fee in payment (sold) asset\\n        vars.maxProtocolFeeInPaymentAsset = _params.maxProtocolFee == type(uint256).max\\n            ? type(uint256).max\\n            : getOracleAmountsOut(\\n                NATIVE_CURRENCY,\\n                _params.paymentAsset,\\n                _params.maxProtocolFee,\\n                _params.priceOracle,\\n                _nativePaymentAssetOracleData\\n            );\\n        vars.minProtocolFeeInPaymentAsset = minProtocolFeeCloseBatch(\\n            _params.paymentAsset,\\n            _params.priceOracle,\\n            IKeeperRewardDistributorV3(_params.keeperRewardDistributor),\\n            _params.estimatedGasAmount,\\n            _params.estimatedBaseLength,\\n            _params.primexDNS,\\n            _nativePaymentAssetOracleData\\n        );\\n\\n        vars.feeInPaymentAsset = new uint256[](_params.numberOfPositions);\\n\\n        uint256[] memory protocolFeeRates;\\n        if (_params.isFeeProhibitedInPmx) {\\n            vars.protocolFeeRate = _params.primexDNS.getProtocolFeeRateByTier(_params.feeRateType, 0);\\n        } else {\\n            protocolFeeRates = _params.primexDNS.getProtocolFeeRatesByTier(\\n                _params.feeRateType,\\n                _params.tierManager.getTraderTiersForAddresses(_traders)\\n            );\\n        }\\n        // Calculate protocol fee in position asset\\n        for (uint256 i; i < _params.numberOfPositions; i++) {\\n            if (!_params.isFeeProhibitedInPmx) {\\n                vars.protocolFeeRate = protocolFeeRates[i];\\n            }\\n            vars.feeInPaymentAsset[i] = _params.paymentAmounts[i].wmul(vars.protocolFeeRate);\\n            _require(\\n                vars.minProtocolFeeInPaymentAsset < _params.paymentAmounts[i],\\n                Errors.MIN_PROTOCOL_FEE_IS_GREATER_THAN_PAYMENT_AMOUNT.selector\\n            );\\n            vars.feeInPaymentAsset[i] = min(\\n                max(vars.feeInPaymentAsset[i], vars.minProtocolFeeInPaymentAsset),\\n                vars.maxProtocolFeeInPaymentAsset\\n            );\\n        }\\n        return vars.feeInPaymentAsset;\\n    }\\n\\n    /**\\n     * @notice Calculate minProtocolFee based on the gas price\\n     */\\n    function minProtocolFee(MinProtocolFeeParams memory params) public returns (uint256 minProtocolFeeInPositionAsset) {\\n        MinProtocolFeeVars memory vars;\\n        (vars.restrictedGasPrice) = calculateRestrictedGasPrice(params.priceOracle, params.keeperRewardDistributor);\\n        if (\\n            params.feeRateType == IPrimexDNSStorageV3.FeeRateType.MarginPositionClosedByKeeper ||\\n            params.feeRateType == IPrimexDNSStorageV3.FeeRateType.SpotPositionClosedByKeeper\\n        ) {\\n            vars.callingMethod = IPrimexDNSStorageV3.CallingMethod.ClosePositionByCondition;\\n        } else {\\n            vars.callingMethod = IPrimexDNSStorageV3.CallingMethod.OpenPositionByOrder;\\n        }\\n        (\\n            vars.liquidationGasAmount,\\n            vars.protocolFeeCoefficient,\\n            vars.additionalGasSpent,\\n            vars.maxGasAmount,\\n            vars.baseLength\\n        ) = params.primexDNS.getParamsForMinProtocolFee(vars.callingMethod);\\n\\n        vars.l1CostWei = _calculateL1CostWei(vars.baseLength, params.keeperRewardDistributor);\\n\\n        if (params.isFeeProhibitedInPmx) {\\n            vars.minProtocolFeeInNativeAsset =\\n                vars.liquidationGasAmount *\\n                vars.restrictedGasPrice +\\n                vars.l1CostWei +\\n                vars.protocolFeeCoefficient;\\n        } else {\\n            if (vars.callingMethod == IPrimexDNSStorageV3.CallingMethod.ClosePositionByCondition) {\\n                vars.minProtocolFeeInNativeAsset =\\n                    vars.maxGasAmount *\\n                    vars.restrictedGasPrice +\\n                    vars.l1CostWei +\\n                    vars.protocolFeeCoefficient;\\n            } else {\\n                vars.totalGasSpent = params.restrictedGasSpent + vars.additionalGasSpent;\\n                vars.totalGasSpent = min(vars.totalGasSpent, vars.maxGasAmount);\\n\\n                vars.minProtocolFeeInNativeAsset =\\n                    vars.totalGasSpent *\\n                    vars.restrictedGasPrice +\\n                    vars.l1CostWei +\\n                    vars.protocolFeeCoefficient;\\n            }\\n        }\\n        minProtocolFeeInPositionAsset = getOracleAmountsOut(\\n            NATIVE_CURRENCY,\\n            params.paymentAsset,\\n            vars.minProtocolFeeInNativeAsset,\\n            params.priceOracle,\\n            params.nativePaymentAssetOracleData\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculate minProtocolFee based on the gas price in closeBatchPositions\\n     */\\n    function minProtocolFeeCloseBatch(\\n        address _paymentAsset,\\n        address _priceOracle,\\n        IKeeperRewardDistributorV3 _keeperRewardDistributor,\\n        uint256 _estimatedGasAmount,\\n        uint256 _estimatedBaseLength,\\n        IPrimexDNSV3 primexDNS,\\n        bytes calldata _nativePaymentAssetOracleData\\n    ) public returns (uint256 minProtocolFeeInPositionAsset) {\\n        uint256 restrictedGasPrice = calculateRestrictedGasPrice(_priceOracle, _keeperRewardDistributor);\\n\\n        uint256 l1CostWei = _calculateL1CostWei(_estimatedBaseLength, _keeperRewardDistributor);\\n\\n        uint256 minProtocolFeeInNativeAsset = _estimatedGasAmount *\\n            restrictedGasPrice +\\n            l1CostWei +\\n            primexDNS.protocolFeeCoefficient();\\n\\n        minProtocolFeeInPositionAsset = getOracleAmountsOut(\\n            NATIVE_CURRENCY,\\n            _paymentAsset,\\n            minProtocolFeeInNativeAsset,\\n            _priceOracle,\\n            _nativePaymentAssetOracleData\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculate minPositionSize based on the gas price\\n     */\\n    function minPositionSize(\\n        address _priceOracle,\\n        IKeeperRewardDistributorV3 _keeperRewardDistributor,\\n        IPrimexDNSV3 _primexDNS,\\n        IPrimexDNSStorageV3.TradingOrderType _tradingOrderType\\n    ) public view returns (uint256 minPositionSizeInNativeAsset) {\\n        uint256 restrictedGasPrice = calculateRestrictedGasPrice(_priceOracle, _keeperRewardDistributor);\\n        (\\n            uint256 baseLength,\\n            uint256 averageGasPerAction,\\n            uint256 protocolFeeCoefficient,\\n            uint256 gasPriceBuffer\\n        ) = _primexDNS.getParamsForMinPositionSize(_tradingOrderType);\\n        uint256 l1CostWei = _calculateL1CostWei(baseLength, _keeperRewardDistributor);\\n\\n        minPositionSizeInNativeAsset = (averageGasPerAction * restrictedGasPrice + l1CostWei + protocolFeeCoefficient)\\n            .wmul(gasPriceBuffer);\\n    }\\n\\n    function calculateRestrictedGasPrice(\\n        address _priceOracle,\\n        IKeeperRewardDistributorV3 _keeperRewardDistributor\\n    ) internal view returns (uint256 restrictedGasPrice) {\\n        RestrictedGasPriceVars memory vars;\\n        restrictedGasPrice = tx.gasprice;\\n        vars.oracleGasPrice = IPriceOracle(_priceOracle).getGasPrice();\\n        (vars.oracleGasPriceTolerance, vars.defaultMaxGasPrice, , ) = _keeperRewardDistributor\\n            .getGasCalculationParams();\\n\\n        vars.maxGasPrice = vars.oracleGasPrice > 0\\n            ? uint256(vars.oracleGasPrice).wmul(WadRayMath.WAD + vars.oracleGasPriceTolerance)\\n            : vars.defaultMaxGasPrice;\\n\\n        if (restrictedGasPrice > vars.maxGasPrice || restrictedGasPrice == 0) {\\n            restrictedGasPrice = vars.maxGasPrice;\\n        }\\n    }\\n\\n    function getOracleAmountsOut(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _amountAssetA,\\n        address _priceOracle,\\n        bytes memory _oracleData\\n    ) public returns (uint256) {\\n        _require(\\n            IERC165(_priceOracle).supportsInterface(type(IPriceOracleV2).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        if (_tokenA == _tokenB) {\\n            return _amountAssetA;\\n        }\\n        uint256 exchangeRate = IPriceOracleV2(_priceOracle).getExchangeRate(_tokenA, _tokenB, _oracleData);\\n        return (_amountAssetA * _getAssetMultiplier(_tokenA)).wmul(exchangeRate) / _getAssetMultiplier(_tokenB);\\n    }\\n\\n    /**\\n     * @param _tokenA asset for sell\\n     * @param _tokenB asset to buy\\n     * @param _amountsAssetA An array of amounts of tokenA to sell\\n     * @param _priceOracle PriceOracle contract address\\n     * @return returns an array of amounts of `tokenB` by the `amountsAssetA` by the price of the oracle\\n     */\\n    function getBatchOracleAmountsOut(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256[] memory _amountsAssetA,\\n        address _priceOracle,\\n        bytes calldata _oracleData\\n    ) public returns (uint256[] memory) {\\n        _require(\\n            IERC165(_priceOracle).supportsInterface(type(IPriceOracleV2).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        if (_tokenA == _tokenB) {\\n            return _amountsAssetA;\\n        }\\n        uint256[] memory amountsAssetB = new uint256[](_amountsAssetA.length);\\n        uint256 exchangeRate = IPriceOracleV2(_priceOracle).getExchangeRate(_tokenA, _tokenB, _oracleData);\\n        uint256 multiplier1 = 10 ** (18 - IERC20Metadata(_tokenA).decimals());\\n        uint256 multiplier2 = 10 ** (18 - IERC20Metadata(_tokenB).decimals());\\n        for (uint256 i; i < _amountsAssetA.length; i++) {\\n            amountsAssetB[i] = (_amountsAssetA[i] * multiplier1).wmul(exchangeRate) / multiplier2;\\n        }\\n        return amountsAssetB;\\n    }\\n\\n    /**\\n     * @notice Calculates the liquidation price for a position.\\n     * @dev liquidationPrice = (feeBuffer * debt) /\\n     * ((1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - priceDrop) * positionAmount))\\n     * @param _bucket The address of the related bucket.\\n     * @param _positionAsset The address of the position asset.\\n     * @param _positionAmount The size of the opened position.\\n     * @param _positionDebt The debt amount in debtTokens associated with the position.\\n     * @return The calculated liquidation price in borrowed asset.\\n     */\\n    function getLiquidationPrice(\\n        address _bucket,\\n        address _positionAsset,\\n        uint256 _positionAmount,\\n        uint256 _positionDebt,\\n        address _primexDNS\\n    ) public view returns (uint256) {\\n        _require(_positionAsset != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\\n        LiquidationPriceData memory data;\\n        data.bucket = IBucketV3(_bucket);\\n        data.positionManager = data.bucket.positionManager();\\n        data.borrowedAsset = data.bucket.borrowedAsset();\\n        data.priceOracle = data.positionManager.priceOracle();\\n\\n        uint256 multiplier1 = 10 ** (18 - data.borrowedAsset.decimals());\\n        uint256 denominator = (WadRayMath.WAD - data.positionManager.securityBuffer())\\n            .wmul(\\n                WadRayMath.WAD -\\n                    data.positionManager.getOracleTolerableLimit(_positionAsset, address(data.borrowedAsset))\\n            )\\n            .wmul(WadRayMath.WAD - data.priceOracle.getPairPriceDrop(_positionAsset, address(data.borrowedAsset)))\\n            .wmul(_positionAmount)\\n            .wmul(\\n                WadRayMath.WAD -\\n                    IPrimexDNSV3(_primexDNS).getProtocolFeeRateByTier(\\n                        IPrimexDNSStorageV3.FeeRateType.MarginPositionClosedByKeeper,\\n                        0 // we don't consider the tier in liquidation\\n                    )\\n            ) * 10 ** (18 - IERC20Metadata(_positionAsset).decimals());\\n        // numerator = data.bucket.feeBuffer().wmul(_positionDebt) * multiplier1;\\n        return (data.bucket.feeBuffer().wmul(_positionDebt) * multiplier1).wdiv(denominator) / multiplier1;\\n    }\\n\\n    /**\\n     * @notice Validates if a position meets the minimum size requirement.\\n     * @param _amount The amount of the asset in the position.\\n     * @param _asset The asset associated with the position.\\n     * @param _priceOracle The address of the price oracle contract.\\n     * @param _nativeAssetOracleData NativeCurrency => Asset\\n     */\\n    function validateMinPositionSize(\\n        uint256 _amount,\\n        address _asset,\\n        address _priceOracle,\\n        IKeeperRewardDistributorV3 _keeperRewardDistributor,\\n        IPrimexDNSV3 _primexDNS,\\n        IPrimexDNSStorageV3.TradingOrderType _tradingOrderType,\\n        bytes calldata _nativeAssetOracleData\\n    ) public {\\n        _require(\\n            isGreaterThanMinPositionSize(\\n                _asset,\\n                _amount,\\n                _priceOracle,\\n                _keeperRewardDistributor,\\n                _primexDNS,\\n                _tradingOrderType,\\n                _nativeAssetOracleData\\n            ),\\n            Errors.INSUFFICIENT_POSITION_SIZE.selector\\n        );\\n    }\\n\\n    /**\\n     * @notice Checks if the given amount of _asset corresponds to the minimum position size _minPositionSize,\\n     * based on the _minPositionAsset and the provided _priceOracle.\\n     * Returns true if the amount corresponds to or exceeds the minimum position size, otherwise returns false.\\n     * @param _asset The address of the asset being checked.\\n     * @param _amount The amount of _asset being checked.\\n     * @param _priceOracle The address of the price oracle contract.\\n     * @return A boolean value indicating whether the amount corresponds to or exceeds the minimum position size.\\n     */\\n    function isGreaterThanMinPositionSize(\\n        address _asset,\\n        uint256 _amount,\\n        address _priceOracle,\\n        IKeeperRewardDistributorV3 _keeperRewardDistributor,\\n        IPrimexDNSV3 _primexDNS,\\n        IPrimexDNSStorageV3.TradingOrderType _tradingOrderType,\\n        bytes calldata _nativeAssetOracleData\\n    ) public returns (bool) {\\n        uint256 minPositionSizeInNativeCurrency = minPositionSize(\\n            _priceOracle,\\n            _keeperRewardDistributor,\\n            _primexDNS,\\n            _tradingOrderType\\n        );\\n        uint256 minPositionSizeInAsset = getOracleAmountsOut(\\n            NATIVE_CURRENCY,\\n            _asset,\\n            minPositionSizeInNativeCurrency,\\n            _priceOracle,\\n            _nativeAssetOracleData\\n        );\\n        return _amount >= minPositionSizeInAsset;\\n    }\\n\\n    /**\\n     * @notice Decodes an encoded path and returns an array of addresses.\\n     * @param encodedPath The encoded path to be decoded.\\n     * @param dexRouter The address of the DEX router.\\n     * @param dexAdapter The address of the DEX adapter.\\n     * @return path An array of addresses representing the decoded path.\\n     */\\n    function decodePath(\\n        bytes memory encodedPath,\\n        address dexRouter,\\n        address payable dexAdapter\\n    ) public view returns (address[] memory path) {\\n        IDexAdapter.DexType type_ = IDexAdapter(dexAdapter).dexType(dexRouter);\\n\\n        if (type_ == IDexAdapter.DexType.UniswapV2 || type_ == IDexAdapter.DexType.Meshswap) {\\n            path = abi.decode(encodedPath, (address[]));\\n        } else if (type_ == IDexAdapter.DexType.UniswapV3) {\\n            uint256 skip;\\n            uint256 offsetSize = 23; // address size(20) + fee size(3)\\n            uint256 pathLength = encodedPath.length / offsetSize + 1;\\n            path = new address[](pathLength);\\n            for (uint256 i; i < pathLength; i++) {\\n                path[i] = encodedPath.toAddress(skip, encodedPath.length);\\n                skip += offsetSize;\\n            }\\n        } else if (type_ == IDexAdapter.DexType.Curve) {\\n            (path, ) = abi.decode(encodedPath, (address[], address[]));\\n        } else if (type_ == IDexAdapter.DexType.Balancer) {\\n            (path, , ) = abi.decode(encodedPath, (address[], bytes32[], int256[]));\\n        } else if (type_ == IDexAdapter.DexType.AlgebraV3) {\\n            uint256 skip;\\n            uint256 offsetSize = 20; // address size(20)\\n            uint256 pathLength = encodedPath.length / offsetSize;\\n            path = new address[](pathLength);\\n            for (uint256 i; i < pathLength; i++) {\\n                path[i] = encodedPath.toAddress(skip, encodedPath.length);\\n                skip += offsetSize;\\n            }\\n        } else {\\n            _revert(Errors.UNKNOWN_DEX_TYPE.selector);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the asset multiplier for a given asset.\\n     * @dev If the asset is the native currency, the function returns 1.\\n     * If the asset is USD, the function returns the value stored in the constant USD_MULTIPLIER.\\n     * For any other asset, the function calculates the multiplier based on the number of decimals of the token.\\n     * @param _asset The address of the asset.\\n     * @return The asset multiplier. It is a number with 10 raised to a power of decimals of a given asset.\\n     */\\n    function _getAssetMultiplier(address _asset) internal view returns (uint256) {\\n        if (_asset == NATIVE_CURRENCY) return 1;\\n        if (_asset == USD) return USD_MULTIPLIER;\\n\\n        return 10 ** (18 - IERC20Metadata(_asset).decimals());\\n    }\\n\\n    function _calculateL1CostWei(\\n        uint256 _baseLength,\\n        IKeeperRewardDistributorV3 _keeperRewardDistributor\\n    ) internal view returns (uint256 l1CostWei) {\\n        (\\n            ,\\n            ,\\n            uint256 optimisticGasCoefficient,\\n            IKeeperRewardDistributorStorage.PaymentModel paymentModel\\n        ) = _keeperRewardDistributor.getGasCalculationParams();\\n        if (paymentModel == IKeeperRewardDistributorStorage.PaymentModel.ARBITRUM) {\\n            return\\n                l1CostWei =\\n                    ARB_NITRO_ORACLE.getL1BaseFeeEstimate() *\\n                    GAS_FOR_BYTE *\\n                    (_baseLength + TRANSACTION_METADATA_BYTES);\\n        }\\n        if (paymentModel == IKeeperRewardDistributorStorage.PaymentModel.OPTIMISTIC) {\\n            return l1CostWei = OVM_GASPRICEORACLE.getL1FeeUpperBound(_baseLength).wmul(optimisticGasCoefficient);\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Utility function to get the minimum of two values\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Utility function to get the maximum of two values\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x40f873a6384754a225864dc07314334fa721dcecda7c5725f16cd8d8f9232f88\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/TokenTransfersLibrary.sol\":{\"content\":\"// Copyright 2020 Compound Labs, Inc.\\n// (c) 2024 Primex.finance\\n// SPDX-License-Identifier: BSD-3-Clause\\n\\n// Modified version of token transfer logic that allows working with non-standart ERC-20 tokens, added method doTransferFromTo,\\n// modified doTransferIn\\n\\npragma solidity 0.8.26;\\n\\nimport \\\"./Errors.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {EIP20NonStandardInterface} from \\\"../interfaces/EIP20NonStandardInterface.sol\\\";\\n\\nlibrary TokenTransfersLibrary {\\n    function doTransferIn(address token, address from, uint256 amount) public returns (uint256) {\\n        return doTransferFromTo(token, from, address(this), amount);\\n    }\\n\\n    function doTransferFromTo(address token, address from, address to, uint256 amount) public returns (uint256) {\\n        uint256 balanceBefore = IERC20(token).balanceOf(to);\\n        // The returned value is checked in the assembly code below.\\n        // Arbitrary `from` should be checked at a higher level. The library function cannot be called by the user.\\n        // slither-disable-next-line unchecked-transfer arbitrary-send-erc20\\n        EIP20NonStandardInterface(token).transferFrom(from, to, amount);\\n\\n        bool success;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            switch returndatasize()\\n            case 0 {\\n                // This is a non-standard ERC-20\\n                success := not(0) // set success to true\\n            }\\n            case 32 {\\n                // This is a compliant ERC-20\\n                returndatacopy(0, 0, 32)\\n                success := mload(0) // Set `success = returndata` of external call\\n            }\\n            default {\\n                // This is an excessively non-compliant ERC-20, revert.\\n                revert(0, 0)\\n            }\\n        }\\n        _require(success, Errors.TOKEN_TRANSFER_IN_FAILED.selector);\\n\\n        // Calculate the amount that was *actually* transferred\\n        uint256 balanceAfter = IERC20(token).balanceOf(to);\\n        _require(balanceAfter >= balanceBefore, Errors.TOKEN_TRANSFER_IN_OVERFLOW.selector);\\n\\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\\n    }\\n\\n    function doTransferOut(address token, address to, uint256 amount) public {\\n        // The returned value is checked in the assembly code below.\\n        // slither-disable-next-line unchecked-transfer\\n        EIP20NonStandardInterface(token).transfer(to, amount);\\n\\n        bool success;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            switch returndatasize()\\n            case 0 {\\n                // This is a non-standard ERC-20\\n                success := not(0) // set success to true\\n            }\\n            case 32 {\\n                // This is a complaint ERC-20\\n                returndatacopy(0, 0, 32)\\n                success := mload(0) // Set `success = returndata` of external call\\n            }\\n            default {\\n                // This is an excessively non-compliant ERC-20, revert.\\n                revert(0, 0)\\n            }\\n        }\\n        _require(success, Errors.TOKEN_TRANSFER_OUT_FAILED.selector);\\n    }\\n\\n    function doTransferOutETH(address to, uint256 value) internal {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        _require(success, Errors.NATIVE_TOKEN_TRANSFER_FAILED.selector);\\n    }\\n}\\n\",\"keccak256\":\"0x1d8585473739875d2f97e984ac6752b121a656bcded82f73c4b06174ab8786d9\",\"license\":\"BSD-3-Clause\"},\"contracts/libraries/utils/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// A modified version of BytesLib\\n// Origin: https://github.com/1inch/universal-router/blob/b972662f8d3f0ba55ef99411720f613f77c3fab5/contracts/modules/uniswap/v3/BytesLib.sol\\n// Unused methods and constants were removed\\npragma solidity 0.8.26;\\n\\nlibrary BytesLib {\\n    error ToAddressOverflow();\\n    error ToAddressOutOfBounds();\\n\\n    /// @notice Returns the address starting at byte `_start`\\n    /// @dev _bytesLength must equal _bytes.length for this to function correctly\\n    /// @param _bytes The input bytes string to slice\\n    /// @param _start The starting index of the address\\n    /// @param _bytesLength The length of _bytes\\n    /// @return tempAddress The address starting at _start\\n    function toAddress(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _bytesLength\\n    ) internal pure returns (address tempAddress) {\\n        unchecked {\\n            if (_start + 20 < _start) revert ToAddressOverflow();\\n            if (_bytesLength < _start + 20) revert ToAddressOutOfBounds();\\n        }\\n\\n        assembly {\\n            tempAddress := mload(add(add(_bytes, 0x14), _start))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x895f76434296e715d9b8c32552158963fd65a8a0351ac6d334ec0af7c3b6ccf0\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/utils/WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n// A modified version of ds-math library\\n// Origin: https://github.com/dapphub/ds-math/blob/master/src/math.sol\\n// Unused methods were removed, errors changed\\n\\npragma solidity 0.8.26;\\nerror DS_MATH_ADD_OVERFLOW();\\nerror DS_MATH_MUL_OVERFLOW();\\n\\nlibrary WadRayMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        if ((z = x + y) < x) revert DS_MATH_ADD_OVERFLOW();\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        if (!(y == 0 || (z = x * y) / y == x)) revert DS_MATH_MUL_OVERFLOW();\\n    }\\n\\n    uint256 internal constant WAD = 10 ** 18;\\n    uint256 internal constant RAY = 10 ** 27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    //rounds to zero if x*y < RAY / 2\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n}\\n\",\"keccak256\":\"0x49afef0dbc484e0e513c163ee4ce090a30fa061c47a262046c0a7311092a3756\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60a080604052346100f957602081615ef1803803809161001f82856100fe565b8339810103126100f957516001600160a01b0381168082036100f9576040516301ffc9a760e01b8152630452934760e01b600482015290602090829060249082905afa9081156100ed576000916100ab575b501561009957608052604051615db990816101388239608051818181610fc70152613e8b0152f35b60405163044aa57560e41b8152600490fd5b6020813d6020116100e5575b816100c4602093836100fe565b810103126100e157519081151582036100de575038610071565b80fd5b5080fd5b3d91506100b7565b6040513d6000823e3d90fd5b600080fd5b601f909101601f19168101906001600160401b0382119082101761012157604052565b634e487b7160e01b600052604160045260246000fdfe6102e080604052600436101561001457600080fd5b600090813560e01c90816301ffc9a7146116e75750806314fdc0731461169d57806316569dc1146114a657806336ca926314611253578063429bd6461461110957806344ec16141461106b5780634acefed4146110295780636629bf0a14610ff6578063679bfb5b14610fb15780636c5a9cd114610f7457806388782ed914610edd5780638ddbcc6214610ec25780639e09d40e14610e45578063a8d028b514610e03578063b23c434014610d9c578063b29d57d814610d40578063b3e1d9f214610cde578063bdf4cd1814610c7b578063d030bb2514610c53578063debd310d14610c24578063e10a27a4146109e4578063f107f834146108ca5763fa24cc661461011f57600080fd5b60a03660031901126108c75761013361173c565b6044356001600160401b0381116108c357610152903690600401611f3b565b926064356001600160401b0381116108bf57610172903690600401611860565b936084356001600160401b0381116108bb57610192903690600401611860565b604051632630c12f60e01b81526001600160a01b0390931696909391926020816004818b5afa90811561081757869161089c575b506001600160a01b031691823b156108985790859392916101fd6040519687958694859463f197ce3560e01b865260048601613af0565b039134905af1801561088d5761087d575b50906040519263eb02c30160e01b845260243560048501528284602481845afa93841561087257839461084e575b50604051632630c12f60e01b815290602082600481845afa918215610843578492610822575b5060a085018051606087018051604051631dae49b960e21b81526001600160a01b039384166004820152908316602482015292989094909160209184916044918391165afa9182156108175786926107e3575b506040516301ddf49360e61b8152602081600481875afa9081156106a85787916107b1575b5060405163084b557b60e21b815294602086600481885afa9586156107a6578896610770575b508951815160405163a8905dab60e01b81526001600160a01b03928316600482015291166024820152959660208780604481015b0381895afa938415610765578994610730575b60408b81018051915163280188b760e21b8152909d909950906020908a9060049082906001600160a01b03165afa98891561072557908c949392918c9a6106eb575b5051925160c09490940151604051632630c12f60e01b815290986001600160a01b039586169590941693602090829060049082905afa9081156106e05791602095949391610418938e916106b3575b506040519a8b96879663735aad2560e01b885260048801526024870152604486015260018060a01b0316606485015260a0608485015260a4840191613acf565b0381737A0FFAaEFbed420d00c5E60c1668693a8a26B88C5af49384156106a8578794610674575b50670de0b6b3a76400000390670de0b6b3a7640000821161066057670de0b6b3a76400000390670de0b6b3a76400008211610660579061047e91615d06565b90670de0b6b3a76400000390670de0b6b3a7640000821161064c576104ac92916104a791615d06565b615d06565b91670de0b6b3a7640000019081670de0b6b3a76400001161063857906104d191615d06565b90670de0b6b3a7640000808202938285048214831517156105b857806106245750830403610613576105148161050f60049460209460011c90615d6e565b615ce6565b93516040516368d0612f60e01b815292839182906001600160a01b03165afa8015610607576000906105ce575b6105519150602083015190615d37565b916b019d971e4fe8401e740000008301928381116105b85783106105a75761058c6080916b033b2e3c9fd0803ce8000000602095049061226a565b9101518082116105a057505b604051908152f35b9050610598565b630a77254f60e01b60005260046000fd5b634e487b7160e01b600052601160045260246000fd5b506020813d6020116105ff575b816105e860209383611cad565b810103126105fa576105519051610541565b600080fd5b3d91506105db565b6040513d6000823e3d90fd5b631550e8b760e01b60005260046000fd5b634e487b7160e01b81526012600452602490fd5b634e487b7160e01b84526011600452602484fd5b634e487b7160e01b86526011600452602486fd5b634e487b7160e01b87526011600452602487fd5b9093506020813d6020116106a0575b8161069060209383611cad565b810103126105fa5751923861043f565b3d9150610683565b6040513d89823e3d90fd5b6106d39150873d89116106d9575b6106cb8183611cad565b81019061224b565b386103d8565b503d6106c1565b6040513d8e823e3d90fd5b945098506020843d60201161071d575b8161070860209383611cad565b810103126105fa579251978b93906020610389565b3d91506106fb565b6040513d8d823e3d90fd5b93506020873d60201161075d575b8161074b60209383611cad565b810103126105fa576004965193610347565b3d915061073e565b6040513d8b823e3d90fd5b95506020863d60201161079e575b8161078b60209383611cad565b810103126105fa57610334955195610300565b3d915061077e565b6040513d8a823e3d90fd5b90506020813d6020116107db575b816107cc60209383611cad565b810103126105fa5751386102da565b3d91506107bf565b9091506020813d60201161080f575b816107ff60209383611cad565b810103126105fa575190386102b5565b3d91506107f2565b6040513d88823e3d90fd5b61083c91925060203d6020116106d9576106cb8183611cad565b9038610262565b6040513d86823e3d90fd5b61086b9194503d8085833e6108638183611cad565b810190612778565b923861023c565b6040513d85823e3d90fd5b8161088791611cad565b3861020e565b6040513d84823e3d90fd5b8580fd5b6108b5915060203d6020116106d9576106cb8183611cad565b386101c6565b8380fd5b5080fd5b8280fd5b80fd5b50346108c75760403660031901126108c7576004356001600160401b0381116108bf576108fb903690600401611860565b90610904611752565b9061090e8361200c565b9161091c6040519384611cad565b8383526109288461200c565b9361093b6020850195601f190186613597565b855b8181106109a957868587604051928392602084019060208552518091526040840160408260051b8601019392905b82821061097a57505050500390f35b919360019193955060206109998192603f198a820301865288516117c6565b960192019201859493919261096b565b806109c8846109c36109be600195878a61213f565b612165565b612b38565b6109d2828861220e565b526109dd818761220e565b500161093d565b50346108c75760203660031901126108c7576004356001600160401b0381116108bf57610a15903690600401611860565b610a1e8161200c565b91610a2c6040519384611cad565b818352601f19610a3b8361200c565b01845b818110610c0d575050835b828110610acf578385604051918291602083016020845282518091526020604085019301915b818110610a7d575050500390f35b91935091602060a060019269ffffffffffffffffffff60808851828151168452858101518685015260408101516040850152606081015160608501520151166080820152019401910191849392610a6f565b6001600160a01b03610ae56109be83868661213f565b1615610bfb5760049060a06001600160a01b03610b066109be84888861213f565b1660405193848092633fabe5a360e21b82525afa8015610817578687889089928a94610b9b575b6001965069ffffffffffffffffffff610b46878c61220e565b51911690526020610b57868b61220e565b5101526040610b66858a61220e565b5101526060610b75848961220e565b51015269ffffffffffffffffffff6080610b8f848961220e565b51019116905201610a49565b505050505060a0823d8211610bf3575b81610bb860a09383611cad565b810103126108985781610bcc600193615ccf565b6020820151916040810151610be8608060608401519301615ccf565b929390919293610b2d565b3d9150610bab565b60405163044aa57560e41b8152600490fd5b602090610c1861345b565b82828801015201610a3e565b50346108c757610c3f610c3636611f68565b92919091615ac3565b90610c4f60405192839283611fa6565b0390f35b50346108c75760403660031901126108c7576020610598610c7261173c565b60243590615880565b50346108c75760603660031901126108c757610c9561173c565b90602435906001600160401b0382116108c757610c4f610cca84610cbc3660048701612023565b610cc4611768565b916157e2565b60405191829160208352602083019061189f565b50346108c75760803660031901126108c757600435906001600160401b0382116108c757610c4f610d34610d153660048601612023565b610d1d611752565b610d25611768565b90610d2e611890565b9261543e565b60405191829182611b3f565b50346108c75760403660031901126108c7576080610d6d610d5f61173c565b610d67611752565b90615039565b610d9a60405180926060809180518452602081015115156020850152604081015160408501520151910152565bf35b50346108c75760403660031901126108c757610db661173c565b90602435906001600160401b0382116108c7576060610de284610ddc3660048701611ce9565b90614f7f565b610d9a60405180926040809180518452602081015160208501520151910152565b50346108c75760403660031901126108c757610c4f610e31610e2361173c565b610e2b611752565b90614403565b6040519182916020835260208301906118fa565b50346108c75760603660031901126108c757610e5f61173c565b90602435906001600160401b0382116108c75760a0610e9384610e853660048701611ce9565b610e8d611768565b916142e5565b604080518251815260208084015181830152928201518051828401529283015160608201529101516080820152f35b50346108c757610c3f610ed436611f68565b929190916140c9565b5060a03660031901126108c757610ef261173c565b6044356001600160401b0381116108c357610f11903690600401611f3b565b90926064356001600160401b0381116108bf57610f32903690600401611860565b929091608435906001600160401b0382116108c7576020610f6a8888888888610f5e3660048b01611860565b95909460243590613c28565b6040519015158152f35b50346108c75760403660031901126108c757610c4f610f9d610f9461173c565b60243590613672565b604051918291602083526020830190611e6e565b50346108c757806003193601126108c7576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346108c75760403660031901126108c7576004359060068210156108c757602061059883611023611752565b90612d5c565b50346108c75760403660031901126108c757610c4f61105761104961173c565b611051611752565b90612b38565b6040519182916020835260208301906117c6565b50346108c75761108361107d36611d30565b9161285d565b9190604051916040830160408452825180915260608401602060608360051b870101940192905b8282106110be578580868960208301520390f35b909192936020806110fb600193605f198a8203018652885190836110eb8351604084526040840190611dc4565b9201519084818403910152611d5a565b9601920192019092916110aa565b50346108c75761112161111b36611d30565b9161239e565b9190604051916040830160408452825180915260608401602060608360051b870101940192905b82821061115c578580868960208301520390f35b90919293602080611245600193605f198a8203018652885190836110eb6101a0845160408552898060a01b038151166040860152898060a01b0384820151166060860152898060a01b036040820151166080860152606081015160a0860152898060a01b0360808201511660c086015260a081015160e0860152898060a01b0360c08201511661010086015260e08101516101208601526101008101516101408601526101208101516101608601526101408101511515610180860152610160810151828601526101808101516101c086015201516101c06101e08501526102008401906117a1565b960192019201909291611148565b50346108c75760a03660031901126108c75761126d61173c565b6024356001600160401b0381116108c35761128c903690600401611ce9565b906064356001600160a01b038116918282036114a2576040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b039190911692602082602481875afa918215610817578692611466575b508161145c575b5015610bfb57602060049260405193848092633f4a2d2760e01b82525afa9182156108435761134592602091869161143f575b5060018060a01b0316936040518094819263af9a2aa760e01b835284600484015260248301906117a1565b0381865afa8015610843578490611405575b604051631839f03960e21b81526001600160a01b0391821660048201529181166024830152608480356044808501919091523560648401529316928101929092525060208160a481737A0FFAaEFbed420d00c5E60c1668693a8a26B88C5af490811561088d5782916113cf575b602082604051908152f35b90506020813d6020116113fd575b816113ea60209383611cad565b810103126108bf576020915051386113c4565b3d91506113dd565b506020823d602011611437575b8161141f60209383611cad565b810103126108bb57611432602092612179565b611357565b3d9150611412565b6114569150823d84116106d9576106cb8183611cad565b3861131a565b90501515386112e7565b9091506020813d60201161149a575b8161148260209383611cad565b81010312610898576114939061223e565b90386112e0565b3d9150611475565b8480fd5b50346108c75760803660031901126108c7576004356001600160401b0381116108bf576114d7903690600401611860565b91906114e1611752565b6114e9611768565b6114f1611890565b946114fb8161200c565b936115096040519586611cad565b818552601f196115188361200c565b01865b81811061168c575050855b82811061160d57505050839484955b845187101561155e5761155660019161154e898861220e565b515190612222565b960195611535565b90849186939461156d8261200c565b9161157b6040519384611cad565b80835261158a601f199161200c565b013660208401378495855b85518710156115fe5780975b6115ab888861220e565b51518910156115f1576001906115e9906001600160a01b036115d78c6115d18d8d61220e565b5161220e565b51166115e3828961220e565b5261222f565b9801976115a1565b9750600190960195611595565b50610c4f9391610d349361543e565b6004876001600160a01b036116266109be85888861213f565b166040519283809263f9776bcb60e01b82525afa9081156107a6579060019291899161166a575b50611658828961220e565b52611663818861220e565b5001611526565b61168691503d808b833e61167e8183611cad565b81019061218d565b3861164d565b806060602080938a0101520161151b565b50346108c75760603660031901126108c757610c4f6116d36116bd61173c565b6116c5611752565b6116cd611768565b9161210a565b604051918291602083526020830190611817565b9050346108bf5760203660031901126108bf5760043563ffffffff60e01b81168091036108c3576020925063055e0aa960e51b811490811561172b575b5015158152f35b6301ffc9a760e01b14905038611724565b600435906001600160a01b03821682036105fa57565b602435906001600160a01b03821682036105fa57565b604435906001600160a01b03821682036105fa57565b60005b8381106117915750506000910152565b8181015183820152602001611781565b906020916117ba8151809281855285808601910161177e565b601f01601f1916010190565b9060018060a01b0382511681526080806118046117f2602086015160a0602087015260a08601906117a1565b604086015185820360408701526117a1565b9360608101516060850152015191015290565b9061185d90602080611832855160a0855260a08501906117c6565b9401519101906060809180518452602081015115156020850152604081015160408501520151910152565b90565b9181601f840112156105fa578235916001600160401b0383116105fa576020808501948460051b0101116105fa57565b6064359081151582036105fa57565b9080602083519182815201916020808360051b8301019401926000915b8383106118cb57505050505090565b90919293946020806118e9600193601f198682030187528951611817565b970193019301919392906118bc565b565b9060018060a01b0382511681526105006102c06119d26119be6119aa611946611934602089015161052060208a01526105208901906117a1565b604089015188820360408a01526117c6565b6001600160801b0360608901511660608801526001600160801b03608089015116608088015260a088015160a088015260c088015160c088015260e088015160e088015261010088015161010088015261012088015187820361012089015261189f565b6101408701518682036101408801526117c6565b6101608601518582036101608701526117c6565b936101808101516101808501526101a08101516101a08501526101006101c082015160018060a01b038151166101c0870152602081015115156101e087015260408101516102008701526060810151610220870152608081015161024087015260a081015161026087015260c081015161028087015260e08101516102a0870152015182850152611a956101e08201516102e086019080518252602080820151818401526040918201518051838501529081015160608401520151608090910152565b610200810151805161038086015260208101516103a0860152604001516103c08501526001600160801b03610220820151166103e08501526001600160801b03610240820151166104008501526102608101511515610420850152610280810151151561044085015260806102a08201518051610460870152602081015161048087015260408101516104a087015260608101516104c087015201516104e0850152015191015290565b602081016020825282518091526040820191602060408360051b8301019401926000915b838310611b7257505050505090565b9091929394602080611b90600193603f1986820301875289516118fa565b97019301930191939290611b63565b60a081019081106001600160401b03821117611bba57604052565b634e487b7160e01b600052604160045260246000fd5b608081019081106001600160401b03821117611bba57604052565b604081019081106001600160401b03821117611bba57604052565b6101c081019081106001600160401b03821117611bba57604052565b61018081019081106001600160401b03821117611bba57604052565b606081019081106001600160401b03821117611bba57604052565b6102e081019081106001600160401b03821117611bba57604052565b61012081019081106001600160401b03821117611bba57604052565b61016081019081106001600160401b03821117611bba57604052565b90601f801991011681019081106001600160401b03821117611bba57604052565b6001600160401b038111611bba57601f01601f191660200190565b81601f820112156105fa57803590611d0082611cce565b92611d0e6040519485611cad565b828452602083830101116105fa57816000926020809301838601378301015290565b60609060031901126105fa576004356001600160a01b03811681036105fa57906024359060443590565b9080602083519182815201916020808360051b8301019401926000915b838310611d8657505050505090565b9091929394602080611db5600193601f198682030187526040838b5180518452015191818582015201906117a1565b97019301930191939290611d77565b9061018061016061185d93805184526020810151602085015260018060a01b03604082015116604085015260018060a01b0360608201511660608501526080810151608085015260018060a01b0360a08201511660a085015260c081015160c085015260018060a01b0360e08201511660e08501526101008101516101008501526101208101516101208501526101408101516101408501520151918161016082015201906117a1565b919082518152611e8f602084015161016060208401526101608301906118fa565b6040848101518383038285015290820192916000815b60028210611f14575050505061014084606061185d9596015160608401526080810151608084015260a081015160a084015260c081015160c084015260e081015160e08401526101008101516101008401526101208101516101208401520151906101408184039101526117a1565b90919294602080611f2d838760019503865289516117c6565b970192019201909291611ea5565b9181601f840112156105fa578235916001600160401b0383116105fa57602083818601950101116105fa57565b60809060031901126105fa576004356001600160a01b03811681036105fa57906024356001600160a01b03811681036105fa57906044359060643590565b92919060408401906040855280518092526060850191602060608260051b8801019201926000905b828210611fe15750505060209150930152565b909192602080611ffd600193605f198c82030186528851611e6e565b96019201920190939291611fce565b6001600160401b038111611bba5760051b60200190565b9080601f830112156105fa5781359061203b8261200c565b926120496040519485611cad565b82845260208085019360051b8201019182116105fa57602001915b8183106120715750505090565b82356001600160a01b03811681036105fa57815260209283019201612064565b6040519061209e82611b9f565b600060808382815260606020820152606060408201528260608201520152565b604051906120cb82611bd0565b60006060838281528260208201528260408201520152565b604051906120f082611beb565b816120f9612091565b815260206121056120be565b910152565b91906121226121289261211b6120e3565b5082612b38565b92615039565b6040519161213583611beb565b8252602082015290565b919081101561214f5760051b0190565b634e487b7160e01b600052603260045260246000fd5b356001600160a01b03811681036105fa5790565b51906001600160a01b03821682036105fa57565b6020818303126105fa578051906001600160401b0382116105fa57019080601f830112156105fa5781516121c08161200c565b926121ce6040519485611cad565b81845260208085019260051b8201019283116105fa57602001905b8282106121f65750505090565b6020809161220384612179565b8152019101906121e9565b805182101561214f5760209160051b010190565b919082018092116105b857565b60001981146105b85760010190565b519081151582036105fa57565b908160209103126105fa57516001600160a01b03811681036105fa5790565b919082039182116105b857565b9092919261228481611cce565b916122926040519384611cad565b8294828452828201116105fa5760206118f893019061177e565b9080601f830112156105fa57815161185d92602001612277565b6020818303126105fa578051906001600160401b0382116105fa57019080601f830112156105fa578151916122fa8361200c565b926123086040519485611cad565b80845260208085019160051b830101918383116105fa5760208101915b83831061233457505050505090565b82516001600160401b0381116105fa578201906040828703601f1901126105fa576040519061236282611beb565b602083015182526040830151916001600160401b0383116105fa5761238f886020809695819601016122ac565b83820152815201920191612325565b6040516301ffc9a760e01b815263fabd349d60e01b6004820152600094936001600160a01b039092169190602081602481865afa9081156106075760009161273e575b5015610bfb576040516301f0b85b60e21b815290602082600481865afa9182156106075760009261270a575b50818410156126fc57816124218286612222565b106126e75750826124319161226a565b905b61243c8261200c565b9261244a6040519485611cad565b828452601f196124598461200c565b0160005b81811061265457505060005b83811061247857505050509190565b6124828183612222565b6040519063dabe8a7160e01b82526004820152600081602481875afa90811561060757600091612530575b506124b8828761220e565b51526101006124c7828761220e565b515101519060405191635973af3960e01b83526004830152600082602481875afa80156106075760019260009161250f575b506020612506838961220e565b51015201612469565b61252a913d8091833e6125228183611cad565b8101906122c6565b386124f9565b3d8083833e61253f8183611cad565b8101906020818303126108c3578051906001600160401b0382116108bb5701916101c0838303126108c7576040519261257784611c06565b61258081612179565b845261258e60208201612179565b602085015261259f60408201612179565b6040850152606081015160608501526125ba60808201612179565b608085015260a081015160a08501526125d560c08201612179565b60c085015260e081015160e0850152610100810151610100850152610120810151610120850152612609610140820161223e565b6101408501526101608101516101608501526101808101516101808501526101a0810151916001600160401b0383116108c757506126489291016122ac565b6101a0820152386124ad565b60209060405161266381611beb565b60405161266f81611c06565b60008152600084820152600060408201526000606082015260006080820152600060a0820152600060c0820152600060e08201526000610100820152600061012082015260006101408201526000610160820152600061018082015260606101a082015281526060838201528282890101520161245d565b809295506126f6915083612222565b93612433565b505050509050606090600090565b90916020823d602011612736575b8161272560209383611cad565b810103126108c7575051903861240d565b3d9150612718565b90506020813d602011612770575b8161275960209383611cad565b810103126105fa5761276a9061223e565b386123e1565b3d915061274c565b6020818303126105fa578051906001600160401b0382116105fa5701610180818303126105fa57604051916127ac83611c22565b81518352602082015160208401526127c660408301612179565b60408401526127d760608301612179565b6060840152608082015160808401526127f260a08301612179565b60a084015260c082015160c084015261280d60e08301612179565b60e08401526101008201516101008401526101208201516101208401526101408201516101408401526101608201516001600160401b0381116105fa5761285492016122ac565b61016082015290565b6040516301ffc9a760e01b8152633d79d7fb60e11b6004820152600094936001600160a01b039092169190602081602481865afa90811561060757600091612ac8575b5015610bfb57604051630d96c0f960e21b815290602082600481865afa91821561060757600092612a94575b50818410156126fc57816128e08286612222565b10612a7f5750826128f09161226a565b905b6128fb8261200c565b926129096040519485611cad565b828452601f196129188461200c565b0160005b8181106129fc57505060005b83811061293757505050509190565b6129418183612222565b604051906344ff7dc360e01b82526004820152600081602481875afa908115610607576000916129e3575b50612977828761220e565b5152612983818661220e565b5151519060405191631d40683560e31b83526004830152600082602481875afa8015610607576001926000916129ca575b5060206129c1838961220e565b51015201612928565b6129dd913d8091833e6125228183611cad565b386129b4565b6129f6913d8091833e6108638183611cad565b3861296c565b602090604051612a0b81611beb565b604051612a1781611c22565b60008152600084820152600060408201526000606082015260006080820152600060a0820152600060c0820152600060e0820152600061010082015260006101208201526000610140820152606061016082015281526060838201528282890101520161291c565b80929550612a8e915083612222565b936128f2565b90916020823d602011612ac0575b81612aaf60209383611cad565b810103126108c757505190386128cc565b3d9150612aa2565b90506020813d602011612afa575b81612ae360209383611cad565b810103126105fa57612af49061223e565b386128a0565b3d9150612ad6565b6020818303126105fa578051906001600160401b0382116105fa57019080601f830112156105fa57815161185d92602001612277565b612b40612091565b506001600160a01b0316908115610bfb576040516395d89b4160e01b815290600082600481865afa91821561060757600092612cce575b506040516306fdde0360e01b815290600082600481875afa91821561060757600092612ca9575b5060405163313ce56760e01b8152602081600481885afa90811561060757600091612c6d575b506001600160a01b03909116918215612c6157604051926370a0823160e01b84526004840152602083602481885afa801561060757600090612c2e575b60ff9350935b60405195612c1487611b9f565b865260208601526040850152166060830152608082015290565b506020833d602011612c59575b81612c4860209383611cad565b810103126105fa5760ff9251612c01565b3d9150612c3b565b60ff9250600093612c07565b6020813d602011612ca1575b81612c8660209383611cad565b810103126108bf57519060ff821682036108c7575038612bc4565b3d9150612c79565b612cc79192503d806000833e612cbf8183611cad565b810190612b02565b9038612b9e565b612ce49192503d806000833e612cbf8183611cad565b9038612b77565b91908260809103126105fa578151916020810151916060604083015192015160038110156105fa5790565b60031115612d2057565b634e487b7160e01b600052602160045260246000fd5b818102929181159184041417156105b857565b919060208301926006821015612d205752565b604051632630c12f60e01b81526001600160a01b0390921691602081600481865afa908115610607576000916133fa575b50604051637496a94d60e11b8152602081600481875afa908115610607576000916133db575b50612dbc6120be565b60405163455259cb60e01b81523a93602090829060049082906001600160a01b03165afa908115610607576000916133a8575b508152604051632c18d6af60e21b815291608090839060049082906001600160a01b03165afa91821561060757600090600093613382575b50826040830152806060830152815192600084136000146133755750670de0b6b3a7640000019182670de0b6b3a7640000116105b857602092612e6991615d06565b9182915b0152803a11801561336d575b613365575b50604051637496a94d60e11b815291602083600481875afa92831561060757600493608091600091613346575b50604051632c18d6af60e21b815294859182906001600160a01b03165afa9384156106075760009360009561330c575b50604051633f4a2d2760e01b815293602085600481855afa948515610607576004956020916000916132ef575b506040516324890e1560e21b815296879182906001600160a01b03165afa948515610607576000956132bb575b50600095612f4281612d16565b8061301a575b5050602060049160405192838092633f4a2d2760e01b82525afa91821561060757612f9492602092600091612ffd575b50604051808095819463ee42b2d160e01b835260048301612d49565b03916001600160a01b03165afa90811561060757600091612fc7575b5092612fc2612fc29261185d95612d36565b612222565b9390506020843d602011612ff5575b81612fe360209383611cad565b810103126105fa579251612fc2612fb0565b3d9150612fd6565b6130149150833d85116106d9576106cb8183611cad565b38612f78565b61302381612d16565b60018114613174575b60029061303881612d16565b146130435780612f48565b9450600491925060209060405192838092633f4a2d2760e01b82525afa9182156106075761309292602092600091613157575b5060405180809581946306bdf5b760e21b835260048301612d49565b03916001600160a01b03165afa90811561060757600091613125575b5060405163f1c7a58b60e01b81526004810191909152602081602481600f602160991b015afa908115610607576000916130f1575b5061185d92612fc291615d06565b90506020813d60201161311d575b8161310c60209383611cad565b810103126105fa575161185d6130e3565b3d91506130ff565b90506020813d60201161314f575b8161314060209383611cad565b810103126105fa5751386130ae565b3d9150613133565b61316e9150833d85116106d9576106cb8183611cad565b38613076565b60405163f5d6ded760e01b8152909650602081600481606c5afa90811561060757600091613289575b508060041b90808204601014901517156105b857604051633f4a2d2760e01b815290602082600481875afa91821561060757600092613268575b50602060405180936306bdf5b760e21b825281806131f88a60048301612d49565b03916001600160a01b03165afa91821561060757600092613234575b50608c82018092116105b85760029161322c91612d36565b96905061302c565b90916020823d602011613260575b8161324f60209383611cad565b810103126108c75750519038613214565b3d9150613242565b61328291925060203d6020116106d9576106cb8183611cad565b90386131d7565b906020823d6020116132b3575b816132a360209383611cad565b810103126108c75750513861319d565b3d9150613296565b90946020823d6020116132e7575b816132d660209383611cad565b810103126108c75750519338612f35565b3d91506132c9565b6133069150823d84116106d9576106cb8183611cad565b38612f08565b90945061333291935060803d60801161333f575b61332a8183611cad565b810190612ceb565b9492509050929338612edb565b503d613320565b61335f915060203d6020116106d9576106cb8183611cad565b38612eab565b905038612e7e565b503a15612e79565b9250829160209150612e6d565b905061339e91925060803d60801161333f5761332a8183611cad565b5050919038612e27565b90506020813d6020116133d3575b816133c360209383611cad565b810103126105fa57516004612def565b3d91506133b6565b6133f4915060203d6020116106d9576106cb8183611cad565b38612db3565b613413915060203d6020116106d9576106cb8183611cad565b38612d8d565b6040519061342682611c3e565b60006040838281528260208201520152565b6040519061344582611c3e565b8160008152600060208201526040612105613419565b6040519061346882611b9f565b60006080838281528260208201528260408201528260608201520152565b6040519061349382611c59565b60006102c083828152606060208201526134ab612091565b60408201528260608201528260808201528260a08201528260c08201528260e08201528261010082015260606101208201526134e5612091565b6101408201526134f3612091565b61016082015282610180820152826101a082015260405161351381611c75565b8381528360208201528360408201528360608201528360808201528360a08201528360c08201528360e0820152836101008201526101c0820152613555613438565b6101e0820152613563613419565b6102008201528261022082015282610240820152826102608201528261028082015261358d61345b565b6102a08201520152565b60005b8281106135a657505050565b6020906135b1612091565b818401520161359a565b604051906135c882611c91565b81600081526135d5613486565b602082015260408051906135e98183611cad565b60005b8181106136355750916101409160609382015260008382015260006080820152600060a0820152600060c0820152600060e0820152600061010082015260006101208201520152565b602090613640612091565b81850152016135ec565b908160409103126105fa5760206040519161366483611beb565b805183520151602082015290565b9061367b6135bb565b506040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b0383169290602081602481875afa90811561060757600091613a95575b5015610bfb5760405163eb02c30160e01b815260048101839052600081602481875afa90811561060757600091613a7c575b50604081810180519151632f60fad360e21b81526004810186905290936001600160a01b0390921615916020826024818a5afa91821561060757600092613a48575b50613737613486565b948315613a22575b50604051631d40683560e31b8152600481018790526000816024818b5afa90811561060757600091613a09575b50604051600061377b82611beb565b80825260208201529760005b82518110156139fb57604051633f4a2d2760e01b8152602081600481865afa908115610607576000916139dd575b5060206137c2838661220e565b51516040516352ff146960e11b8152600481019190915291829060249082906001600160a01b03165afa9081156106075760009161399f575b506040516301ffc9a760e01b8152630452934760e01b600482015290602090829060249082906001600160a01b03165afa90811561060757600091613966575b508061394e575b61384e57600101613787565b6138789394959697989950613866915060209261220e565b5101516020808251830101910161364a565b6138e28551976040519561388b87611beb565b1561394457606087015160e08801516138b0916001600160a01b039182169116612b38565b865260a087015160e08801516138d2916001600160a01b039182169116612b38565b602087015260c087015193615880565b6020820151915192608087015195610160610120890151980151986040519a61390a8c611c91565b8b5260208b015260408a01526060890152608088015260a087015260c086015260e085015261010084015261012083015261014082015290565b60408801516138b0565b50602061395b828561220e565b510151511515613842565b906020823d8211613997575b8161397f60209383611cad565b810103126108c757506139919061223e565b3861383b565b3d9150613972565b906020823d82116139d5575b816139b860209383611cad565b810103126108c7575060206139ce602492612179565b91506137fb565b3d91506139ab565b6139f5915060203d81116106d9576106cb8183611cad565b386137b5565b505050909192939495613878565b613a1c913d8091833e6125228183611cad565b3861376c565b5160e0850151919550613a41916001600160a01b039081169116614403565b933861373f565b9091506020813d602011613a74575b81613a6460209383611cad565b810103126105fa5751903861372e565b3d9150613a57565b613a8f913d8091833e6108638183611cad565b386136ec565b90506020813d602011613ac7575b81613ab060209383611cad565b810103126105fa57613ac19061223e565b386136ba565b3d9150613aa3565b908060209392818452848401376000828201840152601f01601f1916010190565b9082604083016040845252606082019060608460051b840101938192600092601e19813603015b838510613b4d57505050505050602081830391015282815260018060fb1b0383116105fa5760209260051b809284830137010190565b909192939496605f198782030184528735828112156105fa57830180359160208201926001600160401b0381116105fa578060051b9182360385136105fa5792908084526020808501938501019493600092603e19813603015b838510613bcb57505050505050506020806001929901940195019392949190613b17565b90919293949596601f198482030187528735828112156105fa57830190604060208301359201916001600160401b0381116105fa5780360383136105fa57613c196020928392600195613acf565b99019701950193929190613ba7565b6040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b03909116976000979396959293909290916020816024818d5afa90811561076557899161403b575b5015610bfb5760405163eb02c30160e01b8152600481018590529588876024818d5afa96871561076557899761401f575b5060405194631d40683560e31b8652600486015288856024818d5afa948515610765578995614003575b50604051632630c12f60e01b81526020816004818e5afa908115613ff8578a91613fd9575b506001600160a01b031691823b15613fd5579089939291613d286040519687958694859463f197ce3560e01b865260048601613af0565b039134905af1801561081757613fc1575b50805115613fb857604051613d4d81611beb565b600081526000602082015295855b8251811015613fa257604051633f4a2d2760e01b8152602081600481865afa9081156107a6578891613f84575b506020613d95838661220e565b51516040516352ff146960e11b8152600481019190915291829060249082906001600160a01b03165afa9081156107a6578891613f46575b506040516301ffc9a760e01b8152630452934760e01b600482015290602090829060249082906001600160a01b03165afa9081156107a6578891613f09575b50613e1957600101613d5b565b602095969750613e6f94939150613e4986613e388193613e869661220e565b51015182808251830101910161364a565b015190604051968795869563a455976760e01b8752606060048801526064870190611dc4565b926024860152600319858403016044860152613acf565b0381857f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af1918215613efd578092613ec757505090565b9091506020823d602011613ef5575b81613ee360209383611cad565b810103126108c7575061185d9061223e565b3d9150613ed6565b604051903d90823e3d90fd5b90506020813d8211613f3e575b81613f2360209383611cad565b81010312613f3a57613f349061223e565b38613e0c565b8780fd5b3d9150613f16565b90506020813d8211613f7c575b81613f6060209383611cad565b81010312613f3a576020613f75602492612179565b9150613dcd565b3d9150613f53565b613f9c915060203d81116106d9576106cb8183611cad565b38613d88565b50505090613e86613e6f92602080959697613e49565b50505050905090565b85613fce91969296611cad565b9338613d39565b8980fd5b613ff2915060203d6020116106d9576106cb8183611cad565b38613cf1565b6040513d8c823e3d90fd5b6140189195503d808b833e6125228183611cad565b9338613ccc565b6140349197503d808b833e6108638183611cad565b9538613ca2565b90506020813d602011614071575b8161405660209383611cad565b8101031261406d576140679061223e565b38613c71565b8880fd5b3d9150614049565b906140838261200c565b6140906040519182611cad565b82815280926140a1601f199161200c565b019060005b8281106140b257505050565b6020906140bd6135bb565b828285010152016140a6565b6040516301ffc9a760e01b8152633d79d7fb60e11b6004820152600095946001600160a01b0383169391602081602481885afa908115610607576000916142ab575b5080614299575b15610bfb57604051636bb1c52360e11b81526001600160a01b038316600482015290602082602481885afa91821561060757600092614265575b508186101561425557816141608288612222565b106142405750846141709161226a565b925b61417b84614079565b9460005b858110614190575050505050509190565b6141cf602061419f8385612222565b604051632906d3a960e21b81526001600160a01b0388166004820152602481019190915291829081906044820190565b0381875afa9081156106075760009161420d575b50906141f160019287613672565b6141fb828a61220e565b52614206818961220e565b500161417f565b906020823d8211614238575b8161422660209383611cad565b810103126108c75750516141f16141e3565b3d9150614219565b8094975061424f915085612222565b95614172565b5050505050509050606090600090565b90916020823d602011614291575b8161428060209383611cad565b810103126108c7575051903861414c565b3d9150614273565b506001600160a01b0382161515614112565b90506020813d6020116142dd575b816142c660209383611cad565b810103126105fa576142d79061223e565b3861410b565b3d91506142b9565b91906142ef613438565b506142f8613438565b926001600160a01b03169081156143de5760a091614334916040518095819482936311ddedf160e01b84526060600485015260648401906117a1565b90600180881b0316602483015242604483015203915afa908115610607576000918291839161436e575b5060408401526020830152815290565b9150508060a03d60a0116143d7575b6143878183611cad565b8101039160a083126108c7578151906060602084015194603f1901126108c757506080604051926143b784611c3e565b60408101518452606081015160208501520151604083015291903861435e565b503d61437d565b50505090565b908160209103126105fa57516001600160801b03811681036105fa5790565b9061440c613486565b506040516301ffc9a760e01b815260006102c052633aa17d5560e11b60048201526020816024816001600160a01b0387165afa908115614b0b576102c05191614f45575b5015610bfb57604051637437535960e01b8152916020836004816001600160a01b0385165afa928315614b0b576102c05193614f11575b50604051631f1b131360e31b81526020816004816001600160a01b0386165afa908115614b0b576004916020916102c05191614ef4575b506040516318160ddd60e01b815292839182906001600160a01b03165afa908115614b0b576102c05191614ec2575b506144f88482612222565b908115614eb9576b033b2e3c9fd0803ce800000081810290821583830482141715614e9f578104829003610613578261050f614538928260011c90615d6e565b604051630783377560e51b81526102c051816004816001600160a01b0389165afa908115614b0b576145779187916102c05191614e82575b50866157e2565b604051634c66358f60e11b815296909190610120886004816001600160a01b038a165afa978815614b0b576102c05198614dd3575b506040516307c0e8c160e31b81526020816004816001600160a01b038b165afa908115614b0b576102c05191614d90575b5060405163ddce491760e01b81526001600160a01b038881166004830152909160a09183916024918391165afa8015614b0b576102c0516102a052614d24575b506040516306fdde0360e01b81526102c051816004816001600160a01b038b165afa8015614b0b576102c05160c052614d05575b5060405163011ddaef60e71b81526020816004816001600160a01b038b165afa908115614b0b576146979189916102c05191614ca2575b506001600160a01b0316612b38565b61028052604051637f5d87bf60e11b81526020816004816001600160a01b038b165afa8015614b0b576102c05161026052614ce3575b5060405163905e383760e01b81526020816004816001600160a01b038b165afa8015614b0b576102c05161024052614cc1575b506040516358a06f0760e01b81526020816004816001600160a01b038b165afa908115614b0b576147459189916102c05191614ca257506001600160a01b0316612b38565b604051631f1b131360e31b81529094906020816004816001600160a01b038c165afa908115614b0b5761478c918a916102c05191614ca257506001600160a01b0316612b38565b60405163280188b760e21b8152979096906020896004816001600160a01b0385165afa988915614b0b576102c05199614c6e575b5060405163a223f82160e01b81529960208b6004816001600160a01b0386165afa9a8b15614b0b576102c0519b614c3a575b508b516040516306fdde0360e01b81526102c0519092916001600160a01b0390811691908490600490829088165afa908115614b0b5761483c936102c05192614c1b575b506142e5565b60e0528a516040516306fdde0360e01b81526102c05190916001600160a01b0390811691908390600490829087165afa908115614b0b57614887926102c05192614bfc575b50614f7f565b61014052604051635ea24eef60e11b81526020816004816001600160a01b0386165afa8015614b0b576102c05161022052614bda575b506040516327c37b2560e01b81526020816004816001600160a01b0386165afa8015614b0b576102c0516101e052614ba8575b50604051610200818152630c71782360e41b909152516020906004816001600160a01b0385165afa6101c0526101c05115614b0b576102c0516101a0526101c051614b64575b604051610180818152634ad09aa560e01b909152516020906004816001600160a01b0385165afa610160526101605115614b0b576102c0516101205261016051614b19575b6040516371a6cab760e01b81526020816004816001600160a01b0386165afa610100526101005115614b0b576102c05160a05261010051614ad8575b506040516080526149c9608051611c59565b60018060a01b03166080515260c0516020608051015261028051604060805101526001600160801b036102605116606060805101526001600160801b03610240511660808051015260a0608051015260c0608051015260e06080510152610100608051015261012060805101526101406080510152610160608051015261018060805101526101a060805101526101c0608051015260e0516101e060805101526101405161020060805101526001600160801b03610220511661022060805101526001600160801b036101e0511661024060805101526101a0511515610260608051015261012051151561028060805101526102a0516102a0608051015260a0516102c0608051015260805190565b6020813d602011614b03575b81614af160209383611cad565b810103126105fa575160a052386149b7565b3d9150614ae4565b6040513d6102c051823e3d90fd5b60203d602011614b5d575b80614b3460209261018051611cad565b610180519081010312614b5657614b4d6101805161223e565b6101205261497b565b6102c05180fd5b503d614b24565b60203d602011614ba1575b80614b7f60209261020051611cad565b610200519081010312614b5657614b986102005161223e565b6101a052614936565b503d614b6f565b614bc99060203d602011614bd3575b614bc18183611cad565b8101906143e4565b6101e052386148f0565b503d614bb7565b614bf29060203d602011614bd357614bc18183611cad565b61022052386148bd565b614c149192503d806102c051833e612cbf8183611cad565b9038614881565b614c339192503d806102c051833e612cbf8183611cad565b9038614836565b909a506020813d602011614c66575b81614c5660209383611cad565b810103126105fa575199386147f2565b3d9150614c49565b9098506020813d602011614c9a575b81614c8a60209383611cad565b810103126105fa575197386147c0565b3d9150614c7d565b614cbb915060203d6020116106d9576106cb8183611cad565b38614688565b614cd99060203d602011614bd357614bc18183611cad565b6102405238614700565b614cfb9060203d602011614bd357614bc18183611cad565b61026052386146cd565b614d1b903d806102c051833e612cbf8183611cad565b60c05238614651565b60a0813d60a011614d88575b81614d3d60a09383611cad565b81010312614b565760405190608090614d5583611b9f565b80518352602081015160208401526040810151604084015260608101516060840152015160808201526102a0523861461d565b3d9150614d30565b90506020813d602011614dcb575b81614dab60209383611cad565b81010312614b5657516001600160a01b0381168103614b565760a06145dd565b3d9150614d9e565b909750610120813d8211614e7a575b81614df06101209383611cad565b81010312614b565760405190614e0582611c75565b8051906001600160a01b0382168203614b5657610100918352614e2a6020820161223e565b602084015260408101516040840152606081015160608401526080810151608084015260a081015160a084015260c081015160c084015260e081015160e0840152015161010082015296386145ac565b3d9150614de2565b614e9991503d806102c051833e61167e8183611cad565b38614570565b634e487b7160e01b6102c05152601160045260246102c051fd5b6102c051614538565b90506020813d602011614eec575b81614edd60209383611cad565b81010312614b565751386144ed565b3d9150614ed0565b614f0b9150823d84116106d9576106cb8183611cad565b386144be565b9092506020813d602011614f3d575b81614f2d60209383611cad565b81010312614b5657519138614487565b3d9150614f20565b90506020813d602011614f77575b81614f6060209383611cad565b81010312614b5657614f719061223e565b38614450565b3d9150614f53565b90614f88613419565b50614f91613419565b916001600160a01b0316801561503457614fcb91606091604051808095819463230fa49560e21b83526020600484015260248301906117a1565b03915afa9081156106075760009182918391614ff1575060408401526020830152815290565b929150506060823d60601161502c575b8161500e60609383611cad565b810103126108c757508051604060208301519201519091903861435e565b3d9150615001565b505090565b6150416120be565b506040516301ffc9a760e01b8152633aa17d5560e11b60048201526001600160a01b039190911690602081602481855afa90811561060757600091615404575b50806153f2575b15610bfb57604051631e46e62f60e21b8152602081600481855afa908115610607576000916153b0575b50604051632630c12f60e01b8152906001600160a01b0316602082600481845afa9182156106075760009261538f575b5060405163011ddaef60e71b8152602081600481875afa80156106075761514493602092600092615370575b50604051634858138f60e01b81526001600160a01b03888116600483015290921660248301529093849190829081906044820190565b03916001600160a01b03165afa9182156106075760009261533c575b506040805163a4c1cccb60e01b81526001600160a01b0386166004820152949085602481875afa918215610607576000956000936152f4575b5090602060049260405193848092633f4a2d2760e01b82525afa918215610607576044926020916000916152d7575b506040516345a1aa4160e11b8152600260048201526000602482015293849182906001600160a01b03165afa918215610607576000926152a1575b50604051633623869b60e01b81526001600160a01b03909116600482015260248101919091529260209084908180604481015b03915afa9283156106075760009361526d575b506040519361525785611bd0565b8452151560208401526040830152606082015290565b9092506020813d602011615299575b8161528960209383611cad565b810103126105fa57519138615249565b3d915061527c565b91506020823d6020116152cf575b816152bc60209383611cad565b810103126105fa57905190615236615203565b3d91506152af565b6152ee9150823d84116106d9576106cb8183611cad565b386151c8565b955091506040853d604011615334575b8161531160409383611cad565b810103126105fa57600490602061532b818851980161223e565b93919250615199565b3d9150615304565b9091506020813d602011615368575b8161535860209383611cad565b810103126105fa57519038615160565b3d915061534b565b615388919250833d85116106d9576106cb8183611cad565b903861510e565b6153a991925060203d6020116106d9576106cb8183611cad565b90386150e2565b6020813d6020116153ea575b816153c960209383611cad565b810103126108bf5751906001600160a01b03821682036108c75750386150b2565b3d91506153bc565b506001600160a01b0382161515615088565b90506020813d602011615436575b8161541f60209383611cad565b810103126105fa576154309061223e565b38615081565b3d9150615412565b6040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b0390931694939092602081602481895afa908115610607576000916157a8575b5015610bfb5760009160005b845181101561570a576001600160a01b036154a6828761220e565b5116604051633f4a2d2760e01b81526020816004818c5afa908115610607576000916156ec575b506040516306fdde0360e01b8152600081600481865afa80156106075761551d926080926000926156d1575b50604051808095819463481d98fb60e11b83526020600484015260248301906117a1565b03916001600160a01b03165afa918215610607576000918293615685575b50859286156155a6575b50508161557d575b5061555b575b60010161548b565b92600190615575906001600160a01b036115d7878961220e565b939050615553565b90506001600160a01b03615591838861220e565b516001600160a01b039092169116143861554d565b6002919293506155b581612d16565b1490816155c7575b5015903880615545565b6040516358a06f0760e01b81529150602090829060049082905afa90811561060757602491602091600091615668575b506040516370a0823160e01b81526001600160a01b0387811660048301529093849290918391165afa90811561060757600091615637575b5015386155bd565b906020823d8211615660575b8161565060209383611cad565b810103126108c75750513861562f565b3d9150615643565b61567f9150823d81116106d9576106cb8183611cad565b386155f7565b9092506080813d82116156c9575b816156a060809383611cad565b810103126108bf5760206156b382612179565b9101519160038310156108c7575090913861553b565b3d9150615693565b6156e591923d8091833e612cbf8183611cad565b90386154f9565b615704915060203d81116106d9576106cb8183611cad565b386154cd565b5091929394505061571a8261200c565b926157286040519485611cad565b828452601f196157378461200c565b0160005b81811061579157505060005b838110615755575050505090565b600190615775846001600160a01b0361576e848761220e565b5116614403565b61577f828861220e565b5261578a818761220e565b5001615747565b60209061579c613486565b8282890101520161573b565b90506020813d6020116157da575b816157c360209383611cad565b810103126105fa576157d49061223e565b3861547f565b3d91506157b6565b90918251916157f08361200c565b936157fe6040519586611cad565b838552601f1961580d8561200c565b0160005b81811061586957505060005b84811061582c57505050505090565b60019061584d856001600160a01b03615845848761220e565b51168661210a565b615857828961220e565b52615862818861220e565b500161581d565b6020906158746120e3565b82828a01015201615811565b6040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b03919091169190602081602481865afa90811561060757600091615a89575b5015610bfb5760405163eb02c30160e01b815260048101829052600081602481865afa90811561060757600091615a70575b50602081015115615a685760405191632f60fad360e21b83526004830152602082602481865afa801561060757600090615a35575b60408281015160a084015160c0909401519151633f4a2d2760e01b815291959194506001600160a01b03938416931690602090859060049082905afa90811561060757602094600092615a14575b50604051631839f03960e21b81526001600160a01b0391821660048201529381166024850152604484019590955260648301919091529092166084830152818060a481015b0381737A0FFAaEFbed420d00c5E60c1668693a8a26B88C5af4908115610607576000916159e5575090565b90506020813d602011615a0c575b81615a0060209383611cad565b810103126105fa575190565b3d91506159f3565b6159ba9250615a2f90863d88116106d9576106cb8183611cad565b91615975565b506020823d602011615a60575b81615a4f60209383611cad565b810103126105fa5760049151615927565b3d9150615a42565b505050600090565b615a83913d8091833e6108638183611cad565b386158f2565b90506020813d602011615abb575b81615aa460209383611cad565b810103126105fa57615ab59061223e565b386158c0565b3d9150615a97565b6040516301ffc9a760e01b8152633d79d7fb60e11b6004820152600095946001600160a01b0383169391602081602481885afa90811561060757600091615c95575b5080615c83575b15610bfb5760405163183ea23960e21b81526001600160a01b038316600482015290602082602481885afa91821561060757600092615c4f575b50818610156142555781615b5a8288612222565b10615c3a575084615b6a9161226a565b925b615b7584614079565b9460005b858110615b8a575050505050509190565b615bc96020615b998385612222565b60405163d64470e960e01b81526001600160a01b0388166004820152602481019190915291829081906044820190565b0381875afa90811561060757600091615c07575b5090615beb60019287613672565b615bf5828a61220e565b52615c00818961220e565b5001615b79565b906020823d8211615c32575b81615c2060209383611cad565b810103126108c7575051615beb615bdd565b3d9150615c13565b80949750615c49915085612222565b95615b6c565b90916020823d602011615c7b575b81615c6a60209383611cad565b810103126108c75750519038615b46565b3d9150615c5d565b506001600160a01b0382161515615b0c565b90506020813d602011615cc7575b81615cb060209383611cad565b810103126105fa57615cc19061223e565b38615b05565b3d9150615ca3565b519069ffffffffffffffffffff821682036105fa57565b8115615cf0570490565b634e487b7160e01b600052601260045260246000fd5b90615d1091615d37565b6706f05b59d3b200008101908181116105b85781106105a757670de0b6b3a7640000900490565b600092918015918215615d4e575b50501561061357565b91509250615d66615d5f8483612d36565b9384615ce6565b143880615d45565b9190615d7a9083612222565b9182106105a75756fea26469706673582212204f5ca5dddc8f7c53ee88438958254c711c0573b5bd19e28783412409cbf5958764736f6c634300081a0033",
  "deployedBytecode": "0x6102e080604052600436101561001457600080fd5b600090813560e01c90816301ffc9a7146116e75750806314fdc0731461169d57806316569dc1146114a657806336ca926314611253578063429bd6461461110957806344ec16141461106b5780634acefed4146110295780636629bf0a14610ff6578063679bfb5b14610fb15780636c5a9cd114610f7457806388782ed914610edd5780638ddbcc6214610ec25780639e09d40e14610e45578063a8d028b514610e03578063b23c434014610d9c578063b29d57d814610d40578063b3e1d9f214610cde578063bdf4cd1814610c7b578063d030bb2514610c53578063debd310d14610c24578063e10a27a4146109e4578063f107f834146108ca5763fa24cc661461011f57600080fd5b60a03660031901126108c75761013361173c565b6044356001600160401b0381116108c357610152903690600401611f3b565b926064356001600160401b0381116108bf57610172903690600401611860565b936084356001600160401b0381116108bb57610192903690600401611860565b604051632630c12f60e01b81526001600160a01b0390931696909391926020816004818b5afa90811561081757869161089c575b506001600160a01b031691823b156108985790859392916101fd6040519687958694859463f197ce3560e01b865260048601613af0565b039134905af1801561088d5761087d575b50906040519263eb02c30160e01b845260243560048501528284602481845afa93841561087257839461084e575b50604051632630c12f60e01b815290602082600481845afa918215610843578492610822575b5060a085018051606087018051604051631dae49b960e21b81526001600160a01b039384166004820152908316602482015292989094909160209184916044918391165afa9182156108175786926107e3575b506040516301ddf49360e61b8152602081600481875afa9081156106a85787916107b1575b5060405163084b557b60e21b815294602086600481885afa9586156107a6578896610770575b508951815160405163a8905dab60e01b81526001600160a01b03928316600482015291166024820152959660208780604481015b0381895afa938415610765578994610730575b60408b81018051915163280188b760e21b8152909d909950906020908a9060049082906001600160a01b03165afa98891561072557908c949392918c9a6106eb575b5051925160c09490940151604051632630c12f60e01b815290986001600160a01b039586169590941693602090829060049082905afa9081156106e05791602095949391610418938e916106b3575b506040519a8b96879663735aad2560e01b885260048801526024870152604486015260018060a01b0316606485015260a0608485015260a4840191613acf565b038173__$75df3f6366b0557754cd3ba14359105414$__5af49384156106a8578794610674575b50670de0b6b3a76400000390670de0b6b3a7640000821161066057670de0b6b3a76400000390670de0b6b3a76400008211610660579061047e91615d06565b90670de0b6b3a76400000390670de0b6b3a7640000821161064c576104ac92916104a791615d06565b615d06565b91670de0b6b3a7640000019081670de0b6b3a76400001161063857906104d191615d06565b90670de0b6b3a7640000808202938285048214831517156105b857806106245750830403610613576105148161050f60049460209460011c90615d6e565b615ce6565b93516040516368d0612f60e01b815292839182906001600160a01b03165afa8015610607576000906105ce575b6105519150602083015190615d37565b916b019d971e4fe8401e740000008301928381116105b85783106105a75761058c6080916b033b2e3c9fd0803ce8000000602095049061226a565b9101518082116105a057505b604051908152f35b9050610598565b630a77254f60e01b60005260046000fd5b634e487b7160e01b600052601160045260246000fd5b506020813d6020116105ff575b816105e860209383611cad565b810103126105fa576105519051610541565b600080fd5b3d91506105db565b6040513d6000823e3d90fd5b631550e8b760e01b60005260046000fd5b634e487b7160e01b81526012600452602490fd5b634e487b7160e01b84526011600452602484fd5b634e487b7160e01b86526011600452602486fd5b634e487b7160e01b87526011600452602487fd5b9093506020813d6020116106a0575b8161069060209383611cad565b810103126105fa5751923861043f565b3d9150610683565b6040513d89823e3d90fd5b6106d39150873d89116106d9575b6106cb8183611cad565b81019061224b565b386103d8565b503d6106c1565b6040513d8e823e3d90fd5b945098506020843d60201161071d575b8161070860209383611cad565b810103126105fa579251978b93906020610389565b3d91506106fb565b6040513d8d823e3d90fd5b93506020873d60201161075d575b8161074b60209383611cad565b810103126105fa576004965193610347565b3d915061073e565b6040513d8b823e3d90fd5b95506020863d60201161079e575b8161078b60209383611cad565b810103126105fa57610334955195610300565b3d915061077e565b6040513d8a823e3d90fd5b90506020813d6020116107db575b816107cc60209383611cad565b810103126105fa5751386102da565b3d91506107bf565b9091506020813d60201161080f575b816107ff60209383611cad565b810103126105fa575190386102b5565b3d91506107f2565b6040513d88823e3d90fd5b61083c91925060203d6020116106d9576106cb8183611cad565b9038610262565b6040513d86823e3d90fd5b61086b9194503d8085833e6108638183611cad565b810190612778565b923861023c565b6040513d85823e3d90fd5b8161088791611cad565b3861020e565b6040513d84823e3d90fd5b8580fd5b6108b5915060203d6020116106d9576106cb8183611cad565b386101c6565b8380fd5b5080fd5b8280fd5b80fd5b50346108c75760403660031901126108c7576004356001600160401b0381116108bf576108fb903690600401611860565b90610904611752565b9061090e8361200c565b9161091c6040519384611cad565b8383526109288461200c565b9361093b6020850195601f190186613597565b855b8181106109a957868587604051928392602084019060208552518091526040840160408260051b8601019392905b82821061097a57505050500390f35b919360019193955060206109998192603f198a820301865288516117c6565b960192019201859493919261096b565b806109c8846109c36109be600195878a61213f565b612165565b612b38565b6109d2828861220e565b526109dd818761220e565b500161093d565b50346108c75760203660031901126108c7576004356001600160401b0381116108bf57610a15903690600401611860565b610a1e8161200c565b91610a2c6040519384611cad565b818352601f19610a3b8361200c565b01845b818110610c0d575050835b828110610acf578385604051918291602083016020845282518091526020604085019301915b818110610a7d575050500390f35b91935091602060a060019269ffffffffffffffffffff60808851828151168452858101518685015260408101516040850152606081015160608501520151166080820152019401910191849392610a6f565b6001600160a01b03610ae56109be83868661213f565b1615610bfb5760049060a06001600160a01b03610b066109be84888861213f565b1660405193848092633fabe5a360e21b82525afa8015610817578687889089928a94610b9b575b6001965069ffffffffffffffffffff610b46878c61220e565b51911690526020610b57868b61220e565b5101526040610b66858a61220e565b5101526060610b75848961220e565b51015269ffffffffffffffffffff6080610b8f848961220e565b51019116905201610a49565b505050505060a0823d8211610bf3575b81610bb860a09383611cad565b810103126108985781610bcc600193615ccf565b6020820151916040810151610be8608060608401519301615ccf565b929390919293610b2d565b3d9150610bab565b60405163044aa57560e41b8152600490fd5b602090610c1861345b565b82828801015201610a3e565b50346108c757610c3f610c3636611f68565b92919091615ac3565b90610c4f60405192839283611fa6565b0390f35b50346108c75760403660031901126108c7576020610598610c7261173c565b60243590615880565b50346108c75760603660031901126108c757610c9561173c565b90602435906001600160401b0382116108c757610c4f610cca84610cbc3660048701612023565b610cc4611768565b916157e2565b60405191829160208352602083019061189f565b50346108c75760803660031901126108c757600435906001600160401b0382116108c757610c4f610d34610d153660048601612023565b610d1d611752565b610d25611768565b90610d2e611890565b9261543e565b60405191829182611b3f565b50346108c75760403660031901126108c7576080610d6d610d5f61173c565b610d67611752565b90615039565b610d9a60405180926060809180518452602081015115156020850152604081015160408501520151910152565bf35b50346108c75760403660031901126108c757610db661173c565b90602435906001600160401b0382116108c7576060610de284610ddc3660048701611ce9565b90614f7f565b610d9a60405180926040809180518452602081015160208501520151910152565b50346108c75760403660031901126108c757610c4f610e31610e2361173c565b610e2b611752565b90614403565b6040519182916020835260208301906118fa565b50346108c75760603660031901126108c757610e5f61173c565b90602435906001600160401b0382116108c75760a0610e9384610e853660048701611ce9565b610e8d611768565b916142e5565b604080518251815260208084015181830152928201518051828401529283015160608201529101516080820152f35b50346108c757610c3f610ed436611f68565b929190916140c9565b5060a03660031901126108c757610ef261173c565b6044356001600160401b0381116108c357610f11903690600401611f3b565b90926064356001600160401b0381116108bf57610f32903690600401611860565b929091608435906001600160401b0382116108c7576020610f6a8888888888610f5e3660048b01611860565b95909460243590613c28565b6040519015158152f35b50346108c75760403660031901126108c757610c4f610f9d610f9461173c565b60243590613672565b604051918291602083526020830190611e6e565b50346108c757806003193601126108c7576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346108c75760403660031901126108c7576004359060068210156108c757602061059883611023611752565b90612d5c565b50346108c75760403660031901126108c757610c4f61105761104961173c565b611051611752565b90612b38565b6040519182916020835260208301906117c6565b50346108c75761108361107d36611d30565b9161285d565b9190604051916040830160408452825180915260608401602060608360051b870101940192905b8282106110be578580868960208301520390f35b909192936020806110fb600193605f198a8203018652885190836110eb8351604084526040840190611dc4565b9201519084818403910152611d5a565b9601920192019092916110aa565b50346108c75761112161111b36611d30565b9161239e565b9190604051916040830160408452825180915260608401602060608360051b870101940192905b82821061115c578580868960208301520390f35b90919293602080611245600193605f198a8203018652885190836110eb6101a0845160408552898060a01b038151166040860152898060a01b0384820151166060860152898060a01b036040820151166080860152606081015160a0860152898060a01b0360808201511660c086015260a081015160e0860152898060a01b0360c08201511661010086015260e08101516101208601526101008101516101408601526101208101516101608601526101408101511515610180860152610160810151828601526101808101516101c086015201516101c06101e08501526102008401906117a1565b960192019201909291611148565b50346108c75760a03660031901126108c75761126d61173c565b6024356001600160401b0381116108c35761128c903690600401611ce9565b906064356001600160a01b038116918282036114a2576040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b039190911692602082602481875afa918215610817578692611466575b508161145c575b5015610bfb57602060049260405193848092633f4a2d2760e01b82525afa9182156108435761134592602091869161143f575b5060018060a01b0316936040518094819263af9a2aa760e01b835284600484015260248301906117a1565b0381865afa8015610843578490611405575b604051631839f03960e21b81526001600160a01b0391821660048201529181166024830152608480356044808501919091523560648401529316928101929092525060208160a48173__$75df3f6366b0557754cd3ba14359105414$__5af490811561088d5782916113cf575b602082604051908152f35b90506020813d6020116113fd575b816113ea60209383611cad565b810103126108bf576020915051386113c4565b3d91506113dd565b506020823d602011611437575b8161141f60209383611cad565b810103126108bb57611432602092612179565b611357565b3d9150611412565b6114569150823d84116106d9576106cb8183611cad565b3861131a565b90501515386112e7565b9091506020813d60201161149a575b8161148260209383611cad565b81010312610898576114939061223e565b90386112e0565b3d9150611475565b8480fd5b50346108c75760803660031901126108c7576004356001600160401b0381116108bf576114d7903690600401611860565b91906114e1611752565b6114e9611768565b6114f1611890565b946114fb8161200c565b936115096040519586611cad565b818552601f196115188361200c565b01865b81811061168c575050855b82811061160d57505050839484955b845187101561155e5761155660019161154e898861220e565b515190612222565b960195611535565b90849186939461156d8261200c565b9161157b6040519384611cad565b80835261158a601f199161200c565b013660208401378495855b85518710156115fe5780975b6115ab888861220e565b51518910156115f1576001906115e9906001600160a01b036115d78c6115d18d8d61220e565b5161220e565b51166115e3828961220e565b5261222f565b9801976115a1565b9750600190960195611595565b50610c4f9391610d349361543e565b6004876001600160a01b036116266109be85888861213f565b166040519283809263f9776bcb60e01b82525afa9081156107a6579060019291899161166a575b50611658828961220e565b52611663818861220e565b5001611526565b61168691503d808b833e61167e8183611cad565b81019061218d565b3861164d565b806060602080938a0101520161151b565b50346108c75760603660031901126108c757610c4f6116d36116bd61173c565b6116c5611752565b6116cd611768565b9161210a565b604051918291602083526020830190611817565b9050346108bf5760203660031901126108bf5760043563ffffffff60e01b81168091036108c3576020925063055e0aa960e51b811490811561172b575b5015158152f35b6301ffc9a760e01b14905038611724565b600435906001600160a01b03821682036105fa57565b602435906001600160a01b03821682036105fa57565b604435906001600160a01b03821682036105fa57565b60005b8381106117915750506000910152565b8181015183820152602001611781565b906020916117ba8151809281855285808601910161177e565b601f01601f1916010190565b9060018060a01b0382511681526080806118046117f2602086015160a0602087015260a08601906117a1565b604086015185820360408701526117a1565b9360608101516060850152015191015290565b9061185d90602080611832855160a0855260a08501906117c6565b9401519101906060809180518452602081015115156020850152604081015160408501520151910152565b90565b9181601f840112156105fa578235916001600160401b0383116105fa576020808501948460051b0101116105fa57565b6064359081151582036105fa57565b9080602083519182815201916020808360051b8301019401926000915b8383106118cb57505050505090565b90919293946020806118e9600193601f198682030187528951611817565b970193019301919392906118bc565b565b9060018060a01b0382511681526105006102c06119d26119be6119aa611946611934602089015161052060208a01526105208901906117a1565b604089015188820360408a01526117c6565b6001600160801b0360608901511660608801526001600160801b03608089015116608088015260a088015160a088015260c088015160c088015260e088015160e088015261010088015161010088015261012088015187820361012089015261189f565b6101408701518682036101408801526117c6565b6101608601518582036101608701526117c6565b936101808101516101808501526101a08101516101a08501526101006101c082015160018060a01b038151166101c0870152602081015115156101e087015260408101516102008701526060810151610220870152608081015161024087015260a081015161026087015260c081015161028087015260e08101516102a0870152015182850152611a956101e08201516102e086019080518252602080820151818401526040918201518051838501529081015160608401520151608090910152565b610200810151805161038086015260208101516103a0860152604001516103c08501526001600160801b03610220820151166103e08501526001600160801b03610240820151166104008501526102608101511515610420850152610280810151151561044085015260806102a08201518051610460870152602081015161048087015260408101516104a087015260608101516104c087015201516104e0850152015191015290565b602081016020825282518091526040820191602060408360051b8301019401926000915b838310611b7257505050505090565b9091929394602080611b90600193603f1986820301875289516118fa565b97019301930191939290611b63565b60a081019081106001600160401b03821117611bba57604052565b634e487b7160e01b600052604160045260246000fd5b608081019081106001600160401b03821117611bba57604052565b604081019081106001600160401b03821117611bba57604052565b6101c081019081106001600160401b03821117611bba57604052565b61018081019081106001600160401b03821117611bba57604052565b606081019081106001600160401b03821117611bba57604052565b6102e081019081106001600160401b03821117611bba57604052565b61012081019081106001600160401b03821117611bba57604052565b61016081019081106001600160401b03821117611bba57604052565b90601f801991011681019081106001600160401b03821117611bba57604052565b6001600160401b038111611bba57601f01601f191660200190565b81601f820112156105fa57803590611d0082611cce565b92611d0e6040519485611cad565b828452602083830101116105fa57816000926020809301838601378301015290565b60609060031901126105fa576004356001600160a01b03811681036105fa57906024359060443590565b9080602083519182815201916020808360051b8301019401926000915b838310611d8657505050505090565b9091929394602080611db5600193601f198682030187526040838b5180518452015191818582015201906117a1565b97019301930191939290611d77565b9061018061016061185d93805184526020810151602085015260018060a01b03604082015116604085015260018060a01b0360608201511660608501526080810151608085015260018060a01b0360a08201511660a085015260c081015160c085015260018060a01b0360e08201511660e08501526101008101516101008501526101208101516101208501526101408101516101408501520151918161016082015201906117a1565b919082518152611e8f602084015161016060208401526101608301906118fa565b6040848101518383038285015290820192916000815b60028210611f14575050505061014084606061185d9596015160608401526080810151608084015260a081015160a084015260c081015160c084015260e081015160e08401526101008101516101008401526101208101516101208401520151906101408184039101526117a1565b90919294602080611f2d838760019503865289516117c6565b970192019201909291611ea5565b9181601f840112156105fa578235916001600160401b0383116105fa57602083818601950101116105fa57565b60809060031901126105fa576004356001600160a01b03811681036105fa57906024356001600160a01b03811681036105fa57906044359060643590565b92919060408401906040855280518092526060850191602060608260051b8801019201926000905b828210611fe15750505060209150930152565b909192602080611ffd600193605f198c82030186528851611e6e565b96019201920190939291611fce565b6001600160401b038111611bba5760051b60200190565b9080601f830112156105fa5781359061203b8261200c565b926120496040519485611cad565b82845260208085019360051b8201019182116105fa57602001915b8183106120715750505090565b82356001600160a01b03811681036105fa57815260209283019201612064565b6040519061209e82611b9f565b600060808382815260606020820152606060408201528260608201520152565b604051906120cb82611bd0565b60006060838281528260208201528260408201520152565b604051906120f082611beb565b816120f9612091565b815260206121056120be565b910152565b91906121226121289261211b6120e3565b5082612b38565b92615039565b6040519161213583611beb565b8252602082015290565b919081101561214f5760051b0190565b634e487b7160e01b600052603260045260246000fd5b356001600160a01b03811681036105fa5790565b51906001600160a01b03821682036105fa57565b6020818303126105fa578051906001600160401b0382116105fa57019080601f830112156105fa5781516121c08161200c565b926121ce6040519485611cad565b81845260208085019260051b8201019283116105fa57602001905b8282106121f65750505090565b6020809161220384612179565b8152019101906121e9565b805182101561214f5760209160051b010190565b919082018092116105b857565b60001981146105b85760010190565b519081151582036105fa57565b908160209103126105fa57516001600160a01b03811681036105fa5790565b919082039182116105b857565b9092919261228481611cce565b916122926040519384611cad565b8294828452828201116105fa5760206118f893019061177e565b9080601f830112156105fa57815161185d92602001612277565b6020818303126105fa578051906001600160401b0382116105fa57019080601f830112156105fa578151916122fa8361200c565b926123086040519485611cad565b80845260208085019160051b830101918383116105fa5760208101915b83831061233457505050505090565b82516001600160401b0381116105fa578201906040828703601f1901126105fa576040519061236282611beb565b602083015182526040830151916001600160401b0383116105fa5761238f886020809695819601016122ac565b83820152815201920191612325565b6040516301ffc9a760e01b815263fabd349d60e01b6004820152600094936001600160a01b039092169190602081602481865afa9081156106075760009161273e575b5015610bfb576040516301f0b85b60e21b815290602082600481865afa9182156106075760009261270a575b50818410156126fc57816124218286612222565b106126e75750826124319161226a565b905b61243c8261200c565b9261244a6040519485611cad565b828452601f196124598461200c565b0160005b81811061265457505060005b83811061247857505050509190565b6124828183612222565b6040519063dabe8a7160e01b82526004820152600081602481875afa90811561060757600091612530575b506124b8828761220e565b51526101006124c7828761220e565b515101519060405191635973af3960e01b83526004830152600082602481875afa80156106075760019260009161250f575b506020612506838961220e565b51015201612469565b61252a913d8091833e6125228183611cad565b8101906122c6565b386124f9565b3d8083833e61253f8183611cad565b8101906020818303126108c3578051906001600160401b0382116108bb5701916101c0838303126108c7576040519261257784611c06565b61258081612179565b845261258e60208201612179565b602085015261259f60408201612179565b6040850152606081015160608501526125ba60808201612179565b608085015260a081015160a08501526125d560c08201612179565b60c085015260e081015160e0850152610100810151610100850152610120810151610120850152612609610140820161223e565b6101408501526101608101516101608501526101808101516101808501526101a0810151916001600160401b0383116108c757506126489291016122ac565b6101a0820152386124ad565b60209060405161266381611beb565b60405161266f81611c06565b60008152600084820152600060408201526000606082015260006080820152600060a0820152600060c0820152600060e08201526000610100820152600061012082015260006101408201526000610160820152600061018082015260606101a082015281526060838201528282890101520161245d565b809295506126f6915083612222565b93612433565b505050509050606090600090565b90916020823d602011612736575b8161272560209383611cad565b810103126108c7575051903861240d565b3d9150612718565b90506020813d602011612770575b8161275960209383611cad565b810103126105fa5761276a9061223e565b386123e1565b3d915061274c565b6020818303126105fa578051906001600160401b0382116105fa5701610180818303126105fa57604051916127ac83611c22565b81518352602082015160208401526127c660408301612179565b60408401526127d760608301612179565b6060840152608082015160808401526127f260a08301612179565b60a084015260c082015160c084015261280d60e08301612179565b60e08401526101008201516101008401526101208201516101208401526101408201516101408401526101608201516001600160401b0381116105fa5761285492016122ac565b61016082015290565b6040516301ffc9a760e01b8152633d79d7fb60e11b6004820152600094936001600160a01b039092169190602081602481865afa90811561060757600091612ac8575b5015610bfb57604051630d96c0f960e21b815290602082600481865afa91821561060757600092612a94575b50818410156126fc57816128e08286612222565b10612a7f5750826128f09161226a565b905b6128fb8261200c565b926129096040519485611cad565b828452601f196129188461200c565b0160005b8181106129fc57505060005b83811061293757505050509190565b6129418183612222565b604051906344ff7dc360e01b82526004820152600081602481875afa908115610607576000916129e3575b50612977828761220e565b5152612983818661220e565b5151519060405191631d40683560e31b83526004830152600082602481875afa8015610607576001926000916129ca575b5060206129c1838961220e565b51015201612928565b6129dd913d8091833e6125228183611cad565b386129b4565b6129f6913d8091833e6108638183611cad565b3861296c565b602090604051612a0b81611beb565b604051612a1781611c22565b60008152600084820152600060408201526000606082015260006080820152600060a0820152600060c0820152600060e0820152600061010082015260006101208201526000610140820152606061016082015281526060838201528282890101520161291c565b80929550612a8e915083612222565b936128f2565b90916020823d602011612ac0575b81612aaf60209383611cad565b810103126108c757505190386128cc565b3d9150612aa2565b90506020813d602011612afa575b81612ae360209383611cad565b810103126105fa57612af49061223e565b386128a0565b3d9150612ad6565b6020818303126105fa578051906001600160401b0382116105fa57019080601f830112156105fa57815161185d92602001612277565b612b40612091565b506001600160a01b0316908115610bfb576040516395d89b4160e01b815290600082600481865afa91821561060757600092612cce575b506040516306fdde0360e01b815290600082600481875afa91821561060757600092612ca9575b5060405163313ce56760e01b8152602081600481885afa90811561060757600091612c6d575b506001600160a01b03909116918215612c6157604051926370a0823160e01b84526004840152602083602481885afa801561060757600090612c2e575b60ff9350935b60405195612c1487611b9f565b865260208601526040850152166060830152608082015290565b506020833d602011612c59575b81612c4860209383611cad565b810103126105fa5760ff9251612c01565b3d9150612c3b565b60ff9250600093612c07565b6020813d602011612ca1575b81612c8660209383611cad565b810103126108bf57519060ff821682036108c7575038612bc4565b3d9150612c79565b612cc79192503d806000833e612cbf8183611cad565b810190612b02565b9038612b9e565b612ce49192503d806000833e612cbf8183611cad565b9038612b77565b91908260809103126105fa578151916020810151916060604083015192015160038110156105fa5790565b60031115612d2057565b634e487b7160e01b600052602160045260246000fd5b818102929181159184041417156105b857565b919060208301926006821015612d205752565b604051632630c12f60e01b81526001600160a01b0390921691602081600481865afa908115610607576000916133fa575b50604051637496a94d60e11b8152602081600481875afa908115610607576000916133db575b50612dbc6120be565b60405163455259cb60e01b81523a93602090829060049082906001600160a01b03165afa908115610607576000916133a8575b508152604051632c18d6af60e21b815291608090839060049082906001600160a01b03165afa91821561060757600090600093613382575b50826040830152806060830152815192600084136000146133755750670de0b6b3a7640000019182670de0b6b3a7640000116105b857602092612e6991615d06565b9182915b0152803a11801561336d575b613365575b50604051637496a94d60e11b815291602083600481875afa92831561060757600493608091600091613346575b50604051632c18d6af60e21b815294859182906001600160a01b03165afa9384156106075760009360009561330c575b50604051633f4a2d2760e01b815293602085600481855afa948515610607576004956020916000916132ef575b506040516324890e1560e21b815296879182906001600160a01b03165afa948515610607576000956132bb575b50600095612f4281612d16565b8061301a575b5050602060049160405192838092633f4a2d2760e01b82525afa91821561060757612f9492602092600091612ffd575b50604051808095819463ee42b2d160e01b835260048301612d49565b03916001600160a01b03165afa90811561060757600091612fc7575b5092612fc2612fc29261185d95612d36565b612222565b9390506020843d602011612ff5575b81612fe360209383611cad565b810103126105fa579251612fc2612fb0565b3d9150612fd6565b6130149150833d85116106d9576106cb8183611cad565b38612f78565b61302381612d16565b60018114613174575b60029061303881612d16565b146130435780612f48565b9450600491925060209060405192838092633f4a2d2760e01b82525afa9182156106075761309292602092600091613157575b5060405180809581946306bdf5b760e21b835260048301612d49565b03916001600160a01b03165afa90811561060757600091613125575b5060405163f1c7a58b60e01b81526004810191909152602081602481600f602160991b015afa908115610607576000916130f1575b5061185d92612fc291615d06565b90506020813d60201161311d575b8161310c60209383611cad565b810103126105fa575161185d6130e3565b3d91506130ff565b90506020813d60201161314f575b8161314060209383611cad565b810103126105fa5751386130ae565b3d9150613133565b61316e9150833d85116106d9576106cb8183611cad565b38613076565b60405163f5d6ded760e01b8152909650602081600481606c5afa90811561060757600091613289575b508060041b90808204601014901517156105b857604051633f4a2d2760e01b815290602082600481875afa91821561060757600092613268575b50602060405180936306bdf5b760e21b825281806131f88a60048301612d49565b03916001600160a01b03165afa91821561060757600092613234575b50608c82018092116105b85760029161322c91612d36565b96905061302c565b90916020823d602011613260575b8161324f60209383611cad565b810103126108c75750519038613214565b3d9150613242565b61328291925060203d6020116106d9576106cb8183611cad565b90386131d7565b906020823d6020116132b3575b816132a360209383611cad565b810103126108c75750513861319d565b3d9150613296565b90946020823d6020116132e7575b816132d660209383611cad565b810103126108c75750519338612f35565b3d91506132c9565b6133069150823d84116106d9576106cb8183611cad565b38612f08565b90945061333291935060803d60801161333f575b61332a8183611cad565b810190612ceb565b9492509050929338612edb565b503d613320565b61335f915060203d6020116106d9576106cb8183611cad565b38612eab565b905038612e7e565b503a15612e79565b9250829160209150612e6d565b905061339e91925060803d60801161333f5761332a8183611cad565b5050919038612e27565b90506020813d6020116133d3575b816133c360209383611cad565b810103126105fa57516004612def565b3d91506133b6565b6133f4915060203d6020116106d9576106cb8183611cad565b38612db3565b613413915060203d6020116106d9576106cb8183611cad565b38612d8d565b6040519061342682611c3e565b60006040838281528260208201520152565b6040519061344582611c3e565b8160008152600060208201526040612105613419565b6040519061346882611b9f565b60006080838281528260208201528260408201528260608201520152565b6040519061349382611c59565b60006102c083828152606060208201526134ab612091565b60408201528260608201528260808201528260a08201528260c08201528260e08201528261010082015260606101208201526134e5612091565b6101408201526134f3612091565b61016082015282610180820152826101a082015260405161351381611c75565b8381528360208201528360408201528360608201528360808201528360a08201528360c08201528360e0820152836101008201526101c0820152613555613438565b6101e0820152613563613419565b6102008201528261022082015282610240820152826102608201528261028082015261358d61345b565b6102a08201520152565b60005b8281106135a657505050565b6020906135b1612091565b818401520161359a565b604051906135c882611c91565b81600081526135d5613486565b602082015260408051906135e98183611cad565b60005b8181106136355750916101409160609382015260008382015260006080820152600060a0820152600060c0820152600060e0820152600061010082015260006101208201520152565b602090613640612091565b81850152016135ec565b908160409103126105fa5760206040519161366483611beb565b805183520151602082015290565b9061367b6135bb565b506040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b0383169290602081602481875afa90811561060757600091613a95575b5015610bfb5760405163eb02c30160e01b815260048101839052600081602481875afa90811561060757600091613a7c575b50604081810180519151632f60fad360e21b81526004810186905290936001600160a01b0390921615916020826024818a5afa91821561060757600092613a48575b50613737613486565b948315613a22575b50604051631d40683560e31b8152600481018790526000816024818b5afa90811561060757600091613a09575b50604051600061377b82611beb565b80825260208201529760005b82518110156139fb57604051633f4a2d2760e01b8152602081600481865afa908115610607576000916139dd575b5060206137c2838661220e565b51516040516352ff146960e11b8152600481019190915291829060249082906001600160a01b03165afa9081156106075760009161399f575b506040516301ffc9a760e01b8152630452934760e01b600482015290602090829060249082906001600160a01b03165afa90811561060757600091613966575b508061394e575b61384e57600101613787565b6138789394959697989950613866915060209261220e565b5101516020808251830101910161364a565b6138e28551976040519561388b87611beb565b1561394457606087015160e08801516138b0916001600160a01b039182169116612b38565b865260a087015160e08801516138d2916001600160a01b039182169116612b38565b602087015260c087015193615880565b6020820151915192608087015195610160610120890151980151986040519a61390a8c611c91565b8b5260208b015260408a01526060890152608088015260a087015260c086015260e085015261010084015261012083015261014082015290565b60408801516138b0565b50602061395b828561220e565b510151511515613842565b906020823d8211613997575b8161397f60209383611cad565b810103126108c757506139919061223e565b3861383b565b3d9150613972565b906020823d82116139d5575b816139b860209383611cad565b810103126108c7575060206139ce602492612179565b91506137fb565b3d91506139ab565b6139f5915060203d81116106d9576106cb8183611cad565b386137b5565b505050909192939495613878565b613a1c913d8091833e6125228183611cad565b3861376c565b5160e0850151919550613a41916001600160a01b039081169116614403565b933861373f565b9091506020813d602011613a74575b81613a6460209383611cad565b810103126105fa5751903861372e565b3d9150613a57565b613a8f913d8091833e6108638183611cad565b386136ec565b90506020813d602011613ac7575b81613ab060209383611cad565b810103126105fa57613ac19061223e565b386136ba565b3d9150613aa3565b908060209392818452848401376000828201840152601f01601f1916010190565b9082604083016040845252606082019060608460051b840101938192600092601e19813603015b838510613b4d57505050505050602081830391015282815260018060fb1b0383116105fa5760209260051b809284830137010190565b909192939496605f198782030184528735828112156105fa57830180359160208201926001600160401b0381116105fa578060051b9182360385136105fa5792908084526020808501938501019493600092603e19813603015b838510613bcb57505050505050506020806001929901940195019392949190613b17565b90919293949596601f198482030187528735828112156105fa57830190604060208301359201916001600160401b0381116105fa5780360383136105fa57613c196020928392600195613acf565b99019701950193929190613ba7565b6040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b03909116976000979396959293909290916020816024818d5afa90811561076557899161403b575b5015610bfb5760405163eb02c30160e01b8152600481018590529588876024818d5afa96871561076557899761401f575b5060405194631d40683560e31b8652600486015288856024818d5afa948515610765578995614003575b50604051632630c12f60e01b81526020816004818e5afa908115613ff8578a91613fd9575b506001600160a01b031691823b15613fd5579089939291613d286040519687958694859463f197ce3560e01b865260048601613af0565b039134905af1801561081757613fc1575b50805115613fb857604051613d4d81611beb565b600081526000602082015295855b8251811015613fa257604051633f4a2d2760e01b8152602081600481865afa9081156107a6578891613f84575b506020613d95838661220e565b51516040516352ff146960e11b8152600481019190915291829060249082906001600160a01b03165afa9081156107a6578891613f46575b506040516301ffc9a760e01b8152630452934760e01b600482015290602090829060249082906001600160a01b03165afa9081156107a6578891613f09575b50613e1957600101613d5b565b602095969750613e6f94939150613e4986613e388193613e869661220e565b51015182808251830101910161364a565b015190604051968795869563a455976760e01b8752606060048801526064870190611dc4565b926024860152600319858403016044860152613acf565b0381857f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165af1918215613efd578092613ec757505090565b9091506020823d602011613ef5575b81613ee360209383611cad565b810103126108c7575061185d9061223e565b3d9150613ed6565b604051903d90823e3d90fd5b90506020813d8211613f3e575b81613f2360209383611cad565b81010312613f3a57613f349061223e565b38613e0c565b8780fd5b3d9150613f16565b90506020813d8211613f7c575b81613f6060209383611cad565b81010312613f3a576020613f75602492612179565b9150613dcd565b3d9150613f53565b613f9c915060203d81116106d9576106cb8183611cad565b38613d88565b50505090613e86613e6f92602080959697613e49565b50505050905090565b85613fce91969296611cad565b9338613d39565b8980fd5b613ff2915060203d6020116106d9576106cb8183611cad565b38613cf1565b6040513d8c823e3d90fd5b6140189195503d808b833e6125228183611cad565b9338613ccc565b6140349197503d808b833e6108638183611cad565b9538613ca2565b90506020813d602011614071575b8161405660209383611cad565b8101031261406d576140679061223e565b38613c71565b8880fd5b3d9150614049565b906140838261200c565b6140906040519182611cad565b82815280926140a1601f199161200c565b019060005b8281106140b257505050565b6020906140bd6135bb565b828285010152016140a6565b6040516301ffc9a760e01b8152633d79d7fb60e11b6004820152600095946001600160a01b0383169391602081602481885afa908115610607576000916142ab575b5080614299575b15610bfb57604051636bb1c52360e11b81526001600160a01b038316600482015290602082602481885afa91821561060757600092614265575b508186101561425557816141608288612222565b106142405750846141709161226a565b925b61417b84614079565b9460005b858110614190575050505050509190565b6141cf602061419f8385612222565b604051632906d3a960e21b81526001600160a01b0388166004820152602481019190915291829081906044820190565b0381875afa9081156106075760009161420d575b50906141f160019287613672565b6141fb828a61220e565b52614206818961220e565b500161417f565b906020823d8211614238575b8161422660209383611cad565b810103126108c75750516141f16141e3565b3d9150614219565b8094975061424f915085612222565b95614172565b5050505050509050606090600090565b90916020823d602011614291575b8161428060209383611cad565b810103126108c7575051903861414c565b3d9150614273565b506001600160a01b0382161515614112565b90506020813d6020116142dd575b816142c660209383611cad565b810103126105fa576142d79061223e565b3861410b565b3d91506142b9565b91906142ef613438565b506142f8613438565b926001600160a01b03169081156143de5760a091614334916040518095819482936311ddedf160e01b84526060600485015260648401906117a1565b90600180881b0316602483015242604483015203915afa908115610607576000918291839161436e575b5060408401526020830152815290565b9150508060a03d60a0116143d7575b6143878183611cad565b8101039160a083126108c7578151906060602084015194603f1901126108c757506080604051926143b784611c3e565b60408101518452606081015160208501520151604083015291903861435e565b503d61437d565b50505090565b908160209103126105fa57516001600160801b03811681036105fa5790565b9061440c613486565b506040516301ffc9a760e01b815260006102c052633aa17d5560e11b60048201526020816024816001600160a01b0387165afa908115614b0b576102c05191614f45575b5015610bfb57604051637437535960e01b8152916020836004816001600160a01b0385165afa928315614b0b576102c05193614f11575b50604051631f1b131360e31b81526020816004816001600160a01b0386165afa908115614b0b576004916020916102c05191614ef4575b506040516318160ddd60e01b815292839182906001600160a01b03165afa908115614b0b576102c05191614ec2575b506144f88482612222565b908115614eb9576b033b2e3c9fd0803ce800000081810290821583830482141715614e9f578104829003610613578261050f614538928260011c90615d6e565b604051630783377560e51b81526102c051816004816001600160a01b0389165afa908115614b0b576145779187916102c05191614e82575b50866157e2565b604051634c66358f60e11b815296909190610120886004816001600160a01b038a165afa978815614b0b576102c05198614dd3575b506040516307c0e8c160e31b81526020816004816001600160a01b038b165afa908115614b0b576102c05191614d90575b5060405163ddce491760e01b81526001600160a01b038881166004830152909160a09183916024918391165afa8015614b0b576102c0516102a052614d24575b506040516306fdde0360e01b81526102c051816004816001600160a01b038b165afa8015614b0b576102c05160c052614d05575b5060405163011ddaef60e71b81526020816004816001600160a01b038b165afa908115614b0b576146979189916102c05191614ca2575b506001600160a01b0316612b38565b61028052604051637f5d87bf60e11b81526020816004816001600160a01b038b165afa8015614b0b576102c05161026052614ce3575b5060405163905e383760e01b81526020816004816001600160a01b038b165afa8015614b0b576102c05161024052614cc1575b506040516358a06f0760e01b81526020816004816001600160a01b038b165afa908115614b0b576147459189916102c05191614ca257506001600160a01b0316612b38565b604051631f1b131360e31b81529094906020816004816001600160a01b038c165afa908115614b0b5761478c918a916102c05191614ca257506001600160a01b0316612b38565b60405163280188b760e21b8152979096906020896004816001600160a01b0385165afa988915614b0b576102c05199614c6e575b5060405163a223f82160e01b81529960208b6004816001600160a01b0386165afa9a8b15614b0b576102c0519b614c3a575b508b516040516306fdde0360e01b81526102c0519092916001600160a01b0390811691908490600490829088165afa908115614b0b5761483c936102c05192614c1b575b506142e5565b60e0528a516040516306fdde0360e01b81526102c05190916001600160a01b0390811691908390600490829087165afa908115614b0b57614887926102c05192614bfc575b50614f7f565b61014052604051635ea24eef60e11b81526020816004816001600160a01b0386165afa8015614b0b576102c05161022052614bda575b506040516327c37b2560e01b81526020816004816001600160a01b0386165afa8015614b0b576102c0516101e052614ba8575b50604051610200818152630c71782360e41b909152516020906004816001600160a01b0385165afa6101c0526101c05115614b0b576102c0516101a0526101c051614b64575b604051610180818152634ad09aa560e01b909152516020906004816001600160a01b0385165afa610160526101605115614b0b576102c0516101205261016051614b19575b6040516371a6cab760e01b81526020816004816001600160a01b0386165afa610100526101005115614b0b576102c05160a05261010051614ad8575b506040516080526149c9608051611c59565b60018060a01b03166080515260c0516020608051015261028051604060805101526001600160801b036102605116606060805101526001600160801b03610240511660808051015260a0608051015260c0608051015260e06080510152610100608051015261012060805101526101406080510152610160608051015261018060805101526101a060805101526101c0608051015260e0516101e060805101526101405161020060805101526001600160801b03610220511661022060805101526001600160801b036101e0511661024060805101526101a0511515610260608051015261012051151561028060805101526102a0516102a0608051015260a0516102c0608051015260805190565b6020813d602011614b03575b81614af160209383611cad565b810103126105fa575160a052386149b7565b3d9150614ae4565b6040513d6102c051823e3d90fd5b60203d602011614b5d575b80614b3460209261018051611cad565b610180519081010312614b5657614b4d6101805161223e565b6101205261497b565b6102c05180fd5b503d614b24565b60203d602011614ba1575b80614b7f60209261020051611cad565b610200519081010312614b5657614b986102005161223e565b6101a052614936565b503d614b6f565b614bc99060203d602011614bd3575b614bc18183611cad565b8101906143e4565b6101e052386148f0565b503d614bb7565b614bf29060203d602011614bd357614bc18183611cad565b61022052386148bd565b614c149192503d806102c051833e612cbf8183611cad565b9038614881565b614c339192503d806102c051833e612cbf8183611cad565b9038614836565b909a506020813d602011614c66575b81614c5660209383611cad565b810103126105fa575199386147f2565b3d9150614c49565b9098506020813d602011614c9a575b81614c8a60209383611cad565b810103126105fa575197386147c0565b3d9150614c7d565b614cbb915060203d6020116106d9576106cb8183611cad565b38614688565b614cd99060203d602011614bd357614bc18183611cad565b6102405238614700565b614cfb9060203d602011614bd357614bc18183611cad565b61026052386146cd565b614d1b903d806102c051833e612cbf8183611cad565b60c05238614651565b60a0813d60a011614d88575b81614d3d60a09383611cad565b81010312614b565760405190608090614d5583611b9f565b80518352602081015160208401526040810151604084015260608101516060840152015160808201526102a0523861461d565b3d9150614d30565b90506020813d602011614dcb575b81614dab60209383611cad565b81010312614b5657516001600160a01b0381168103614b565760a06145dd565b3d9150614d9e565b909750610120813d8211614e7a575b81614df06101209383611cad565b81010312614b565760405190614e0582611c75565b8051906001600160a01b0382168203614b5657610100918352614e2a6020820161223e565b602084015260408101516040840152606081015160608401526080810151608084015260a081015160a084015260c081015160c084015260e081015160e0840152015161010082015296386145ac565b3d9150614de2565b614e9991503d806102c051833e61167e8183611cad565b38614570565b634e487b7160e01b6102c05152601160045260246102c051fd5b6102c051614538565b90506020813d602011614eec575b81614edd60209383611cad565b81010312614b565751386144ed565b3d9150614ed0565b614f0b9150823d84116106d9576106cb8183611cad565b386144be565b9092506020813d602011614f3d575b81614f2d60209383611cad565b81010312614b5657519138614487565b3d9150614f20565b90506020813d602011614f77575b81614f6060209383611cad565b81010312614b5657614f719061223e565b38614450565b3d9150614f53565b90614f88613419565b50614f91613419565b916001600160a01b0316801561503457614fcb91606091604051808095819463230fa49560e21b83526020600484015260248301906117a1565b03915afa9081156106075760009182918391614ff1575060408401526020830152815290565b929150506060823d60601161502c575b8161500e60609383611cad565b810103126108c757508051604060208301519201519091903861435e565b3d9150615001565b505090565b6150416120be565b506040516301ffc9a760e01b8152633aa17d5560e11b60048201526001600160a01b039190911690602081602481855afa90811561060757600091615404575b50806153f2575b15610bfb57604051631e46e62f60e21b8152602081600481855afa908115610607576000916153b0575b50604051632630c12f60e01b8152906001600160a01b0316602082600481845afa9182156106075760009261538f575b5060405163011ddaef60e71b8152602081600481875afa80156106075761514493602092600092615370575b50604051634858138f60e01b81526001600160a01b03888116600483015290921660248301529093849190829081906044820190565b03916001600160a01b03165afa9182156106075760009261533c575b506040805163a4c1cccb60e01b81526001600160a01b0386166004820152949085602481875afa918215610607576000956000936152f4575b5090602060049260405193848092633f4a2d2760e01b82525afa918215610607576044926020916000916152d7575b506040516345a1aa4160e11b8152600260048201526000602482015293849182906001600160a01b03165afa918215610607576000926152a1575b50604051633623869b60e01b81526001600160a01b03909116600482015260248101919091529260209084908180604481015b03915afa9283156106075760009361526d575b506040519361525785611bd0565b8452151560208401526040830152606082015290565b9092506020813d602011615299575b8161528960209383611cad565b810103126105fa57519138615249565b3d915061527c565b91506020823d6020116152cf575b816152bc60209383611cad565b810103126105fa57905190615236615203565b3d91506152af565b6152ee9150823d84116106d9576106cb8183611cad565b386151c8565b955091506040853d604011615334575b8161531160409383611cad565b810103126105fa57600490602061532b818851980161223e565b93919250615199565b3d9150615304565b9091506020813d602011615368575b8161535860209383611cad565b810103126105fa57519038615160565b3d915061534b565b615388919250833d85116106d9576106cb8183611cad565b903861510e565b6153a991925060203d6020116106d9576106cb8183611cad565b90386150e2565b6020813d6020116153ea575b816153c960209383611cad565b810103126108bf5751906001600160a01b03821682036108c75750386150b2565b3d91506153bc565b506001600160a01b0382161515615088565b90506020813d602011615436575b8161541f60209383611cad565b810103126105fa576154309061223e565b38615081565b3d9150615412565b6040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b0390931694939092602081602481895afa908115610607576000916157a8575b5015610bfb5760009160005b845181101561570a576001600160a01b036154a6828761220e565b5116604051633f4a2d2760e01b81526020816004818c5afa908115610607576000916156ec575b506040516306fdde0360e01b8152600081600481865afa80156106075761551d926080926000926156d1575b50604051808095819463481d98fb60e11b83526020600484015260248301906117a1565b03916001600160a01b03165afa918215610607576000918293615685575b50859286156155a6575b50508161557d575b5061555b575b60010161548b565b92600190615575906001600160a01b036115d7878961220e565b939050615553565b90506001600160a01b03615591838861220e565b516001600160a01b039092169116143861554d565b6002919293506155b581612d16565b1490816155c7575b5015903880615545565b6040516358a06f0760e01b81529150602090829060049082905afa90811561060757602491602091600091615668575b506040516370a0823160e01b81526001600160a01b0387811660048301529093849290918391165afa90811561060757600091615637575b5015386155bd565b906020823d8211615660575b8161565060209383611cad565b810103126108c75750513861562f565b3d9150615643565b61567f9150823d81116106d9576106cb8183611cad565b386155f7565b9092506080813d82116156c9575b816156a060809383611cad565b810103126108bf5760206156b382612179565b9101519160038310156108c7575090913861553b565b3d9150615693565b6156e591923d8091833e612cbf8183611cad565b90386154f9565b615704915060203d81116106d9576106cb8183611cad565b386154cd565b5091929394505061571a8261200c565b926157286040519485611cad565b828452601f196157378461200c565b0160005b81811061579157505060005b838110615755575050505090565b600190615775846001600160a01b0361576e848761220e565b5116614403565b61577f828861220e565b5261578a818761220e565b5001615747565b60209061579c613486565b8282890101520161573b565b90506020813d6020116157da575b816157c360209383611cad565b810103126105fa576157d49061223e565b3861547f565b3d91506157b6565b90918251916157f08361200c565b936157fe6040519586611cad565b838552601f1961580d8561200c565b0160005b81811061586957505060005b84811061582c57505050505090565b60019061584d856001600160a01b03615845848761220e565b51168661210a565b615857828961220e565b52615862818861220e565b500161581d565b6020906158746120e3565b82828a01015201615811565b6040516301ffc9a760e01b8152633d79d7fb60e11b60048201526001600160a01b03919091169190602081602481865afa90811561060757600091615a89575b5015610bfb5760405163eb02c30160e01b815260048101829052600081602481865afa90811561060757600091615a70575b50602081015115615a685760405191632f60fad360e21b83526004830152602082602481865afa801561060757600090615a35575b60408281015160a084015160c0909401519151633f4a2d2760e01b815291959194506001600160a01b03938416931690602090859060049082905afa90811561060757602094600092615a14575b50604051631839f03960e21b81526001600160a01b0391821660048201529381166024850152604484019590955260648301919091529092166084830152818060a481015b038173__$75df3f6366b0557754cd3ba14359105414$__5af4908115610607576000916159e5575090565b90506020813d602011615a0c575b81615a0060209383611cad565b810103126105fa575190565b3d91506159f3565b6159ba9250615a2f90863d88116106d9576106cb8183611cad565b91615975565b506020823d602011615a60575b81615a4f60209383611cad565b810103126105fa5760049151615927565b3d9150615a42565b505050600090565b615a83913d8091833e6108638183611cad565b386158f2565b90506020813d602011615abb575b81615aa460209383611cad565b810103126105fa57615ab59061223e565b386158c0565b3d9150615a97565b6040516301ffc9a760e01b8152633d79d7fb60e11b6004820152600095946001600160a01b0383169391602081602481885afa90811561060757600091615c95575b5080615c83575b15610bfb5760405163183ea23960e21b81526001600160a01b038316600482015290602082602481885afa91821561060757600092615c4f575b50818610156142555781615b5a8288612222565b10615c3a575084615b6a9161226a565b925b615b7584614079565b9460005b858110615b8a575050505050509190565b615bc96020615b998385612222565b60405163d64470e960e01b81526001600160a01b0388166004820152602481019190915291829081906044820190565b0381875afa90811561060757600091615c07575b5090615beb60019287613672565b615bf5828a61220e565b52615c00818961220e565b5001615b79565b906020823d8211615c32575b81615c2060209383611cad565b810103126108c7575051615beb615bdd565b3d9150615c13565b80949750615c49915085612222565b95615b6c565b90916020823d602011615c7b575b81615c6a60209383611cad565b810103126108c75750519038615b46565b3d9150615c5d565b506001600160a01b0382161515615b0c565b90506020813d602011615cc7575b81615cb060209383611cad565b810103126105fa57615cc19061223e565b38615b05565b3d9150615ca3565b519069ffffffffffffffffffff821682036105fa57565b8115615cf0570490565b634e487b7160e01b600052601260045260246000fd5b90615d1091615d37565b6706f05b59d3b200008101908181116105b85781106105a757670de0b6b3a7640000900490565b600092918015918215615d4e575b50501561061357565b91509250615d66615d5f8483612d36565b9384615ce6565b143880615d45565b9190615d7a9083612222565b9182106105a75756fea26469706673582212204f5ca5dddc8f7c53ee88438958254c711c0573b5bd19e28783412409cbf5958764736f6c634300081a0033",
  "libraries": {
    "PrimexPricingLibrary": "0x7A0FFAaEFbed420d00c5E60c1668693a8a26B88C",
    "PositionLibrary": "0xe31a74961DE60A4c117e000734F5079728CEB83F",
    "LimitOrderLibrary": "0x5C52411192b79A935a66b34661D5523187E7d07e",
    "Errors": "0x988288925196F0725268378d0C7c8aA0E50EB423"
  },
  "devdoc": {
    "details": "All functions in this contract are intended to be called off-chain. Do not call functions from other contracts to avoid an out-of-gas error.",
    "kind": "dev",
    "methods": {
      "getAllBucketsFactory(address[],address,address,bool)": {
        "params": {
          "_bucketFactories": "An array of the BucketFactory contracts addresses.",
          "_positionManager": "The address of the PositionManager contract.",
          "_showDeprecated": "A boolean flag indicating whether to include deprecated buckets in the result.",
          "_trader": "The address of the trader for whom the buckets are retrieved."
        },
        "returns": {
          "_0": "An array of BucketMetaData structs representing the bucket metadata."
        }
      },
      "getArrayOpenPositionDataByBucket(address,address,uint256,uint256)": {
        "params": {
          "_bucket": "The address of the bucket positions are related to",
          "_count": "The number of positions to retrieve.",
          "_cursor": "The cursor value for pagination.",
          "_positionManager": "The address of the PositionManager where the positions is stored"
        }
      },
      "getArrayOpenPositionDataByTrader(address,address,uint256,uint256)": {
        "params": {
          "_count": "The number of positions to retrieve.",
          "_cursor": "The cursor value for pagination.",
          "_positionManager": "The address of the PositionManager where the positions is stored",
          "_trader": "The address, information about all positions of which will be displayed"
        }
      },
      "getAssetMetadata(address,address)": {
        "params": {
          "_asset": "The address of the asset to retrieve metadata for.",
          "_bucket": "The address of the Bucket contract."
        },
        "returns": {
          "_0": "metadata The metadata of the asset within the bucket."
        }
      },
      "getBucket(address,address)": {
        "params": {
          "_bucket": "The address of the Bucket contract.",
          "_trader": "The address of the trader."
        },
        "returns": {
          "_0": "The metadata of the bucket."
        }
      },
      "getBucketsArray(address[],address,address,bool)": {
        "params": {
          "_buckets": "The array of bucket addresses.",
          "_positionManager": "The address of the PositionManager contract.",
          "_showDeprecated": "Flag to determine whether deprecated buckets should be included.",
          "_trader": "The address of the trader."
        },
        "returns": {
          "_0": "An array of `BucketMetaData` objects."
        }
      },
      "getChainlinkLatestRoundData(address[])": {
        "params": {
          "_feeds": "An array of feed addresses."
        },
        "returns": {
          "_0": "res An array of RoundData structs containing the latest round data for each feed."
        }
      },
      "getEstimatedMinProtocolFee(uint8,address)": {
        "params": {
          "_pm": "The instance of the PositionManager contract.",
          "_tradingOrderType": "Represents the type of trading order in enum TradingOrderType (IPrimexDNSStorageV3)"
        }
      },
      "getLMBucketInfo(address,string)": {
        "params": {
          "_bucketName": "The name of the liquidity mining bucket.",
          "liquidityMiningRewardDistributor": "The instance of the LiquidityMiningRewardDistributor contract."
        },
        "returns": {
          "_0": "info The liquidity mining bucket information."
        }
      },
      "getLenderInfo(address,string,address)": {
        "params": {
          "bucketName": "The name of the lending bucket.",
          "liquidityMiningRewardDistributor": "The instance of the LiquidityMiningRewardDistributor contract.",
          "user": "The address of the lender."
        },
        "returns": {
          "_0": "info The lender information."
        }
      },
      "getLimitOrdersWithConditions(address,uint256,uint256)": {
        "params": {
          "_count": "The number of positions to retrieve.",
          "_cursor": "The cursor value for pagination.",
          "_limitOrderManager": "The address of the LimitOrderManager where the order is stored."
        },
        "returns": {
          "limitOrdersWithConditions": "limitOrderWithConditions An array of LimitOrderWithConditions structs representing open positions with conditions.",
          "newCursor": "The new cursor value for pagination."
        }
      },
      "getLiquidationPrice(address,string,uint256,address,uint256)": {
        "details": "The liquidation price is the price at which a position can be liquidated (i.e., its collateral can cover the borrowed amount).",
        "params": {
          "_borrowedAmount": "The amount borrowed in the position.",
          "_bucket": "The name of the bucket associated with the position.",
          "_positionAmount": "The amount of the asset held in the position.",
          "_positionAsset": "The address of the asset held in the position.",
          "_positionManager": "The address of the PositionManager contract."
        },
        "returns": {
          "_0": "The liquidation price in borrowed asset for the position."
        }
      },
      "getLiquidationPrice(address,uint256)": {
        "params": {
          "_id": "The ID of the position.",
          "_positionManager": "The address of the PositionManager contract."
        },
        "returns": {
          "_0": "The liquidation price in borrowed asset of the position."
        }
      },
      "getOpenPositionData(address,uint256)": {
        "params": {
          "_id": "Position id to show the parameters position",
          "_positionManager": "The address of the PositionManager where the position is stored"
        },
        "returns": {
          "_0": "openPositionData The open position data including various details."
        }
      },
      "getOpenPositionsWithConditions(address,uint256,uint256)": {
        "params": {
          "_count": "The number of positions to retrieve.",
          "_cursor": "The cursor value for pagination.",
          "_positionManager": "The address of the PositionManager where the position is stored."
        },
        "returns": {
          "newCursor": "The new cursor value for pagination.",
          "openPositionsWithConditions": "openPositionsWithConditionsArray An array of OpenPositionWithConditions structs representing open positions with conditions."
        }
      },
      "getPositionMaxDecrease(address,uint256,bytes,bytes[][],uint256[])": {
        "details": "maxDecrease = (1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - pricedrop) * positionAmountInBorrowedAsset / (feeBuffer * (1 + maintenanceBuffer)) - position.bucket.getNormalizedVariableDebt() * position.scaledDebtAmount",
        "params": {
          "_id": "The ID of the position.",
          "_pm": "The instance of the PositionManager contract."
        },
        "returns": {
          "_0": "The maximum decrease in position value."
        }
      },
      "getSupportedAsset(address,address,address)": {
        "params": {
          "_asset": "The address of the asset for which information is requested.",
          "_bucket": "The address of the Bucket where the asset is supported.",
          "_trader": "The address of the Trader requesting the information."
        },
        "returns": {
          "_0": "supportedAsset The SupportedAsset struct containing the asset and its properties."
        }
      },
      "getSupportedAssetArray(address,address[],address)": {
        "params": {
          "_assets": "An array of asset addresses.",
          "_bucket": "The address of the Bucket.",
          "_trader": "The address of the trader."
        },
        "returns": {
          "_0": "res An array of SupportedAsset structs representing the supported assets."
        }
      },
      "getTokenArrayMetadata(address[],address)": {
        "params": {
          "_tokens": "The array of token addresses.",
          "_trader": "The address of the trader."
        },
        "returns": {
          "_0": "res The array of token metadata."
        }
      },
      "getTokenMetadata(address,address)": {
        "params": {
          "_token": "The address of the token.",
          "_trader": "The address of the trader."
        },
        "returns": {
          "_0": "metadata The metadata of the token."
        }
      },
      "isStopLossReached(address,uint256,bytes,bytes[][],uint256[])": {
        "params": {
          "_id": "The ID of the position to check.",
          "_positionManager": "The address of the PositionManager contract."
        },
        "returns": {
          "_0": "A boolean indicating whether the stop loss condition is reached."
        }
      },
      "supportsInterface(bytes4)": {
        "params": {
          "interfaceId": "The interface id to check"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAllBucketsFactory(address[],address,address,bool)": {
        "notice": "Retrieves all bucket metadata from a bucket factory contract."
      },
      "getArrayOpenPositionDataByBucket(address,address,uint256,uint256)": {
        "notice": "The function shows the parameters for all open positions of the `_trader` with the best dex for each position"
      },
      "getArrayOpenPositionDataByTrader(address,address,uint256,uint256)": {
        "notice": "The function shows the parameters for all open positions of the `_trader` with the best dex for each position"
      },
      "getAssetMetadata(address,address)": {
        "notice": "Retrieves the metadata of an asset within a bucket."
      },
      "getBucket(address,address)": {
        "notice": "Retrieves the metadata of a bucket."
      },
      "getBucketsArray(address[],address,address,bool)": {
        "notice": "Retrieves an array of `BucketMetaData` for the given `_user`."
      },
      "getChainlinkLatestRoundData(address[])": {
        "notice": "Retrieves the latest round data for multiple Chainlink feeds."
      },
      "getEstimatedMinProtocolFee(uint8,address)": {
        "notice": "Calculate an approximate min protocol fee based on averageGasPerAction, which represents the typical amount of gas expended by the Keeper for the relevant action."
      },
      "getLMBucketInfo(address,string)": {
        "notice": "Retrieves information about a liquidity mining bucket."
      },
      "getLenderInfo(address,string,address)": {
        "notice": "Retrieves information about a lender from the LiquidityMiningRewardDistributor contract."
      },
      "getLimitOrdersWithConditions(address,uint256,uint256)": {
        "notice": "The function returns the limit orders with corresponding conditions"
      },
      "getLiquidationPrice(address,string,uint256,address,uint256)": {
        "notice": "Calculates the liquidation price for a given position."
      },
      "getLiquidationPrice(address,uint256)": {
        "notice": "Retrieves the liquidation price of a position."
      },
      "getOpenPositionData(address,uint256)": {
        "notice": "Retrieves open position data based on the provided position manager and id."
      },
      "getOpenPositionsWithConditions(address,uint256,uint256)": {
        "notice": "The function returns the positions with corresponding conditions."
      },
      "getPositionMaxDecrease(address,uint256,bytes,bytes[][],uint256[])": {
        "notice": "Retrieves the maximum decrease in position value for a given position ID."
      },
      "getSupportedAsset(address,address,address)": {
        "notice": "Retrieves information about a supported asset."
      },
      "getSupportedAssetArray(address,address[],address)": {
        "notice": "Retrieves an array of SupportedAsset structs for the given bucket, assets, and trader."
      },
      "getTokenArrayMetadata(address[],address)": {
        "notice": "Retrieves the metadata of an array of tokens for a given trader."
      },
      "getTokenMetadata(address,address)": {
        "notice": "Retrieves the metadata of a token for a given trader."
      },
      "isStopLossReached(address,uint256,bytes,bytes[][],uint256[])": {
        "notice": "Checks if the stop loss condition of a position is reached."
      },
      "supportsInterface(bytes4)": {
        "notice": "Interface checker"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}