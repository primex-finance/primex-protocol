{
  "address": "0xd12557d79263f1E2Cd0D4023Fd77292C0E26afD5",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "DS_MATH_ADD_OVERFLOW",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DS_MATH_MUL_OVERFLOW",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "addedAsset",
          "type": "address"
        }
      ],
      "name": "AddAsset",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "params",
          "type": "bytes"
        }
      ],
      "name": "BarCalculationParamsChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "BucketLaunched",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "depositer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "pTokenReceiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "DepositToAave",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "feeBuffer",
          "type": "uint256"
        }
      ],
      "name": "FeeBufferChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "interestRateStrategy",
          "type": "address"
        }
      ],
      "name": "InterestRateStrategyChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maxTotalDeposit",
          "type": "uint256"
        }
      ],
      "name": "MaxTotalDepositChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "bar",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "lar",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "variableBorrowIndex",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "liquidityIndex",
          "type": "uint128"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "RatesIndexesUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "deletedAsset",
          "type": "address"
        }
      ],
      "name": "RemoveAsset",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reserveRate",
          "type": "uint256"
        }
      ],
      "name": "ReserveRateChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TopUpTreasury",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "withdrawer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "borrowAssetReceiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Withdraw",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "WithdrawFromAave",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawalFeeRate",
          "type": "uint256"
        }
      ],
      "name": "WithdrawalFeeChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "aaveDeposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newAsset",
          "type": "address"
        }
      ],
      "name": "addAsset",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "allowedAssets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isSupported",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "availableLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "bar",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_traders",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "_debtsToBurn",
          "type": "uint256[]"
        },
        {
          "internalType": "address",
          "name": "_receiverOfAmountToReturn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amountToReturn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_permanentLossAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_length",
          "type": "uint256"
        }
      ],
      "name": "batchDecreaseTradersDebt",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "borrowedAsset",
      "outputs": [
        {
          "internalType": "contract IERC20Metadata",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "debtToken",
      "outputs": [
        {
          "internalType": "contract IDebtToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_trader",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_debtToBurn",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_receiverOfAmountToReturn",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amountToReturn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_permanentLossAmount",
          "type": "uint256"
        }
      ],
      "name": "decreaseTraderDebt",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pTokenReceiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_takeDepositFromWallet",
          "type": "bool"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pTokenReceiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_bucketTo",
          "type": "string"
        },
        {
          "internalType": "contract ISwapManager",
          "name": "_swapManager",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "shares",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "dexName",
                  "type": "string"
                },
                {
                  "internalType": "bytes",
                  "name": "encodedPath",
                  "type": "bytes"
                }
              ],
              "internalType": "struct PrimexPricingLibrary.SwapPath[]",
              "name": "paths",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct PrimexPricingLibrary.Route[]",
          "name": "routes",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "_amountOutMin",
          "type": "uint256"
        }
      ],
      "name": "depositFromBucket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "estimatedBar",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "estimatedLar",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feeBuffer",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllowedAssets",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLiquidityMiningParams",
      "outputs": [
        {
          "components": [
            {
              "internalType": "contract ILiquidityMiningRewardDistributor",
              "name": "liquidityMiningRewardDistributor",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "isBucketLaunched",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "accumulatingAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deadlineTimestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stabilizationDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stabilizationEndTimestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxAmountPerUser",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maxStabilizationEndTimestamp",
              "type": "uint256"
            }
          ],
          "internalType": "struct IBucketStorage.LiquidityMiningParams",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getNormalizedIncome",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getNormalizedVariableDebt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_trader",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        }
      ],
      "name": "increaseDebt",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "contract IPToken",
              "name": "pToken",
              "type": "address"
            },
            {
              "internalType": "contract IDebtToken",
              "name": "debtToken",
              "type": "address"
            },
            {
              "internalType": "contract IPositionManager",
              "name": "positionManager",
              "type": "address"
            },
            {
              "internalType": "contract IPriceOracle",
              "name": "priceOracle",
              "type": "address"
            },
            {
              "internalType": "contract IPrimexDNS",
              "name": "dns",
              "type": "address"
            },
            {
              "internalType": "contract IReserve",
              "name": "reserve",
              "type": "address"
            },
            {
              "internalType": "contract IWhiteBlackList",
              "name": "whiteBlackList",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "contract IERC20Metadata",
              "name": "borrowedAsset",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "feeBuffer",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "withdrawalFeeRate",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "reserveRate",
              "type": "uint256"
            },
            {
              "internalType": "contract ILiquidityMiningRewardDistributor",
              "name": "liquidityMiningRewardDistributor",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "liquidityMiningAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityMiningDeadline",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stabilizationDuration",
              "type": "uint256"
            },
            {
              "internalType": "contract IInterestRateStrategy",
              "name": "interestRateStrategy",
              "type": "address"
            },
            {
              "internalType": "uint128",
              "name": "estimatedBar",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "estimatedLar",
              "type": "uint128"
            },
            {
              "internalType": "uint256",
              "name": "maxAmountPerUser",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "isReinvestToAaveEnabled",
              "type": "bool"
            },
            {
              "internalType": "bytes",
              "name": "barCalcParams",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "maxTotalDeposit",
              "type": "uint256"
            }
          ],
          "internalType": "struct IBucket.ConstructorParams",
          "name": "_params",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "_registry",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "interestRateStrategy",
      "outputs": [
        {
          "internalType": "contract IInterestRateStrategy",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isActive",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isBucketStable",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isDelisted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isDeprecated",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isReinvestToAaveEnabled",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isWithdrawAfterDelistingAvailable",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lar",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastUpdatedBlockTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquidityIndex",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_asset",
          "type": "address"
        }
      ],
      "name": "maxAssetLeverage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxTotalDeposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pToken",
      "outputs": [
        {
          "internalType": "contract IPToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "paybackPermanentLoss",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "permanentLoss",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "permanentLossScaled",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "positionManager",
      "outputs": [
        {
          "internalType": "contract IPositionManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pTokenReceiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_duration",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "_bucketFrom",
          "type": "string"
        }
      ],
      "name": "receiveDeposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "registry",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_assetToDelete",
          "type": "address"
        }
      ],
      "name": "removeAsset",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "reserve",
      "outputs": [
        {
          "internalType": "contract IReserve",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "reserveRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "returnLiquidityFromAaveToBucket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_params",
          "type": "bytes"
        }
      ],
      "name": "setBarCalculationParams",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_feeBuffer",
          "type": "uint256"
        }
      ],
      "name": "setFeeBuffer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_interestRateStrategy",
          "type": "address"
        }
      ],
      "name": "setInterestRateStrategy",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_maxTotalDeposit",
          "type": "uint256"
        }
      ],
      "name": "setMaxTotalDeposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_reserveRate",
          "type": "uint256"
        }
      ],
      "name": "setReserveRate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_withdrawalFeeRate",
          "type": "uint256"
        }
      ],
      "name": "setWithdrawalFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "variableBorrowIndex",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "whiteBlackList",
      "outputs": [
        {
          "internalType": "contract IWhiteBlackList",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_borrowAssetReceiver",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawAfterDelisting",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawalFeeRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe5a7687bc280309fcb784ed2c76bf96f90ec157de44e8b2b48a4671994e23254",
  "receipt": {
    "to": null,
    "from": "0xC110b6e93a51ACF1f3DEd19c754789E7A2304F07",
    "contractAddress": "0xd12557d79263f1E2Cd0D4023Fd77292C0E26afD5",
    "transactionIndex": 7,
    "gasUsed": "5217357",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000008000000000000000000000000000000080100000000000000000000000800000000000000000000100000000000000000800010000000000000000000000000000000000000080000000000000000000000000000000200000000020000000000000000080000000000000080000200000000000000000000000000400000000000000000040000000000000004000000000000000000001000000040000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x6f7329152c1ac7bd27859677989b2a728b5666be776c6b00d070ead89af05d1f",
    "transactionHash": "0xe5a7687bc280309fcb784ed2c76bf96f90ec157de44e8b2b48a4671994e23254",
    "logs": [
      {
        "transactionIndex": 7,
        "blockNumber": 50091019,
        "transactionHash": "0xe5a7687bc280309fcb784ed2c76bf96f90ec157de44e8b2b48a4671994e23254",
        "address": "0xd12557d79263f1E2Cd0D4023Fd77292C0E26afD5",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 13,
        "blockHash": "0x6f7329152c1ac7bd27859677989b2a728b5666be776c6b00d070ead89af05d1f"
      },
      {
        "transactionIndex": 7,
        "blockNumber": 50091019,
        "transactionHash": "0xe5a7687bc280309fcb784ed2c76bf96f90ec157de44e8b2b48a4671994e23254",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000c110b6e93a51acf1f3ded19c754789e7a2304f07",
          "0x000000000000000000000000f0245f6251bef9447a08766b9da2b07b28ad80b0"
        ],
        "data": "0x00000000000000000000000000000000000000000000000006ae98e60a7e58f000000000000000000000000000000000000000000000000056488347331e44020000000000000000000000000000000000000000000006a70d14b100562310e50000000000000000000000000000000000000000000000004f99ea61289feb120000000000000000000000000000000000000000000006a713c349e660a169d5",
        "logIndex": 14,
        "blockHash": "0x6f7329152c1ac7bd27859677989b2a728b5666be776c6b00d070ead89af05d1f"
      }
    ],
    "blockNumber": 50091019,
    "cumulativeGasUsed": "5677653",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 3,
  "solcInputHash": "ac08d1652288d4d03be56436412dd0c4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DS_MATH_ADD_OVERFLOW\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DS_MATH_MUL_OVERFLOW\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addedAsset\",\"type\":\"address\"}],\"name\":\"AddAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"BarCalculationParamsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BucketLaunched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pTokenReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositToAave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBuffer\",\"type\":\"uint256\"}],\"name\":\"FeeBufferChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interestRateStrategy\",\"type\":\"address\"}],\"name\":\"InterestRateStrategyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTotalDeposit\",\"type\":\"uint256\"}],\"name\":\"MaxTotalDepositChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"bar\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"lar\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"variableBorrowIndex\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidityIndex\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RatesIndexesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"deletedAsset\",\"type\":\"address\"}],\"name\":\"RemoveAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveRate\",\"type\":\"uint256\"}],\"name\":\"ReserveRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TopUpTreasury\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowAssetReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFromAave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"}],\"name\":\"WithdrawalFeeChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aaveDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAsset\",\"type\":\"address\"}],\"name\":\"addAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bar\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_traders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_debtsToBurn\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_receiverOfAmountToReturn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountToReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_permanentLossAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"batchDecreaseTradersDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowedAsset\",\"outputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtToken\",\"outputs\":[{\"internalType\":\"contract IDebtToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debtToBurn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiverOfAmountToReturn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountToReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_permanentLossAmount\",\"type\":\"uint256\"}],\"name\":\"decreaseTraderDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pTokenReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_takeDepositFromWallet\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pTokenReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_bucketTo\",\"type\":\"string\"},{\"internalType\":\"contract ISwapManager\",\"name\":\"_swapManager\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"dexName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"encodedPath\",\"type\":\"bytes\"}],\"internalType\":\"struct PrimexPricingLibrary.SwapPath[]\",\"name\":\"paths\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PrimexPricingLibrary.Route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"depositFromBucket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedBar\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedLar\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowedAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityMiningParams\",\"outputs\":[{\"components\":[{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBucketLaunched\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"accumulatingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStabilizationEndTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct IBucketStorage.LiquidityMiningParams\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNormalizedIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNormalizedVariableDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"increaseDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IPToken\",\"name\":\"pToken\",\"type\":\"address\"},{\"internalType\":\"contract IDebtToken\",\"name\":\"debtToken\",\"type\":\"address\"},{\"internalType\":\"contract IPositionManager\",\"name\":\"positionManager\",\"type\":\"address\"},{\"internalType\":\"contract IPriceOracle\",\"name\":\"priceOracle\",\"type\":\"address\"},{\"internalType\":\"contract IPrimexDNS\",\"name\":\"dns\",\"type\":\"address\"},{\"internalType\":\"contract IReserve\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"contract IWhiteBlackList\",\"name\":\"whiteBlackList\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC20Metadata\",\"name\":\"borrowedAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveRate\",\"type\":\"uint256\"},{\"internalType\":\"contract ILiquidityMiningRewardDistributor\",\"name\":\"liquidityMiningRewardDistributor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityMiningAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityMiningDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stabilizationDuration\",\"type\":\"uint256\"},{\"internalType\":\"contract IInterestRateStrategy\",\"name\":\"interestRateStrategy\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"estimatedBar\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"estimatedLar\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountPerUser\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReinvestToAaveEnabled\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"barCalcParams\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct IBucket.ConstructorParams\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateStrategy\",\"outputs\":[{\"internalType\":\"contract IInterestRateStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBucketStable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDeprecated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReinvestToAaveEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWithdrawAfterDelistingAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lar\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdatedBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityIndex\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"maxAssetLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTotalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pToken\",\"outputs\":[{\"internalType\":\"contract IPToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"paybackPermanentLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permanentLoss\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permanentLossScaled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positionManager\",\"outputs\":[{\"internalType\":\"contract IPositionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pTokenReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_bucketFrom\",\"type\":\"string\"}],\"name\":\"receiveDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetToDelete\",\"type\":\"address\"}],\"name\":\"removeAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"internalType\":\"contract IReserve\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnLiquidityFromAaveToBucket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"setBarCalculationParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeBuffer\",\"type\":\"uint256\"}],\"name\":\"setFeeBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interestRateStrategy\",\"type\":\"address\"}],\"name\":\"setInterestRateStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTotalDeposit\",\"type\":\"uint256\"}],\"name\":\"setMaxTotalDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserveRate\",\"type\":\"uint256\"}],\"name\":\"setReserveRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawalFeeRate\",\"type\":\"uint256\"}],\"name\":\"setWithdrawalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"variableBorrowIndex\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whiteBlackList\",\"outputs\":[{\"internalType\":\"contract IWhiteBlackList\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrowAssetReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAfterDelisting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Initialized(uint8)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"addAsset(address)\":{\"details\":\"Function to add new trading asset for this bucketOnly callable by the MEDIUM_TIMELOCK_ADMIN role.\",\"params\":{\"_newAsset\":\"The address of trading asset\"}},\"availableLiquidity()\":{\"details\":\"Returns current avalable liquidity of borrowedAsset for trading.\",\"returns\":{\"_0\":\"The amount of available borrowedAsset\"}},\"batchDecreaseTradersDebt(address[],uint256[],address,uint256,uint256,uint256)\":{\"details\":\"This function can only be called by the BATCH_MANAGER_ROLE.\",\"params\":{\"_amountToReturn\":\"The amount to be returned.\",\"_debtsToBurn\":\"An array of uint256 values representing the debts to burn for each trader.\",\"_length\":\"The length of the traders array.\",\"_permanentLossAmount\":\"The amount of permanent loss.\",\"_receiverOfAmountToReturn\":\"The address that will receive the amount to be returned.\",\"_traders\":\"An array of addresses representing the traders.\"}},\"decreaseTraderDebt(address,uint256,address,uint256,uint256)\":{\"details\":\"Function to update rates and indexes. Burns debt tokens of trader. Called only by positionManager contract.\",\"params\":{\"_amountToReturn\":\"Amount to transfer from bucket\",\"_debtToBurn\":\"The 'amount' of trader's debtTokens will be burned by the trader.\",\"_permanentLossAmount\":\"The amount of the protocol's debt to creditors accrued for this position\",\"_receiverOfAmountToReturn\":\"Treasury in case of liquidation. TraderBalanceVault in other cases\",\"_trader\":\"The address of the trader, who opened position.\"}},\"deposit(address,uint256)\":{\"details\":\"Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.\",\"params\":{\"_amount\":\"The amount of underlying tokens to be deposited\",\"_pTokenReceiver\":\"The address to receive the deposited pTokens.\"}},\"deposit(address,uint256,bool)\":{\"details\":\"Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.\",\"params\":{\"_amount\":\"The amount of underlying tokens to be deposited\",\"_pTokenReceiver\":\"The address to receive the deposited pTokens.\",\"_takeDepositFromWallet\":\"A flag indicating whether to make the deposit from user wallet\"}},\"depositFromBucket(string,address,(uint256,(string,bytes)[])[],uint256)\":{\"params\":{\"_amountOutMin\":\"The minimum amount of tokens to receive from the swap.\",\"_bucketTo\":\"The name of the destination bucket.\",\"_swapManager\":\"The address of the swap manager.\",\"routes\":\"The array of routes for swapping tokens.\"}},\"getAllowedAssets()\":{\"details\":\"Returns allowed trading assets for current bucket\",\"returns\":{\"_0\":\"List of addresses of allowed assets\"}},\"getLiquidityMiningParams()\":{\"details\":\"Returns the parameters for liquidity mining.\",\"returns\":{\"_0\":\"LMparams The liquidity mining parameters.\"}},\"getNormalizedIncome()\":{\"details\":\"Returns the normalized income per unit of underlying asset, expressed in ray\",\"returns\":{\"_0\":\"The normalized income per unit of underlying asset, expressed in ray\"}},\"getNormalizedVariableDebt()\":{\"details\":\"Returns the normalized variable debt per unit of underlying asset, expressed in ray\"},\"increaseDebt(address,uint256,address)\":{\"details\":\"Function to update rates and indexes when a trader opens a trading position. Mints debt tokens to trader. Calls only by positionManager contract.\",\"params\":{\"_amount\":\"The 'amount' for which the deal is open, and 'amount' of debtTokens will be minted to the trader.\",\"_to\":\"The address to transfer the borrowed asset to.\",\"_trader\":\"The address of the trader, who opens position.\"}},\"initialize((string,address,address,address,address,address,address,address,address[],address,uint256,uint256,uint256,address,uint256,uint256,uint256,address,uint128,uint128,uint256,bool,bytes,uint256),address)\":{\"details\":\"Initializes the contract with the given parameters.\",\"params\":{\"_params\":\"The ConstructorParams struct containing initialization parameters.\",\"_registry\":\"The address of the registry contract.\"}},\"isActive()\":{\"details\":\"Checks if this bucket is active in the protocol.\",\"returns\":{\"_0\":\"bool True if the bucket is active, false otherwise.\"}},\"isBucketStable()\":{\"details\":\"Returns a boolean value indicating whether the bucket is stable in the liquidity mining event.\",\"returns\":{\"_0\":\"A boolean value representing the stability of the bucket.\"}},\"isDelisted()\":{\"details\":\"Returns a boolean value indicating whether the bucket is delisted.\",\"returns\":{\"_0\":\"True if the bucket is delisted, otherwise false.\"}},\"isDeprecated()\":{\"details\":\"Checks if the bucket is deprecated in the protocol.\",\"returns\":{\"_0\":\"Whether the bucket is deprecated or not.\"}},\"isWithdrawAfterDelistingAvailable()\":{\"details\":\"Checks if an admin can withdraw from the bucket after delisting.\",\"returns\":{\"_0\":\"A boolean indicating whether withdrawal is available.\"}},\"maxAssetLeverage(address)\":{\"details\":\"Calculates the max leverage according to the following formula: ((1 + maintenanceBuffer) * feeBuffer) / ((1 + maintenanceBuffer) * feeBuffer - (1 - securityBuffer) * (1 - pairPriceDropBA) * (1 - oracleTolerableLimitAB) * (1 - oracleTolerableLimitBA))\",\"params\":{\"_asset\":\"The address of trading asset\"},\"returns\":{\"_0\":\"The maximum leverage as a uint256 value.\"}},\"paybackPermanentLoss(uint256)\":{\"params\":{\"amount\":\"The amount of pTokens to be burned to pay back the permanent loss.\"}},\"permanentLoss()\":{\"details\":\"Calculates the permanent loss based on the scaled permanent loss and the normalized income.\",\"returns\":{\"_0\":\"The amount of permanent loss.\"}},\"receiveDeposit(address,uint256,uint256,string)\":{\"details\":\"Receives a deposit and distributes it to the specified pToken receiver.Can be called only by another bucket.\",\"params\":{\"_amount\":\"The amount of tokens being deposited.\",\"_bucketFrom\":\"The name of the bucket from which the deposit is being made.\",\"_duration\":\"The blocking time for a fixed-term deposit (if it's 0, then it will be a usual deposit)\",\"_pTokenReceiver\":\"The address of the recipient of the pToken.\"}},\"removeAsset(address)\":{\"details\":\"Only callable by the SMALL_TIMELOCK_ADMIN role.\",\"params\":{\"_assetToDelete\":\"The address of the asset to be removed.\"}},\"returnLiquidityFromAaveToBucket()\":{\"details\":\"Allows the SMALL_TIMELOCK_ADMIN to withdraw all liquidity from Aave to Bucket.\"},\"setFeeBuffer(uint256)\":{\"details\":\"Sets the new fee buffer.Only callable by the MEDIUM_TIMELOCK_ADMIN role.\",\"params\":{\"_feeBuffer\":\"The new fee buffer value.\"}},\"setInterestRateStrategy(address)\":{\"details\":\"Sets the interest rate strategy contract address.Only callable by the BIG_TIMELOCK_ADMIN role.\",\"params\":{\"_interestRateStrategy\":\"The address of the interest rate strategy contract.\"}},\"setMaxTotalDeposit(uint256)\":{\"params\":{\"_maxTotalDeposit\":\"The amount of max total deposit for the bucket\"}},\"setReserveRate(uint256)\":{\"details\":\"Sets the reserve rate.Only callable by the BIG_TIMELOCK_ADMIN role.\",\"params\":{\"_reserveRate\":\"The new reserve rate value.\"}},\"setWithdrawalFee(uint256)\":{\"details\":\"Sets the withdrawal fee.Only callable by the BIG_TIMELOCK_ADMIN role.\",\"params\":{\"_withdrawalFee\":\"The new withdrawal fee value.\"}},\"withdraw(address,uint256)\":{\"details\":\"Withdraws the 'amount' of underlying asset from the bucket. The 'amount' of overlying pTokens will be burned.\",\"params\":{\"_borrowAssetReceiver\":\"The address of receiver of the borrowed asset.\",\"amount\":\"The amount of underlying tokens to be withdrawn.\"}},\"withdrawAfterDelisting(uint256)\":{\"params\":{\"_amount\":\"The amount of tokens to withdraw.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"bar()\":{\"notice\":\"bar = borrowing annual rate (originally APR)\"},\"batchDecreaseTradersDebt(address[],uint256[],address,uint256,uint256,uint256)\":{\"notice\":\"Batch decreases the debt of multiple traders.\"},\"depositFromBucket(string,address,(uint256,(string,bytes)[])[],uint256)\":{\"notice\":\"Deposits (reinvests) funds from a bucket to another bucket. Used only in the case of failed liquidity mining in the bucket from where the transfer happens.\"},\"lar()\":{\"notice\":\"lar = lending annual rate (originally APY)\"},\"paybackPermanentLoss(uint256)\":{\"notice\":\"This function allows a user to pay back a permanent loss by burning his pTokens.\"},\"removeAsset(address)\":{\"notice\":\"Removes a trading asset from this bucket.\"},\"setMaxTotalDeposit(uint256)\":{\"notice\":\"The function sets the max total deposit for the particular bucket\"},\"supportsInterface(bytes4)\":{\"notice\":\"Interface checker\"},\"withdrawAfterDelisting(uint256)\":{\"notice\":\"Allows the BIG_TIMELOCK_ADMIN role to withdraw a specified amount of tokens after delisting.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Bucket/Bucket.sol\":\"Bucket\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x6e56fb472b39561ef68a43d8ec1845171b211635746cfc2c17cf4d3a687fe85d\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/interfaces/IAToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\\nimport {IInitializableAToken} from './IInitializableAToken.sol';\\n\\n/**\\n * @title IAToken\\n * @author Aave\\n * @notice Defines the basic interface for an AToken.\\n */\\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\\n  /**\\n   * @dev Emitted during the transfer action\\n   * @param from The user whose tokens are being transferred\\n   * @param to The recipient\\n   * @param value The scaled amount being transferred\\n   * @param index The next liquidity index of the reserve\\n   */\\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\\n\\n  /**\\n   * @notice Mints `amount` aTokens to `user`\\n   * @param caller The address performing the mint\\n   * @param onBehalfOf The address of the user that will receive the minted aTokens\\n   * @param amount The amount of tokens getting minted\\n   * @param index The next liquidity index of the reserve\\n   * @return `true` if the the previous balance of the user was 0\\n   */\\n  function mint(\\n    address caller,\\n    address onBehalfOf,\\n    uint256 amount,\\n    uint256 index\\n  ) external returns (bool);\\n\\n  /**\\n   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n   * @dev In some instances, the mint event could be emitted from a burn transaction\\n   * if the amount to burn is less than the interest that the user accrued\\n   * @param from The address from which the aTokens will be burned\\n   * @param receiverOfUnderlying The address that will receive the underlying\\n   * @param amount The amount being burned\\n   * @param index The next liquidity index of the reserve\\n   */\\n  function burn(\\n    address from,\\n    address receiverOfUnderlying,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  /**\\n   * @notice Mints aTokens to the reserve treasury\\n   * @param amount The amount of tokens getting minted\\n   * @param index The next liquidity index of the reserve\\n   */\\n  function mintToTreasury(uint256 amount, uint256 index) external;\\n\\n  /**\\n   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\\n   * @param from The address getting liquidated, current owner of the aTokens\\n   * @param to The recipient\\n   * @param value The amount of tokens getting transferred\\n   */\\n  function transferOnLiquidation(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external;\\n\\n  /**\\n   * @notice Transfers the underlying asset to `target`.\\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\\n   * @param target The recipient of the underlying\\n   * @param amount The amount getting transferred\\n   */\\n  function transferUnderlyingTo(address target, uint256 amount) external;\\n\\n  /**\\n   * @notice Handles the underlying received by the aToken after the transfer has been completed.\\n   * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the\\n   * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying\\n   * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.\\n   * @param user The user executing the repayment\\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed\\n   * @param amount The amount getting repaid\\n   */\\n  function handleRepayment(\\n    address user,\\n    address onBehalfOf,\\n    uint256 amount\\n  ) external;\\n\\n  /**\\n   * @notice Allow passing a signed message to approve spending\\n   * @dev implements the permit function as for\\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\\n   * @param owner The owner of the funds\\n   * @param spender The spender\\n   * @param value The amount\\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\\n   * @param v Signature param\\n   * @param s Signature param\\n   * @param r Signature param\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\\n   * @return The address of the underlying asset\\n   */\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n\\n  /**\\n   * @notice Returns the address of the Aave treasury, receiving the fees on this aToken.\\n   * @return Address of the Aave treasury\\n   */\\n  function RESERVE_TREASURY_ADDRESS() external view returns (address);\\n\\n  /**\\n   * @notice Get the domain separator for the token\\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\\n   * @return The domain separator of the token at current chain\\n   */\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  /**\\n   * @notice Returns the nonce for owner.\\n   * @param owner The address of the owner\\n   * @return The nonce of the owner\\n   */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @notice Rescue and transfer tokens locked in this contract\\n   * @param token The address of the token\\n   * @param to The address of the recipient\\n   * @param amount The amount of token to transfer\\n   */\\n  function rescueTokens(\\n    address token,\\n    address to,\\n    uint256 amount\\n  ) external;\\n}\\n\",\"keccak256\":\"0x3be0a6b8a763ab6ea1c36f367bdfe2382127b7e3a4dbe4ef9c1dd4d8b3bf03c4\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IAaveIncentivesController\\n * @author Aave\\n * @notice Defines the basic interface for an Aave Incentives Controller.\\n * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.\\n */\\ninterface IAaveIncentivesController {\\n  /**\\n   * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\\n   * @dev The units of `totalSupply` and `userBalance` should be the same.\\n   * @param user The address of the user whose asset balance has changed\\n   * @param totalSupply The total supply of the asset prior to user balance change\\n   * @param userBalance The previous user balance prior to balance change\\n   */\\n  function handleAction(\\n    address user,\\n    uint256 totalSupply,\\n    uint256 userBalance\\n  ) external;\\n}\\n\",\"keccak256\":\"0xfebb2258ed0f33f66ede2dc6f452adbfe9f1e0115c1ae856b65bf518ab142018\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/interfaces/IInitializableAToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\\nimport {IPool} from './IPool.sol';\\n\\n/**\\n * @title IInitializableAToken\\n * @author Aave\\n * @notice Interface for the initialize function on AToken\\n */\\ninterface IInitializableAToken {\\n  /**\\n   * @dev Emitted when an aToken is initialized\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param pool The address of the associated pool\\n   * @param treasury The address of the treasury\\n   * @param incentivesController The address of the incentives controller for this aToken\\n   * @param aTokenDecimals The decimals of the underlying\\n   * @param aTokenName The name of the aToken\\n   * @param aTokenSymbol The symbol of the aToken\\n   * @param params A set of encoded parameters for additional initialization\\n   */\\n  event Initialized(\\n    address indexed underlyingAsset,\\n    address indexed pool,\\n    address treasury,\\n    address incentivesController,\\n    uint8 aTokenDecimals,\\n    string aTokenName,\\n    string aTokenSymbol,\\n    bytes params\\n  );\\n\\n  /**\\n   * @notice Initializes the aToken\\n   * @param pool The pool contract that is initializing this contract\\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\\n   * @param incentivesController The smart contract managing potential incentives distribution\\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\\n   * @param aTokenName The name of the aToken\\n   * @param aTokenSymbol The symbol of the aToken\\n   * @param params A set of encoded parameters for additional initialization\\n   */\\n  function initialize(\\n    IPool pool,\\n    address treasury,\\n    address underlyingAsset,\\n    IAaveIncentivesController incentivesController,\\n    uint8 aTokenDecimals,\\n    string calldata aTokenName,\\n    string calldata aTokenSymbol,\\n    bytes calldata params\\n  ) external;\\n}\\n\",\"keccak256\":\"0xb7c0da4c50ab10ce00e2325e649297923497738350092f64ef4b259307039dee\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\\n\\n/**\\n * @title IPool\\n * @author Aave\\n * @notice Defines the basic interface for an Aave Pool.\\n */\\ninterface IPool {\\n  /**\\n   * @dev Emitted on mintUnbacked()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address initiating the supply\\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\\n   * @param amount The amount of supplied assets\\n   * @param referralCode The referral code used\\n   */\\n  event MintUnbacked(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint16 indexed referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted on backUnbacked()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param backer The address paying for the backing\\n   * @param amount The amount added as backing\\n   * @param fee The amount paid in fees\\n   */\\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\\n\\n  /**\\n   * @dev Emitted on supply()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address initiating the supply\\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\\n   * @param amount The amount supplied\\n   * @param referralCode The referral code used\\n   */\\n  event Supply(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint16 indexed referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted on withdraw()\\n   * @param reserve The address of the underlying asset being withdrawn\\n   * @param user The address initiating the withdrawal, owner of aTokens\\n   * @param to The address that will receive the underlying\\n   * @param amount The amount to be withdrawn\\n   */\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\n\\n  /**\\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n   * @param reserve The address of the underlying asset being borrowed\\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\n   * initiator of the transaction on flashLoan()\\n   * @param onBehalfOf The address that will be getting the debt\\n   * @param amount The amount borrowed out\\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\\n   * @param referralCode The referral code used\\n   */\\n  event Borrow(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    DataTypes.InterestRateMode interestRateMode,\\n    uint256 borrowRate,\\n    uint16 indexed referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted on repay()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The beneficiary of the repayment, getting his debt reduced\\n   * @param repayer The address of the user initiating the repay(), providing the funds\\n   * @param amount The amount repaid\\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\\n   */\\n  event Repay(\\n    address indexed reserve,\\n    address indexed user,\\n    address indexed repayer,\\n    uint256 amount,\\n    bool useATokens\\n  );\\n\\n  /**\\n   * @dev Emitted on swapBorrowRateMode()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user swapping his rate mode\\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\\n   */\\n  event SwapBorrowRateMode(\\n    address indexed reserve,\\n    address indexed user,\\n    DataTypes.InterestRateMode interestRateMode\\n  );\\n\\n  /**\\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param totalDebt The total isolation mode debt for the reserve\\n   */\\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\\n\\n  /**\\n   * @dev Emitted when the user selects a certain asset category for eMode\\n   * @param user The address of the user\\n   * @param categoryId The category id\\n   */\\n  event UserEModeSet(address indexed user, uint8 categoryId);\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   */\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   */\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on rebalanceStableBorrowRate()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user for which the rebalance has been executed\\n   */\\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on flashLoan()\\n   * @param target The address of the flash loan receiver contract\\n   * @param initiator The address initiating the flash loan\\n   * @param asset The address of the asset being flash borrowed\\n   * @param amount The amount flash borrowed\\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\\n   * @param premium The fee flash borrowed\\n   * @param referralCode The referral code used\\n   */\\n  event FlashLoan(\\n    address indexed target,\\n    address initiator,\\n    address indexed asset,\\n    uint256 amount,\\n    DataTypes.InterestRateMode interestRateMode,\\n    uint256 premium,\\n    uint16 indexed referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted when a borrower is liquidated.\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\\n   * @param liquidator The address of the liquidator\\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   */\\n  event LiquidationCall(\\n    address indexed collateralAsset,\\n    address indexed debtAsset,\\n    address indexed user,\\n    uint256 debtToCover,\\n    uint256 liquidatedCollateralAmount,\\n    address liquidator,\\n    bool receiveAToken\\n  );\\n\\n  /**\\n   * @dev Emitted when the state of a reserve is updated.\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param liquidityRate The next liquidity rate\\n   * @param stableBorrowRate The next stable borrow rate\\n   * @param variableBorrowRate The next variable borrow rate\\n   * @param liquidityIndex The next liquidity index\\n   * @param variableBorrowIndex The next variable borrow index\\n   */\\n  event ReserveDataUpdated(\\n    address indexed reserve,\\n    uint256 liquidityRate,\\n    uint256 stableBorrowRate,\\n    uint256 variableBorrowRate,\\n    uint256 liquidityIndex,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  /**\\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\\n   * @param reserve The address of the reserve\\n   * @param amountMinted The amount minted to the treasury\\n   */\\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\\n\\n  /**\\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\\n   * @param asset The address of the underlying asset to mint\\n   * @param amount The amount to mint\\n   * @param onBehalfOf The address that will receive the aTokens\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function mintUnbacked(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\\n   * @param asset The address of the underlying asset to back\\n   * @param amount The amount to back\\n   * @param fee The amount paid in fees\\n   * @return The backed amount\\n   */\\n  function backUnbacked(\\n    address asset,\\n    uint256 amount,\\n    uint256 fee\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\n   * @param asset The address of the underlying asset to supply\\n   * @param amount The amount to be supplied\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function supply(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\n   * @param asset The address of the underlying asset to supply\\n   * @param amount The amount to be supplied\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param deadline The deadline timestamp that the permit is valid\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   * @param permitV The V parameter of ERC712 permit sig\\n   * @param permitR The R parameter of ERC712 permit sig\\n   * @param permitS The S parameter of ERC712 permit sig\\n   */\\n  function supplyWithPermit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode,\\n    uint256 deadline,\\n    uint8 permitV,\\n    bytes32 permitR,\\n    bytes32 permitS\\n  ) external;\\n\\n  /**\\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n   * @param to The address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   */\\n  function withdraw(\\n    address asset,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n   * @param asset The address of the underlying asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n   * if he has been given credit delegation allowance\\n   */\\n  function borrow(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    uint16 referralCode,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n   * other borrower whose debt should be removed\\n   * @return The final amount repaid\\n   */\\n  function repay(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    address onBehalfOf\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n   * other borrower whose debt should be removed\\n   * @param deadline The deadline timestamp that the permit is valid\\n   * @param permitV The V parameter of ERC712 permit sig\\n   * @param permitR The R parameter of ERC712 permit sig\\n   * @param permitS The S parameter of ERC712 permit sig\\n   * @return The final amount repaid\\n   */\\n  function repayWithPermit(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    address onBehalfOf,\\n    uint256 deadline,\\n    uint8 permitV,\\n    bytes32 permitR,\\n    bytes32 permitS\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\\n   * equivalent debt tokens\\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\\n   * balance is not enough to cover the whole debt\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n   * @return The final amount repaid\\n   */\\n  function repayWithATokens(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\\n   * @param asset The address of the underlying asset borrowed\\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\\n   */\\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\\n\\n  /**\\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\n   * - Users can be rebalanced if the following conditions are satisfied:\\n   *     1. Usage ratio is above 95%\\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\\n   * @param asset The address of the underlying asset borrowed\\n   * @param user The address of the user to be rebalanced\\n   */\\n  function rebalanceStableBorrowRate(address asset, address user) external;\\n\\n  /**\\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\\n   * @param asset The address of the underlying asset supplied\\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\\n   */\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n\\n  /**\\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   */\\n  function liquidationCall(\\n    address collateralAsset,\\n    address debtAsset,\\n    address user,\\n    uint256 debtToCover,\\n    bool receiveAToken\\n  ) external;\\n\\n  /**\\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\n   * as long as the amount taken plus a fee is returned.\\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\n   * into consideration. For further details please visit https://docs.aave.com/developers/\\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\\n   * @param assets The addresses of the assets being flash-borrowed\\n   * @param amounts The amounts of the assets being flash-borrowed\\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\n   * @param params Variadic packed params to pass to the receiver as extra information\\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function flashLoan(\\n    address receiverAddress,\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata interestRateModes,\\n    address onBehalfOf,\\n    bytes calldata params,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\\n   * as long as the amount taken plus a fee is returned.\\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\\n   * into consideration. For further details please visit https://docs.aave.com/developers/\\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\\n   * @param asset The address of the asset being flash-borrowed\\n   * @param amount The amount of the asset being flash-borrowed\\n   * @param params Variadic packed params to pass to the receiver as extra information\\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function flashLoanSimple(\\n    address receiverAddress,\\n    address asset,\\n    uint256 amount,\\n    bytes calldata params,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @notice Returns the user account data across all the reserves\\n   * @param user The address of the user\\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\\n   * @return currentLiquidationThreshold The liquidation threshold of the user\\n   * @return ltv The loan to value of The user\\n   * @return healthFactor The current health factor of the user\\n   */\\n  function getUserAccountData(address user)\\n    external\\n    view\\n    returns (\\n      uint256 totalCollateralBase,\\n      uint256 totalDebtBase,\\n      uint256 availableBorrowsBase,\\n      uint256 currentLiquidationThreshold,\\n      uint256 ltv,\\n      uint256 healthFactor\\n    );\\n\\n  /**\\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\\n   * interest rate strategy\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\\n   */\\n  function initReserve(\\n    address asset,\\n    address aTokenAddress,\\n    address stableDebtAddress,\\n    address variableDebtAddress,\\n    address interestRateStrategyAddress\\n  ) external;\\n\\n  /**\\n   * @notice Drop a reserve\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @param asset The address of the underlying asset of the reserve\\n   */\\n  function dropReserve(address asset) external;\\n\\n  /**\\n   * @notice Updates the address of the interest rate strategy contract\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param rateStrategyAddress The address of the interest rate strategy contract\\n   */\\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\\n    external;\\n\\n  /**\\n   * @notice Sets the configuration bitmap of the reserve as a whole\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @param asset The address of the underlying asset of the reserve\\n   * @param configuration The new configuration bitmap\\n   */\\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\\n    external;\\n\\n  /**\\n   * @notice Returns the configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The configuration of the reserve\\n   */\\n  function getConfiguration(address asset)\\n    external\\n    view\\n    returns (DataTypes.ReserveConfigurationMap memory);\\n\\n  /**\\n   * @notice Returns the configuration of the user across all the reserves\\n   * @param user The user address\\n   * @return The configuration of the user\\n   */\\n  function getUserConfiguration(address user)\\n    external\\n    view\\n    returns (DataTypes.UserConfigurationMap memory);\\n\\n  /**\\n   * @notice Returns the normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the normalized variable debt per unit of asset\\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\\n   * \\\"dynamic\\\" variable index based on time, current stored index and virtual rate at the current\\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\\n   * combination with variable debt supply/balances.\\n   * If using this function externally, consider that is possible to have an increasing normalized\\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\\n   * (e.g. only updates with non-zero variable debt supply)\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve normalized variable debt\\n   */\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state and configuration data of the reserve\\n   */\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n\\n  /**\\n   * @notice Validates and finalizes an aToken transfer\\n   * @dev Only callable by the overlying aToken of the `asset`\\n   * @param asset The address of the underlying asset of the aToken\\n   * @param from The user from which the aTokens are transferred\\n   * @param to The user receiving the aTokens\\n   * @param amount The amount being transferred/withdrawn\\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\\n   */\\n  function finalizeTransfer(\\n    address asset,\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint256 balanceFromBefore,\\n    uint256 balanceToBefore\\n  ) external;\\n\\n  /**\\n   * @notice Returns the list of the underlying assets of all the initialized reserves\\n   * @dev It does not include dropped reserves\\n   * @return The addresses of the underlying assets of the initialized reserves\\n   */\\n  function getReservesList() external view returns (address[] memory);\\n\\n  /**\\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\\n   * @return The address of the reserve associated with id\\n   */\\n  function getReserveAddressById(uint16 id) external view returns (address);\\n\\n  /**\\n   * @notice Returns the PoolAddressesProvider connected to this contract\\n   * @return The address of the PoolAddressesProvider\\n   */\\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\\n\\n  /**\\n   * @notice Updates the protocol fee on the bridging\\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\\n   */\\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\\n\\n  /**\\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\\n   * - A part is sent to aToken holders as extra, one time accumulated interest\\n   * - A part is collected by the protocol treasury\\n   * @dev The total premium is calculated on the total borrowed amount\\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\\n   * @dev Only callable by the PoolConfigurator contract\\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\\n   */\\n  function updateFlashloanPremiums(\\n    uint128 flashLoanPremiumTotal,\\n    uint128 flashLoanPremiumToProtocol\\n  ) external;\\n\\n  /**\\n   * @notice Configures a new category for the eMode.\\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\\n   * The category 0 is reserved as it's the default for volatile assets\\n   * @param id The id of the category\\n   * @param config The configuration of the category\\n   */\\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\\n\\n  /**\\n   * @notice Returns the data of an eMode category\\n   * @param id The id of the category\\n   * @return The configuration data of the category\\n   */\\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\\n\\n  /**\\n   * @notice Allows a user to use the protocol in eMode\\n   * @param categoryId The id of the category\\n   */\\n  function setUserEMode(uint8 categoryId) external;\\n\\n  /**\\n   * @notice Returns the eMode the user is using\\n   * @param user The address of the user\\n   * @return The eMode id\\n   */\\n  function getUserEMode(address user) external view returns (uint256);\\n\\n  /**\\n   * @notice Resets the isolation mode total debt of the given asset to zero\\n   * @dev It requires the given asset has zero debt ceiling\\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\\n   */\\n  function resetIsolationModeTotalDebt(address asset) external;\\n\\n  /**\\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\\n   * @return The percentage of available liquidity to borrow, expressed in bps\\n   */\\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the total fee on flash loans\\n   * @return The total fee on flashloans\\n   */\\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the part of the bridge fees sent to protocol\\n   * @return The bridge fee sent to the protocol treasury\\n   */\\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the part of the flashloan fees sent to protocol\\n   * @return The flashloan fee sent to the protocol treasury\\n   */\\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\\n   * @return The maximum number of reserves supported\\n   */\\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\\n\\n  /**\\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\\n   * @param assets The list of reserves for which the minting needs to be executed\\n   */\\n  function mintToTreasury(address[] calldata assets) external;\\n\\n  /**\\n   * @notice Rescue and transfer tokens locked in this contract\\n   * @param token The address of the token\\n   * @param to The address of the recipient\\n   * @param amount The amount of token to transfer\\n   */\\n  function rescueTokens(\\n    address token,\\n    address to,\\n    uint256 amount\\n  ) external;\\n\\n  /**\\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\\n   * @dev Deprecated: Use the `supply` function instead\\n   * @param asset The address of the underlying asset to supply\\n   * @param amount The amount to be supplied\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   */\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n}\\n\",\"keccak256\":\"0x96c0b6559a9f4b11a4ce0f825007d0b1a50340551714d0d79c6c1c5854b43f16\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPoolAddressesProvider\\n * @author Aave\\n * @notice Defines the basic interface for a Pool Addresses Provider.\\n */\\ninterface IPoolAddressesProvider {\\n  /**\\n   * @dev Emitted when the market identifier is updated.\\n   * @param oldMarketId The old id of the market\\n   * @param newMarketId The new id of the market\\n   */\\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\\n\\n  /**\\n   * @dev Emitted when the pool is updated.\\n   * @param oldAddress The old address of the Pool\\n   * @param newAddress The new address of the Pool\\n   */\\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the pool configurator is updated.\\n   * @param oldAddress The old address of the PoolConfigurator\\n   * @param newAddress The new address of the PoolConfigurator\\n   */\\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the price oracle is updated.\\n   * @param oldAddress The old address of the PriceOracle\\n   * @param newAddress The new address of the PriceOracle\\n   */\\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the ACL manager is updated.\\n   * @param oldAddress The old address of the ACLManager\\n   * @param newAddress The new address of the ACLManager\\n   */\\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the ACL admin is updated.\\n   * @param oldAddress The old address of the ACLAdmin\\n   * @param newAddress The new address of the ACLAdmin\\n   */\\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the price oracle sentinel is updated.\\n   * @param oldAddress The old address of the PriceOracleSentinel\\n   * @param newAddress The new address of the PriceOracleSentinel\\n   */\\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the pool data provider is updated.\\n   * @param oldAddress The old address of the PoolDataProvider\\n   * @param newAddress The new address of the PoolDataProvider\\n   */\\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when a new proxy is created.\\n   * @param id The identifier of the proxy\\n   * @param proxyAddress The address of the created proxy contract\\n   * @param implementationAddress The address of the implementation contract\\n   */\\n  event ProxyCreated(\\n    bytes32 indexed id,\\n    address indexed proxyAddress,\\n    address indexed implementationAddress\\n  );\\n\\n  /**\\n   * @dev Emitted when a new non-proxied contract address is registered.\\n   * @param id The identifier of the contract\\n   * @param oldAddress The address of the old contract\\n   * @param newAddress The address of the new contract\\n   */\\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the implementation of the proxy registered with id is updated\\n   * @param id The identifier of the contract\\n   * @param proxyAddress The address of the proxy contract\\n   * @param oldImplementationAddress The address of the old implementation contract\\n   * @param newImplementationAddress The address of the new implementation contract\\n   */\\n  event AddressSetAsProxy(\\n    bytes32 indexed id,\\n    address indexed proxyAddress,\\n    address oldImplementationAddress,\\n    address indexed newImplementationAddress\\n  );\\n\\n  /**\\n   * @notice Returns the id of the Aave market to which this contract points to.\\n   * @return The market id\\n   */\\n  function getMarketId() external view returns (string memory);\\n\\n  /**\\n   * @notice Associates an id with a specific PoolAddressesProvider.\\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\\n   * identify and validate multiple Aave markets.\\n   * @param newMarketId The market id\\n   */\\n  function setMarketId(string calldata newMarketId) external;\\n\\n  /**\\n   * @notice Returns an address by its identifier.\\n   * @dev The returned address might be an EOA or a contract, potentially proxied\\n   * @dev It returns ZERO if there is no registered address with the given id\\n   * @param id The id\\n   * @return The address of the registered for the specified id\\n   */\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  /**\\n   * @notice General function to update the implementation of a proxy registered with\\n   * certain `id`. If there is no proxy registered, it will instantiate one and\\n   * set as implementation the `newImplementationAddress`.\\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\\n   * setter function, in order to avoid unexpected consequences\\n   * @param id The id\\n   * @param newImplementationAddress The address of the new implementation\\n   */\\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\\n\\n  /**\\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\\n   * @param id The id\\n   * @param newAddress The address to set\\n   */\\n  function setAddress(bytes32 id, address newAddress) external;\\n\\n  /**\\n   * @notice Returns the address of the Pool proxy.\\n   * @return The Pool proxy address\\n   */\\n  function getPool() external view returns (address);\\n\\n  /**\\n   * @notice Updates the implementation of the Pool, or creates a proxy\\n   * setting the new `pool` implementation when the function is called for the first time.\\n   * @param newPoolImpl The new Pool implementation\\n   */\\n  function setPoolImpl(address newPoolImpl) external;\\n\\n  /**\\n   * @notice Returns the address of the PoolConfigurator proxy.\\n   * @return The PoolConfigurator proxy address\\n   */\\n  function getPoolConfigurator() external view returns (address);\\n\\n  /**\\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\\n   */\\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\\n\\n  /**\\n   * @notice Returns the address of the price oracle.\\n   * @return The address of the PriceOracle\\n   */\\n  function getPriceOracle() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the price oracle.\\n   * @param newPriceOracle The address of the new PriceOracle\\n   */\\n  function setPriceOracle(address newPriceOracle) external;\\n\\n  /**\\n   * @notice Returns the address of the ACL manager.\\n   * @return The address of the ACLManager\\n   */\\n  function getACLManager() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the ACL manager.\\n   * @param newAclManager The address of the new ACLManager\\n   */\\n  function setACLManager(address newAclManager) external;\\n\\n  /**\\n   * @notice Returns the address of the ACL admin.\\n   * @return The address of the ACL admin\\n   */\\n  function getACLAdmin() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the ACL admin.\\n   * @param newAclAdmin The address of the new ACL admin\\n   */\\n  function setACLAdmin(address newAclAdmin) external;\\n\\n  /**\\n   * @notice Returns the address of the price oracle sentinel.\\n   * @return The address of the PriceOracleSentinel\\n   */\\n  function getPriceOracleSentinel() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the price oracle sentinel.\\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\\n   */\\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\\n\\n  /**\\n   * @notice Returns the address of the data provider.\\n   * @return The address of the DataProvider\\n   */\\n  function getPoolDataProvider() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the data provider.\\n   * @param newDataProvider The address of the new DataProvider\\n   */\\n  function setPoolDataProvider(address newDataProvider) external;\\n}\\n\",\"keccak256\":\"0x33d4308d9407b4ee2297fc4ba5acce1a96a6c658189e2778a4f6b90e032fb3b5\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IScaledBalanceToken\\n * @author Aave\\n * @notice Defines the basic interface for a scaled-balance token.\\n */\\ninterface IScaledBalanceToken {\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param caller The address performing the mint\\n   * @param onBehalfOf The address of the user that will receive the minted tokens\\n   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\\n   * @param index The next liquidity index of the reserve\\n   */\\n  event Mint(\\n    address indexed caller,\\n    address indexed onBehalfOf,\\n    uint256 value,\\n    uint256 balanceIncrease,\\n    uint256 index\\n  );\\n\\n  /**\\n   * @dev Emitted after the burn action\\n   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\\n   * @param from The address from which the tokens will be burned\\n   * @param target The address that will receive the underlying, if any\\n   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\\n   * @param index The next liquidity index of the reserve\\n   */\\n  event Burn(\\n    address indexed from,\\n    address indexed target,\\n    uint256 value,\\n    uint256 balanceIncrease,\\n    uint256 index\\n  );\\n\\n  /**\\n   * @notice Returns the scaled balance of the user.\\n   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\\n   * at the moment of the update\\n   * @param user The user whose balance is calculated\\n   * @return The scaled balance of the user\\n   */\\n  function scaledBalanceOf(address user) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the scaled balance of the user and the scaled total supply.\\n   * @param user The address of the user\\n   * @return The scaled balance of the user\\n   * @return The scaled total supply\\n   */\\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\n\\n  /**\\n   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\\n   * @return The scaled total supply\\n   */\\n  function scaledTotalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns last index interest was accrued to the user's balance\\n   * @param user The address of the user\\n   * @return The last index interest was accrued to the user's balance, expressed in ray\\n   */\\n  function getPreviousIndex(address user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x72b3ea433cd3386f369f1643a154bf233ec60c02acd02c32088a97556207d2e4\",\"license\":\"AGPL-3.0\"},\"@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary DataTypes {\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    //timestamp of last update\\n    uint40 lastUpdateTimestamp;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint16 id;\\n    //aToken address\\n    address aTokenAddress;\\n    //stableDebtToken address\\n    address stableDebtTokenAddress;\\n    //variableDebtToken address\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the current treasury balance, scaled\\n    uint128 accruedToTreasury;\\n    //the outstanding unbacked aTokens minted through the bridging feature\\n    uint128 unbacked;\\n    //the outstanding debt borrowed against this asset in isolation mode\\n    uint128 isolationModeTotalDebt;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60: asset is paused\\n    //bit 61: borrowing in isolation mode is enabled\\n    //bit 62-63: reserved\\n    //bit 64-79: reserve factor\\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\\n    //bit 152-167 liquidation protocol fee\\n    //bit 168-175 eMode category\\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\\n    //bit 252-255 unused\\n\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    /**\\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\\n     * asset is borrowed by the user.\\n     */\\n    uint256 data;\\n  }\\n\\n  struct EModeCategory {\\n    // each eMode category has a custom ltv and liquidation threshold\\n    uint16 ltv;\\n    uint16 liquidationThreshold;\\n    uint16 liquidationBonus;\\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\\n    address priceSource;\\n    string label;\\n  }\\n\\n  enum InterestRateMode {\\n    NONE,\\n    STABLE,\\n    VARIABLE\\n  }\\n\\n  struct ReserveCache {\\n    uint256 currScaledVariableDebt;\\n    uint256 nextScaledVariableDebt;\\n    uint256 currPrincipalStableDebt;\\n    uint256 currAvgStableBorrowRate;\\n    uint256 currTotalStableDebt;\\n    uint256 nextAvgStableBorrowRate;\\n    uint256 nextTotalStableDebt;\\n    uint256 currLiquidityIndex;\\n    uint256 nextLiquidityIndex;\\n    uint256 currVariableBorrowIndex;\\n    uint256 nextVariableBorrowIndex;\\n    uint256 currLiquidityRate;\\n    uint256 currVariableBorrowRate;\\n    uint256 reserveFactor;\\n    ReserveConfigurationMap reserveConfiguration;\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    uint40 reserveLastUpdateTimestamp;\\n    uint40 stableDebtLastUpdateTimestamp;\\n  }\\n\\n  struct ExecuteLiquidationCallParams {\\n    uint256 reservesCount;\\n    uint256 debtToCover;\\n    address collateralAsset;\\n    address debtAsset;\\n    address user;\\n    bool receiveAToken;\\n    address priceOracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct ExecuteSupplyParams {\\n    address asset;\\n    uint256 amount;\\n    address onBehalfOf;\\n    uint16 referralCode;\\n  }\\n\\n  struct ExecuteBorrowParams {\\n    address asset;\\n    address user;\\n    address onBehalfOf;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    uint16 referralCode;\\n    bool releaseUnderlying;\\n    uint256 maxStableRateBorrowSizePercent;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct ExecuteRepayParams {\\n    address asset;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    address onBehalfOf;\\n    bool useATokens;\\n  }\\n\\n  struct ExecuteWithdrawParams {\\n    address asset;\\n    uint256 amount;\\n    address to;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 userEModeCategory;\\n  }\\n\\n  struct ExecuteSetUserEModeParams {\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 categoryId;\\n  }\\n\\n  struct FinalizeTransferParams {\\n    address asset;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 balanceFromBefore;\\n    uint256 balanceToBefore;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 fromEModeCategory;\\n  }\\n\\n  struct FlashloanParams {\\n    address receiverAddress;\\n    address[] assets;\\n    uint256[] amounts;\\n    uint256[] interestRateModes;\\n    address onBehalfOf;\\n    bytes params;\\n    uint16 referralCode;\\n    uint256 flashLoanPremiumToProtocol;\\n    uint256 flashLoanPremiumTotal;\\n    uint256 maxStableRateBorrowSizePercent;\\n    uint256 reservesCount;\\n    address addressesProvider;\\n    uint8 userEModeCategory;\\n    bool isAuthorizedFlashBorrower;\\n  }\\n\\n  struct FlashloanSimpleParams {\\n    address receiverAddress;\\n    address asset;\\n    uint256 amount;\\n    bytes params;\\n    uint16 referralCode;\\n    uint256 flashLoanPremiumToProtocol;\\n    uint256 flashLoanPremiumTotal;\\n  }\\n\\n  struct FlashLoanRepaymentParams {\\n    uint256 amount;\\n    uint256 totalPremium;\\n    uint256 flashLoanPremiumToProtocol;\\n    address asset;\\n    address receiverAddress;\\n    uint16 referralCode;\\n  }\\n\\n  struct CalculateUserAccountDataParams {\\n    UserConfigurationMap userConfig;\\n    uint256 reservesCount;\\n    address user;\\n    address oracle;\\n    uint8 userEModeCategory;\\n  }\\n\\n  struct ValidateBorrowParams {\\n    ReserveCache reserveCache;\\n    UserConfigurationMap userConfig;\\n    address asset;\\n    address userAddress;\\n    uint256 amount;\\n    InterestRateMode interestRateMode;\\n    uint256 maxStableLoanPercent;\\n    uint256 reservesCount;\\n    address oracle;\\n    uint8 userEModeCategory;\\n    address priceOracleSentinel;\\n    bool isolationModeActive;\\n    address isolationModeCollateralAddress;\\n    uint256 isolationModeDebtCeiling;\\n  }\\n\\n  struct ValidateLiquidationCallParams {\\n    ReserveCache debtReserveCache;\\n    uint256 totalDebt;\\n    uint256 healthFactor;\\n    address priceOracleSentinel;\\n  }\\n\\n  struct CalculateInterestRatesParams {\\n    uint256 unbacked;\\n    uint256 liquidityAdded;\\n    uint256 liquidityTaken;\\n    uint256 totalStableDebt;\\n    uint256 totalVariableDebt;\\n    uint256 averageStableBorrowRate;\\n    uint256 reserveFactor;\\n    address reserve;\\n    address aToken;\\n  }\\n\\n  struct InitReserveParams {\\n    address asset;\\n    address aTokenAddress;\\n    address stableDebtAddress;\\n    address variableDebtAddress;\\n    address interestRateStrategyAddress;\\n    uint16 reservesCount;\\n    uint16 maxNumberReserves;\\n  }\\n}\\n\",\"keccak256\":\"0xe5c6db4edc44768b334b6f9271e1ae21c81d6ab0692c2740cce0c56c4ac433dd\",\"license\":\"BUSL-1.1\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0x6e6e4b0835904509406b070ee173b5bc8f677c19421b76be38aea3b1b3d30846\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0xb82ef33f43b6b96109687d91b39c94573fdccaaa423fe28e8ba0977b31c023e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x0e1f0f5f62f67a881cd1a9597acbc0a5e4071f3c2c10449a183b922ae7272e3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\n/// @title Quoter Interface\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IQuoter {\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\n    /// @param amountIn The amount of the first token to swap\\n    /// @return amountOut The amount of the last token that would be received\\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountIn The desired input amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountOut The amount of `tokenOut` that would be received\\n    function quoteExactInputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountOut);\\n\\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n    /// @param amountOut The amount of the last token to receive\\n    /// @return amountIn The amount of first token required to be paid\\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\\n\\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n    /// @param tokenIn The token being swapped in\\n    /// @param tokenOut The token being swapped out\\n    /// @param fee The fee of the token pool to consider for the pair\\n    /// @param amountOut The desired output amount\\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n    function quoteExactOutputSingle(\\n        address tokenIn,\\n        address tokenOut,\\n        uint24 fee,\\n        uint256 amountOut,\\n        uint160 sqrtPriceLimitX96\\n    ) external returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0x124b4334f058f70afd8f3b04315cc0812961d400957225d0875872b2a31afbff\",\"license\":\"GPL-2.0-or-later\"},\"contracts/ActivityRewardDistributor/IActivityRewardDistributor.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IActivityRewardDistributorStorage, IERC20, IPrimexDNS, ITraderBalanceVault} from \\\"./IActivityRewardDistributorStorage.sol\\\";\\nimport {IWhiteBlackList} from \\\"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\\\";\\nimport {IBucket} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface IActivityRewardDistributor is IActivityRewardDistributorStorage, IPausable {\\n    enum Role {\\n        LENDER,\\n        TRADER\\n    }\\n\\n    struct BucketWithRole {\\n        address bucketAddress;\\n        Role role;\\n    }\\n\\n    /**\\n     * @notice Emitted on claimReward()\\n     * @param user The address of the user who claimed reward\\n     * @param bucket The address of the bucket this reward is related to\\n     * @param role User role - TRADER or LENDER\\n     * @param amount Claimed amount\\n     */\\n    event ClaimReward(address indexed user, address indexed bucket, Role indexed role, uint256 amount);\\n\\n    /**\\n     * @notice  Initializes the ActivityRewardDistributor contract.\\n     * @dev This function should only be called once during the initial setup of the contract.\\n     * @param _pmx The address of the PMXToken contract.\\n     * @param _dns The address of the PrimexDNS contract.\\n     * @param _registry The address of the PrimexRegistry contract.\\n     * @param _treasury The address of the treasury where fees will be collected.\\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\\n     */\\n    function initialize(\\n        IERC20 _pmx,\\n        IPrimexDNS _dns,\\n        address _registry,\\n        address _treasury,\\n        ITraderBalanceVault _traderBalanceVault,\\n        IWhiteBlackList _whiteBlackList\\n    ) external;\\n\\n    /**\\n     * @notice  Saves user activity in the protocol for reward calculation\\n     * @param   bucket  The address of the bucket\\n     * @param   user  User address\\n     * @param   newBalance  User balance after action\\n     * @param   role  User role - TRADER or LENDER\\n     */\\n    function updateUserActivity(IBucket bucket, address user, uint256 newBalance, Role role) external;\\n\\n    /**\\n     * @notice  Saves activity of multiple users in the protocol for reward calculation\\n     * @param   bucket  The address of the bucket\\n     * @param   users  Array of user addresses\\n     * @param   newBalances  Array of users balances after action\\n     * @param   length  The length of the users and oldBalances arrays\\n     * @param   role  User role - TRADER or LENDER\\n     */\\n    function updateUsersActivities(\\n        IBucket bucket,\\n        address[] calldata users,\\n        uint256[] calldata newBalances,\\n        uint256 length,\\n        Role role\\n    ) external;\\n\\n    /**\\n     * @notice Allows the caller to claim their accumulated reward from the specified buckets.\\n     * @param bucketsArray The array of BucketWithRole objects containing the buckets from which to claim the rewards.\\n     */\\n    function claimReward(BucketWithRole[] calldata bucketsArray) external;\\n\\n    /**\\n     * @notice Sets up activity rewards distribution in bucket with the specified role and reward parameters.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param bucket The address of the bucket to set up.\\n     * @param role The role associated with the bucket.\\n     * @param increaseAmount The amount by which to increase the total reward for the bucket (in PMX).\\n     * Adds specified amount to totalReward of the bucket. Initial value of totalReward is 0.\\n     * @param rewardPerDay The reward amount per day for the bucket.\\n     */\\n    function setupBucket(address bucket, Role role, uint256 increaseAmount, uint256 rewardPerDay) external;\\n\\n    /**\\n     * @notice Allows the caller to withdraw PMX tokens from a specific bucket.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param bucket The address of the bucket from which to withdraw PMX tokens.\\n     * @param role The role associated with the bucket.\\n     * @param amount The amount of PMX tokens to withdraw.\\n     */\\n    function withdrawPmx(address bucket, Role role, uint256 amount) external;\\n\\n    /**\\n     * @notice Decreases the reward per day for a bucket and role.\\n     * @dev Only callable by the EMERGENCY_ADMIN role.\\n     * @param bucket The address of the bucket for which to decrease the reward per day.\\n     * @param role The role associated with the bucket.\\n     * @param rewardPerDay The amount by which to decrease the reward per day.\\n     */\\n    function decreaseRewardPerDay(address bucket, Role role, uint256 rewardPerDay) external;\\n\\n    /**\\n     * @notice Returns the accumulated reward for a specific bucket and role.\\n     * @param bucket The address of the bucket for which to retrieve the accumulated reward.\\n     * @param role The role associated with the bucket.\\n     * @return The accumulated reward for the specified bucket and role.\\n     */\\n    function getBucketAccumulatedReward(address bucket, Role role) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the claimable reward for a user across multiple buckets.\\n     * @param bucketsArray The array of BucketWithRole objects containing the buckets to check for claimable rewards.\\n     * @param user The address of the user for whom to calculate the claimable reward.\\n     * @return The total claimable reward for the specified user across all provided buckets.\\n     */\\n    function getClaimableReward(BucketWithRole[] calldata bucketsArray, address user) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the user information from a specific bucket and role.\\n     * @param bucket The address of the bucket from which to retrieve the user information.\\n     * @param role The role associated with the bucket.\\n     * @param user The address of the user for whom to retrieve the information.\\n     * @return A UserInfo struct containing the user information.\\n     */\\n    function getUserInfoFromBucket(address bucket, Role role, address user) external view returns (UserInfo memory);\\n}\\n\",\"keccak256\":\"0x92e646c799437ad1e02850a871701b0d1a4fcf0d9b88062720d85aca99bd2152\",\"license\":\"BUSL-1.1\"},\"contracts/ActivityRewardDistributor/IActivityRewardDistributorStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\n\\ninterface IActivityRewardDistributorStorage {\\n    /*\\n     * @param oldBalance last updated balance for user\\n     * @param fixedReward the accumulated value of the reward at the time lastUpdatedRewardIndex\\n     * @param lastUpdatedRewardIndex last index with which the user's reward was accumulated\\n     */\\n    struct UserInfo {\\n        uint256 fixedReward;\\n        uint256 lastUpdatedRewardIndex;\\n        uint256 oldBalance;\\n    }\\n\\n    /*\\n     * @param users data to calculate users rewards in this bucket\\n     * @param rewardIndex an index that accumulates user rewards\\n     * @param lastUpdatedTimestamp timestamp of the last update of user activity\\n     * @param rewardPerToken current reward for one token(PToken or DebtToken of bucket)\\n     * @param isFinished Shows that the bucket has distributed all the rewards\\n     * @param fixedReward reward distributed by a bucket over the past period\\n     * with a certain reward per day or with the entire reward fully distributed\\n     * @param lastUpdatedRewardTimestamp timestamp of last fixed reward update\\n     * @param rewardPerDay current reward distributed for 1 day\\n     * @param totalReward Full distributable reward\\n     * @param endTimestamp end time of the distribution of rewards, which is calculated relative to the rewardPerDay and totalReward\\n     */\\n    struct BucketInfo {\\n        mapping(address => UserInfo) users;\\n        //accumulated reward per token\\n        uint256 rewardIndex;\\n        uint256 lastUpdatedTimestamp;\\n        uint256 rewardPerToken;\\n        uint256 scaledTotalSupply;\\n        bool isFinished;\\n        // setted by admin's actions\\n        uint256 fixedReward;\\n        uint256 lastUpdatedRewardTimestamp;\\n        uint256 rewardPerDay;\\n        uint256 totalReward;\\n        uint256 endTimestamp;\\n    }\\n\\n    function pmx() external returns (IERC20);\\n\\n    function dns() external returns (IPrimexDNS);\\n\\n    function registry() external returns (address);\\n\\n    function traderBalanceVault() external returns (ITraderBalanceVault);\\n\\n    function treasury() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc4e25952cf7dd9eade5559b4c78a2e857381b67d4554e2afa2dfd2edc48af950\",\"license\":\"BUSL-1.1\"},\"contracts/BonusExecutor/IFeeExecutor.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IFeeExecutorStorage} from \\\"./IFeeExecutorStorage.sol\\\";\\n\\ninterface IFeeExecutor is IFeeExecutorStorage {\\n    /**\\n     * @dev Sets tier bonuses for a specific bucket.\\n     * @param _bucket The address of the bucket.\\n     * @param _tiers The array of tier values.\\n     * @param _bonuses The array of NFT bonus parameters.\\n     */\\n    function setTierBonus(address _bucket, uint256[] calldata _tiers, NFTBonusParams[] calldata _bonuses) external;\\n\\n    /**\\n     * @dev Updates the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called by the Debt-Token\\n     * @param _user User for which the bonus will be updated. If user doesn't have the bonus for paused\\n     * @param _oldScaledBalance Balance of the user before the operation at which the updateBonus function was called (e.g mint/burn)\\n     * @param _bucket The Bucket to which the ActivatedBonus relates\\n     **/\\n    function updateBonus(address _user, uint256 _oldScaledBalance, address _bucket, uint256 _currentIndex) external;\\n\\n    /**\\n     * @dev Updates the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called directly by the user\\n     * @param _nftId Id of activated token\\n     **/\\n    function updateBonus(uint256 _nftId) external;\\n\\n    /**\\n     * @dev Updates the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called by the P-Token or Debt-Token\\n     * @param _users Array of the users for whom the bonus will be updated.\\n     * @param _oldBalances Array of the balances before the operation at which the updateBonus function was called (e.g mint/transfer)\\n     * @param _bucket The Bucket to which the ActivatedBonus relates\\n     **/\\n    function updateBonuses(\\n        address[] memory _users,\\n        uint256[] memory _oldBalances,\\n        address _bucket,\\n        uint256 _currentIndex\\n    ) external;\\n\\n    /**\\n     * @dev Returns accumulated amount of p-tokens at the moment\\n     * @param _user The user for which the accumatedAmount will return. If the bonus does not exist will return 0.\\n     * If the NFT does not exist will throw an error\\n     * @param _nftId Id of activated token\\n     * @return The accumulated amount.\\n     */\\n    function getAccumulatedAmount(address _user, uint256 _nftId) external returns (uint256);\\n\\n    /**\\n     * @dev Returns the available amount (accumulated - claimedAmount) of p-tokens at the moment.\\n     * @param _user The user for which the available amount will return. If the bonus does not exist will return 0.\\n     * If the NFT does not exist will throw an error\\n     * @param _nftId Id of activated token\\n     **/\\n    function getAvailableAmount(address _user, uint256 _nftId) external returns (uint256);\\n\\n    /**\\n     * @dev Retrieves the bonus information for a user and NFT.\\n     * @param _user The address of the user.\\n     * @param _nftId The ID of the NFT.\\n     * @return bonus The activated bonus information.\\n     */\\n    function getBonus(address _user, uint256 _nftId) external view returns (ActivatedBonus memory);\\n}\\n\",\"keccak256\":\"0x4e89772ddb2daeefc1f970ce15d03bc6de8c284e126498bfd9f39d8646f2325a\",\"license\":\"BUSL-1.1\"},\"contracts/BonusExecutor/IFeeExecutorStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IBucket} from \\\"../Bucket/IBucket.sol\\\";\\n\\ninterface IFeeExecutorStorage {\\n    struct ActivatedBonus {\\n        uint256 nftId;\\n        IBucket bucket;\\n        uint256 percent;\\n        uint256 maxAmount;\\n        uint256 accumulatedAmount;\\n        uint256 lastUpdatedIndex;\\n        uint256 deadline;\\n        //if we allow to claim funds before the end of the bonus\\n        uint256 claimedAmount;\\n    }\\n\\n    struct NFTBonusParams {\\n        uint256 percent;\\n        uint256 maxAmount;\\n        uint256 duration;\\n    }\\n}\\n\",\"keccak256\":\"0x1a966b20c524d3f40b1f3afcc425d37502efde4d043e022de4078af4c334fb54\",\"license\":\"BUSL-1.1\"},\"contracts/Bucket/Bucket.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport {WadRayMath} from \\\"../libraries/utils/WadRayMath.sol\\\";\\n\\nimport {TokenTransfersLibrary} from \\\"../libraries/TokenTransfersLibrary.sol\\\";\\n\\nimport \\\"./BucketStorage.sol\\\";\\nimport {VAULT_ACCESS_ROLE, PM_ROLE, BATCH_MANAGER_ROLE, MAX_ASSET_DECIMALS, SECONDS_PER_YEAR} from \\\"../Constants.sol\\\";\\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN} from \\\"../Constants.sol\\\";\\nimport {IBucket, IBucketV2} from \\\"./IBucket.sol\\\";\\n\\n/* solhint-disable max-states-count */\\ncontract Bucket is IBucketV2, BucketStorage {\\n    using WadRayMath for uint256;\\n\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @dev Modifier that checks if the caller has a specific role.\\n     * @param _role The role identifier to check.\\n     */\\n    modifier onlyRole(bytes32 _role) {\\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\\n        _;\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function initialize(ConstructorParams calldata _params, address _registry) public override initializer {\\n        _require(\\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\\n                IERC165Upgradeable(address(_params.pToken)).supportsInterface(type(IPToken).interfaceId) &&\\n                IERC165Upgradeable(address(_params.dns)).supportsInterface(type(IPrimexDNS).interfaceId) &&\\n                IERC165Upgradeable(address(_params.debtToken)).supportsInterface(type(IDebtToken).interfaceId) &&\\n                IERC165Upgradeable(address(_params.positionManager)).supportsInterface(\\n                    type(IPositionManager).interfaceId\\n                ) &&\\n                IERC165Upgradeable(address(_params.priceOracle)).supportsInterface(type(IPriceOracle).interfaceId) &&\\n                IERC165Upgradeable(address(_params.reserve)).supportsInterface(type(IReserve).interfaceId) &&\\n                IERC165Upgradeable(address(_params.interestRateStrategy)).supportsInterface(\\n                    type(IInterestRateStrategy).interfaceId\\n                ) &&\\n                IERC165Upgradeable(address(_params.whiteBlackList)).supportsInterface(\\n                    type(IWhiteBlackList).interfaceId\\n                ),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        _require(\\n            _params.borrowedAsset.decimals() <= MAX_ASSET_DECIMALS,\\n            Errors.ASSET_DECIMALS_EXCEEDS_MAX_VALUE.selector\\n        );\\n        _require(_params.withdrawalFeeRate <= WadRayMath.WAD / 10, Errors.WITHDRAW_RATE_IS_MORE_10_PERCENT.selector);\\n        _require(\\n            _params.feeBuffer > WadRayMath.WAD && _params.feeBuffer < WadRayMath.WAD + WadRayMath.WAD / 100,\\n            Errors.INVALID_FEE_BUFFER.selector\\n        );\\n        _require(_params.reserveRate < WadRayMath.WAD, Errors.RESERVE_RATE_SHOULD_BE_LESS_THAN_1.selector);\\n        _require(_params.maxTotalDeposit > 0, Errors.MAX_TOTAL_DEPOSIT_IS_ZERO.selector);\\n\\n        if (_params.liquidityMiningAmount == 0) {\\n            LMparams.isBucketLaunched = true;\\n            emit BucketLaunched();\\n        } else {\\n            _require(\\n                _params.liquidityMiningDeadline > block.timestamp &&\\n                    IERC165Upgradeable(address(_params.liquidityMiningRewardDistributor)).supportsInterface(\\n                        type(ILiquidityMiningRewardDistributor).interfaceId\\n                    ) &&\\n                    _params.maxAmountPerUser > 0,\\n                Errors.INCORRECT_LIQUIDITY_MINING_PARAMS.selector\\n            );\\n            LMparams.maxStabilizationEndTimestamp = _params.liquidityMiningDeadline + _params.stabilizationDuration;\\n            LMparams.maxDuration = LMparams.maxStabilizationEndTimestamp - block.timestamp;\\n            LMparams.liquidityMiningRewardDistributor = _params.liquidityMiningRewardDistributor;\\n            LMparams.accumulatingAmount = _params.liquidityMiningAmount;\\n            LMparams.deadlineTimestamp = _params.liquidityMiningDeadline;\\n            LMparams.stabilizationDuration = _params.stabilizationDuration;\\n            LMparams.maxAmountPerUser = _params.maxAmountPerUser;\\n            estimatedBar = _params.estimatedBar;\\n            estimatedLar = _params.estimatedLar;\\n            isReinvestToAaveEnabled = _params.isReinvestToAaveEnabled;\\n        }\\n        maxTotalDeposit = _params.maxTotalDeposit;\\n        _params.interestRateStrategy.setBarCalculationParams(_params.barCalcParams);\\n        name = _params.name;\\n        pToken = _params.pToken;\\n        dns = _params.dns;\\n        positionManager = _params.positionManager;\\n        priceOracle = _params.priceOracle;\\n        debtToken = _params.debtToken;\\n        reserve = _params.reserve;\\n        whiteBlackList = _params.whiteBlackList;\\n        borrowedAsset = _params.borrowedAsset;\\n        feeBuffer = _params.feeBuffer;\\n        withdrawalFeeRate = _params.withdrawalFeeRate;\\n        reserveRate = _params.reserveRate;\\n\\n        for (uint256 i; i < _params.assets.length; i++) {\\n            _addAsset(_params.assets[i]);\\n        }\\n        registry = _registry;\\n        interestRateStrategy = _params.interestRateStrategy;\\n        liquidityIndex = 1e27;\\n        variableBorrowIndex = 1e27;\\n        __ReentrancyGuard_init();\\n        __ERC165_init();\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function addAsset(address _newAsset) external override {\\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\\n        _addAsset(_newAsset);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function removeAsset(address _assetToDelete) external override {\\n        _onlyRole(SMALL_TIMELOCK_ADMIN);\\n        Asset storage assetToDelete = allowedAssets[_assetToDelete];\\n        _require(assetToDelete.isSupported, Errors.ASSET_IS_NOT_SUPPORTED.selector);\\n\\n        address assetToMove = assets[assets.length - 1];\\n        assets[assetToDelete.index] = assetToMove;\\n        assets.pop();\\n\\n        allowedAssets[assetToMove].index = assetToDelete.index;\\n        delete allowedAssets[_assetToDelete];\\n\\n        emit RemoveAsset(_assetToDelete);\\n    }\\n\\n    function setBarCalculationParams(bytes calldata _params) external override {\\n        _onlyRole(BIG_TIMELOCK_ADMIN);\\n        interestRateStrategy.setBarCalculationParams(_params);\\n        emit BarCalculationParamsChanged(_params);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function setReserveRate(uint256 _reserveRate) external override {\\n        _onlyRole(BIG_TIMELOCK_ADMIN);\\n        _require(_reserveRate < WadRayMath.WAD, Errors.RESERVE_RATE_SHOULD_BE_LESS_THAN_1.selector);\\n        reserveRate = _reserveRate;\\n        emit ReserveRateChanged(_reserveRate);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function setFeeBuffer(uint256 _feeBuffer) external override {\\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\\n        _require(\\n            _feeBuffer > WadRayMath.WAD && _feeBuffer < WadRayMath.WAD + WadRayMath.WAD / 100,\\n            Errors.INVALID_FEE_BUFFER.selector\\n        );\\n        feeBuffer = _feeBuffer;\\n        emit FeeBufferChanged(_feeBuffer);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function setWithdrawalFee(uint256 _withdrawalFeeRate) external override {\\n        _onlyRole(BIG_TIMELOCK_ADMIN);\\n        _require(_withdrawalFeeRate <= WadRayMath.WAD / 10, Errors.WITHDRAW_RATE_IS_MORE_10_PERCENT.selector);\\n        withdrawalFeeRate = _withdrawalFeeRate;\\n        emit WithdrawalFeeChanged(_withdrawalFeeRate);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function setInterestRateStrategy(address _interestRateStrategy) external override {\\n        _onlyRole(BIG_TIMELOCK_ADMIN);\\n        _require(\\n            IERC165Upgradeable(_interestRateStrategy).supportsInterface(type(IInterestRateStrategy).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        interestRateStrategy = IInterestRateStrategy(_interestRateStrategy);\\n        emit InterestRateStrategyChanged(_interestRateStrategy);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function setMaxTotalDeposit(uint256 _maxTotalDeposit) external override {\\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\\n        _require(_maxTotalDeposit > 0, Errors.MAX_TOTAL_DEPOSIT_IS_ZERO.selector);\\n        maxTotalDeposit = _maxTotalDeposit;\\n        emit MaxTotalDepositChanged(_maxTotalDeposit);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function deposit(address _pTokenReceiver, uint256 _amount) external override {\\n        deposit(_pTokenReceiver, _amount, true);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucketV2\\n     */\\n    function deposit(\\n        address _pTokenReceiver,\\n        uint256 _amount,\\n        bool _takeDepositFromWallet\\n    ) public override nonReentrant {\\n        _notBlackListed();\\n        _require(pToken.totalSupply() + _amount < maxTotalDeposit, Errors.DEPOSIT_EXCEEDS_MAX_TOTAL_DEPOSIT.selector);\\n        if (_takeDepositFromWallet) {\\n            TokenTransfersLibrary.doTransferIn(address(borrowedAsset), msg.sender, _amount);\\n        } else {\\n            positionManager.traderBalanceVault().withdrawFrom(\\n                msg.sender,\\n                address(this),\\n                address(borrowedAsset),\\n                _amount,\\n                false\\n            );\\n        }\\n        if (LMparams.isBucketLaunched) {\\n            _deposit(_pTokenReceiver, _amount);\\n        } else {\\n            _require(_pTokenReceiver == msg.sender, Errors.CALLER_IS_NOT_P_TOKEN_RECEIVER.selector);\\n            _depositLM(_pTokenReceiver, _amount);\\n        }\\n        emit Deposit(msg.sender, _pTokenReceiver, _amount);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function withdrawAfterDelisting(uint256 _amount) external override {\\n        _onlyRole(BIG_TIMELOCK_ADMIN);\\n        _require(isWithdrawAfterDelistingAvailable(), Errors.WITHDRAWAL_NOT_ALLOWED.selector);\\n        TokenTransfersLibrary.doTransferOut(address(borrowedAsset), dns.treasury(), _amount);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function receiveDeposit(\\n        address _pTokenReceiver,\\n        uint256 _amount,\\n        uint256 _duration,\\n        string calldata _bucketFrom\\n    ) external override nonReentrant {\\n        _require(pToken.totalSupply() + _amount < maxTotalDeposit, Errors.DEPOSIT_EXCEEDS_MAX_TOTAL_DEPOSIT.selector);\\n        _require(dns.getBucketAddress(_bucketFrom) == msg.sender, Errors.FORBIDDEN.selector);\\n        if (LMparams.isBucketLaunched) {\\n            if (_duration > 0) pToken.lockDeposit(_pTokenReceiver, _deposit(_pTokenReceiver, _amount), _duration);\\n        } else {\\n            _depositLM(_pTokenReceiver, _amount);\\n        }\\n        emit Deposit(msg.sender, _pTokenReceiver, _amount);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function depositFromBucket(\\n        string calldata _bucketTo,\\n        ISwapManager _swapManager,\\n        PrimexPricingLibrary.Route[] calldata routes,\\n        uint256 _amountOutMin\\n    ) external override nonReentrant {\\n        _notBlackListed();\\n        // don't need check that _bucketTo isn't this bucket name\\n        // tx will be reverted by ReentrancyGuard\\n        _require(\\n            !LMparams.isBucketLaunched && block.timestamp > LMparams.deadlineTimestamp,\\n            Errors.DEADLINE_IS_NOT_PASSED.selector\\n        );\\n        if (isReinvestToAaveEnabled && aaveDeposit > 0) {\\n            _withdrawBucketLiquidityFromAave();\\n        }\\n        IBucket receiverBucket = IBucket(dns.getBucketAddress(_bucketTo));\\n\\n        LMparams.liquidityMiningRewardDistributor.reinvest(\\n            name,\\n            _bucketTo,\\n            msg.sender,\\n            receiverBucket.getLiquidityMiningParams().isBucketLaunched,\\n            LMparams.deadlineTimestamp\\n        );\\n\\n        uint256 allUserBalance = pToken.burn(msg.sender, type(uint256).max, liquidityIndex);\\n        emit Withdraw(msg.sender, address(receiverBucket), allUserBalance);\\n        IERC20Metadata bucketToAsset = receiverBucket.borrowedAsset();\\n        if (bucketToAsset != borrowedAsset) {\\n            // Need this check that _swapManager is legit.\\n            // Without it, user can specify any address of _swapManager to withdraw their funds with an extra reward\\n            _require(\\n                IAccessControl(registry).hasRole(VAULT_ACCESS_ROLE, address(_swapManager)),\\n                Errors.FORBIDDEN.selector\\n            );\\n            borrowedAsset.approve(address(_swapManager), allUserBalance);\\n            allUserBalance = _swapManager.swap(\\n                ISwapManager.SwapParams({\\n                    tokenA: address(borrowedAsset),\\n                    tokenB: address(bucketToAsset),\\n                    amountTokenA: allUserBalance,\\n                    amountOutMin: _amountOutMin,\\n                    routes: routes,\\n                    receiver: address(receiverBucket),\\n                    deadline: block.timestamp,\\n                    isSwapFromWallet: true,\\n                    isSwapToWallet: true,\\n                    isSwapFeeInPmx: false,\\n                    payFeeFromWallet: false\\n                }),\\n                0,\\n                false\\n            );\\n        } else {\\n            TokenTransfersLibrary.doTransferOut(address(borrowedAsset), address(receiverBucket), allUserBalance);\\n        }\\n\\n        receiverBucket.receiveDeposit(msg.sender, allUserBalance, LMparams.stabilizationDuration, name);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function returnLiquidityFromAaveToBucket() external override {\\n        _onlyRole(SMALL_TIMELOCK_ADMIN);\\n        _withdrawBucketLiquidityFromAave();\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function withdraw(address _borrowAssetReceiver, uint256 _amount) external override nonReentrant {\\n        _notBlackListed();\\n        if (!LMparams.isBucketLaunched) {\\n            LMparams.liquidityMiningRewardDistributor.removePoints(name, msg.sender, _amount);\\n        } else if (block.timestamp < LMparams.stabilizationEndTimestamp) {\\n            _require(\\n                _amount <=\\n                    pToken.balanceOf(msg.sender) -\\n                        LMparams.liquidityMiningRewardDistributor.getLenderAmountInMining(name, msg.sender),\\n                Errors.MINING_AMOUNT_WITHDRAW_IS_LOCKED_ON_STABILIZATION_PERIOD.selector\\n            );\\n        }\\n\\n        if (LMparams.isBucketLaunched) _updateIndexes();\\n        uint256 amountToWithdraw = pToken.burn(msg.sender, _amount, liquidityIndex);\\n        uint256 amountToLender = (WadRayMath.WAD - withdrawalFeeRate).wmul(amountToWithdraw);\\n        uint256 amountToTreasury = amountToWithdraw - amountToLender;\\n        if (!LMparams.isBucketLaunched && isReinvestToAaveEnabled && aaveDeposit > 0) {\\n            // if liquidity mining failed, take all tokens from aave during first withdraw from bucket\\n            if (block.timestamp > LMparams.deadlineTimestamp) {\\n                _withdrawBucketLiquidityFromAave();\\n            } else {\\n                // if liquidity mining is in progress, withdraw needed amount from aave\\n                address aavePool = dns.aavePool();\\n                IPool(aavePool).withdraw(address(borrowedAsset), amountToWithdraw, address(this));\\n                emit WithdrawFromAave(aavePool, amountToWithdraw);\\n                aaveDeposit -= amountToWithdraw;\\n            }\\n        }\\n\\n        _require(\\n            amountToWithdraw <= borrowedAsset.balanceOf(address(this)),\\n            Errors.NOT_ENOUGH_LIQUIDITY_IN_THE_BUCKET.selector\\n        );\\n\\n        TokenTransfersLibrary.doTransferOut(address(borrowedAsset), dns.treasury(), amountToTreasury);\\n        emit TopUpTreasury(msg.sender, amountToTreasury);\\n\\n        TokenTransfersLibrary.doTransferOut(address(borrowedAsset), _borrowAssetReceiver, amountToLender);\\n        if (LMparams.isBucketLaunched) _updateRates();\\n\\n        emit Withdraw(msg.sender, _borrowAssetReceiver, amountToWithdraw);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function increaseDebt(address _trader, uint256 _amount, address _to) external override {\\n        _onlyRole(PM_ROLE);\\n        _require(LMparams.isBucketLaunched, Errors.BUCKET_IS_NOT_LAUNCHED.selector);\\n        TokenTransfersLibrary.doTransferOut(address(borrowedAsset), _to, _amount);\\n        _updateIndexes();\\n        debtToken.mint(_trader, _amount, variableBorrowIndex);\\n        _updateRates();\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function decreaseTraderDebt(\\n        address _trader,\\n        uint256 _debtToBurn,\\n        address _receiverOfAmountToReturn,\\n        uint256 _amountToReturn,\\n        uint256 _permanentLossAmount\\n    ) external override {\\n        _onlyRole(PM_ROLE);\\n        // don't need require on isBucketLaunched,\\n        // because if we can't openPosition in this bucket then we can't closePosition in this bucket\\n        if (_amountToReturn > 0) {\\n            TokenTransfersLibrary.doTransferOut(address(borrowedAsset), _receiverOfAmountToReturn, _amountToReturn);\\n        }\\n        _updateIndexes();\\n        debtToken.burn(_trader, _debtToBurn, variableBorrowIndex);\\n        _updateRates();\\n        if (_permanentLossAmount > 0) {\\n            permanentLossScaled += _permanentLossAmount.rdiv(liquidityIndex);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function batchDecreaseTradersDebt(\\n        address[] calldata _traders,\\n        uint256[] calldata _debtsToBurn,\\n        address _receiverOfAmountToReturn,\\n        uint256 _amountToReturn,\\n        uint256 _permanentLossAmount,\\n        uint256 _length\\n    ) external override {\\n        _onlyRole(BATCH_MANAGER_ROLE);\\n        // don't need require on isBucketLaunched,\\n        // because if we can't openPosition in this bucket then we can't closePosition in this bucket\\n        if (_amountToReturn > 0) {\\n            TokenTransfersLibrary.doTransferOut(address(borrowedAsset), _receiverOfAmountToReturn, _amountToReturn);\\n        }\\n        _updateIndexes();\\n        debtToken.batchBurn(_traders, _debtsToBurn, variableBorrowIndex, _length);\\n        _updateRates();\\n        if (_permanentLossAmount > 0) {\\n            permanentLossScaled += _permanentLossAmount.rdiv(liquidityIndex);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function getLiquidityMiningParams() external view override returns (LiquidityMiningParams memory) {\\n        return LMparams;\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function isDeprecated() external view override returns (bool) {\\n        (, IPrimexDNSStorage.Status status, , ) = dns.buckets(name);\\n        return status == IPrimexDNSStorage.Status.Deprecated;\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function isActive() external view override returns (bool) {\\n        (, IPrimexDNSStorage.Status status, , ) = dns.buckets(name);\\n        return status == IPrimexDNSStorage.Status.Active;\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function isDelisted() external view override returns (bool) {\\n        (, IPrimexDNSStorage.Status status, uint256 delistingDeadline, ) = dns.buckets(name);\\n        return status == IPrimexDNSStorage.Status.Deprecated && delistingDeadline < block.timestamp;\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function isBucketStable() external view override returns (bool) {\\n        return LMparams.isBucketLaunched && block.timestamp > LMparams.stabilizationEndTimestamp;\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function maxAssetLeverage(address _asset) external view override returns (uint256) {\\n        _require(allowedAssets[_asset].isSupported, Errors.ASSET_IS_NOT_SUPPORTED.selector);\\n        uint256 maintenanceBuffer = positionManager.maintenanceBuffer();\\n        //  The formula is:\\n        //  (WAD + maintenanceBuffer) feeBuffer /\\n        //  ((WAD + maintenanceBuffer) feeBuffer) -\\n        //  (WAD - securityBuffer) (WAD - pairPriceDropBA) (WAD - oracleTolerableLimitAB) (WAD - oracleTolerableLimitBA)\\n        return\\n            (WadRayMath.WAD + maintenanceBuffer).wmul(feeBuffer).wdiv(\\n                (WadRayMath.WAD + maintenanceBuffer).wmul(feeBuffer) -\\n                    (WadRayMath.WAD - positionManager.securityBuffer())\\n                        .wmul(WadRayMath.WAD - priceOracle.getPairPriceDrop(_asset, address(borrowedAsset)))\\n                        .wmul(WadRayMath.WAD - positionManager.getOracleTolerableLimit(address(borrowedAsset), _asset))\\n                        .wmul(WadRayMath.WAD - positionManager.getOracleTolerableLimit(_asset, address(borrowedAsset)))\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function getNormalizedVariableDebt() external view override returns (uint256) {\\n        return _calculateCompoundedInterest(bar, lastUpdatedBlockTimestamp).rmul(variableBorrowIndex);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function getAllowedAssets() external view override returns (address[] memory) {\\n        return assets;\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function paybackPermanentLoss(uint256 amount) public override nonReentrant {\\n        _notBlackListed();\\n        uint256 amountScaled = amount.rdiv(getNormalizedIncome());\\n        _require(amountScaled > 0, Errors.AMOUNT_SCALED_SHOULD_BE_GREATER_THAN_ZERO.selector);\\n        if (amountScaled > permanentLossScaled) {\\n            amountScaled = permanentLossScaled;\\n            amount = permanentLoss();\\n        }\\n        unchecked {\\n            permanentLossScaled -= amountScaled;\\n        }\\n        pToken.burn(msg.sender, amount, getNormalizedIncome());\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function isWithdrawAfterDelistingAvailable() public view override returns (bool) {\\n        (, IPrimexDNSStorage.Status status, , uint256 adminDeadline) = dns.buckets(name);\\n        return status == IPrimexDNSStorage.Status.Deprecated && adminDeadline < block.timestamp;\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function permanentLoss() public view override returns (uint256) {\\n        return permanentLossScaled.rmul(getNormalizedIncome());\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function getNormalizedIncome() public view override returns (uint256) {\\n        return _calculateLinearInterest(lar, lastUpdatedBlockTimestamp).rmul(liquidityIndex);\\n    }\\n\\n    /**\\n     * @inheritdoc IBucket\\n     */\\n    function availableLiquidity() public view override returns (uint256) {\\n        return borrowedAsset.balanceOf(address(this)) + aaveDeposit;\\n    }\\n\\n    /// @notice Interface checker\\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\n        return\\n            _interfaceId == type(IBucketV2).interfaceId ||\\n            _interfaceId == type(IBucket).interfaceId ||\\n            super.supportsInterface(_interfaceId);\\n    }\\n\\n    /**\\n     * @dev Internal function to deposit funds into the bucket.\\n     * @param _pTokenReceiver The address to receive the pTokens.\\n     * @param _amount The amount of funds to deposit.\\n     * @return _mintedAmount The amount of pTokens minted during deposit\\n     */\\n    function _deposit(address _pTokenReceiver, uint256 _amount) internal returns (uint256 _mintedAmount) {\\n        // launched phase\\n        // here it's also checked that the bucket is active\\n        _require(dns.getBucketAddress(name) == address(this), Errors.BUCKET_OUTSIDE_PRIMEX_PROTOCOL.selector);\\n        _updateIndexes();\\n        _mintedAmount = pToken.mint(_pTokenReceiver, _amount, liquidityIndex);\\n        _updateRates();\\n    }\\n\\n    /**\\n     * @notice Internal function for depositing during liquidity mining period.\\n     * @param _pTokenReceiver The address of the receiver of the pToken.\\n     * @param _amount The amount of tokens to be deposited.\\n     */\\n    function _depositLM(address _pTokenReceiver, uint256 _amount) internal {\\n        // liquidity mining phase\\n        _require(block.timestamp <= LMparams.deadlineTimestamp, Errors.DEADLINE_IS_PASSED.selector);\\n\\n        uint256 _availableLiquidityBeforeTransfer = availableLiquidity() - _amount;\\n\\n        // we don't need update rates and indexes because\\n        // they're zero and 1 ray accordingly while no one borrow\\n        pToken.mint(_pTokenReceiver, _amount, liquidityIndex);\\n\\n        if (_availableLiquidityBeforeTransfer >= LMparams.accumulatingAmount) {\\n            _launchBucket();\\n            return;\\n        }\\n        uint256 tokensLeft = LMparams.accumulatingAmount - _availableLiquidityBeforeTransfer;\\n        uint256 miningAmount;\\n        if (tokensLeft > _amount) {\\n            miningAmount = _amount;\\n            if (isReinvestToAaveEnabled) {\\n                uint256 bucketBalance = borrowedAsset.balanceOf(address(this));\\n                aaveDeposit += bucketBalance;\\n                address aavePool = dns.aavePool();\\n                borrowedAsset.approve(aavePool, bucketBalance);\\n                IPool(aavePool).supply(address(borrowedAsset), bucketBalance, address(this), 0);\\n                emit DepositToAave(aavePool, bucketBalance);\\n            }\\n        } else {\\n            miningAmount = tokensLeft;\\n            _launchBucket();\\n        }\\n\\n        _require(\\n            LMparams.liquidityMiningRewardDistributor.getLenderAmountInMining(name, _pTokenReceiver) + miningAmount <=\\n                LMparams.maxAmountPerUser,\\n            Errors.DEPOSIT_IS_MORE_AMOUNT_PER_USER.selector\\n        );\\n\\n        // save lender activity for future reward distribution\\n        LMparams.liquidityMiningRewardDistributor.addPoints(\\n            name,\\n            _pTokenReceiver,\\n            miningAmount,\\n            LMparams.maxStabilizationEndTimestamp,\\n            LMparams.maxDuration,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the liquidityIndex and variableBorrowIndex\\n     */\\n    function _updateIndexes() internal {\\n        uint256 newLiquidityIndex = _calculateLinearInterest(lar, lastUpdatedBlockTimestamp).rmul(liquidityIndex);\\n        _require(newLiquidityIndex <= type(uint128).max, Errors.LIQUIDITY_INDEX_OVERFLOW.selector);\\n        liquidityIndex = uint128(newLiquidityIndex);\\n\\n        uint256 newVariableBorrowIndex = _calculateCompoundedInterest(bar, lastUpdatedBlockTimestamp).rmul(\\n            variableBorrowIndex\\n        );\\n        _require(newVariableBorrowIndex <= type(uint128).max, Errors.BORROW_INDEX_OVERFLOW.selector);\\n        uint256 previousVariableBorrowIndex = variableBorrowIndex;\\n        variableBorrowIndex = uint128(newVariableBorrowIndex);\\n\\n        lastUpdatedBlockTimestamp = block.timestamp;\\n        _mintToReserve(debtToken.scaledTotalSupply(), previousVariableBorrowIndex, variableBorrowIndex);\\n    }\\n\\n    /**\\n     * @dev Mints portion of the interest that goes to the Primex Reserve\\n     */\\n    function _mintToReserve(\\n        uint256 _scaledVariableDebt,\\n        uint256 _previousVariableBorrowIndex,\\n        uint256 _newVariableBorrowIndex\\n    ) internal {\\n        if (reserveRate == 0) {\\n            return;\\n        }\\n        // debt accrued is the current debt minus the debt at the last update\\n        // percentage multiplied\\n        pToken.mintToReserve(\\n            address(reserve),\\n            (_scaledVariableDebt.rmul(_newVariableBorrowIndex) - _scaledVariableDebt.rmul(_previousVariableBorrowIndex))\\n                .wmul(reserveRate),\\n            liquidityIndex\\n        );\\n    }\\n\\n    /**\\n     * @notice Internal function to set the isBucketLaunched flag to true.\\n     * Set the stabilizationPeriodEnd timestamp.\\n     * If investment is enabled withdraw all liquidity from Aave.\\n     */\\n\\n    function _launchBucket() internal {\\n        LMparams.isBucketLaunched = true;\\n        LMparams.stabilizationEndTimestamp = block.timestamp + LMparams.stabilizationDuration;\\n        if (isReinvestToAaveEnabled) {\\n            _withdrawBucketLiquidityFromAave();\\n        }\\n        emit BucketLaunched();\\n    }\\n\\n    /**\\n     * @notice Internal function to withdraw all liquidity from Aave\\n     */\\n    function _withdrawBucketLiquidityFromAave() internal {\\n        address aavePool = dns.aavePool();\\n        uint256 aaveBalance = IAToken(IPool(aavePool).getReserveData(address(borrowedAsset)).aTokenAddress).balanceOf(\\n            address(this)\\n        );\\n        isReinvestToAaveEnabled = false;\\n        if (aaveBalance == 0) return;\\n\\n        IPool(aavePool).withdraw(address(borrowedAsset), type(uint256).max, address(this));\\n        emit WithdrawFromAave(aavePool, aaveBalance);\\n\\n        // if there is earned interest, withdraw it to treasury\\n        if (aaveBalance > aaveDeposit) {\\n            uint256 interest = aaveBalance - aaveDeposit;\\n            TokenTransfersLibrary.doTransferOut(address(borrowedAsset), dns.treasury(), interest);\\n            emit TopUpTreasury(aavePool, interest);\\n        }\\n        aaveDeposit = 0;\\n    }\\n\\n    /**\\n     * @dev Updates bucket's BAR and LAR.\\n     */\\n    function _updateRates() internal {\\n        uint256 totalDemand = debtToken.totalSupply();\\n        uint256 totalDeposit = availableLiquidity() + totalDemand;\\n        if (totalDeposit == 0) {\\n            bar = 0;\\n            lar = 0;\\n        } else {\\n            (bar, lar) = interestRateStrategy.calculateInterestRates(totalDemand.rdiv(totalDeposit), reserveRate);\\n        }\\n        emit RatesIndexesUpdated(bar, lar, variableBorrowIndex, liquidityIndex, block.timestamp);\\n    }\\n\\n    /**\\n     * @dev Internal function to add a new asset to the allowed assets list.\\n     * @param _newAsset The address of the new asset to be added.\\n     */\\n    function _addAsset(address _newAsset) internal {\\n        _require(_newAsset != address(0), Errors.CAN_NOT_ADD_WITH_ZERO_ADDRESS.selector);\\n        _require(!allowedAssets[_newAsset].isSupported, Errors.ASSET_ALREADY_SUPPORTED.selector);\\n        _require(\\n            IERC20Metadata(_newAsset).decimals() <= MAX_ASSET_DECIMALS,\\n            Errors.ASSET_DECIMALS_EXCEEDS_MAX_VALUE.selector\\n        );\\n        _require(\\n            priceOracle.pairPriceDrops(_newAsset, address(borrowedAsset)) > 0,\\n            Errors.PAIR_PRICE_DROP_IS_NOT_CORRECT.selector\\n        );\\n        // Check that both the new asset and the borrowed asset have oracle price feeds available\\n        priceOracle.getPriceFeedsPair(_newAsset, address(borrowedAsset));\\n        assets.push(_newAsset);\\n        allowedAssets[_newAsset] = Asset(assets.length - 1, true);\\n        emit AddAsset(_newAsset);\\n    }\\n\\n    /**\\n     * @dev Calculates the accumulated interest per blocks delta\\n     * @param _rate The interest rate (in ray)\\n     * @param _lastUpdatedBlockTimestamp The block timestamp of the last update of interest rate\\n     * @return The interest rate accumulated during the secondsDelta (in ray)\\n     */\\n    function _calculateLinearInterest(\\n        uint256 _rate,\\n        uint256 _lastUpdatedBlockTimestamp\\n    ) internal view returns (uint256) {\\n        uint256 secondsDelta = block.timestamp - _lastUpdatedBlockTimestamp;\\n        return (_rate * secondsDelta) / SECONDS_PER_YEAR + WadRayMath.RAY;\\n    }\\n\\n    /**\\n     * @dev Calculates borrow interest using compounded interest formula\\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n     * (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n     * @param _bar Borrowing annual rate (originally APR) (in ray)\\n     * @param _blockTimestamp The block timestamp of the last update of borrow rate\\n     * @return The borrow interest rate compounded during the secondsDelta (in ray)\\n     */\\n    function _calculateCompoundedInterest(uint256 _bar, uint256 _blockTimestamp) internal view returns (uint256) {\\n        uint256 exp = block.timestamp - _blockTimestamp;\\n\\n        if (exp == 0) {\\n            return WadRayMath.RAY;\\n        }\\n\\n        uint256 expMinusOne = exp - 1;\\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n        // multiply first to mitigate rounding related issues\\n        uint256 basePowerTwo = _bar.rmul(_bar) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\\n        uint256 basePowerThree = _bar.rmul(_bar).rmul(_bar) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR * SECONDS_PER_YEAR);\\n\\n        uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\\n        uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\\n\\n        return WadRayMath.RAY + (_bar * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\\n    }\\n\\n    /**\\n     * @dev Function that checks if the caller has a specific role.\\n     * @param _role The role identifier to check.\\n     */\\n    function _onlyRole(bytes32 _role) internal view {\\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\\n    }\\n\\n    /**\\n     * @dev Function that checks if the sender is not blacklisted.\\n     */\\n    function _notBlackListed() internal view {\\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\\n    }\\n}\\n/* solhint-enable max-states-count */\\n\",\"keccak256\":\"0xd35e7ad8439a23b7dcf46e30ba6655672e99841377c28908b396c9b745da0b1b\",\"license\":\"BUSL-1.1\"},\"contracts/Bucket/BucketStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {ReentrancyGuardUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {ERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IPool} from \\\"@aave/core-v3/contracts/interfaces/IPool.sol\\\";\\nimport {IAToken} from \\\"@aave/core-v3/contracts/interfaces/IAToken.sol\\\";\\n\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\n\\nimport {IWhiteBlackList} from \\\"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\\\";\\nimport {IBucketStorage} from \\\"./IBucketStorage.sol\\\";\\nimport {IPToken} from \\\"../PToken/IPToken.sol\\\";\\nimport {IDebtToken} from \\\"../DebtToken/IDebtToken.sol\\\";\\nimport {IPositionManager} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IPrimexDNSStorage} from \\\"../PrimexDNS/IPrimexDNSStorage.sol\\\";\\nimport {IReserve} from \\\"../Reserve/IReserve.sol\\\";\\nimport {IInterestRateStrategy} from \\\"../interfaces/IInterestRateStrategy.sol\\\";\\nimport {ISwapManager} from \\\"../interfaces/ISwapManager.sol\\\";\\nimport {ILiquidityMiningRewardDistributor} from \\\"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\\\";\\n\\nabstract contract BucketStorage is IBucketStorage, ReentrancyGuardUpgradeable, ERC165Upgradeable {\\n    string public override name;\\n    address public override registry;\\n    IPositionManager public override positionManager;\\n    IReserve public override reserve;\\n    IPToken public override pToken;\\n    IDebtToken public override debtToken;\\n    IERC20Metadata public override borrowedAsset;\\n    uint256 public override feeBuffer;\\n    // The current borrow rate, expressed in ray. bar = borrowing annual rate (originally APR)\\n    uint128 public override bar;\\n    // The current interest rate, expressed in ray. lar = lending annual rate (originally APY)\\n    uint128 public override lar;\\n    // The estimated borrowing annual rate, expressed in ray\\n    uint128 public override estimatedBar;\\n    // The estimated lending annual rate, expressed in ray\\n    uint128 public override estimatedLar;\\n    uint128 public override liquidityIndex;\\n    uint128 public override variableBorrowIndex;\\n    // block where indexes were updated\\n    uint256 public lastUpdatedBlockTimestamp;\\n    uint256 public override permanentLossScaled;\\n    uint256 public reserveRate;\\n    uint256 public override withdrawalFeeRate;\\n    IWhiteBlackList public override whiteBlackList;\\n    mapping(address => Asset) public override allowedAssets;\\n    IInterestRateStrategy public interestRateStrategy;\\n    uint256 public aaveDeposit;\\n    bool public isReinvestToAaveEnabled;\\n    uint256 public override maxTotalDeposit;\\n    address[] internal assets;\\n    // solhint-disable-next-line var-name-mixedcase\\n    LiquidityMiningParams internal LMparams;\\n    IPrimexDNS internal dns;\\n    IPriceOracle internal priceOracle;\\n}\\n\",\"keccak256\":\"0xb9ee6a7f226c9a230f6d5e8c2f03572d83137ecd1ee2bc9512c0973a057228e4\",\"license\":\"BUSL-1.1\"},\"contracts/Bucket/IBucket.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\nimport {IPToken} from \\\"../PToken/IPToken.sol\\\";\\nimport {IDebtToken} from \\\"../DebtToken/IDebtToken.sol\\\";\\nimport {IPositionManager} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IWhiteBlackList} from \\\"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\\\";\\nimport {IReserve} from \\\"../Reserve/IReserve.sol\\\";\\nimport {ILiquidityMiningRewardDistributor} from \\\"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\\\";\\nimport {IInterestRateStrategy} from \\\"../interfaces/IInterestRateStrategy.sol\\\";\\nimport {ISwapManager} from \\\"../interfaces/ISwapManager.sol\\\";\\nimport {IBucketStorage} from \\\"./IBucketStorage.sol\\\";\\n\\ninterface IBucket is IBucketStorage {\\n    struct ConstructorParams {\\n        string name;\\n        IPToken pToken;\\n        IDebtToken debtToken;\\n        IPositionManager positionManager;\\n        IPriceOracle priceOracle;\\n        IPrimexDNS dns;\\n        IReserve reserve;\\n        IWhiteBlackList whiteBlackList;\\n        address[] assets;\\n        IERC20Metadata borrowedAsset;\\n        uint256 feeBuffer;\\n        uint256 withdrawalFeeRate;\\n        uint256 reserveRate;\\n        // liquidityMining params\\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor;\\n        uint256 liquidityMiningAmount;\\n        uint256 liquidityMiningDeadline;\\n        uint256 stabilizationDuration;\\n        IInterestRateStrategy interestRateStrategy;\\n        uint128 estimatedBar;\\n        uint128 estimatedLar;\\n        uint256 maxAmountPerUser;\\n        bool isReinvestToAaveEnabled;\\n        bytes barCalcParams;\\n        uint256 maxTotalDeposit;\\n    }\\n\\n    event Deposit(address indexed depositer, address indexed pTokenReceiver, uint256 amount);\\n\\n    event Withdraw(address indexed withdrawer, address indexed borrowAssetReceiver, uint256 amount);\\n\\n    event DepositToAave(address indexed pool, uint256 amount);\\n\\n    event WithdrawFromAave(address indexed pool, uint256 amount);\\n\\n    event TopUpTreasury(address indexed sender, uint256 amount);\\n\\n    event FeeBufferChanged(uint256 feeBuffer);\\n\\n    event ReserveRateChanged(uint256 reserveRate);\\n\\n    event RatesIndexesUpdated(\\n        uint128 bar,\\n        uint128 lar,\\n        uint128 variableBorrowIndex,\\n        uint128 liquidityIndex,\\n        uint256 timestamp\\n    );\\n\\n    event WithdrawalFeeChanged(uint256 withdrawalFeeRate);\\n\\n    event InterestRateStrategyChanged(address interestRateStrategy);\\n\\n    event AddAsset(address addedAsset);\\n\\n    event RemoveAsset(address deletedAsset);\\n\\n    event MaxTotalDepositChanged(uint256 maxTotalDeposit);\\n\\n    event BarCalculationParamsChanged(bytes params);\\n\\n    event BucketLaunched();\\n\\n    /**\\n     * @dev Initializes the contract with the given parameters.\\n     * @param _params The ConstructorParams struct containing initialization parameters.\\n     * @param _registry The address of the registry contract.\\n     */\\n    function initialize(ConstructorParams memory _params, address _registry) external;\\n\\n    /**\\n     * @dev Function to add new trading asset for this bucket\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _newAsset The address of trading asset\\n     */\\n    function addAsset(address _newAsset) external;\\n\\n    /**\\n     * @notice Removes a trading asset from this bucket.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _assetToDelete The address of the asset to be removed.\\n     */\\n    function removeAsset(address _assetToDelete) external;\\n\\n    function setBarCalculationParams(bytes memory _params) external;\\n\\n    /**\\n     * @dev Sets the reserve rate.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _reserveRate The new reserve rate value.\\n     */\\n    function setReserveRate(uint256 _reserveRate) external;\\n\\n    /**\\n     * @dev Sets the new fee buffer.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _feeBuffer The new fee buffer value.\\n     */\\n    function setFeeBuffer(uint256 _feeBuffer) external;\\n\\n    /**\\n     * @dev Sets the withdrawal fee.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _withdrawalFee The new withdrawal fee value.\\n     */\\n    function setWithdrawalFee(uint256 _withdrawalFee) external;\\n\\n    /**\\n     * @dev Sets the interest rate strategy contract address.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _interestRateStrategy The address of the interest rate strategy contract.\\n     */\\n    function setInterestRateStrategy(address _interestRateStrategy) external;\\n\\n    /**\\n     * @notice The function sets the max total deposit for the particular bucket\\n     * @param _maxTotalDeposit The amount of max total deposit for the bucket\\n     */\\n    function setMaxTotalDeposit(uint256 _maxTotalDeposit) external;\\n\\n    /**\\n     * @dev Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.\\n     * @param _pTokenReceiver The address to receive the deposited pTokens.\\n     * @param _amount The amount of underlying tokens to be deposited\\n     */\\n    function deposit(address _pTokenReceiver, uint256 _amount) external;\\n\\n    /**\\n     * @dev Withdraws the 'amount' of underlying asset from the bucket. The 'amount' of overlying pTokens will be burned.\\n     * @param _borrowAssetReceiver The address of receiver of the borrowed asset.\\n     * @param amount The amount of underlying tokens to be withdrawn.\\n     */\\n    function withdraw(address _borrowAssetReceiver, uint256 amount) external;\\n\\n    /**\\n     * @notice Allows the BIG_TIMELOCK_ADMIN role to withdraw a specified amount of tokens after delisting.\\n     * @param _amount The amount of tokens to withdraw.\\n     */\\n    function withdrawAfterDelisting(uint256 _amount) external;\\n\\n    /**\\n     * @dev Receives a deposit and distributes it to the specified pToken receiver.\\n     * @dev Can be called only by another bucket.\\n     * @param _pTokenReceiver The address of the recipient of the pToken.\\n     * @param _amount The amount of tokens being deposited.\\n     * @param _duration The blocking time for a fixed-term deposit (if it's 0, then it will be a usual deposit)\\n     * @param _bucketFrom The name of the bucket from which the deposit is being made.\\n     */\\n    function receiveDeposit(\\n        address _pTokenReceiver,\\n        uint256 _amount,\\n        uint256 _duration,\\n        string memory _bucketFrom\\n    ) external;\\n\\n    /**\\n     * @notice Deposits (reinvests) funds from a bucket to another bucket.\\n     * Used only in the case of failed liquidity mining in the bucket from where the transfer happens.\\n     * @param _bucketTo The name of the destination bucket.\\n     * @param _swapManager The address of the swap manager.\\n     * @param routes The array of routes for swapping tokens.\\n     * @param _amountOutMin The minimum amount of tokens to receive from the swap.\\n     */\\n    function depositFromBucket(\\n        string calldata _bucketTo,\\n        ISwapManager _swapManager,\\n        PrimexPricingLibrary.Route[] calldata routes,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /**\\n     * @dev Allows the SMALL_TIMELOCK_ADMIN to withdraw all liquidity from Aave to Bucket.\\n     */\\n    function returnLiquidityFromAaveToBucket() external;\\n\\n    /**\\n     * @dev Function to update rates and indexes when a trader opens a trading position.\\n     * Mints debt tokens to trader. Calls only by positionManager contract.\\n     * @param _trader The address of the trader, who opens position.\\n     * @param _amount The 'amount' for which the deal is open, and 'amount' of debtTokens will be minted to the trader.\\n     * @param _to The address to transfer the borrowed asset to.\\n     */\\n\\n    function increaseDebt(address _trader, uint256 _amount, address _to) external;\\n\\n    /**\\n     * @dev Function to update rates and indexes.\\n     * Burns debt tokens of trader. Called only by positionManager contract.\\n     * @param _trader The address of the trader, who opened position.\\n     * @param _debtToBurn The 'amount' of trader's debtTokens will be burned by the trader.\\n     * @param _receiverOfAmountToReturn Treasury in case of liquidation. TraderBalanceVault in other cases\\n     * @param _amountToReturn Amount to transfer from bucket\\n     * @param _permanentLossAmount The amount of the protocol's debt to creditors accrued for this position\\n     */\\n    function decreaseTraderDebt(\\n        address _trader,\\n        uint256 _debtToBurn,\\n        address _receiverOfAmountToReturn,\\n        uint256 _amountToReturn,\\n        uint256 _permanentLossAmount\\n    ) external;\\n\\n    /**\\n     * @notice Batch decreases the debt of multiple traders.\\n     * @dev This function can only be called by the BATCH_MANAGER_ROLE.\\n     * @param _traders An array of addresses representing the traders.\\n     * @param _debtsToBurn An array of uint256 values representing the debts to burn for each trader.\\n     * @param _receiverOfAmountToReturn The address that will receive the amount to be returned.\\n     * @param _amountToReturn The amount to be returned.\\n     * @param _permanentLossAmount The amount of permanent loss.\\n     * @param _length The length of the traders array.\\n     */\\n    function batchDecreaseTradersDebt(\\n        address[] memory _traders,\\n        uint256[] memory _debtsToBurn,\\n        address _receiverOfAmountToReturn,\\n        uint256 _amountToReturn,\\n        uint256 _permanentLossAmount,\\n        uint256 _length\\n    ) external;\\n\\n    /**\\n     * @notice This function allows a user to pay back a permanent loss by burning his pTokens.\\n     * @param amount The amount of pTokens to be burned to pay back the permanent loss.\\n     */\\n    function paybackPermanentLoss(uint256 amount) external;\\n\\n    /**\\n     * @dev Calculates the permanent loss based on the scaled permanent loss and the normalized income.\\n     * @return The amount of permanent loss.\\n     */\\n    function permanentLoss() external view returns (uint256);\\n\\n    /**\\n     * @dev Checks if the bucket is deprecated in the protocol.\\n     * @return Whether the bucket is deprecated or not.\\n     */\\n    function isDeprecated() external view returns (bool);\\n\\n    /**\\n     * @dev Returns a boolean value indicating whether the bucket is delisted.\\n     * @return True if the bucket is delisted, otherwise false.\\n     */\\n    function isDelisted() external view returns (bool);\\n\\n    /**\\n     * @dev Checks if an admin can withdraw from the bucket after delisting.\\n     * @return A boolean indicating whether withdrawal is available.\\n     */\\n    function isWithdrawAfterDelistingAvailable() external view returns (bool);\\n\\n    /**\\n     * @dev Checks if this bucket is active in the protocol.\\n     * @return bool True if the bucket is active, false otherwise.\\n     */\\n    function isActive() external view returns (bool);\\n\\n    /**\\n     * @dev Returns the parameters for liquidity mining.\\n     * @return LMparams The liquidity mining parameters.\\n     */\\n    function getLiquidityMiningParams() external view returns (LiquidityMiningParams memory);\\n\\n    /**\\n     * @dev Returns a boolean value indicating whether the bucket is stable in the liquidity mining event.\\n     * @return A boolean value representing the stability of the bucket.\\n     */\\n    function isBucketStable() external view returns (bool);\\n\\n    /**\\n     * @dev Calculates the max leverage according to the following formula:\\n     * ((1 + maintenanceBuffer) * feeBuffer) / ((1 + maintenanceBuffer) * feeBuffer - (1 - securityBuffer) *\\n     * (1 - pairPriceDropBA) * (1 - oracleTolerableLimitAB) * (1 - oracleTolerableLimitBA))\\n     * @param _asset The address of trading asset\\n     * @return The maximum leverage as a uint256 value.\\n     */\\n    function maxAssetLeverage(address _asset) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the normalized income per unit of underlying asset, expressed in ray\\n     * @return The normalized income per unit of underlying asset, expressed in ray\\n     */\\n    function getNormalizedIncome() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the normalized variable debt per unit of underlying asset, expressed in ray\\n     */\\n    function getNormalizedVariableDebt() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns allowed trading assets for current bucket\\n     * @return List of addresses of allowed assets\\n     */\\n    function getAllowedAssets() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Returns current avalable liquidity of borrowedAsset for trading.\\n     * @return The amount of available borrowedAsset\\n     */\\n    function availableLiquidity() external view returns (uint256);\\n}\\n\\ninterface IBucketV2 is IBucket {\\n    /**\\n     * @dev Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.\\n     * @param _pTokenReceiver The address to receive the deposited pTokens.\\n     * @param _amount The amount of underlying tokens to be deposited\\n     * @param _takeDepositFromWallet A flag indicating whether to make the deposit from user wallet\\n     */\\n    function deposit(address _pTokenReceiver, uint256 _amount, bool _takeDepositFromWallet) external;\\n}\\n\",\"keccak256\":\"0xcb6d018cd67323ea8891193d1dfcd8f19d23e8aae921797c39244aa30c33e0f2\",\"license\":\"BUSL-1.1\"},\"contracts/Bucket/IBucketStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport {IPToken} from \\\"../PToken/IPToken.sol\\\";\\nimport {IDebtToken} from \\\"../DebtToken/IDebtToken.sol\\\";\\nimport {IPositionManager} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IReserve} from \\\"../Reserve/IReserve.sol\\\";\\nimport {ILiquidityMiningRewardDistributor} from \\\"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\\\";\\nimport {IWhiteBlackList} from \\\"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\\\";\\nimport {IInterestRateStrategy} from \\\"../interfaces/IInterestRateStrategy.sol\\\";\\n\\ninterface IBucketStorage {\\n    /**\\n     * @dev Parameters of liquidity mining\\n     */\\n    struct LiquidityMiningParams {\\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor;\\n        bool isBucketLaunched;\\n        uint256 accumulatingAmount;\\n        uint256 deadlineTimestamp;\\n        uint256 stabilizationDuration;\\n        uint256 stabilizationEndTimestamp;\\n        uint256 maxAmountPerUser; // if maxAmountPerUser is >= accumulatingAmount then check on maxAmountPerUser is off\\n        // Constant max variables are used for calculating users' points.\\n        // These intervals are used for fair distribution of points among Lenders.\\n        // Lenders who brought liquidity earlier receive more than the ones who deposited later.\\n        // To get maximum points per token, a Lender should deposit immediately after the Bucket deployment.\\n        uint256 maxDuration;\\n        uint256 maxStabilizationEndTimestamp;\\n    }\\n    //                                        1. Corner case of bucket launch\\n    //\\n    //                                              maxDuration\\n    //       ------------------------------------------------------------------------------------------------\\n    //      |                                                                                               |\\n    //      |                                                                        stabilizationDuration  |\\n    //      |                                                                      -------------------------|\\n    //      |                                                                     | bucket launch           |\\n    //   +--+---------------------------------------------------------------------+-------------------------+------> time\\n    //      bucket deploy                                                         deadlineTimestamp         maxStabilizationEndTimestamp\\n    //                                                                                                       (=stabilizationEndTimestamp here)\\n    //                                  (corner case of bucket launch)\\n\\n    //                                        2. One of cases of bucket launch\\n    //\\n    //      |                     stabilizationDuration\\n    //      |                   -------------------------\\n    //      |                  |                         |\\n    //   +--+------------------+-------------------------+------------------------+-------------------------+------> time\\n    //      bucket deploy      bucket launch            stabilizationEndTimestamp  deadlineTimestamp        maxStabilizationEndTimestamp\\n    //                                                                            (after deadline bucket can't be launched)\\n\\n    struct Asset {\\n        uint256 index;\\n        bool isSupported;\\n    }\\n\\n    function liquidityIndex() external returns (uint128);\\n\\n    function variableBorrowIndex() external returns (uint128);\\n\\n    function name() external view returns (string memory);\\n\\n    function registry() external view returns (address);\\n\\n    function positionManager() external view returns (IPositionManager);\\n\\n    function reserve() external view returns (IReserve);\\n\\n    function permanentLossScaled() external view returns (uint256);\\n\\n    function pToken() external view returns (IPToken);\\n\\n    function debtToken() external view returns (IDebtToken);\\n\\n    function borrowedAsset() external view returns (IERC20Metadata);\\n\\n    function feeBuffer() external view returns (uint256);\\n\\n    function withdrawalFeeRate() external view returns (uint256);\\n\\n    /**\\n     * @notice bar = borrowing annual rate (originally APR)\\n     */\\n    function bar() external view returns (uint128);\\n\\n    /**\\n     * @notice lar = lending annual rate (originally APY)\\n     */\\n    function lar() external view returns (uint128);\\n\\n    function interestRateStrategy() external view returns (IInterestRateStrategy);\\n\\n    function estimatedBar() external view returns (uint128);\\n\\n    function estimatedLar() external view returns (uint128);\\n\\n    function allowedAssets(address _asset) external view returns (uint256, bool);\\n\\n    function whiteBlackList() external view returns (IWhiteBlackList);\\n\\n    function maxTotalDeposit() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x21ab63957721b0662c50fdff4b13ed53dfad864fc24220517e98a54ce12250f8\",\"license\":\"BUSL-1.1\"},\"contracts/Constants.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\n// admin roles\\nbytes32 constant BIG_TIMELOCK_ADMIN = 0x00; // It's primary admin.\\nbytes32 constant MEDIUM_TIMELOCK_ADMIN = keccak256(\\\"MEDIUM_TIMELOCK_ADMIN\\\");\\nbytes32 constant SMALL_TIMELOCK_ADMIN = keccak256(\\\"SMALL_TIMELOCK_ADMIN\\\");\\nbytes32 constant EMERGENCY_ADMIN = keccak256(\\\"EMERGENCY_ADMIN\\\");\\nbytes32 constant GUARDIAN_ADMIN = keccak256(\\\"GUARDIAN_ADMIN\\\");\\nbytes32 constant NFT_MINTER = keccak256(\\\"NFT_MINTER\\\");\\nbytes32 constant TRUSTED_TOLERABLE_LIMIT_ROLE = keccak256(\\\"TRUSTED_TOLERABLE_LIMIT_ROLE\\\");\\n\\n// inter-contract interactions roles\\nbytes32 constant NO_FEE_ROLE = keccak256(\\\"NO_FEE_ROLE\\\");\\nbytes32 constant VAULT_ACCESS_ROLE = keccak256(\\\"VAULT_ACCESS_ROLE\\\");\\nbytes32 constant PM_ROLE = keccak256(\\\"PM_ROLE\\\");\\nbytes32 constant LOM_ROLE = keccak256(\\\"LOM_ROLE\\\");\\nbytes32 constant BATCH_MANAGER_ROLE = keccak256(\\\"BATCH_MANAGER_ROLE\\\");\\n\\n// token constants\\naddress constant NATIVE_CURRENCY = address(uint160(bytes20(keccak256(\\\"NATIVE_CURRENCY\\\"))));\\naddress constant USD = 0x0000000000000000000000000000000000000348;\\nuint256 constant USD_MULTIPLIER = 10 ** (18 - 8); // usd decimals in chainlink is 8\\nuint8 constant MAX_ASSET_DECIMALS = 18;\\n\\n// time constants\\nuint256 constant SECONDS_PER_YEAR = 365 days;\\nuint256 constant SECONDS_PER_DAY = 1 days;\\nuint256 constant HOUR = 1 hours;\\nuint256 constant TEN_WAD = 10 ether;\\n\",\"keccak256\":\"0xdfd1623c3bf46ff9a6fbbdff42a7d9a1b5e76c4252dd394db1b7811989dcaba3\",\"license\":\"BUSL-1.1\"},\"contracts/DebtToken/IDebtToken.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\n\\nimport {IDebtTokenStorage, IBucket, IFeeExecutor, IERC20Upgradeable, IActivityRewardDistributor} from \\\"./IDebtTokenStorage.sol\\\";\\n\\ninterface IDebtToken is IDebtTokenStorage {\\n    /**\\n     * @dev Emitted after the mint action\\n     * @param from The address performing the mint\\n     * @param value The amount being\\n     **/\\n    event Mint(address indexed from, uint256 value);\\n\\n    /**\\n     * @dev Emitted after DebtTokens are burned\\n     * @param from The owner of the aTokens, getting them burned\\n     * @param value The amount being burned\\n     **/\\n    event Burn(address indexed from, uint256 value);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param _name The name of the ERC20 token.\\n     * @param _symbol The symbol of the ERC20 token.\\n     * @param _decimals The number of decimals for the ERC20 token.\\n     * @param _bucketsFactory Address of the buckets factory that will call the setBucket fucntion\\n     */\\n    function initialize(string memory _name, string memory _symbol, uint8 _decimals, address _bucketsFactory) external;\\n\\n    /**\\n     * @dev Sets the bucket for the contract.\\n     * @param _bucket The address of the bucket to set.\\n     */\\n    function setBucket(IBucket _bucket) external;\\n\\n    /**\\n     * @dev Sets the FeeDecreaser for current DebtToken.\\n     * @param _feeDecreaser The interest increaser address.\\n     */\\n    function setFeeDecreaser(IFeeExecutor _feeDecreaser) external;\\n\\n    /**\\n     * @dev Sets the trader reward distributor contract address.\\n     * @param _traderRewardDistributor The address of the trader reward distributor contract.\\n     * Only the BIG_TIMELOCK_ADMIN role can call this function.\\n     */\\n    function setTraderRewardDistributor(IActivityRewardDistributor _traderRewardDistributor) external;\\n\\n    /**\\n     * @dev Mints `amount` DebtTokens to `user`\\n     * @param _user The address receiving the minted tokens\\n     * @param _amount The amount of tokens getting minted\\n     * @param _index The current variableBorrowIndex\\n     */\\n    function mint(address _user, uint256 _amount, uint256 _index) external;\\n\\n    /**\\n     * @dev Burns DebtTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n     * @param _user The owner of the DebtTokens, getting them burned\\n     * @param _amount The amount being burned\\n     * @param _index The current variableBorrowIndex\\n     **/\\n    function burn(address _user, uint256 _amount, uint256 _index) external;\\n\\n    /**\\n     * @dev Burns a batch of tokens from multiple users.\\n     * @param _users An array of user addresses whose tokens will be burned.\\n     * @param _amounts An array of token amounts to be burned for each user.\\n     * @param _index The index used to calculate the scaled amounts.\\n     * @param _length The length of the user and amounts arrays.\\n     */\\n    function batchBurn(address[] memory _users, uint256[] memory _amounts, uint256 _index, uint256 _length) external;\\n\\n    /**\\n     * @dev Returns the principal debt balance of the user\\n     * @param _user The address of the user.\\n     * @return The scaled balance of the user.\\n     */\\n    function scaledBalanceOf(address _user) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the scaled total supply of debtToken.\\n     * @return The scaled total supply of the debtToken.\\n     */\\n    function scaledTotalSupply() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x181f52e402dfafa461a15a25983c2c6b13e8d7688accee410987cb8e27f38bdd\",\"license\":\"BUSL-1.1\"},\"contracts/DebtToken/IDebtTokenStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport {IBucket} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IFeeExecutor} from \\\"../BonusExecutor/IFeeExecutor.sol\\\";\\nimport {IActivityRewardDistributor} from \\\"../ActivityRewardDistributor/IActivityRewardDistributor.sol\\\";\\n\\ninterface IDebtTokenStorage is IERC20Upgradeable {\\n    function bucket() external view returns (IBucket);\\n\\n    function feeDecreaser() external view returns (IFeeExecutor);\\n\\n    function traderRewardDistributor() external view returns (IActivityRewardDistributor);\\n}\\n\",\"keccak256\":\"0x22ecd3fd35265d62e8ee590e1d0fd3fd7df07347e7ed20c4b5745d2aba49f2df\",\"license\":\"BUSL-1.1\"},\"contracts/KeeperRewardDistributor/IKeeperRewardDistributor.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IKeeperRewardDistributorStorage, IKeeperRewardDistributorStorageV2} from \\\"./IKeeperRewardDistributorStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface IKeeperRewardDistributor is IKeeperRewardDistributorStorage, IPausable {\\n    struct DecreasingGasByReasonParams {\\n        DecreasingReason reason;\\n        uint256 amount;\\n    }\\n    struct MaxGasPerPositionParams {\\n        KeeperActionType actionType;\\n        KeeperActionRewardConfig config;\\n    }\\n\\n    /**\\n     * @dev     Params for initialize() function\\n     * @param   priceOracle  Address of the PriceOracle contract\\n     * @param   registry  Address of the Registry contract\\n     * @param   pmx  Address of PMXToken\\n     * @param   treasury  Address of the Treasury contract\\n     * @param   pmxPartInReward  Percentage of PMX in reward (in WAD)\\n     * @param   nativePartInReward  Percentage of native token in reward (in WAD)\\n     * @param   positionSizeCoefficientA  CoefficientA in the formula positionSize * CoefficientA + CoefficientB\\n     * @param   positionSizeCoefficientB  CoefficientB in the formula positionSize * CoefficientA + CoefficientB\\n     * @param   additionalGas  Additional gas added to actual gas spent\\n     * @param   defaultMaxGasPrice  Max gas price allowed during reward calculation (used when no oracle price found)\\n     * @param   oracleGasPriceTolerance  Percentage by which oracle gas price can be exceeded (in WAD)\\n     * @param   paymentModel  The model of payment for gas in the network\\n     * @param   maxGasPerPositionParams  Parameters for the setMaxGasPerPosition function\\n     * @param   decreasingGasByReasonParams  Parameters for the setDecreasingGasByReason function\\n     */\\n    struct InitParams {\\n        address priceOracle;\\n        address registry;\\n        address pmx;\\n        address treasury;\\n        address whiteBlackList;\\n        uint256 pmxPartInReward;\\n        uint256 nativePartInReward;\\n        uint256 positionSizeCoefficientA;\\n        int256 positionSizeCoefficientB;\\n        uint256 additionalGas;\\n        uint256 defaultMaxGasPrice;\\n        uint256 oracleGasPriceTolerance;\\n        PaymentModel paymentModel;\\n        MaxGasPerPositionParams[] maxGasPerPositionParams;\\n        DecreasingGasByReasonParams[] decreasingGasByReasonParams;\\n    }\\n\\n    event ClaimFees(address indexed keeper, address indexed asset, uint256 amount);\\n    event DefaultMaxGasPriceChanged(uint256 indexed defaultMaxGasPrice);\\n    event OracleGasPriceToleranceChanged(uint256 indexed oracleGasPriceTolerance);\\n    event MaxGasPerPositionChanged(KeeperActionType indexed actionType, KeeperActionRewardConfig config);\\n    event DataLengthRestrictionsChanged(KeeperCallingMethod callingMethod, uint256 maxRoutesLength, uint256 baseLength);\\n    event DecreasingGasByReasonChanged(DecreasingReason indexed reason, uint256 amount);\\n    event PmxPartInRewardChanged(uint256 indexed pmxPartInReward);\\n    event NativePartInRewardChanged(uint256 indexed nativePartInReward);\\n    event PositionSizeCoefficientsChanged(\\n        uint256 indexed positionSizeCoefficientA,\\n        int256 indexed positionSizeCoefficientB\\n    );\\n    event AdditionalGasChanged(uint256 indexed additionalGas);\\n    event KeeperRewardUpdated(address indexed keeper, uint256 rewardInPmx, uint256 rewardInNativeCurrency);\\n\\n    /**\\n     * @notice Initializes the KeeperRewardDistributor contract.\\n     * @param _params  Parameters for initialization\\n     */\\n    function initialize(InitParams calldata _params) external;\\n\\n    /**\\n     * @dev Params for the updateReward function\\n     * @param keeper  Address of the keeper\\n     * @param positionAsset  Address of the position asset\\n     * @param positionSize  Size of the position\\n     * @param action  The action that was performed by the keeper\\n     * @param numberOfActions  Number of actions performed by the keeper\\n     * @param gasSpent Gas spent on executing transaction\\n     * @param decreasingCounter An array where each index contains the number of decreasing reasons according to the DecreasingReason enum\\n     * @param routesLength  The length of routes provided as input to the protocol function,\\n     * subject to an additional commission in the ARBITRUM payment model.\\n     */\\n\\n    struct UpdateRewardParams {\\n        address keeper;\\n        address positionAsset;\\n        uint256 positionSize;\\n        KeeperActionType action;\\n        uint256 numberOfActions;\\n        uint256 gasSpent;\\n        uint256[] decreasingCounter;\\n        uint256 routesLength;\\n    }\\n\\n    /**\\n     * @notice Updates reward for keeper for closing position or executing order\\n     * @dev Only callable by the PM_ROLE, LOM_ROLE, BATCH_MANAGER_ROLE roles.\\n     * @param _params The UpdateRewardParams params\\n     */\\n    function updateReward(UpdateRewardParams calldata _params) external;\\n\\n    /**\\n     * @notice Claims earned reward of the keeper\\n     * @param _pmxAmount  Amount of PMX token to claim\\n     * @param _nativeAmount  Amount of native token to claim\\n     */\\n    function claim(uint256 _pmxAmount, uint256 _nativeAmount) external;\\n\\n    /**\\n     * @notice Sets the default maximum gas price allowed.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _defaultMaxGasPrice The new default maximum gas price value.\\n     */\\n    function setDefaultMaxGasPrice(uint256 _defaultMaxGasPrice) external;\\n\\n    /**\\n     * @notice Sets the amount of gas to be removed for the specified reason\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _reason The reason for which an amount is set\\n     * @param _amount Gas amount.\\n     */\\n    function setDecreasingGasByReason(DecreasingReason _reason, uint256 _amount) external;\\n\\n    /**\\n     * @notice Sets the KeeperActionRewardConfig for the specified action type\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _actionType The action type for which the config is set\\n     * @param _config The KeeperActionRewardConfig struct\\n     */\\n\\n    function setMaxGasPerPosition(KeeperActionType _actionType, KeeperActionRewardConfig calldata _config) external;\\n\\n    /**\\n     * @notice Sets the dataLengthRestrictions for the specified KeeperCallingMethod.\\n     * @param _callingMethod The calling method for which dataLengthRestrictions is set\\n     * @param _maxRoutesLength The maximum routes length for which an additional fee will be paid in the ARBITRUM payment model, in bytes\\n     * @param _baseLength The length of the data entering the protocol function including method signature\\n     * and excluding dynamic types(e.g, routesLength), in bytes\\n     */\\n    function setDataLengthRestrictions(\\n        KeeperCallingMethod _callingMethod,\\n        uint256 _maxRoutesLength,\\n        uint256 _baseLength\\n    ) external;\\n\\n    /**\\n     * @notice Sets the tolerance for gas price fluctuations from the oracle price.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _oracleGasPriceTolerance The new oracle gas price tolerance value (percent expressed as WAD).\\n     */\\n    function setOracleGasPriceTolerance(uint256 _oracleGasPriceTolerance) external;\\n\\n    /**\\n     * @notice Sets the PMX token's portion in the reward calculation.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _pmxPartInReward The new PMX token's portion in the reward calculation (percent expressed as WAD).\\n     */\\n    function setPmxPartInReward(uint256 _pmxPartInReward) external;\\n\\n    /**\\n     * @notice Sets the native token's portion in the reward calculation.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _nativePartInReward The new native token's portion in the reward calculation (percent expressed as WAD).\\n     */\\n    function setNativePartInReward(uint256 _nativePartInReward) external;\\n\\n    /**\\n     * @notice Sets the position size coefficients for reward calculations.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _positionSizeCoefficientA The new positionSizeCoefficientA value (in WAD).\\n     * @param _positionSizeCoefficientB The new positionSizeCoefficientB value (in WAD).\\n     */\\n    function setPositionSizeCoefficients(uint256 _positionSizeCoefficientA, int256 _positionSizeCoefficientB) external;\\n\\n    /**\\n     * @notice Sets the additional gas value for reward calculations.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _additionalGas The new additionalGas value.\\n     */\\n    function setAdditionalGas(uint256 _additionalGas) external;\\n}\\n\\ninterface IKeeperRewardDistributorV2 is IKeeperRewardDistributor, IKeeperRewardDistributorStorageV2 {\\n    event MinPositionSizeMultiplierChanged(int256 newMinPositionSizeMultiplier);\\n\\n    /**\\n     * @notice Sets the minPositionSizeMultiplier for reward calculations.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _minPositionSizeMultiplier The new minPositionSizeMultiplier value (in WAD).\\n     */\\n\\n    function setMinPositionSizeMultiplier(int256 _minPositionSizeMultiplier) external;\\n}\\n\",\"keccak256\":\"0x7f423b368b400856023883a2a39d6de927e983af935e5bfd05c96031395550e0\",\"license\":\"BUSL-1.1\"},\"contracts/KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IKeeperRewardDistributorStorage {\\n    enum DecreasingReason {\\n        NonExistentIdForLiquidation,\\n        NonExistentIdForSLOrTP,\\n        IncorrectConditionForLiquidation,\\n        IncorrectConditionForSL,\\n        ClosePostionInTheSameBlock\\n    }\\n\\n    enum KeeperActionType {\\n        OpenByOrder,\\n        StopLoss,\\n        TakeProfit,\\n        Liquidation,\\n        BucketDelisted\\n    }\\n\\n    enum KeeperCallingMethod {\\n        ClosePositionByCondition,\\n        OpenPositionByOrder,\\n        CloseBatchPositions\\n    }\\n\\n    /**\\n     * @dev Structure used in the calculation of keeper rewards in the ARBITRUM payment model\\n     * @param maxRoutesLength The maximum length of routes for which will be paid keeper rewards, depending on KeeperCallingMethod\\n     * @param baseLength The static length of the data entering the protocol function, depending on KeeperCallingMethod\\n     */\\n    struct DataLengthRestrictions {\\n        uint256 maxRoutesLength;\\n        uint256 baseLength;\\n    }\\n\\n    /**\\n     * @dev Structure used in the calculation of maximum gas per position\\n     * @param baseMaxGas1 Base gas amount that used to calculate max gas amount\\n     * @param baseMaxGas2 Base gas amount that used to calculate max gas amount when number of keeper actions > inflectionPoint\\n     * @param multiplier2 The multiplier which is multiplied by the number of keeper actions when number of keeper actions > inflectionPoint\\n     * @param inflectionPoint Number of actions after which the multiplier2 takes effect\\n     */\\n    struct KeeperActionRewardConfig {\\n        uint256 baseMaxGas1;\\n        uint256 baseMaxGas2;\\n        uint256 multiplier1;\\n        uint256 multiplier2;\\n        uint256 inflectionPoint;\\n    }\\n\\n    struct KeeperBalance {\\n        uint256 pmxBalance;\\n        uint256 nativeBalance;\\n    }\\n    enum PaymentModel {\\n        DEFAULT,\\n        ARBITRUM\\n    }\\n\\n    function priceOracle() external view returns (address);\\n\\n    function registry() external view returns (address);\\n\\n    function pmx() external view returns (address);\\n\\n    function treasury() external view returns (address payable);\\n\\n    function pmxPartInReward() external view returns (uint256);\\n\\n    function nativePartInReward() external view returns (uint256);\\n\\n    function positionSizeCoefficientA() external view returns (uint256);\\n\\n    function positionSizeCoefficientB() external view returns (int256);\\n\\n    function additionalGas() external view returns (uint256);\\n\\n    function defaultMaxGasPrice() external view returns (uint256);\\n\\n    function oracleGasPriceTolerance() external view returns (uint256);\\n\\n    function paymentModel() external view returns (PaymentModel);\\n\\n    function keeperBalance(address) external view returns (uint256, uint256);\\n\\n    function maxGasPerPosition(KeeperActionType) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    function dataLengthRestrictions(KeeperCallingMethod) external view returns (uint256, uint256);\\n\\n    function decreasingGasByReason(DecreasingReason) external view returns (uint256);\\n\\n    function totalBalance() external view returns (uint256, uint256);\\n}\\n\\ninterface IKeeperRewardDistributorStorageV2 is IKeeperRewardDistributorStorage {\\n    function minPositionSizeMultiplier() external view returns (int256);\\n}\\n\",\"keccak256\":\"0xcdb1217375138dbfa37b55c551bbb374c10af7fa39e91113a55921bcb153b4ce\",\"license\":\"BUSL-1.1\"},\"contracts/LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IWhiteBlackList} from \\\"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\\\";\\nimport {ILiquidityMiningRewardDistributorStorage} from \\\"./ILiquidityMiningRewardDistributorStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ILiquidityMiningRewardDistributor is ILiquidityMiningRewardDistributorStorage, IPausable {\\n    struct RewardsInPMX {\\n        uint256 minReward;\\n        uint256 maxReward;\\n        uint256 extraReward;\\n    }\\n\\n    /**\\n     * @notice Emitted when a reward is claimed by a receiver from a specific bucket.\\n     * @param receiver The address of the receiver.\\n     * @param bucket The address of the bucket from which the reward is claimed.\\n     * @param amount The amount of the claimed reward.\\n     */\\n    event ClaimedReward(address indexed receiver, address indexed bucket, uint256 amount);\\n    /**\\n     * @notice Emitted when PMX tokens are withdrawn by an admin.\\n     * @param amount The amount of PMX tokens withdrawn.\\n     */\\n    event WithdrawPmxByAdmin(uint256 indexed amount);\\n\\n    /**\\n     * @notice Initializes the contract with the specified parameters.\\n     * @param _primexDNS The address of the IPrimexDNS contract.\\n     * @param _pmx The address of the PMX token contract.\\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\\n     * @param _registry The address of the registry contract.\\n     * @param _treasury The address of the treasury contract.\\n     * @param _reinvestmentRate The rate at which rewards are reinvested.\\n     * @param _reinvestmentDuration The duration for which rewards are reinvested.\\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\\n     */\\n    function initialize(\\n        IPrimexDNS _primexDNS,\\n        IERC20 _pmx,\\n        ITraderBalanceVault _traderBalanceVault,\\n        address _registry,\\n        address _treasury,\\n        uint256 _reinvestmentRate,\\n        uint256 _reinvestmentDuration,\\n        IWhiteBlackList _whiteBlackList\\n    ) external;\\n\\n    /**\\n     * @notice Updates the reward amount for a specific bucket.\\n     * @dev Only callable by the PrimexDNS contract.\\n     * @param _bucketName The name of the bucket.\\n     * @param _pmxRewardsAmount The amount of PMX rewards to be allocated to the bucket.\\n     */\\n    function updateBucketReward(string memory _bucketName, uint256 _pmxRewardsAmount) external;\\n\\n    /**\\n     * @notice Adds points for a user for future reward distribution.\\n     * @dev Only callable by the Bucket contract.\\n     * @param _bucketName The name of the bucket.\\n     * @param _user The address of the user.\\n     * @param _miningAmount The amount of mining points to be added.\\n     * @param _maxStabilizationPeriodEnd The maximum end timestamp of the stabilization period.\\n     * @param _maxPeriodTime The maximum period time.\\n     * @param _currentTimestamp The current timestamp.\\n     */\\n    function addPoints(\\n        string memory _bucketName,\\n        address _user,\\n        uint256 _miningAmount,\\n        uint256 _maxStabilizationPeriodEnd,\\n        uint256 _maxPeriodTime,\\n        uint256 _currentTimestamp\\n    ) external;\\n\\n    /**\\n     * @notice Removes points for a user.\\n     * @dev Only callable by the Bucket contract.\\n     * @param _name The name of the bucket.\\n     * @param _user The address of the user.\\n     * @param _amount The amount of mining points to be removed.\\n     */\\n    function removePoints(string memory _name, address _user, uint256 _amount) external;\\n\\n    /**\\n     * @notice Claims the accumulated rewards for a specific bucket.\\n     * @param _bucketName The name of the bucket.\\n     */\\n    function claimReward(string memory _bucketName) external;\\n\\n    /**\\n     * @notice Moves rewards from one bucket to another.\\n     * @dev Only callable by the Bucket contract.\\n     * @param _bucketFrom The name of the source bucket.\\n     * @param _bucketTo The name of the destination bucket.\\n     * @param _user The address of the user.\\n     * @param _isBucketLaunched A flag indicating if the destination bucket is launched.\\n     * @param _liquidityMiningDeadline The deadline for liquidity mining\\n     */\\n    function reinvest(\\n        string memory _bucketFrom,\\n        string memory _bucketTo,\\n        address _user,\\n        bool _isBucketLaunched,\\n        uint256 _liquidityMiningDeadline\\n    ) external;\\n\\n    /**\\n     * @dev The function to withdraw PMX from a delisted bucket or a bucket where liquidity mining failed (after reinvesting period).\\n     * Emits WithdrawPmxByAdmin event.\\n     * @param _bucketFrom Name of the bucket with failed liquidity mining event.\\n     */\\n    function withdrawPmxByAdmin(string memory _bucketFrom) external;\\n\\n    /**\\n     * @notice Retrieves information about a lender in a specific bucket.\\n     * @param _bucketName The name of the bucket.\\n     * @param _lender The address of the lender.\\n     * @param _timestamp The timestamp for which the information is queried.\\n     * @return amountInMining The amount of tokens the lender has in mining for the given bucket.\\n     * @return currentPercent The current percentage of rewards the lender is eligible to receive for the given bucket.\\n     * Measured in WAD (1 WAD = 100%).\\n     * @return rewardsInPMX An object containing information about the lender's rewards in PMX for the given bucket.\\n     */\\n    function getLenderInfo(\\n        string calldata _bucketName,\\n        address _lender,\\n        uint256 _timestamp\\n    ) external view returns (uint256 amountInMining, uint256 currentPercent, RewardsInPMX memory rewardsInPMX);\\n\\n    /**\\n     * @notice Retrieves rewards information about a specific bucket.\\n     * @param _bucketName The name of the bucket.\\n     * @return totalPmxReward The total amount of PMX reward in the bucket.\\n     * @return withdrawnRewards The total amount of withdrawn rewards from the bucket.\\n     * @return totalPoints The total number of mining points in the bucket.\\n     */\\n    function getBucketInfo(\\n        string calldata _bucketName\\n    ) external view returns (uint256 totalPmxReward, uint256 withdrawnRewards, uint256 totalPoints);\\n\\n    /**\\n     * @notice Retrieves the amount of tokens a lender has in mining for a specific bucket.\\n     * @param _bucket The name of the bucket.\\n     * @param _lender The address of the lender.\\n     * @return The amount of tokens the lender has in mining for the given bucket.\\n     */\\n    function getLenderAmountInMining(string calldata _bucket, address _lender) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xc7af5cea0bdc1399a660a5d861d17af7933cd5665e2016239bc3656f262b40d4\",\"license\":\"BUSL-1.1\"},\"contracts/LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributorStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\n\\ninterface ILiquidityMiningRewardDistributorStorage {\\n    struct LenderInfo {\\n        uint256 points;\\n        uint256 depositedAmount;\\n    }\\n\\n    struct BucketInfo {\\n        uint256 totalPoints;\\n        uint256 totalPmxReward;\\n        uint256 withdrawnRewards;\\n        mapping(address => LenderInfo) lendersInfo;\\n    }\\n\\n    function primexDNS() external view returns (IPrimexDNS);\\n\\n    function pmx() external view returns (IERC20);\\n\\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\\n\\n    function registry() external view returns (address);\\n\\n    function reinvestmentRate() external view returns (uint256);\\n\\n    function reinvestmentDuration() external view returns (uint256);\\n\\n    function extraRewards(address, string calldata) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x57beb8b607e842d2c04494b6cd351101acde829388c9b2c68b7ac0c4a37bdc0d\",\"license\":\"BUSL-1.1\"},\"contracts/PToken/IPToken.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\n\\nimport {IPTokenStorage, IBucket, IFeeExecutor, IERC20MetadataUpgradeable, IActivityRewardDistributor} from \\\"./IPTokenStorage.sol\\\";\\n\\ninterface IPToken is IPTokenStorage {\\n    /**\\n     * @dev Emitted after the mint action\\n     * @param from The address performing the mint\\n     * @param value The amount being\\n     */\\n    event Mint(address indexed from, uint256 value);\\n\\n    /**\\n     * @dev Emitted after pTokens are burned\\n     * @param from The owner of the aTokens, getting them burned\\n     * @param value The amount being burned\\n     */\\n    event Burn(address indexed from, uint256 value);\\n\\n    /**\\n     * @dev Emitted during the transfer action\\n     * @param from The user whose tokens are being transferred\\n     * @param to The recipient\\n     * @param amount The amount being transferred\\n     * @param index The new liquidity index of the reserve\\n     */\\n    event BalanceTransfer(address indexed from, address indexed to, uint256 amount, uint256 index);\\n\\n    event LockDeposit(address indexed user, uint256 indexed id, uint256 deadline, uint256 amount);\\n    event UnlockDeposit(address indexed user, uint256 indexed id);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param _name The name of the ERC20 token.\\n     * @param _symbol The symbol of the ERC20 token.\\n     * @param _decimals The number of decimals for the ERC20 token.\\n     * @param _bucketsFactory Address of the buckets factory that will call the setBucket fucntion\\n     */\\n    function initialize(string memory _name, string memory _symbol, uint8 _decimals, address _bucketsFactory) external;\\n\\n    /**\\n     * @dev Sets the bucket for the contract.\\n     * @param _bucket The address of the bucket to set.\\n     */\\n    function setBucket(IBucket _bucket) external;\\n\\n    /**\\n     * @dev Sets the InterestIncreaser for current PToken.\\n     * @param _interestIncreaser The interest increaser address.\\n     */\\n    function setInterestIncreaser(IFeeExecutor _interestIncreaser) external;\\n\\n    /**\\n     * @dev Sets the lender reward distributor contract address.\\n     * @param _lenderRewardDistributor The address of the lender reward distributor contract.\\n     */\\n    function setLenderRewardDistributor(IActivityRewardDistributor _lenderRewardDistributor) external;\\n\\n    /**\\n     * @notice Locks a deposit for a specified user.\\n     * @param _user The address of the user for whom the deposit is being locked.\\n     * @param _amount The amount to be locked as a deposit.\\n     * @param _duration The duration for which the deposit will be locked.\\n     * @dev This function can only be called externally and overrides the corresponding function in the parent contract.\\n     * @dev The user must not be blacklisted.\\n     */\\n    function lockDeposit(address _user, uint256 _amount, uint256 _duration) external;\\n\\n    /**\\n     * @dev Unlocks a specific deposit.\\n     * @param _depositId The ID of the deposit to be unlocked.\\n     */\\n    function unlockDeposit(uint256 _depositId) external;\\n\\n    /**\\n     * @dev Mints `amount` pTokens to `user`\\n     * @param _user The address receiving the minted tokens\\n     * @param _amount The amount of tokens getting minted\\n     * @param _index The current liquidityIndex\\n     * @return Minted amount of PTokens\\n     */\\n    function mint(address _user, uint256 _amount, uint256 _index) external returns (uint256);\\n\\n    /**\\n     * @dev Mints pTokens to the reserve address\\n     * Compared to the normal mint, we don't revert when the amountScaled is equal to the zero. Additional checks were also removed\\n     * Only callable by the Bucket\\n     * @param _reserve The address of the reserve\\n     * @param _amount The amount of tokens getting minted\\n     * @param _index The current liquidityIndex\\n     */\\n    function mintToReserve(address _reserve, uint256 _amount, uint256 _index) external;\\n\\n    /**\\n     * @dev Burns pTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n     * @param _user The owner of the pTokens, getting them burned\\n     * @param _amount The amount of underlying token being returned to receiver\\n     * @param _index The current liquidityIndex\\n     * @return Burned amount of PTokens\\n     */\\n    function burn(address _user, uint256 _amount, uint256 _index) external returns (uint256);\\n\\n    /**\\n     * @dev Returns the scaled balance of the user.\\n     * @param _user The owner of pToken\\n     * @return The scaled balances of the user\\n     */\\n    function scaledBalanceOf(address _user) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns available balance of the user.\\n     * @param _user The owner of pToken\\n     * @return The available balance of the user\\n     */\\n    function availableBalanceOf(address _user) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns locked deposits and balance of user\\n     * @param _user The owner of locked deposits\\n     * @return Structure with deposits and total locked balance of user\\n     */\\n    function getUserLockedBalance(address _user) external view returns (LockedBalance memory);\\n\\n    /**\\n     * @dev Returns the scaled total supply of pToken.\\n     * @return The scaled total supply of the pToken.\\n     */\\n    function scaledTotalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Function to get a deposit index in user's deposit array.\\n     * @param id Deposit id.\\n     * @return index Deposit index in user's 'deposit' array.\\n     */\\n    function getDepositIndexById(uint256 id) external returns (uint256 index);\\n}\\n\",\"keccak256\":\"0x2dc39fe1abee0110b63e93b78a647bfb11e00bed853dd4008efe9847d1028b1f\",\"license\":\"BUSL-1.1\"},\"contracts/PToken/IPTokenStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\nimport {IBucket} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IFeeExecutor} from \\\"../BonusExecutor/IFeeExecutor.sol\\\";\\nimport {IActivityRewardDistributor} from \\\"../ActivityRewardDistributor/IActivityRewardDistributor.sol\\\";\\n\\ninterface IPTokenStorage is IERC20MetadataUpgradeable {\\n    struct Deposit {\\n        uint256 lockedBalance;\\n        uint256 deadline;\\n        uint256 id;\\n    }\\n\\n    struct LockedBalance {\\n        uint256 totalLockedBalance;\\n        Deposit[] deposits;\\n    }\\n\\n    function bucket() external view returns (IBucket);\\n\\n    function interestIncreaser() external view returns (IFeeExecutor);\\n\\n    function lenderRewardDistributor() external view returns (IActivityRewardDistributor);\\n}\\n\",\"keccak256\":\"0x7be5f1ceda782aa7ce44588cf3b1f16af3e48d1fda0368f3dc801e84a67e0097\",\"license\":\"BUSL-1.1\"},\"contracts/PositionManager/IPositionManager.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\n\\nimport {IPositionManagerStorage} from \\\"./IPositionManagerStorage.sol\\\";\\nimport {IKeeperRewardDistributor} from \\\"../KeeperRewardDistributor/IKeeperRewardDistributor.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface IPositionManager is IPositionManagerStorage, IPausable {\\n    struct ClosePositionVars {\\n        PositionLibrary.Position position;\\n        bool borrowedAmountIsNotZero;\\n        uint256 oracleTolerableLimit;\\n        bool needOracleTolerableLimitCheck;\\n    }\\n\\n    event SetMaxPositionSize(address token0, address token1, uint256 amountInToken0, uint256 amountInToken1);\\n    event SetDefaultOracleTolerableLimit(uint256 indexed oracleTolerableLimit);\\n    event SecurityBufferChanged(uint256 indexed securityBuffer);\\n    event MaintenanceBufferChanged(uint256 indexed maintenanceBuffer);\\n    event SetOracleTolerableLimit(address indexed assetA, address indexed assetB, uint256 oracleTolerableLimit);\\n    event KeeperRewardDistributorChanged(address indexed _keeperRewardDistributor);\\n    event MinPositionSizeAndAssetChanged(uint256 indexed _minPositionSize, address indexed _minPositionAsset);\\n    event OracleTolerableLimitMultiplierChanged(uint256 indexed newMultiplier);\\n\\n    event OpenPosition(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        address indexed openedBy,\\n        PositionLibrary.Position position,\\n        address feeToken,\\n        uint256 protocolFee,\\n        uint256 entryPrice,\\n        uint256 leverage,\\n        LimitOrderLibrary.Condition[] closeConditions\\n    );\\n\\n    event PartialClosePosition(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        address bucketAddress,\\n        address soldAsset,\\n        address positionAsset,\\n        uint256 decreasePositionAmount,\\n        uint256 depositedAmount,\\n        uint256 scaledDebtAmount,\\n        int256 profit,\\n        uint256 positionDebt,\\n        uint256 amountOut\\n    );\\n\\n    event IncreaseDeposit(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        uint256 depositDelta,\\n        uint256 scaledDebtAmount\\n    );\\n\\n    event DecreaseDeposit(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        uint256 depositDelta,\\n        uint256 scaledDebtAmount\\n    );\\n\\n    event UpdatePositionConditions(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        LimitOrderLibrary.Condition[] closeConditions\\n    );\\n\\n    /**\\n     * @notice Initializes the contract with the specified addresses and initializes inherited contracts.\\n     * @param _registry The address of the Registry contract.\\n     * @param _primexDNS The address of the PrimexDNS contract.\\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\\n     * @param _priceOracle The address of the PriceOracle contract.\\n     * @param _keeperRewardDistributor The address of the KeeperRewardDistributor contract.\\n     * @param _whiteBlackList The address of the WhiteBlacklist contract.\\n     */\\n    function initialize(\\n        address _registry,\\n        address _primexDNS,\\n        address payable _traderBalanceVault,\\n        address _priceOracle,\\n        address _keeperRewardDistributor,\\n        address _whiteBlackList\\n    ) external;\\n\\n    /**\\n     * @notice Sets the maximum position size for a pair of tokens.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _token0 The address of the first token in the pair.\\n     * @param _token1 The address of the second token in the pair.\\n     * @param _amountInToken0 The maximum amount of token0 allowed in the position.\\n     * @param _amountInToken1 The maximum amount of token1 allowed in the position.\\n     */\\n    function setMaxPositionSize(\\n        address _token0,\\n        address _token1,\\n        uint256 _amountInToken0,\\n        uint256 _amountInToken1\\n    ) external;\\n\\n    /**\\n     * @notice Sets the default oracle tolerable limit for the protocol.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _percent The new value for the default oracle tolerable limit. Measured in WAD (1 WAD = 100%).\\n     */\\n    function setDefaultOracleTolerableLimit(uint256 _percent) external;\\n\\n    /**\\n     * @notice Sets the oracle tolerable limit between two assets.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _assetA The address of the first asset.\\n     * @param _assetB The address of the second asset.\\n     * @param _percent The new value for the oracle tolerable limit between two assets. Measured in WAD (1 WAD = 100%).\\n     */\\n    function setOracleTolerableLimit(address _assetA, address _assetB, uint256 _percent) external;\\n\\n    /**\\n     * @notice Function to set oracleTolerableLimitMultiplier.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param newMultiplier New multiplier in WAD format.\\n     */\\n    function setOracleTolerableLimitMultiplier(uint256 newMultiplier) external;\\n\\n    /**\\n     * @notice Sets the security buffer value.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * 0 <= newSecurityBuffer < 1.\\n     * Buffer security parameter is used in calculating the liquidation conditions\\n     * https://docs.google.com/document/d/1kR8eaqV4289MAbLKgIfKsZ2NgjFpeC0vpVL7jVUTvho/edit#bookmark=id.i9v508hvrv42\\n     * @param newSecurityBuffer The new value of the security buffer in WAD format.\\n     */\\n    function setSecurityBuffer(uint256 newSecurityBuffer) external;\\n\\n    /**\\n     * @notice Sets the maintenance buffer value.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * The new maintenance buffer value should be greater than zero and less than one.\\n     * Maintenance buffer is used in calculating the maximum leverage\\n     * https://docs.google.com/document/d/1kR8eaqV4289MAbLKgIfKsZ2NgjFpeC0vpVL7jVUTvho/edit#bookmark=id.87oc1j1s9z21\\n     * @param newMaintenanceBuffer The new value of the maintenance buffer in WAD format.\\n     */\\n    function setMaintenanceBuffer(uint256 newMaintenanceBuffer) external;\\n\\n    /**\\n     * @notice Sets the address of the SpotTradingRewardDistributor contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _spotTradingRewardDistributor The address of the SpotTradingRewardDistributor contract.\\n     */\\n    function setSpotTradingRewardDistributor(address _spotTradingRewardDistributor) external;\\n\\n    /**\\n     * @notice Sets the KeeperRewardDistributor contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _keeperRewardDistributor The address of the KeeperRewardDistributor contract.\\n     */\\n    function setKeeperRewardDistributor(IKeeperRewardDistributor _keeperRewardDistributor) external;\\n\\n    /**\\n     * @notice Opens a position based on the provided order parameters.\\n     * @dev Only callable by the LOM_ROLE role.\\n     * @param _params The parameters for opening a position.\\n     * @return The total borrowed amount, position amount, position ID, and entry price of the new position.\\n     */\\n    function openPositionByOrder(\\n        LimitOrderLibrary.OpenPositionByOrderParams calldata _params\\n    ) external returns (uint256, uint256, uint256, uint256);\\n\\n    /**\\n     * @notice Opens margin position.\\n     * @dev Locks trader's collateral in TraderBalanceVault. Takes loan from bucket for deal.\\n     * Makes swap bucket borrowedAsset amount on '_dex'. Updates rates and indexes in the '_bucket'.\\n     * Mints debtToken for trader (msg.sender)\\n     * @param _params The parameters required to open a position.\\n     */\\n    function openPosition(PositionLibrary.OpenPositionParams calldata _params) external payable;\\n\\n    /**\\n     * @notice Close trader's active position or liquidate risky position.\\n     * @dev Protocol will fall down (revert) if two conditions occur both:\\n     * 1. (token1Price + position.depositedAmount).wdiv(positionDebt) will become lower than 1,\\n     * so position will make loss for Protocol.\\n     * 2. Not enough liquidity in bucket to pay that loss.\\n     * @param _id Position id for `msg.sender`.\\n     * @param _dealReceiver The receiver of the rest of trader's deposit.\\n     * @param _routes swap routes on dexes\\n     * @param _amountOutMin minimum allowed amount out for position\\n     */\\n    function closePosition(\\n        uint256 _id,\\n        address _dealReceiver,\\n        PrimexPricingLibrary.Route[] memory _routes,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /**\\n     * @notice Closes trader's active position by closing condition\\n     * @param _id Position id.\\n     * @param _keeper The address of the keeper or the recipient of the reward.\\n     * @param _routes An array of routes for executing trades, swap routes on dexes.\\n     * @param _conditionIndex The index of the condition to be used for closing the position.\\n     * @param _ccmAdditionalParams Additional params needed for canBeClosed() of the ConditionalClosingManager.\\n     * @param _closeReason The reason for closing the position.\\n     */\\n    function closePositionByCondition(\\n        uint256 _id,\\n        address _keeper,\\n        PrimexPricingLibrary.Route[] calldata _routes,\\n        uint256 _conditionIndex,\\n        bytes calldata _ccmAdditionalParams,\\n        PositionLibrary.CloseReason _closeReason\\n    ) external;\\n\\n    /**\\n     * @notice Allows the trader to partially close a position.\\n     * @param _positionId The ID of the position to be partially closed.\\n     * @param _amount The amount of the position asset to be closed from the position.\\n     * @param _depositReceiver The address where the remaining deposit will be sent.\\n     * @param _routes The routing information for swapping assets.\\n     * @param _amountOutMin The minimum amount to be received after swapping, measured in the same decimal format as the position's asset.\\n     */\\n    function partiallyClosePosition(\\n        uint256 _positionId,\\n        uint256 _amount,\\n        address _depositReceiver,\\n        PrimexPricingLibrary.Route[] calldata _routes,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /**\\n     * @notice Updates the position with the given position ID by setting new close conditions.\\n     * @param _positionId The ID of the position to update.\\n     * @param _closeConditions An array of close conditions for the position.\\n     * @dev The caller of this function must be the trader who owns the position.\\n     * @dev Emits an `UpdatePositionConditions` event upon successful update.\\n     */\\n    function updatePositionConditions(\\n        uint256 _positionId,\\n        LimitOrderLibrary.Condition[] calldata _closeConditions\\n    ) external;\\n\\n    /**\\n     * @notice Increases the deposit amount for a given position.\\n     * @param _positionId The ID of the position to increase the deposit for.\\n     * @param _amount The amount to increase the deposit by.\\n     * @param _asset The address of the asset to deposit.\\n     * @param _takeDepositFromWallet A flag indicating whether to make the deposit immediately.\\n     * @param _routes An array of routes to use for trading.\\n     * @param _amountOutMin The minimum amount of the output asset to receive from trading.\\n     */\\n    function increaseDeposit(\\n        uint256 _positionId,\\n        uint256 _amount,\\n        address _asset,\\n        bool _takeDepositFromWallet,\\n        PrimexPricingLibrary.Route[] calldata _routes,\\n        uint256 _amountOutMin\\n    ) external;\\n\\n    /**\\n     * @notice Decreases the deposit amount for a given position.\\n     * @param _positionId The ID of the position.\\n     * @param _amount The amount to decrease the deposit by.\\n     */\\n    function decreaseDeposit(uint256 _positionId, uint256 _amount) external;\\n\\n    /**\\n     * @notice Sets the minimum position size and the corresponding asset for positions.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _minPositionSize The new minimum position size.\\n     * @param _minPositionAsset The address of the asset associated with the minimum position size.\\n     */\\n    function setMinPositionSize(uint256 _minPositionSize, address _minPositionAsset) external;\\n\\n    /**\\n     * @notice Checks if a position can be closed based on a specific condition.\\n     * @param _positionId The ID of the position.\\n     * @param _conditionIndex The index of the condition within the position's close conditions.\\n     * @param _additionalParams Additional parameters required for the condition check.\\n     * @return A boolean indicating whether the position can be closed.\\n     */\\n    function canBeClosed(\\n        uint256 _positionId,\\n        uint256 _conditionIndex,\\n        bytes calldata _additionalParams\\n    ) external returns (bool);\\n\\n    /**\\n     * @notice Deletes a positions by their IDs from a specific bucket for a given traders.\\n     * @param _ids The IDs of the positions to be deleted.\\n     * @param _traders The addresses of the traders who owns the position.\\n     * @param _length The length of the traders array.\\n     * @param _bucket The address of the bucket from which the position is to be deleted.\\n     */\\n    function deletePositions(\\n        uint256[] calldata _ids,\\n        address[] calldata _traders,\\n        uint256 _length,\\n        address _bucket\\n    ) external;\\n\\n    /**\\n     * @notice Transfers a specified amount of tokens from the contract to a specified address.\\n     * @dev Only callable by the BATCH_MANAGER_ROLE role.\\n     * @param _token The address of the token to be transferred.\\n     * @param _to The address to which the tokens will be transferred.\\n     * @param _amount The amount of tokens to be transferred.\\n     */\\n    function doTransferOut(address _token, address _to, uint256 _amount) external;\\n\\n    /**\\n     * @notice Returns the oracle tolerable limit for the given asset pair.\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @return The oracle tolerable limit in WAD format (1 WAD = 100%) for the asset pair.\\n     */\\n    function getOracleTolerableLimit(address assetA, address assetB) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the position information for a given ID.\\n     * @param _id The ID of the position to retrieve.\\n     * @return position The position information associated with the given ID.\\n     */\\n    function getPosition(uint256 _id) external view returns (PositionLibrary.Position memory);\\n\\n    /**\\n     * @notice Retrieves the position at the specified index.\\n     * @param _index The index of the position to retrieve.\\n     * @return The Position struct at the specified index.\\n     */\\n    function getPositionByIndex(uint256 _index) external view returns (PositionLibrary.Position memory);\\n\\n    /**\\n     * @notice Returns the length of the positions array.\\n     * @return The length of the positions array.\\n     */\\n    function getAllPositionsLength() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the length of the array containing the positions of a specific trader.\\n     * @param _trader The address of the trader.\\n     * @return The number of positions the trader has.\\n     */\\n    function getTraderPositionsLength(address _trader) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the length of the array containing the positions of a specific bucket.\\n     * @param _bucket The address of the bucket.\\n     * @return The number of positions the bucket has.\\n     */\\n    function getBucketPositionsLength(address _bucket) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the debt of a position with the given ID.\\n     * @param _id The ID of the position.\\n     * @return The debt of the position, measured in the same decimal format as debtTokens.\\n     */\\n    function getPositionDebt(uint256 _id) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the close conditions for a specific position.\\n     * @param _positionId The ID of the position.\\n     * @return An array of close conditions associated with the position.\\n     */\\n    function getCloseConditions(uint256 _positionId) external view returns (LimitOrderLibrary.Condition[] memory);\\n\\n    /**\\n     * @notice Retrieves the close condition for a given position and index.\\n     * @param _positionId The identifier of the position.\\n     * @param _index The index of the close condition.\\n     * @return The close condition at the specified position and index.\\n     */\\n    function getCloseCondition(\\n        uint256 _positionId,\\n        uint256 _index\\n    ) external view returns (LimitOrderLibrary.Condition memory);\\n\\n    /**\\n     * @notice \\u0421hecks if the position is risky.\\n     * @param _id the id of the position\\n     * @return (1) True if position is risky\\n     */\\n    function isPositionRisky(uint256 _id) external view returns (bool);\\n\\n    /**\\n     * @notice Checks if a position with the given ID is delisted.\\n     * @param _id The ID of the position.\\n     * @return A boolean indicating whether the position is delisted or not.\\n     */\\n    function isDelistedPosition(uint256 _id) external view returns (bool);\\n\\n    /**\\n     * @notice Retrieves the health value of a position.\\n     * @param _id The ID of the position.\\n     * @return The health value of the position in WAD format.\\n     */\\n    function healthPosition(uint256 _id) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x980be3b8ebfcd45983fa826a4875e9d5762bed30c3f067d6839c76b0f19c78a1\",\"license\":\"BUSL-1.1\"},\"contracts/PositionManager/IPositionManagerStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\n\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IBucket} from \\\"../Bucket/IBucket.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IKeeperRewardDistributor} from \\\"../KeeperRewardDistributor/IKeeperRewardDistributor.sol\\\";\\nimport {ISpotTradingRewardDistributor} from \\\"../SpotTradingRewardDistributor/ISpotTradingRewardDistributor.sol\\\";\\n\\ninterface IPositionManagerStorage {\\n    function maxPositionSize(address, address) external returns (uint256);\\n\\n    function defaultOracleTolerableLimit() external returns (uint256);\\n\\n    function securityBuffer() external view returns (uint256);\\n\\n    function maintenanceBuffer() external view returns (uint256);\\n\\n    function positionsId() external view returns (uint256);\\n\\n    function traderPositionIds(address _trader, uint256 _index) external view returns (uint256);\\n\\n    function bucketPositionIds(address _bucket, uint256 _index) external view returns (uint256);\\n\\n    function registry() external view returns (IAccessControl);\\n\\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\\n\\n    function primexDNS() external view returns (IPrimexDNS);\\n\\n    function priceOracle() external view returns (IPriceOracle);\\n\\n    function keeperRewardDistributor() external view returns (IKeeperRewardDistributor);\\n\\n    function spotTradingRewardDistributor() external view returns (ISpotTradingRewardDistributor);\\n\\n    function minPositionSize() external view returns (uint256);\\n\\n    function minPositionAsset() external view returns (address);\\n}\\n\",\"keccak256\":\"0x7527f93ae59e40d28aeffed2a17eda5cef1d5caf8cc2c3efcd7ae6388e776f42\",\"license\":\"BUSL-1.1\"},\"contracts/PriceOracle/IPriceOracle.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IPriceOracleStorage} from \\\"./IPriceOracleStorage.sol\\\";\\n\\ninterface IPriceOracle is IPriceOracleStorage {\\n    event PairPriceDropChanged(address indexed assetA, address indexed assetB, uint256 pairPriceDrop);\\n    event PriceFeedUpdated(address indexed assetA, address indexed assetB, address indexed priceFeed);\\n    event PriceDropFeedUpdated(address indexed assetA, address indexed assetB, address indexed priceDropFeed);\\n    event GasPriceFeedChanged(address priceFeed);\\n\\n    /**\\n     * @param _registry The address of PrimexRegistry contract\\n     * @param _eth Weth address if eth isn't native token of network. Otherwise set to zero address.\\n     */\\n    function initialize(address _registry, address _eth) external;\\n\\n    /**\\n     * @notice Function to set (change) the pair priceDrop of the trading assets\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN.\\n     * @param _assetA The address of position asset\\n     * @param _assetB The address of borrowed asset\\n     * @param _pairPriceDrop The pair priceDrop (in wad)\\n     */\\n    function setPairPriceDrop(address _assetA, address _assetB, uint256 _pairPriceDrop) external;\\n\\n    /**\\n     * @notice Increases the priceDrop of a pair of assets in the system.\\n     * @dev Only callable by the EMERGENCY_ADMIN role.\\n     * The _pairPriceDrop value must be greater than the current priceDrop value for the pair\\n     * and less than the maximum allowed priceDrop (WadRayMath.WAD / 2).\\n     * @param _assetA The address of position asset\\n     * @param _assetB The address of borrowed asset\\n     * @param _pairPriceDrop The new priceDrop value for the pair (in wad)\\n     */\\n    function increasePairPriceDrop(address _assetA, address _assetB, uint256 _pairPriceDrop) external;\\n\\n    /**\\n     * @notice Add or update price feed for assets pair. For only the admin role.\\n     * @param assetA The first currency within the currency pair quotation (the base currency).\\n     * @param assetB The second currency within the currency pair quotation (the quote currency).\\n     * @param priceFeed The chain link price feed address for the pair assetA/assetB\\n     */\\n    function updatePriceFeed(address assetA, address assetB, address priceFeed) external;\\n\\n    /**\\n     * @notice Sets the gas price feed contract address.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param priceFeed The address of the gas price feed contract.\\n     */\\n    function setGasPriceFeed(address priceFeed) external;\\n\\n    /**\\n     * @notice Updates the priceDrop feed for a specific pair of assets.\\n     * @dev Add or update priceDrop feed for assets pair.\\n     * Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @param priceDropFeed The chain link priceDrop feed address for the pair assetA/assetB\\n     */\\n    function updatePriceDropFeed(address assetA, address assetB, address priceDropFeed) external;\\n\\n    /**\\n     * @notice Requests two priceFeeds - assetA/ETH and assetB/ETH (or assetA/USD and assetB/USD).\\n     * @dev If there is no price feed found, the code will return a message that no price feed found.\\n     * @param baseAsset The first currency within the currency pair quotation (the base currency).\\n     * @param quoteAsset The second currency within the currency pair quotation (the quote currency).\\n     * @return A tuple of basePriceFeed and quotePriceFeed. The addresses of the price feed for the base asset and quote asset respectively.\\n     */\\n    function getPriceFeedsPair(address baseAsset, address quoteAsset) external view returns (address, address);\\n\\n    /**\\n     * @notice Requests priceFeed for the actual exchange rate for an assetA/assetB pair.\\n     * @dev If no price feed for the pair found, USD and ETH are used as intermediate tokens.\\n     * A price for assetA/assetB can be derived if two data feeds exist:\\n     * assetA/ETH and assetB/ETH (or assetA/USD and assetB/USD).\\n     * If there is no price feed found, the code will return a message that no price feed found.\\n     * @param assetA The first currency within the currency pair quotation (the base currency).\\n     * @param assetB The second currency within the currency pair quotation (the quote currency).\\n     * @return exchangeRate for assetA/assetB in 10**18 decimality which will be recalucaled in PrimexPricingLibrary.\\n     * @return direction of a pair as it stored in chainLinkPriceFeeds (i.e. returns 'true' for assetA/assetB, and 'false' for assetB/assetA).\\n     * Throws if priceFeed wasn't found or priceFeed hasn't answer is 0.\\n     */\\n    function getExchangeRate(address assetA, address assetB) external view returns (uint256, bool);\\n\\n    /**\\n     * @notice Retrieves the direct price feed for the given asset pair.\\n     * @param assetA The address of the first asset.\\n     * @param assetB The address of the second asset.\\n     * @return priceFeed The address of the direct price feed.\\n     */\\n    function getDirectPriceFeed(address assetA, address assetB) external view returns (address);\\n\\n    /**\\n     * @notice Retrieves the current gas price from the specified gas price feed.\\n     * @return The current gas price.\\n     */\\n    function getGasPrice() external view returns (int256);\\n\\n    /**\\n     * @notice For a given asset pair retrieves the priceDrop rate which is the higher\\n     * of the oracle pair priceDrop and the historical pair priceDrop.\\n     * @param _assetA The address of asset A.\\n     * @param _assetB The address of asset B.\\n     * @return The priceDrop rate.\\n     */\\n    function getPairPriceDrop(address _assetA, address _assetB) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the priceDrop rate between two assets based on the oracle pair priceDrop.\\n     * @param assetA The address of the first asset.\\n     * @param assetB The address of the second asset.\\n     * @return The priceDrop rate as a uint256 value.\\n     */\\n    function getOraclePriceDrop(address assetA, address assetB) external view returns (uint256);\\n\\n    /**\\n     * @notice Retreives a priceDrop feed address from the oraclePriceDropFeeds mapping\\n     * @param assetA The address of the first asset in the pair.\\n     * @param assetB The address of the second asset in the pair.\\n     * @return priceDropFeed The address of the priceDrop feed associated with the asset pair.\\n     */\\n    function getOraclePriceDropFeed(address assetA, address assetB) external view returns (address);\\n}\\n\",\"keccak256\":\"0xfbf719814c5ec263c449b7bc715594323e892de4b1bf463fe27dd1f6883e52c2\",\"license\":\"BUSL-1.1\"},\"contracts/PriceOracle/IPriceOracleStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IPriceOracleStorage {\\n    function registry() external view returns (address);\\n\\n    function eth() external view returns (address);\\n\\n    function gasPriceFeed() external view returns (address);\\n\\n    function pairPriceDrops(address, address) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd9231195e9d884dc5fa4b2d772a2a6d6cdd62b9bf321899102983e88e62af8dc\",\"license\":\"BUSL-1.1\"},\"contracts/PrimexDNS/IPrimexDNS.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IPrimexDNSStorage, IPrimexDNSStorageV2} from \\\"./IPrimexDNSStorage.sol\\\";\\n\\ninterface IPrimexDNS is IPrimexDNSStorage {\\n    event AddNewBucket(BucketData newBucketData);\\n    event BucketDeprecated(address bucketAddress, uint256 delistingTime);\\n    event AddNewDex(DexData newDexData);\\n    event ChangeFeeRate(OrderType orderType, address token, uint256 rate);\\n    event ConditionalManagerChanged(uint256 indexed cmType, address indexed cmAddress);\\n    event PMXchanged(address indexed pmx);\\n    event AavePoolChanged(address indexed aavePool);\\n    event BucketActivated(address indexed bucketAddress);\\n    event BucketFrozen(address indexed bucketAddress);\\n    event DexAdapterChanged(address indexed newAdapterAddress);\\n    event DexActivated(address indexed routerAddress);\\n    event DexFrozen(address indexed routerAddress);\\n\\n    /**\\n     * @param orderType The order type for which the rate is set\\n     * @param feeToken The token address for which the rate is set\\n     * @param rate Setting rate in WAD format (1 WAD = 100%)\\n     */\\n    struct FeeRateParams {\\n        OrderType orderType;\\n        address feeToken;\\n        uint256 rate;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract with the specified parameters.\\n     * @param _registry The address of the PrimexRegistry contract.\\n     * @param _pmx The address of the PMX token contract.\\n     * @param _treasury The address of the Treasury contract.\\n     * @param _delistingDelay The time (in seconds) between deprecation and delisting of a bucket.\\n     * @param _adminWithdrawalDelay The time (in seconds) between delisting of a bucket and an adminDeadline.\\n     * @param _feeRateParams Initial fee params\\n     */\\n    function initialize(\\n        address _registry,\\n        address _pmx,\\n        address _treasury,\\n        uint256 _delistingDelay,\\n        uint256 _adminWithdrawalDelay,\\n        FeeRateParams[] calldata _feeRateParams\\n    ) external;\\n\\n    /**\\n     * @notice Deprecates a bucket.\\n     * @dev This function is used to deprecate a bucket by changing its current status to \\\"Deprecated\\\".\\n     * Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _bucket The name of the bucket to deprecate.\\n     * Emits a BucketDeprecated event with the bucket address and the delisting time.\\n     */\\n    function deprecateBucket(string memory _bucket) external;\\n\\n    /**\\n     * @notice This function is used to set the address of the Aave pool contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _aavePool The address of the Aave pool contract to be set.\\n     */\\n    function setAavePool(address _aavePool) external;\\n\\n    /**\\n     * @notice Sets the protocol rate in PMX.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     */\\n    function setFeeRate(FeeRateParams calldata _feeRateParams) external;\\n\\n    /**\\n     * @notice Sets the address of the PMX token contract.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _pmx The address of the PMX token contract.\\n     */\\n    function setPMX(address _pmx) external;\\n\\n    /**\\n     * @notice Activates a bucket by changing its status from inactive to active.\\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\\n     * @param _bucket The bucket to activate.\\n     */\\n    function activateBucket(string memory _bucket) external;\\n\\n    /**\\n     * @notice Freezes a bucket, preventing further operations on it,\\n     * by changing its status from active to inactive.\\n     * @dev Only callable by the EMERGENCY_ADMIN role.\\n     * @param _bucket The bucket to be frozen.\\n     */\\n    function freezeBucket(string memory _bucket) external;\\n\\n    /**\\n     * @notice Adds a new bucket.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param _newBucket The address of the new bucket to be added.\\n     * @param _pmxRewardAmount The amount of PMX tokens to be rewarded from the bucket.\\n     * Emits a AddNewBucket event with the struct BucketData of the newly added bucket.\\n     */\\n    function addBucket(address _newBucket, uint256 _pmxRewardAmount) external;\\n\\n    /**\\n     * @notice Activates a DEX by changing flag isActive on to true.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _dex The name of the DEX to activate.\\n     */\\n    function activateDEX(string memory _dex) external;\\n\\n    /**\\n     * @notice Freezes a DEX by changing flag isActive to false.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _dex The name of the DEX to be frozen.\\n     */\\n    function freezeDEX(string memory _dex) external;\\n\\n    /**\\n     * @notice Adds a new DEX to the protocol.\\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\\n     * @param _name The name of the DEX.\\n     * @param _routerAddress The address of the DEX router.\\n     */\\n    function addDEX(string memory _name, address _routerAddress) external;\\n\\n    /**\\n     * @notice Sets the address of the DEX adapter.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     * @param newAdapterAddress The address of the new DEX adapter.\\n     */\\n    function setDexAdapter(address newAdapterAddress) external;\\n\\n    /**\\n     * @dev The function to specify the address of conditional manager of some type\\n     * 1 => LimitPriceCOM\\n     * 2 => TakeProfitStopLossCCM\\n     * 3 => TrailingStopCCM\\n     * @param _address Address to be set for a conditional manager\\n     * @param _cmType The type of a conditional manager\\n     */\\n    function setConditionalManager(uint256 _cmType, address _address) external;\\n\\n    /**\\n     * @notice Retrieves the address of a bucket by its name.\\n     * @param _name The name of the bucket.\\n     * @return The address of the bucket.\\n     */\\n    function getBucketAddress(string memory _name) external view returns (address);\\n\\n    /**\\n     * @notice Retrieves the address of the DEX router based on the given DEX name.\\n     * @param _name The name of the DEX.\\n     * @return The address of the DEX router.\\n     */\\n    function getDexAddress(string memory _name) external view returns (address);\\n\\n    /**\\n     * @notice Retrieves the names of Dexes registered in the protocol.\\n     * @return An array of strings containing the names of all Dexes.\\n     */\\n    function getAllDexes() external view returns (string[] memory);\\n}\\n\\ninterface IPrimexDNSV2 is IPrimexDNS, IPrimexDNSStorageV2 {\\n    event ChangeFeeRestrictions(OrderType indexed orderType, FeeRestrictions feeRestrictions);\\n\\n    /**\\n     * @notice Set the protocol fee restriction for one type of order.\\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\\n     */\\n    function setFeeRestrictions(OrderType _orderType, FeeRestrictions calldata _feeRestrictions) external;\\n}\\n\",\"keccak256\":\"0x2d3ab17ad1ba1e1f205695e6f49b6cd91d7e1821762837b8fea1d91c6722ecff\",\"license\":\"BUSL-1.1\"},\"contracts/PrimexDNS/IPrimexDNSStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IPrimexDNSStorage {\\n    enum Status {\\n        Inactive,\\n        Active,\\n        Deprecated\\n    }\\n\\n    enum OrderType {\\n        MARKET_ORDER,\\n        LIMIT_ORDER,\\n        SWAP_MARKET_ORDER,\\n        SWAP_LIMIT_ORDER\\n    }\\n\\n    struct BucketData {\\n        address bucketAddress;\\n        Status currentStatus;\\n        uint256 delistingDeadline;\\n        // The deadline is for the admin to call Bucket.withdrawAfterDelisting().\\n        uint256 adminDeadline;\\n    }\\n    struct DexData {\\n        address routerAddress;\\n        bool isActive;\\n    }\\n\\n    struct AdapterData {\\n        string[] dexes;\\n        bool isAdded;\\n    }\\n\\n    function registry() external view returns (address);\\n\\n    function delistingDelay() external view returns (uint256);\\n\\n    function adminWithdrawalDelay() external view returns (uint256);\\n\\n    function buckets(string memory) external view returns (address, Status, uint256, uint256);\\n\\n    function dexes(string memory) external view returns (address, bool);\\n\\n    function cmTypeToAddress(uint256 cmType) external view returns (address);\\n\\n    function dexAdapter() external view returns (address);\\n\\n    function pmx() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function aavePool() external view returns (address);\\n\\n    function feeRates(OrderType _orderType, address _token) external view returns (uint256);\\n}\\n\\ninterface IPrimexDNSStorageV2 is IPrimexDNSStorage {\\n    struct FeeRestrictions {\\n        uint256 minProtocolFee;\\n        uint256 maxProtocolFee;\\n    }\\n\\n    function feeRestrictions(\\n        OrderType _orderType\\n    ) external view returns (uint256 minProtocolFee, uint256 maxProtocolFee);\\n}\\n\",\"keccak256\":\"0x4fc48b90b62725d15a9208bdd65e19730512bfb71dc6b5fddda3df188a3ede68\",\"license\":\"BUSL-1.1\"},\"contracts/Reserve/IReserve.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IBucket} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IReserveStorage} from \\\"./IReserveStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface IReserve is IReserveStorage, IPausable {\\n    event BurnAmountCalculated(uint256 burnAmount);\\n    event TransferRestrictionsChanged(address indexed pToken, TransferRestrictions newTransferRestrictions);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param dns The address of PrimexDNS contract\\n     * @param registry The address of Registry contract\\n     */\\n    function initialize(IPrimexDNS dns, address registry) external;\\n\\n    /**\\n     * @dev Burns the permanent loss amount (presented in pTokens) from the Reserve for a particular bucket\\n     * @param bucket The address of a bucket\\n     * Emits BurnAmountCalculated(burnAmount) event\\n     */\\n    function paybackPermanentLoss(IBucket bucket) external;\\n\\n    /**\\n     * @dev Transfers some bonus in pTokens to receiver from Reserve\\n     * Can be called by executor only\\n     * @param _bucketName The bucket where the msg.sender should be a fee decreaser (for debtToken) or\\n     * interest increaser (for pToken)\\n     * @param _to The receiver of bonus pTokens\\n     * @param _amount The amount of bonus pTokens to transfer\\n     */\\n    function payBonus(string memory _bucketName, address _to, uint256 _amount) external;\\n\\n    /**\\n     * @dev Function to transfer tokens to the Treasury. Only BIG_TIMELOCK_ADMIN can call it.\\n     * @param bucket The bucket from which to transfer pTokens\\n     * @param amount The amount of pTokens to transfer\\n     */\\n    function transferToTreasury(address bucket, uint256 amount) external;\\n\\n    /**\\n     * @dev Function to set transfer restrictions for a token.\\n     * @notice Only BIG_TIMELOCK_ADMIN can call it.\\n     * @param pToken pToken to set restrictions for\\n     * @param transferRestrictions Min amount to be left in the Reserve\\n     */\\n    function setTransferRestrictions(address pToken, TransferRestrictions calldata transferRestrictions) external;\\n}\\n\",\"keccak256\":\"0x2c2145f1905eca14e254a417095b4999ec8b15a6686446871a9442bc8fd0a44f\",\"license\":\"BUSL-1.1\"},\"contracts/Reserve/IReserveStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IReserveStorage {\\n    struct TransferRestrictions {\\n        uint256 minAmountToBeLeft;\\n        uint256 minPercentOfTotalSupplyToBeLeft;\\n    }\\n\\n    event TransferFromReserve(address pToken, address to, uint256 amount);\\n\\n    function transferRestrictions(address pToken) external view returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0x427d460adc8ddd1c2b4692baaec00af9b39742647d3bb1ab15b6be456c17289f\",\"license\":\"BUSL-1.1\"},\"contracts/SpotTradingRewardDistributor/ISpotTradingRewardDistributor.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {ISpotTradingRewardDistributorStorage} from \\\"./ISpotTradingRewardDistributorStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ISpotTradingRewardDistributor is ISpotTradingRewardDistributorStorage, IPausable {\\n    event SpotTradingClaimReward(address indexed trader, uint256 amount);\\n    event RewardPerPeriodDecreased(uint256 indexed rewardPerPeriod);\\n    event TopUpUndistributedPmxBalance(uint256 indexed amount);\\n    event RewardPerPeriodChanged(uint256 indexed rewardPerPeriod);\\n    event PmxWithdrawn(uint256 indexed amount);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param registry The address of Registry contract\\n     * @param periodDuration The duration of a reward period\\n     * @param priceOracle The address of PriceOracle contract\\n     * @param pmx The address of PMX token\\n     * @param traderBalanceVault The address of TraderBalanceVault contract\\n     * @param treasury The address of Treasury contract\\n     */\\n    function initialize(\\n        address registry,\\n        uint256 periodDuration,\\n        address priceOracle,\\n        address pmx,\\n        address payable traderBalanceVault,\\n        address treasury\\n    ) external;\\n\\n    /**\\n     * @dev Function to update spot trader activity. Only PM_ROLE can call it.\\n     * @param trader Address of a trader\\n     * @param positionAsset Address of a position asset\\n     * @param positionAmount Amount of a position asset\\n     */\\n    function updateTraderActivity(address trader, address positionAsset, uint256 positionAmount) external;\\n\\n    /**\\n     * @dev Function to claim reward for spot trading activity.\\n     * Transfer rewards on the balance in traderBalanceVault\\n     * Emits SpotTradingClaimReward(address trader, uint256 amount)\\n     */\\n    function claimReward() external;\\n\\n    /**\\n     * @dev Function to set new reward per period. Only BIG_TIMELOCK_ADMIN can call it.\\n     * @param rewardPerPeriod New value for reward per period\\n     */\\n    function setRewardPerPeriod(uint256 rewardPerPeriod) external;\\n\\n    /**\\n     * @dev Function to decrease reward per period. Only EMERGENCY_ADMIN can call it.\\n     * @param _rewardPerPeriod New value for reward per period, must be less than the current value\\n     */\\n    function decreaseRewardPerPeriod(uint256 _rewardPerPeriod) external;\\n\\n    /**\\n     * @dev Function to topUp the contract PMX balance\\n     * @param amount PMX amount to add to the contract balance\\n     */\\n    function topUpUndistributedPmxBalance(uint256 amount) external;\\n\\n    /**\\n     * @dev Function to withdraw PMX from the contract to treasury\\n     * @param amount Amount of PMX to withdraw from the contract\\n     */\\n    function withdrawPmx(uint256 amount) external;\\n\\n    /**\\n     * @dev Function to get SpotTraderActivity\\n     * @param periodNumber Period number\\n     * @param traderAddress Address of a trader\\n     * @return A struct with activity and hasClaimed members\\n     */\\n    function getSpotTraderActivity(uint256 periodNumber, address traderAddress) external view returns (uint256);\\n\\n    /**\\n     * @dev Get information for the period corresponding to the given timestamp\\n     * @param timestamp The timestamp to get information about\\n     * @return totalReward Total reward for the corresponding period\\n     * @return totalActivity Total activity for the corresponding period\\n     */\\n    function getPeriodInfo(uint256 timestamp) external view returns (uint256, uint256);\\n\\n    /**\\n     * @dev Function to get an array of period numbers when trader had any activity\\n     * @param trader Address of a trader\\n     * @return An array of period numbers with trader activity\\n     */\\n    function getPeriodsWithTraderActivity(address trader) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Function to calculate trader's reward for her activities during periods\\n     * @param trader Address of a trader\\n     * @return reward Amount of reward\\n     * @return currentPeriod The current period\\n     */\\n    function calculateReward(address trader) external view returns (uint256 reward, uint256 currentPeriod);\\n}\\n\",\"keccak256\":\"0xbc25e92e6decf4beb8369378f389ed513371d8ff2deb61d0561699a6f5c39633\",\"license\":\"BUSL-1.1\"},\"contracts/SpotTradingRewardDistributor/ISpotTradingRewardDistributorStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface ISpotTradingRewardDistributorStorage {\\n    struct PeriodInfo {\\n        uint256 totalReward;\\n        // map trader address to her activity\\n        mapping(address => uint256) traderActivity;\\n        uint256 totalActivity;\\n    }\\n\\n    function registry() external view returns (address);\\n\\n    function dns() external view returns (address);\\n\\n    function periodDuration() external view returns (uint256);\\n\\n    function initialPeriodTimestamp() external view returns (uint256);\\n\\n    function rewardPerPeriod() external view returns (uint256);\\n\\n    function pmx() external view returns (address);\\n\\n    function priceOracle() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function traderBalanceVault() external view returns (address payable);\\n\\n    function undistributedPMX() external view returns (uint256);\\n\\n    function periods(uint256 periodNumber) external view returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0x23c8112548009d3d70825d16e9850ebacf0fc4f015aa6ab8649bfeec7bf72ea5\",\"license\":\"BUSL-1.1\"},\"contracts/TraderBalanceVault/ITraderBalanceVault.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {ITraderBalanceVaultStorage} from \\\"./ITraderBalanceVaultStorage.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ITraderBalanceVault is ITraderBalanceVaultStorage, IPausable {\\n    /**\\n     * Types of way to open a position or order\\n     */\\n    enum OpenType {\\n        OPEN_BY_ORDER,\\n        OPEN,\\n        CREATE_LIMIT_ORDER\\n    }\\n\\n    /**\\n     * @param trader The trader, who opens margin deal\\n     * @param depositReceiver the address to which the deposit is transferred when blocked.\\n     * This happens because the trader's deposit is involved in the position\\n     * @param borrowedAsset The token to lock for deal in a borrowed asset\\n     * @param depositAsset The token is a deposit asset\\n     * (it is blocked when creating a limit order\\n     * For others, the operations is transferred to the account of the receiver of the deposit and is swapped )\\n     * @param depositAmount Amount of tokens in a deposit asset\\n     * @param depositInBorrowedAmount Amount of tokens to lock for deal in a borrowed asset\\n     * @param openType Corresponds to the purpose of locking\\n     */\\n    struct LockAssetParams {\\n        address trader;\\n        address depositReceiver;\\n        address depositAsset;\\n        uint256 depositAmount;\\n        OpenType openType;\\n    }\\n\\n    /**\\n     * @param trader The trader who opened the position\\n     * @param receiver The receiver of the rest of trader deposit.\\n     * @param asset Borrowed asset of the position being closed (the need for accrual of profit).\\n     * @param unlockAmount The amount of unlocked collateral for deal\\n     * @param returnToTrader The returned to trader amount when position was closed.\\n     */\\n    struct UnlockAssetParams {\\n        address trader;\\n        address receiver;\\n        address asset;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @param traders An array of traders for which available balance should be increased\\n     * @param amounts An array of amounts corresponding to traders' addresses that should be added to their available balances\\n     * @param asset Asset address which amount will be increased\\n     * @param length The amount of traders in an array\\n     */\\n    struct BatchTopUpAvailableBalanceParams {\\n        address[] traders;\\n        uint256[] amounts;\\n        address asset;\\n        uint256 length;\\n    }\\n\\n    event Deposit(address indexed depositer, address indexed asset, uint256 amount);\\n    event Withdraw(address indexed withdrawer, address asset, uint256 amount);\\n\\n    /**\\n     * @dev contract initializer\\n     * @param _registry The address of Registry contract\\n     * @param _whiteBlackList The address of WhiteBlackList contract\\n     */\\n    function initialize(address _registry, address _whiteBlackList) external;\\n\\n    receive() external payable;\\n\\n    /**\\n     * @dev Deposits trader collateral for margin deal\\n     * @param _asset The collateral asset for deal\\n     * @param _amount The amount of '_asset' to deposit\\n     */\\n    function deposit(address _asset, uint256 _amount) external payable;\\n\\n    /**\\n     * @dev Withdraws the rest of trader's deposit after closing deal\\n     * @param _asset The collateral asset for withdraw\\n     * @param _amount The amount of '_asset' to withdraw\\n     */\\n    function withdraw(address _asset, uint256 _amount) external;\\n\\n    /**\\n     * @dev Traders lock their collateral for the limit order.\\n     * @param _trader The owner of collateral\\n     * @param _asset The collateral asset for deal\\n     * @param _amount The amount of '_asset' to deposit\\n     */\\n    function increaseLockedBalance(address _trader, address _asset, uint256 _amount) external payable;\\n\\n    /**\\n     * @dev Locks deposited trader's assets as collateral for orders.\\n     * Decreases the available balance when opening position.\\n     * Transfers deposited amount to the deposit receiver.\\n     * @param _params parameters necessary to lock asset\\n     */\\n    function useTraderAssets(LockAssetParams calldata _params) external;\\n\\n    /**\\n     * @dev Unlocks trader's collateral when open position by order or update deposit.\\n     * @param _params parameters necessary to unlock asset\\n     */\\n    function unlockAsset(UnlockAssetParams calldata _params) external;\\n\\n    /**\\n     * The function to increase available balance for several traders\\n     * @param _params A struct containing BatchTopUpAvailableBalanceParams\\n     */\\n    function batchTopUpAvailableBalance(BatchTopUpAvailableBalanceParams calldata _params) external;\\n\\n    /**\\n     * Withdraws an asset amount from an asset holder to a receiver\\n     * @param _from Withdraw from address\\n     * @param _to Withdraw to address\\n     * @param _asset Address of an asset\\n     * @param _amount Amount of an asset\\n     * @param fromLocked True if withdraw from locked balance\\n     */\\n    function withdrawFrom(address _from, address _to, address _asset, uint256 _amount, bool fromLocked) external;\\n\\n    /**\\n     * Increases available balance of a receiver in the protocol\\n     * @param receiver The address of an asset receiver\\n     * @param asset The asset address for which available balance will be increased\\n     * @param amount The amount of an asset\\n     */\\n    function topUpAvailableBalance(address receiver, address asset, uint256 amount) external payable;\\n}\\n\",\"keccak256\":\"0x7d7021be769ab6a7c4086eb6dfec873f22ae75e84d72b66492fa23d7a9b4f329\",\"license\":\"BUSL-1.1\"},\"contracts/TraderBalanceVault/ITraderBalanceVaultStorage.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface ITraderBalanceVaultStorage {\\n    struct TraderBalance {\\n        uint256 availableBalance;\\n        uint256 lockedBalance;\\n    }\\n\\n    function registry() external view returns (address);\\n\\n    /**\\n     *\\n     * @param trader Trader's address\\n     * @param asset Asset address\\n     * @return availableBalance availableBalance\\n     * @return lockedBalance lockedBalance\\n     */\\n    function balances(\\n        address trader,\\n        address asset\\n    ) external view returns (uint256 availableBalance, uint256 lockedBalance);\\n}\\n\",\"keccak256\":\"0xd103723047a828ac9dcd2434ac3e8c4f57435faaeb310ae62f1cd67065dc2e80\",\"license\":\"BUSL-1.1\"},\"contracts/WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IWhiteBlackList {\\n    enum AccessType {\\n        UNLISTED,\\n        WHITELISTED,\\n        BLACKLISTED\\n    }\\n    event WhitelistedAddressAdded(address indexed addr);\\n    event WhitelistedAddressRemoved(address indexed addr);\\n    event BlacklistedAddressAdded(address indexed addr);\\n    event BlacklistedAddressRemoved(address indexed addr);\\n\\n    function addAddressToWhitelist(address _address) external;\\n\\n    function addAddressesToWhitelist(address[] calldata _addresses) external;\\n\\n    function removeAddressFromWhitelist(address _address) external;\\n\\n    function removeAddressesFromWhitelist(address[] calldata _addresses) external;\\n\\n    function addAddressToBlacklist(address _address) external;\\n\\n    function addAddressesToBlacklist(address[] calldata _addresses) external;\\n\\n    function removeAddressFromBlacklist(address _address) external;\\n\\n    function removeAddressesFromBlacklist(address[] calldata _addresses) external;\\n\\n    function getAccessType(address _address) external view returns (AccessType);\\n\\n    function isBlackListed(address _address) external view returns (bool);\\n\\n    function registry() external view returns (address);\\n}\\n\",\"keccak256\":\"0xa02e0237ab68d21bb3005cac9d945da1eaab863d2321202295d72a1164d9f0ed\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/EIP20NonStandardInterface.sol\":{\"content\":\"// Copyright 2020 Compound Labs, Inc.\\n// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface EIP20NonStandardInterface {\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     */\\n    function transfer(address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) external;\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved\\n     * @return success Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool success);\\n\\n    /**\\n     * @notice Get the current allowance from `owner` for `spender`\\n     * @param owner The address of the account which owns the tokens to be spent\\n     * @param spender The address of the account which may transfer tokens\\n     * @return remaining The number of tokens allowed to be spent\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\",\"keccak256\":\"0x4b53df7e37eeb7c34aaed6ed236909444a40d5edf62e944f55cf78cbe43948d6\",\"license\":\"BSD-3-Clause\"},\"contracts/interfaces/IConditionalClosingManager.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\ninterface IConditionalClosingManager {\\n    /**\\n     * @notice Checks if a position can be closed.\\n     * @param _position The position details.\\n     * @param _params The encoded parameters for closing the position.\\n     * @param _additionalParams Additional encoded parameters.\\n     * @return A boolean indicating whether the position can be closed.\\n     */\\n    function canBeClosedBeforeSwap(\\n        PositionLibrary.Position calldata _position,\\n        bytes calldata _params,\\n        bytes calldata _additionalParams\\n    ) external returns (bool);\\n\\n    /**\\n     * @notice Checks if a position can be closed.\\n     * @param _position The position details.\\n     * @param _params The encoded parameters for closing the position.\\n     * @param _additionalParams Additional encoded parameters (not used).\\n     * @param _closeAmount The amount of the position to be closed, measured in the same decimal format as the position's asset.\\n     * @param _borowedAssetAmount The amount of borrowed asset.\\n     * @return A boolean indicating whether the position can be closed.\\n     */\\n    function canBeClosedAfterSwap(\\n        PositionLibrary.Position calldata _position,\\n        bytes calldata _params,\\n        bytes calldata _additionalParams,\\n        uint256 _closeAmount,\\n        uint256 _borowedAssetAmount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x18137eb0c4fb8b753c3bd6e9f5dc44aad884c13ed8249351d0e1d59fdb2e5295\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IConditionalOpeningManager.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {LimitOrderLibrary} from \\\"../libraries/LimitOrderLibrary.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\ninterface IConditionalOpeningManager {\\n    /**\\n     * @notice Checks if a limit order can be filled.\\n     * Is used as a view function outside transactions and allows to check whether a specific order can be executed imitating the swap.\\n     * @param _order The limit order details.\\n     * @param _params Open condition parameters for the order.\\n     * @param _additionalParams Additional parameters for the order.\\n     * @return A boolean value indicating if the limit order can be filled.\\n     */\\n    function canBeFilledBeforeSwap(\\n        LimitOrderLibrary.LimitOrder calldata _order,\\n        bytes calldata _params,\\n        bytes calldata _additionalParams\\n    ) external returns (bool);\\n\\n    /**\\n     * @notice Checks if a limit order can be filled based on the exchange rate.\\n     * @dev This function compares the exchange rate with the limit price.\\n     * @param _order The limit order details.\\n     * @param _params Open condition parameters for the order.\\n     * @param _additionalParams Additional parameters for the order.\\n     * @param _exchangeRate The exchange rate in WAD format to compare with the limit price.\\n     * @return A boolean value indicating if the limit order can be filled based on the exchange rate.\\n     */\\n    function canBeFilledAfterSwap(\\n        LimitOrderLibrary.LimitOrder calldata _order,\\n        bytes calldata _params,\\n        bytes calldata _additionalParams,\\n        uint256 _exchangeRate\\n    ) external pure returns (bool);\\n}\\n\",\"keccak256\":\"0xf5bf329b09f2a53e59e60e7faa30e1df63f474ad8d0359c931277f623f120c54\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IDexAdapter.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IQuoter} from \\\"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\\\";\\n\\nimport {IPositionManager} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {ICurveCalc} from \\\"./routers/ICurveCalc.sol\\\";\\nimport {ICurveRegistry} from \\\"./routers/ICurveRegistry.sol\\\";\\n\\ninterface IDexAdapter {\\n    /**\\n     * @notice Possible dex types\\n     */\\n    enum DexType {\\n        none, // 0\\n        UniswapV2, // 1  \\\"uniswap\\\", \\\"sushiswap\\\", \\\"quickswap\\\" (v2)\\n        UniswapV3, // 2\\n        Curve, // 3\\n        Balancer, // 4\\n        AlgebraV3, // 5\\n        Meshswap // 6\\n    }\\n\\n    /*\\n     * @param encodedPath Swap path encoded in bytes\\n     * Encoded differently for different dexes:\\n     * Uniswap v2 - just encoded array of asset addresses\\n     * Uniswap v3 - swap path is a sequence of bytes. In Solidity, a path can be built like that:\\n     *      bytes.concat(bytes20(address(weth)), bytes3(uint24(pool1Fee)), bytes20(address(usdc)), bytes3(uint24(pool2Fee)) ...)\\n     * Quickswap - swap path is a sequence of bytes. In Solidity, a path can be built like that:\\n     *      bytes.concat(bytes20(address(weth)), bytes20(address(usdc)), bytes20(address(usdt) ...)\\n     * Curve - encoded array of asset addresses and pool addresses\\n     * Balancer - encoded array of asset addresses, pool ids and asset limits\\n     * @param _amountIn TokenA amount in\\n     * @param _amountOutMin Min tokenB amount out\\n     * @param _to Destination address for swap\\n     * @param _deadline Timestamp deadline for swap\\n     * @param _dexRouter Dex router address\\n     */\\n    struct SwapParams {\\n        bytes encodedPath;\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n        address to;\\n        uint256 deadline;\\n        address dexRouter;\\n    }\\n\\n    /*\\n     * @param encodedPath Swap path encoded in bytes\\n     * @param _amountIn TokenA amount in\\n     * @param _dexRouter Dex router address\\n     */\\n    struct GetAmountsParams {\\n        bytes encodedPath;\\n        uint256 amount; // amountIn or amountOut\\n        address dexRouter;\\n    }\\n\\n    event QuoterChanged(address indexed dexRouter, address indexed quoter);\\n    event DexTypeChanged(address indexed dexRouter, uint256 indexed dexType);\\n\\n    /**\\n     * @param _dexRouter The router address for which the quoter is set\\n     * @param _quoter The quoter address to set\\n     */\\n    function setQuoter(address _dexRouter, address _quoter) external;\\n\\n    /**\\n     * @notice Set a dex type for a dex router\\n     * @param _dexRouter The dex router address\\n     * @param _dexType The dex type from enum DexType\\n     */\\n    function setDexType(address _dexRouter, uint256 _dexType) external;\\n\\n    /**\\n     * @notice Swap ERC20 tokens\\n     * @param _params SwapParams struct\\n     */\\n    function swapExactTokensForTokens(SwapParams memory _params) external returns (uint256[3] memory);\\n\\n    /**\\n     * @notice Performs chained getAmountOut calculations\\n     * @notice given an input amount of an asset, returns the maximum output amount of the other asset\\n     * @param _params GetAmountsParams struct\\n     */\\n    function getAmountsOut(GetAmountsParams memory _params) external returns (uint256[3] memory);\\n\\n    /**\\n     * @notice Performs chained getAmountIn calculations\\n     * @notice given an output amount of an asset, returns the maximum input amount of the other asset\\n     * @param _params GetAmountsParams struct\\n     */\\n    function getAmountsIn(GetAmountsParams memory _params) external returns (uint256[3] memory);\\n\\n    /**\\n     * @notice Dex type mapping dexRouter => dex type\\n     */\\n    function dexType(address) external view returns (DexType);\\n\\n    /**\\n     * @notice Mapping from the dexRouter to its quoter\\n     */\\n    function quoters(address) external view returns (address);\\n\\n    /**\\n     * @return The address of the Registry contract\\n     */\\n    function registry() external view returns (address);\\n\\n    /**\\n     * @notice Gets the average amount of gas that is required for the swap on some dex\\n     * @param dexRouter The address of a router\\n     */\\n    function getGas(address dexRouter) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x20c68407aaf893618f2c1993ab0cef250ecb8c94e82e1801706bf26fbcc8b4f5\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IInterestRateStrategy.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface IInterestRateStrategy {\\n    /**\\n     * @dev parameters for BAR calculation - they differ depending on bucket's underlying asset\\n     */\\n    struct BarCalculationParams {\\n        uint256 urOptimal;\\n        uint256 k0;\\n        uint256 k1;\\n        uint256 b0;\\n        int256 b1;\\n    }\\n\\n    event BarCalculationParamsChanged(\\n        address indexed bucket,\\n        uint256 urOptimal,\\n        uint256 k0,\\n        uint256 k1,\\n        uint256 b0,\\n        int256 b1\\n    );\\n\\n    /**\\n     * @dev Updates bucket's BAR and LAR.\\n     * Calculates using utilization ratio (UR):\\n     * BAR = UR <= URoptimal ? (k0 * UR + b0) : (k1 * UR + b1), where 'b1' may be < 0,\\n     * LAR = BAR * UR,\\n     * if reserveRate != 0, then LAR = LAR * (1 - reserveRate)\\n     * @param ur Utilization ratio\\n     * @param reserveRate The reserve portion of the interest that goes to the Primex reserve\\n     * @return tuple containing BAR and LAR\\n     */\\n\\n    function calculateInterestRates(uint256 ur, uint256 reserveRate) external returns (uint128, uint128);\\n\\n    /**\\n     * @dev Set parameters for BAR calculation.\\n     * @param _params parameters are represented in byte string\\n     */\\n\\n    function setBarCalculationParams(bytes memory _params) external;\\n\\n    /**\\n     * @dev Retrieves the calculation parameters for the Bar calculation.\\n     * @param _address an address of the bucket\\n     * @return BarCalculationParams struct containing the parameters.\\n     */\\n    function getBarCalculationParams(address _address) external view returns (BarCalculationParams memory);\\n}\\n\",\"keccak256\":\"0x3474a7be6c42ddf5faf12304d1978f0268b7d80c6d1c04880f00832151b280d8\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/IPausable.sol\":{\"content\":\"// Copyright (c) 2016-2023 zOS Global Limited and contributors\\n// SPDX-License-Identifier: MIT\\n\\n// Interface for OpenZeppelin's Pausable contract from https://github.com/OpenZeppelin/openzeppelin-contracts/\\npragma solidity ^0.8.18;\\n\\ninterface IPausable {\\n    /**\\n     * @dev Triggers stopped state.\\n     * This function can only be called by an address with the EMERGENCY_ADMIN role.\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @dev Returns to normal state.\\n     * This function can only be called by an address with the SMALL_TIMELOCK_ADMIN or MEDIUM_TIMELOCK_ADMIN role depending on the contract.\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function unpause() external;\\n}\\n\",\"keccak256\":\"0x12e1f74846ecd309150da9ae8d3e119f39ea1ed32ee0d9db5a7509c6baac94e3\",\"license\":\"MIT\"},\"contracts/interfaces/ISwapManager.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IPausable} from \\\"../interfaces/IPausable.sol\\\";\\n\\ninterface ISwapManager is IPausable {\\n    event SpotSwap(\\n        address indexed trader,\\n        address indexed receiver,\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountSold,\\n        uint256 amountBought\\n    );\\n\\n    /**\\n     * @param tokenA The address of the asset to be swapped from.\\n     * @param tokenB The address of the asset to be received in the swap.\\n     * @param amountTokenA The amount of tokenA to be swapped.\\n     * @param amountOutMin The minimum amount of tokenB expected to receive.\\n     * @param routes An array of PrimexPricingLibrary.Route structs representing the routes for the swap.\\n     * @param receiver The address where the swapped tokens will be received.\\n     * @param deadline The deadline for the swap transaction.\\n     * @param isSwapFromWallet A flag indicating whether the swap is perfomed from a wallet or a protocol balance.\\n     * @param isSwapToWallet A flag indicating whether the swapped tokens will be sent to a wallet or a protocol balance.\\n     * @param isSwapFeeInPmx A flag indicating whether the swap fee is paid in PMX or in native token.\\n     * @param payFeeFromWallet A flag indicating whether the swap fee is perfomed from a wallet or a protocol balance.\\n     */\\n    struct SwapParams {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amountTokenA;\\n        uint256 amountOutMin;\\n        PrimexPricingLibrary.Route[] routes;\\n        address receiver;\\n        uint256 deadline;\\n        bool isSwapFromWallet;\\n        bool isSwapToWallet;\\n        bool isSwapFeeInPmx;\\n        bool payFeeFromWallet;\\n    }\\n\\n    /**\\n     * @notice Executes a swap on dexes defined in routes\\n     * @param params The SwapParams struct containing the details of the swap transaction.\\n     * @param maximumOracleTolerableLimit The maximum tolerable limit in WAD format (1 WAD = 100%)\\n     * @param needOracleTolerableLimitCheck Flag indicating whether to perform an oracle tolerable limit check.\\n     * @return The resulting amount after the swap.\\n     */\\n    function swap(\\n        SwapParams calldata params,\\n        uint256 maximumOracleTolerableLimit,\\n        bool needOracleTolerableLimitCheck\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Retrieves the instance of PrimexRegistry contract.\\n     */\\n    function registry() external view returns (IAccessControl);\\n\\n    /**\\n     * @notice Retrieves the instance of TraderBalanceVault contract.\\n     */\\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\\n\\n    /**\\n     * @notice Retrieves the instance of PrimexDNS contract.\\n     */\\n    function primexDNS() external view returns (IPrimexDNS);\\n\\n    /**\\n     * @notice Retrieves the instance of PriceOracle contract.\\n     */\\n    function priceOracle() external view returns (IPriceOracle);\\n}\\n\",\"keccak256\":\"0xf91a251dbe30ce2840eb804f09dfa6569723900052bc10f559162774d3124b2d\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/ITakeProfitStopLossCCM.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\nimport {PositionLibrary} from \\\"../libraries/PositionLibrary.sol\\\";\\nimport {PrimexPricingLibrary} from \\\"../libraries/PrimexPricingLibrary.sol\\\";\\n\\ninterface ITakeProfitStopLossCCM {\\n    struct CanBeClosedParams {\\n        uint256 takeProfitPrice;\\n        uint256 stopLossPrice;\\n    }\\n\\n    struct AdditionalParams {\\n        PrimexPricingLibrary.Route[] routes;\\n    }\\n\\n    /**\\n     * @notice Checks if the take profit has been reached for a given position.\\n     * @param _position The position details.\\n     * @param takeProfitPrice The take profit price in WAD format.\\n     * @param routes The array of routes for asset swapping.\\n     * @return A boolean indicating whether the take profit has been reached.\\n     */\\n    function isTakeProfitReached(\\n        PositionLibrary.Position calldata _position,\\n        uint256 takeProfitPrice,\\n        PrimexPricingLibrary.Route[] memory routes\\n    ) external returns (bool);\\n\\n    /**\\n     * @notice Checks if the take profit has been reached based on the given parameters.\\n     * @dev Used in closeBatchPositions() function.\\n     * @param _params The encoded parameters.\\n     * @param exchangeRate The exchange rate in WAD format.\\n     * @return A boolean indicating whether the take profit has been reached.\\n     */\\n    function isTakeProfitReached(bytes calldata _params, uint256 exchangeRate) external view returns (bool);\\n\\n    /**\\n     * @notice Checks if the stop loss price has been reached for a given position.\\n     * @param _position The position details.\\n     * @param stopLossPrice The stop loss price in WAD format to compare against.\\n     * @return True if the stop loss price is reached, false otherwise.\\n     */\\n    function isStopLossReached(\\n        PositionLibrary.Position calldata _position,\\n        uint256 stopLossPrice\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Checks if the stop loss price has been reached on the given parameters.\\n     * @dev The takeProfitPrice and stopLossPrice values can be obtained from the encoded data via CanBeClosedParams struct.\\n     * @param _params The encoded closing condition parameters containing stop loss price.\\n     * @param oracleExchangeRate The current exchange rate from the oracle in WAD format.\\n     * @return True if the stop loss price is reached, false otherwise.\\n     */\\n    function isStopLossReached(bytes calldata _params, uint256 oracleExchangeRate) external view returns (bool);\\n\\n    /**\\n     * @notice Retrieves the take profit and stop loss prices from the given parameters.\\n     * @param _params The encoded parameters for closing a position.\\n     * @return takeProfitPrice The take profit price.\\n     * @return stopLossPrice The stop loss price.\\n     */\\n    function getTakeProfitStopLossPrices(bytes calldata _params) external view returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0x5f5df8c88208778ad4387a39f6cc343199c8df8870f21158a48562e81275c8d7\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/routers/ICurveCalc.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface ICurveCalc {\\n    // solhint-disable func-name-mixedcase\\n    function get_dx(\\n        // solhint-disable-next-line var-name-mixedcase\\n        int128 n_coins,\\n        uint256[8] memory balances,\\n        uint256 amp,\\n        uint256 fee,\\n        uint256[8] memory rates,\\n        uint256[8] memory precisions,\\n        bool underlying,\\n        int128 i,\\n        int128 j,\\n        uint256 dy\\n    ) external pure returns (uint256);\\n}\\n\",\"keccak256\":\"0x5fa9879e97a93a46480f230b02f7e8518d2ad482390b3224359dce1c075e4d12\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/routers/ICurveRegistry.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.18;\\n\\ninterface ICurveRegistry {\\n    // solhint-disable func-name-mixedcase\\n    function get_n_coins(address _pool) external view returns (uint256[2] memory);\\n\\n    function get_rates(address _pool) external view returns (uint256[8] memory);\\n\\n    function get_coin_indices(address _pool, address _from, address _to) external view returns (int128, int128, bool);\\n}\\n\",\"keccak256\":\"0xaa6bf52698d973d56d123347ceac0e41bd58d4ceb29f489d74a36ca516b52798\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/Errors.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\n// solhint-disable-next-line func-visibility\\nfunction _require(bool condition, bytes4 selector) pure {\\n    if (!condition) _revert(selector);\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction _revert(bytes4 selector) pure {\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly (\\\"memory-safe\\\") {\\n        let free_mem_ptr := mload(64)\\n        mstore(free_mem_ptr, selector)\\n        revert(free_mem_ptr, 4)\\n    }\\n}\\n\\nlibrary Errors {\\n    event Log(bytes4 error);\\n\\n    //common\\n    error ADDRESS_NOT_SUPPORTED();\\n    error FORBIDDEN();\\n    error AMOUNT_IS_0();\\n    error CALLER_IS_NOT_TRADER();\\n    error CONDITION_INDEX_IS_OUT_OF_BOUNDS();\\n    error INVALID_PERCENT_NUMBER();\\n    error INVALID_SECURITY_BUFFER();\\n    error INVALID_MAINTENANCE_BUFFER();\\n    error TOKEN_ADDRESS_IS_ZERO();\\n    error IDENTICAL_TOKEN_ADDRESSES();\\n    error ASSET_DECIMALS_EXCEEDS_MAX_VALUE();\\n    error CAN_NOT_ADD_WITH_ZERO_ADDRESS();\\n    error SHOULD_BE_DIFFERENT_ASSETS_IN_SPOT();\\n    error TOKEN_NOT_SUPPORTED();\\n    error INSUFFICIENT_DEPOSIT();\\n    error SHOULD_NOT_HAVE_DUPLICATES();\\n    // error LIMIT_PRICE_IS_ZERO();\\n    error BUCKET_IS_NOT_ACTIVE();\\n    error DIFFERENT_DATA_LENGTH();\\n    error RECIPIENT_OR_SENDER_MUST_BE_ON_WHITE_LIST();\\n    error SLIPPAGE_TOLERANCE_EXCEEDED();\\n    error OPERATION_NOT_SUPPORTED();\\n    error SENDER_IS_BLACKLISTED();\\n    error NATIVE_CURRENCY_CANNOT_BE_ASSET();\\n    error DISABLED_TRANSFER_NATIVE_CURRENCY();\\n    error INVALID_AMOUNT();\\n\\n    // bonus executor\\n    error CALLER_IS_NOT_NFT();\\n    error BONUS_FOR_BUCKET_ALREADY_ACTIVATED();\\n    error WRONG_LENGTH();\\n    error BONUS_DOES_NOT_EXIST();\\n    error CALLER_IS_NOT_DEBT_TOKEN();\\n    error CALLER_IS_NOT_P_TOKEN();\\n    error MAX_BONUS_COUNT_EXCEEDED();\\n    error TIER_IS_NOT_ACTIVE();\\n    error BONUS_PERCENT_IS_ZERO();\\n\\n    // bucket\\n    error INCORRECT_LIQUIDITY_MINING_PARAMS();\\n    error PAIR_PRICE_DROP_IS_NOT_CORRECT();\\n    error ASSET_IS_NOT_SUPPORTED();\\n    error BUCKET_OUTSIDE_PRIMEX_PROTOCOL();\\n    error DEADLINE_IS_PASSED();\\n    error DEADLINE_IS_NOT_PASSED();\\n    error BUCKET_IS_NOT_LAUNCHED();\\n    error BURN_AMOUNT_EXCEEDS_PROTOCOL_DEBT();\\n    error LIQUIDITY_INDEX_OVERFLOW();\\n    error BORROW_INDEX_OVERFLOW();\\n    error BAR_OVERFLOW();\\n    error LAR_OVERFLOW();\\n    error UR_IS_MORE_THAN_1();\\n    error ASSET_ALREADY_SUPPORTED();\\n    error DEPOSIT_IS_MORE_AMOUNT_PER_USER();\\n    error DEPOSIT_EXCEEDS_MAX_TOTAL_DEPOSIT();\\n    error MINING_AMOUNT_WITHDRAW_IS_LOCKED_ON_STABILIZATION_PERIOD();\\n    error WITHDRAW_RATE_IS_MORE_10_PERCENT();\\n    error INVALID_FEE_BUFFER();\\n    error RESERVE_RATE_SHOULD_BE_LESS_THAN_1();\\n    error MAX_TOTAL_DEPOSIT_IS_ZERO();\\n    error AMOUNT_SCALED_SHOULD_BE_GREATER_THAN_ZERO();\\n    error NOT_ENOUGH_LIQUIDITY_IN_THE_BUCKET();\\n\\n    // p/debt token, PMXToken\\n    error BUCKET_IS_IMMUTABLE();\\n    error INVALID_MINT_AMOUNT();\\n    error INVALID_BURN_AMOUNT();\\n    error TRANSFER_NOT_SUPPORTED();\\n    error APPROVE_NOT_SUPPORTED();\\n    error CALLER_IS_NOT_BUCKET();\\n    error CALLER_IS_NOT_A_BUCKET_FACTORY();\\n    error CALLER_IS_NOT_P_TOKEN_RECEIVER();\\n    error DURATION_MUST_BE_MORE_THAN_0();\\n    error INCORRECT_ID();\\n    error THERE_ARE_NO_LOCK_DEPOSITS();\\n    error LOCK_TIME_IS_NOT_EXPIRED();\\n    error TRANSFER_AMOUNT_EXCEED_ALLOWANCE();\\n    error CALLER_IS_NOT_A_MINTER();\\n    error ACTION_ONLY_WITH_AVAILABLE_BALANCE();\\n    error FEE_DECREASER_CALL_FAILED();\\n    error TRADER_REWARD_DISTRIBUTOR_CALL_FAILED();\\n    error INTEREST_INCREASER_CALL_FAILED();\\n    error LENDER_REWARD_DISTRIBUTOR_CALL_FAILED();\\n    error DEPOSIT_DOES_NOT_EXIST();\\n    error RECIPIENT_IS_BLACKLISTED();\\n\\n    //LOM\\n    error ORDER_CAN_NOT_BE_FILLED();\\n    error ORDER_DOES_NOT_EXIST();\\n    error ORDER_IS_NOT_SPOT();\\n    error LEVERAGE_MUST_BE_MORE_THAN_1();\\n    error CANNOT_CHANGE_SPOT_ORDER_TO_MARGIN();\\n    error SHOULD_HAVE_OPEN_CONDITIONS();\\n    error INCORRECT_LEVERAGE();\\n    error INCORRECT_DEADLINE();\\n    error LEVERAGE_SHOULD_BE_1();\\n    error LEVERAGE_EXCEEDS_MAX_LEVERAGE();\\n    error SHOULD_OPEN_POSITION();\\n    error IS_SPOT_ORDER();\\n    error SHOULD_NOT_HAVE_CLOSE_CONDITIONS();\\n    error ORDER_HAS_EXPIRED();\\n\\n    // LiquidityMiningRewardDistributor\\n    error BUCKET_IS_NOT_STABLE();\\n    error ATTEMPT_TO_WITHDRAW_MORE_THAN_DEPOSITED();\\n    error WITHDRAW_PMX_BY_ADMIN_FORBIDDEN();\\n\\n    // nft\\n    error TOKEN_IS_BLOCKED();\\n    error ONLY_MINTERS();\\n    error PROGRAM_IS_NOT_ACTIVE();\\n    error CALLER_IS_NOT_OWNER();\\n    error TOKEN_IS_ALREADY_ACTIVATED();\\n    error WRONG_NETWORK();\\n    error ID_DOES_NOT_EXIST();\\n    error WRONG_URIS_LENGTH();\\n\\n    // PM\\n    error ASSET_ADDRESS_NOT_SUPPORTED();\\n    error IDENTICAL_ASSET_ADDRESSES();\\n    error POSITION_DOES_NOT_EXIST();\\n    error AMOUNT_IS_MORE_THAN_POSITION_AMOUNT();\\n    error BORROWED_AMOUNT_IS_ZERO();\\n    error IS_SPOT_POSITION();\\n    error AMOUNT_IS_MORE_THAN_DEPOSIT();\\n    error DECREASE_AMOUNT_IS_ZERO();\\n    error INSUFFICIENT_DEPOSIT_SIZE();\\n    error IS_NOT_RISKY_OR_CANNOT_BE_CLOSED();\\n    error BUCKET_SHOULD_BE_UNDEFINED();\\n    error DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0();\\n    error POSITION_CANNOT_BE_CLOSED_FOR_THIS_REASON();\\n    error ADDRESS_IS_ZERO();\\n    error WRONG_TRUSTED_MULTIPLIER();\\n    error POSITION_SIZE_EXCEEDED();\\n    error POSITION_BUCKET_IS_INCORRECT();\\n    error THERE_MUST_BE_AT_LEAST_ONE_POSITION();\\n    error NOTHING_TO_CLOSE();\\n\\n    // BatchManager\\n    error PARAMS_LENGTH_MISMATCH();\\n    error BATCH_CANNOT_BE_CLOSED_FOR_THIS_REASON();\\n    error CLOSE_CONDITION_IS_NOT_CORRECT();\\n    error SOLD_ASSET_IS_INCORRECT();\\n\\n    // Price Oracle\\n    error ZERO_EXCHANGE_RATE();\\n    error NO_PRICEFEED_FOUND();\\n    error NO_PRICE_DROP_FEED_FOUND();\\n\\n    //DNS\\n    error INCORRECT_FEE_RATE();\\n    error INCORRECT_RESTRICTIONS();\\n    error BUCKET_ALREADY_FROZEN();\\n    error BUCKET_IS_ALREADY_ADDED();\\n    error DEX_IS_ALREADY_ACTIVATED();\\n    error DEX_IS_ALREADY_FROZEN();\\n    error DEX_IS_ALREADY_ADDED();\\n    error BUCKET_NOT_ADDED();\\n    error DEX_NOT_ACTIVE();\\n    error BUCKET_ALREADY_ACTIVATED();\\n    error DEX_NOT_ADDED();\\n    error BUCKET_IS_INACTIVE();\\n    error WITHDRAWAL_NOT_ALLOWED();\\n    error BUCKET_IS_ALREADY_DEPRECATED();\\n\\n    // Primex upkeep\\n    error NUMBER_IS_0();\\n\\n    //referral program, WhiteBlackList\\n    error CALLER_ALREADY_REGISTERED();\\n    error MISMATCH();\\n    error PARENT_NOT_WHITELISTED();\\n    error ADDRESS_ALREADY_WHITELISTED();\\n    error ADDRESS_ALREADY_BLACKLISTED();\\n    error ADDRESS_NOT_BLACKLISTED();\\n    error ADDRESS_NOT_WHITELISTED();\\n    error ADDRESS_NOT_UNLISTED();\\n    error ADDRESS_IS_WHITELISTED();\\n    error ADDRESS_IS_NOT_CONTRACT();\\n\\n    //Reserve\\n    error BURN_AMOUNT_IS_ZERO();\\n    error CALLER_IS_NOT_EXECUTOR();\\n    error ADDRESS_NOT_PRIMEX_BUCKET();\\n    error NOT_SUFFICIENT_RESERVE_BALANCE();\\n    error INCORRECT_TRANSFER_RESTRICTIONS();\\n\\n    //Vault\\n    error AMOUNT_EXCEEDS_AVAILABLE_BALANCE();\\n    error INSUFFICIENT_FREE_ASSETS();\\n    error CALLER_IS_NOT_SPENDER();\\n\\n    //Pricing Library\\n    error IDENTICAL_ASSETS();\\n    error SUM_OF_SHARES_SHOULD_BE_GREATER_THAN_ZERO();\\n    error DIFFERENT_PRICE_DEX_AND_ORACLE();\\n    error TAKE_PROFIT_IS_LTE_LIMIT_PRICE();\\n    error STOP_LOSS_IS_GTE_LIMIT_PRICE();\\n    error STOP_LOSS_IS_LTE_LIQUIDATION_PRICE();\\n    error INSUFFICIENT_POSITION_SIZE();\\n    error INCORRECT_PATH();\\n    error DEPOSITED_TO_BORROWED_ROUTES_LENGTH_SHOULD_BE_0();\\n    error INCORRECT_CM_TYPE();\\n    error FEE_RATE_IN_NATIVE_IS_ZERO();\\n\\n    // Token transfers\\n    error TOKEN_TRANSFER_IN_FAILED();\\n    error TOKEN_TRANSFER_IN_OVERFLOW();\\n    error TOKEN_TRANSFER_OUT_FAILED();\\n    error NATIVE_TOKEN_TRANSFER_FAILED();\\n\\n    // Conditional Managers\\n    error LOW_PRICE_ROUND_IS_LESS_HIGH_PRICE_ROUND();\\n    error TRAILING_DELTA_IS_INCORRECT();\\n    error DATA_FOR_ROUND_DOES_NOT_EXIST();\\n    error HIGH_PRICE_TIMESTAMP_IS_INCORRECT();\\n    error NO_PRICE_FEED_INTERSECTION();\\n    error SHOULD_BE_CCM();\\n    error SHOULD_BE_COM();\\n\\n    //Lens\\n    error DEPOSITED_AMOUNT_IS_0();\\n    error SPOT_DEPOSITED_ASSET_SHOULD_BE_EQUAL_BORROWED_ASSET();\\n    error ZERO_ASSET_ADDRESS();\\n    error ASSETS_SHOULD_BE_DIFFERENT();\\n    error ZERO_SHARES();\\n    error SHARES_AMOUNT_IS_GREATER_THAN_AMOUNT_TO_SELL();\\n    error NO_ACTIVE_DEXES();\\n\\n    //Bots\\n    error WRONG_BALANCES();\\n    error INVALID_INDEX();\\n    error INVALID_DIVIDER();\\n    error ARRAYS_LENGTHS_IS_NOT_EQUAL();\\n    error DENOMINATOR_IS_0();\\n\\n    //DexAdapter\\n    error ZERO_AMOUNT_IN();\\n    error ZERO_AMOUNT();\\n    error UNKNOWN_DEX_TYPE();\\n    error REVERTED_WITHOUT_A_STRING_TRY_TO_CHECK_THE_ANCILLARY_DATA();\\n    error DELTA_OF_TOKEN_OUT_HAS_POSITIVE_VALUE();\\n    error DELTA_OF_TOKEN_IN_HAS_NEGATIVE_VALUE();\\n    error QUOTER_IS_NOT_PROVIDED();\\n    error DEX_ROUTER_NOT_SUPPORTED();\\n    error QUOTER_NOT_SUPPORTED();\\n    error SWAP_DEADLINE_PASSED();\\n\\n    //SpotTradingRewardDistributor\\n    error PERIOD_DURATION_IS_ZERO();\\n    error REWARD_AMOUNT_IS_ZERO();\\n    error REWARD_PER_PERIOD_IS_NOT_CORRECT();\\n\\n    //ActivityRewardDistributor\\n    error TOTAL_REWARD_AMOUNT_IS_ZERO();\\n    error REWARD_PER_DAY_IS_NOT_CORRECT();\\n    error ZERO_BUCKET_ADDRESS();\\n    //KeeperRewardDistributor\\n    error INCORRECT_PART_IN_REWARD();\\n    error INCORRECT_MULTIPLIER();\\n\\n    //Treasury\\n    error TRANSFER_RESTRICTIONS_NOT_MET();\\n    error INSUFFICIENT_NATIVE_TOKEN_BALANCE();\\n    error INSUFFICIENT_TOKEN_BALANCE();\\n    error EXCEEDED_MAX_AMOUNT_DURING_TIMEFRAME();\\n    error EXCEEDED_MAX_SPENDING_LIMITS();\\n    error SPENDING_LIMITS_ARE_INCORRECT();\\n    error SPENDER_IS_NOT_EXIST();\\n}\\n\",\"keccak256\":\"0xdefed1730079812b35863325fa1451cd220f15f8d26af3cd218e579567a8d65f\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/LimitOrderLibrary.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport {WadRayMath} from \\\"./utils/WadRayMath.sol\\\";\\n\\nimport {PrimexPricingLibrary} from \\\"./PrimexPricingLibrary.sol\\\";\\nimport {TokenTransfersLibrary} from \\\"./TokenTransfersLibrary.sol\\\";\\n\\nimport {NATIVE_CURRENCY} from \\\"../Constants.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IPrimexDNSStorage} from \\\"../PrimexDNS/IPrimexDNSStorage.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IBucket} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IConditionalOpeningManager} from \\\"../interfaces/IConditionalOpeningManager.sol\\\";\\nimport {IConditionalClosingManager} from \\\"../interfaces/IConditionalClosingManager.sol\\\";\\nimport {IPositionManager} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {ISwapManager} from \\\"../interfaces/ISwapManager.sol\\\";\\n\\nimport \\\"./Errors.sol\\\";\\n\\nlibrary LimitOrderLibrary {\\n    using WadRayMath for uint256;\\n\\n    enum CloseReason {\\n        FilledMargin,\\n        FilledSpot,\\n        FilledSwap,\\n        Cancelled\\n    }\\n\\n    struct Condition {\\n        uint256 managerType;\\n        bytes params;\\n    }\\n\\n    /**\\n     * @dev Creates a limit order and locks the deposit asset in the traderBalanceVault\\n     * @param bucket The bucket, from which the loan will be taken\\n     * @param positionAsset The address of output token for exchange\\n     * @param depositAsset The address of the deposit token\\n     * @param depositAmount The amount of deposit trader funds for deal\\n     * @param feeToken An asset in which the fee will be paid. At this point it could be the pmx, the epmx or a native currency\\n     * @param trader The trader, who has created the order\\n     * @param deadline Unix timestamp after which the order will not be filled\\n     * @param id The unique id of the order\\n     * @param leverage leverage for trading\\n     * @param shouldOpenPosition The flag to indicate whether position should be opened\\n     * @param createdAt The timeStamp when the order was created\\n     * @param updatedConditionsAt The timestamp when the open condition was updated\\n     */\\n    struct LimitOrder {\\n        IBucket bucket;\\n        address positionAsset;\\n        address depositAsset;\\n        uint256 depositAmount;\\n        address feeToken;\\n        uint256 protocolFee;\\n        address trader;\\n        uint256 deadline;\\n        uint256 id;\\n        uint256 leverage;\\n        bool shouldOpenPosition;\\n        uint256 createdAt;\\n        uint256 updatedConditionsAt;\\n        // The byte-encoded params, can be used for future updates\\n        bytes extraParams;\\n    }\\n\\n    /**\\n     * @dev Structure for the \\u0441reateLimitOrder with parameters necessary to create limit order\\n     * @param bucket The bucket, from which the loan will be taken\\n     * @param depositAsset The address of the deposit token (collateral for margin trade or\\n     * locked funds for spot)\\n     * @param depositAmount The amount of deposit funds for deal\\n     * @param positionAsset The address output token for exchange\\n     * @param deadline Unix timestamp after which the order will not be filled\\n     * @param takeDepositFromWallet Bool, add a collateral deposit within the current transaction\\n     * @param leverage leverage for trading\\n     * @param shouldOpenPosition Bool, indicate whether position should be opened\\n     * @param openingManagerAddresses Array of contract addresses that will be called in canBeFilled\\n     * @param openingManagerParams Array of bytes representing params for contracts in openingManagerAddresses\\n     * @param closingManagerAddresses Array of contract addresses that will be called in canBeClosed\\n     * @param closingManagerParams Array of bytes representing params for contracts in closingManagerAddresses\\n     */\\n    struct CreateLimitOrderParams {\\n        string bucket;\\n        uint256 depositAmount;\\n        address depositAsset;\\n        address positionAsset;\\n        uint256 deadline;\\n        bool takeDepositFromWallet;\\n        bool payFeeFromWallet;\\n        uint256 leverage;\\n        bool shouldOpenPosition;\\n        Condition[] openConditions;\\n        Condition[] closeConditions;\\n        bool isProtocolFeeInPmx;\\n    }\\n\\n    struct CreateLimitOrderVars {\\n        bool isSpot;\\n        IBucket bucket;\\n        uint256 positionSize;\\n        address priceOracle;\\n        uint256 rate;\\n        address feeToken;\\n    }\\n\\n    /**\\n     * @dev Opens a position on an existing order\\n     * @param orderId order id\\n     * @param com address of ConditionalOpeningManager\\n     * @param comAdditionalParams  params needed for ConditionalOpeningManager to calc canBeFilled\\n     * @param firstAssetRoutes routes to swap first asset\\n     * @param depositInThirdAssetRoutes routes to swap deposit asset\\n     */\\n    struct OpenPositionParams {\\n        uint256 orderId;\\n        uint256 conditionIndex;\\n        bytes comAdditionalParams;\\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\\n        address keeper;\\n    }\\n\\n    struct OpenPositionByOrderVars {\\n        address assetIn;\\n        address assetOut;\\n        uint256 amountIn;\\n        uint256 amountOut;\\n        CloseReason closeReason;\\n        uint256 newPositionId;\\n        uint256 exchangeRate;\\n    }\\n\\n    /**\\n     * @dev Params for PositionManager to open position\\n     * @param order order\\n     * @param firstAssetRoutes routes to swap first asset on dex\\n     * (borrowedAmount + depositAmount if deposit in borrowedAsset)\\n     * @param depositInThirdAssetRoutes routes to swap deposit in third asset on dex\\n     */\\n    struct OpenPositionByOrderParams {\\n        address sender;\\n        LimitOrder order;\\n        Condition[] closeConditions;\\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\\n    }\\n\\n    /**\\n     * @dev Structure for the updateOrder with parameters necessary to update limit order\\n     * @param orderId order id to update\\n     * @param depositAmount The amount of deposit funds for deal\\n     * @param makeDeposit Bool, add a collateral deposit within the current transaction\\n     * @param leverage leverage for trading\\n     * @param takeDepositFromWallet Bool, add a collateral deposit within the current transaction\\n     * @param payFeeFromWallet A flag indicating whether the Limit Order fee is perfomed from a wallet or a protocol balance.\\n     */\\n    struct UpdateLimitOrderParams {\\n        uint256 orderId;\\n        uint256 depositAmount;\\n        uint256 leverage;\\n        bool isProtocolFeeInPmx;\\n        bool takeDepositFromWallet;\\n        bool payFeeFromWallet;\\n    }\\n\\n    /**\\n     * @notice Updates the protocol fee for a LimitOrder.\\n     * @param _order The LimitOrder storage object to update.\\n     * @param _params The new parameters for the LimitOrder.\\n     * @param _traderBalanceVault The instance of the TraderBalanceVault contract.\\n     * @param _primexDNS The PrimexDNS contract for accessing PMX-related information.\\n     * @param _priceOracle The address of the price oracle contract.\\n     */\\n    function updateProtocolFee(\\n        LimitOrder storage _order,\\n        UpdateLimitOrderParams calldata _params,\\n        ITraderBalanceVault _traderBalanceVault,\\n        IPrimexDNS _primexDNS,\\n        address _priceOracle\\n    ) public {\\n        address feeToken;\\n        if (_params.isProtocolFeeInPmx) {\\n            feeToken = _primexDNS.pmx();\\n            _require(msg.value == 0, Errors.DISABLED_TRANSFER_NATIVE_CURRENCY.selector);\\n        } else {\\n            feeToken = NATIVE_CURRENCY;\\n        }\\n        if (\\n            _params.leverage != _order.leverage ||\\n            _params.depositAmount != _order.depositAmount ||\\n            feeToken != _order.feeToken\\n        ) {\\n            uint256 newProtocolFee = PrimexPricingLibrary.calculateProtocolFee(\\n                PrimexPricingLibrary.DepositData({\\n                    protocolFee: 0,\\n                    depositAsset: _order.depositAsset,\\n                    depositAmount: _params.depositAmount,\\n                    leverage: _params.leverage\\n                }),\\n                _primexDNS,\\n                _priceOracle,\\n                _order.shouldOpenPosition\\n                    ? IPrimexDNSStorage.OrderType.LIMIT_ORDER\\n                    : IPrimexDNSStorage.OrderType.SWAP_LIMIT_ORDER,\\n                feeToken\\n            );\\n            if (feeToken == _order.feeToken) {\\n                uint256 amount;\\n                unchecked {\\n                    if (newProtocolFee > _order.protocolFee) amount = newProtocolFee - _order.protocolFee;\\n                    else amount = _order.protocolFee - newProtocolFee;\\n                }\\n                depositLockOrUnlock(\\n                    _traderBalanceVault,\\n                    feeToken,\\n                    amount,\\n                    _params.payFeeFromWallet,\\n                    newProtocolFee > _order.protocolFee\\n                );\\n            } else {\\n                if (newProtocolFee > 0) {\\n                    //lock the new fee token\\n                    depositLockOrUnlock(_traderBalanceVault, feeToken, newProtocolFee, _params.payFeeFromWallet, true);\\n                }\\n                //unlock the old fee token\\n                depositLockOrUnlock(\\n                    _traderBalanceVault,\\n                    _order.feeToken,\\n                    _order.protocolFee,\\n                    _params.payFeeFromWallet,\\n                    false\\n                );\\n                _order.feeToken = feeToken;\\n            }\\n            _order.protocolFee = newProtocolFee;\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates the leverage of a limit order.\\n     * @param _order The limit order to update.\\n     * @param _leverage The new leverage value in WAD format for the order.\\n     */\\n    function updateLeverage(LimitOrder storage _order, uint256 _leverage) public {\\n        _require(_leverage > WadRayMath.WAD, Errors.LEVERAGE_MUST_BE_MORE_THAN_1.selector);\\n        _require(_order.leverage != WadRayMath.WAD, Errors.CANNOT_CHANGE_SPOT_ORDER_TO_MARGIN.selector);\\n\\n        _require(\\n            _leverage < _order.bucket.maxAssetLeverage(_order.positionAsset),\\n            Errors.LEVERAGE_EXCEEDS_MAX_LEVERAGE.selector\\n        );\\n        _order.leverage = _leverage;\\n    }\\n\\n    /**\\n     * @notice Updates the deposit details of a LimitOrder.\\n     * @param _order The LimitOrder to update.\\n     * @param _amount The amount of the asset being deposited.\\n     * @param _takeDepositFromWallet Boolean indicating whether to make a deposit or unlock the deposited asset.\\n     * @param traderBalanceVault The instance of ITraderBalanceVault used for deposit and unlock operations.\\n     */\\n    function updateDeposit(\\n        LimitOrderLibrary.LimitOrder storage _order,\\n        uint256 _amount,\\n        bool _takeDepositFromWallet,\\n        ITraderBalanceVault traderBalanceVault\\n    ) public {\\n        depositLockOrUnlock(\\n            traderBalanceVault,\\n            _order.depositAsset,\\n            (_amount > _order.depositAmount) ? _amount - _order.depositAmount : _order.depositAmount - _amount,\\n            _takeDepositFromWallet,\\n            _amount > _order.depositAmount\\n        );\\n        _order.depositAmount = _amount;\\n    }\\n\\n    /**\\n     * @notice Sets the open conditions for a LimitOrder.\\n     * @param _order The limit order.\\n     * @param openConditionsMap The mapping of order IDs to open conditions.\\n     * @param openConditions The array of open conditions.\\n     * @param primexDNS The instance of the Primex DNS contract.\\n     */\\n    function setOpenConditions(\\n        LimitOrderLibrary.LimitOrder memory _order,\\n        mapping(uint256 => Condition[]) storage openConditionsMap,\\n        Condition[] memory openConditions,\\n        IPrimexDNS primexDNS\\n    ) public {\\n        _require(hasNoConditionManagerTypeDuplicates(openConditions), Errors.SHOULD_NOT_HAVE_DUPLICATES.selector);\\n        _require(openConditions.length > 0, Errors.SHOULD_HAVE_OPEN_CONDITIONS.selector);\\n        if (openConditionsMap[_order.id].length > 0) {\\n            delete openConditionsMap[_order.id];\\n        }\\n        Condition memory condition;\\n        for (uint256 i; i < openConditions.length; i++) {\\n            condition = openConditions[i];\\n            _require(\\n                IERC165Upgradeable(primexDNS.cmTypeToAddress(condition.managerType)).supportsInterface(\\n                    type(IConditionalOpeningManager).interfaceId\\n                ),\\n                Errors.SHOULD_BE_COM.selector\\n            );\\n            openConditionsMap[_order.id].push(condition);\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the close conditions for a LimitOrder.\\n     * @param _order The limit order.\\n     * @param closeConditionsMap The mapping of order IDs to close conditions.\\n     * @param closeConditions The array of close conditions to set.\\n     * @param primexDNS The Primex DNS contract address.\\n     */\\n    function setCloseConditions(\\n        LimitOrderLibrary.LimitOrder memory _order,\\n        mapping(uint256 => Condition[]) storage closeConditionsMap,\\n        Condition[] memory closeConditions,\\n        IPrimexDNS primexDNS\\n    ) public {\\n        _require(hasNoConditionManagerTypeDuplicates(closeConditions), Errors.SHOULD_NOT_HAVE_DUPLICATES.selector);\\n        _require(\\n            _order.shouldOpenPosition || closeConditions.length == 0,\\n            Errors.SHOULD_NOT_HAVE_CLOSE_CONDITIONS.selector\\n        );\\n\\n        if (closeConditionsMap[_order.id].length > 0) {\\n            delete closeConditionsMap[_order.id];\\n        }\\n        Condition memory condition;\\n        for (uint256 i; i < closeConditions.length; i++) {\\n            condition = closeConditions[i];\\n            _require(\\n                IERC165Upgradeable(primexDNS.cmTypeToAddress(condition.managerType)).supportsInterface(\\n                    type(IConditionalClosingManager).interfaceId\\n                ),\\n                Errors.SHOULD_BE_CCM.selector\\n            );\\n            closeConditionsMap[_order.id].push(condition);\\n        }\\n    }\\n\\n    /**\\n     * @notice Creates a limit order.\\n     * @param _params The struct containing the order parameters.\\n     * @param pm The instance of the PositionManager contract.\\n     * @param traderBalanceVault The instance of the TraderBalanceVault contract.\\n     * @param primexDNS The instance of the PrimexDNS contract.\\n     * @return The created limit order.\\n     */\\n    function createLimitOrder(\\n        CreateLimitOrderParams calldata _params,\\n        IPositionManager pm,\\n        ITraderBalanceVault traderBalanceVault,\\n        IPrimexDNS primexDNS\\n    ) public returns (LimitOrder memory) {\\n        _require(_params.leverage >= WadRayMath.WAD, Errors.INCORRECT_LEVERAGE.selector);\\n        _require(_params.deadline > block.timestamp, Errors.INCORRECT_DEADLINE.selector);\\n\\n        CreateLimitOrderVars memory vars;\\n        vars.isSpot = bytes(_params.bucket).length == 0;\\n        vars.positionSize = _params.depositAmount.wmul(_params.leverage);\\n        vars.priceOracle = address(pm.priceOracle());\\n        if (vars.isSpot) {\\n            _require(_params.leverage == WadRayMath.WAD, Errors.LEVERAGE_SHOULD_BE_1.selector);\\n            _require(_params.depositAsset != _params.positionAsset, Errors.SHOULD_BE_DIFFERENT_ASSETS_IN_SPOT.selector);\\n            IPriceOracle(vars.priceOracle).getPriceFeedsPair(_params.positionAsset, _params.depositAsset);\\n        } else {\\n            _require(_params.shouldOpenPosition, Errors.SHOULD_OPEN_POSITION.selector);\\n            _require(_params.leverage > WadRayMath.WAD, Errors.LEVERAGE_MUST_BE_MORE_THAN_1.selector);\\n            vars.bucket = IBucket(primexDNS.getBucketAddress(_params.bucket));\\n            _require(vars.bucket.getLiquidityMiningParams().isBucketLaunched, Errors.BUCKET_IS_NOT_LAUNCHED.selector);\\n\\n            (, bool tokenAllowed) = vars.bucket.allowedAssets(_params.positionAsset);\\n            _require(tokenAllowed, Errors.TOKEN_NOT_SUPPORTED.selector);\\n            _require(\\n                _params.leverage < vars.bucket.maxAssetLeverage(_params.positionAsset),\\n                Errors.LEVERAGE_EXCEEDS_MAX_LEVERAGE.selector\\n            );\\n        }\\n        LimitOrder memory order = LimitOrder({\\n            bucket: IBucket(address(0)),\\n            positionAsset: _params.positionAsset,\\n            depositAsset: _params.depositAsset,\\n            depositAmount: _params.depositAmount,\\n            feeToken: _params.isProtocolFeeInPmx ? primexDNS.pmx() : NATIVE_CURRENCY,\\n            protocolFee: 0,\\n            trader: msg.sender,\\n            deadline: _params.deadline,\\n            id: 0,\\n            leverage: _params.leverage,\\n            shouldOpenPosition: _params.shouldOpenPosition,\\n            createdAt: block.timestamp,\\n            updatedConditionsAt: block.timestamp,\\n            extraParams: \\\"\\\"\\n        });\\n        order.bucket = vars.bucket;\\n\\n        PrimexPricingLibrary.validateMinPositionSize(\\n            pm.minPositionSize(),\\n            pm.minPositionAsset(),\\n            vars.positionSize,\\n            order.depositAsset,\\n            vars.priceOracle\\n        );\\n        if (_params.isProtocolFeeInPmx) {\\n            vars.feeToken = primexDNS.pmx();\\n            _require(msg.value == 0, Errors.DISABLED_TRANSFER_NATIVE_CURRENCY.selector);\\n        } else {\\n            vars.feeToken = NATIVE_CURRENCY;\\n        }\\n\\n        order.protocolFee = PrimexPricingLibrary.calculateProtocolFee(\\n            PrimexPricingLibrary.DepositData({\\n                protocolFee: 0,\\n                depositAsset: _params.depositAsset,\\n                depositAmount: _params.depositAmount,\\n                leverage: _params.leverage\\n            }),\\n            primexDNS,\\n            vars.priceOracle,\\n            order.shouldOpenPosition\\n                ? IPrimexDNSStorage.OrderType.LIMIT_ORDER\\n                : IPrimexDNSStorage.OrderType.SWAP_LIMIT_ORDER,\\n            vars.feeToken\\n        );\\n\\n        if (order.protocolFee > 0) {\\n            // fee locking\\n            depositLockOrUnlock(traderBalanceVault, vars.feeToken, order.protocolFee, _params.payFeeFromWallet, true);\\n        }\\n        // deposit locking\\n        depositLockOrUnlock(\\n            traderBalanceVault,\\n            order.depositAsset,\\n            order.depositAmount,\\n            _params.takeDepositFromWallet,\\n            true\\n        );\\n\\n        return order;\\n    }\\n\\n    /**\\n     * @notice Opens a position by order.\\n     * @param order The LimitOrder storage containing order details.\\n     * @param _params The OpenPositionParams calldata containing additional position parameters.\\n     * @param _closeConditions The Condition array containing close conditions for the position.\\n     * @param pm The instance of the PositionManager contract.\\n     * @param traderBalanceVault The instance of the TraderBalanceVault contract.\\n     * @param primexDNS The instance of the PrimexDNS contract.\\n     * @param swapManager The instance of the SwapManager contract.\\n     * @return vars The OpenPositionByOrderVars struct containing the result of the open position operation.\\n     */\\n    function openPositionByOrder(\\n        LimitOrder storage order,\\n        OpenPositionParams calldata _params,\\n        Condition[] memory _closeConditions,\\n        IPositionManager pm,\\n        ITraderBalanceVault traderBalanceVault,\\n        IPrimexDNS primexDNS,\\n        ISwapManager swapManager\\n    ) public returns (OpenPositionByOrderVars memory) {\\n        OpenPositionByOrderVars memory vars;\\n        bool isSpot = address(order.bucket) == address(0);\\n\\n        if (order.shouldOpenPosition) {\\n            vars.closeReason = isSpot ? CloseReason.FilledSpot : CloseReason.FilledMargin;\\n            (vars.amountIn, vars.amountOut, vars.newPositionId, vars.exchangeRate) = pm.openPositionByOrder(\\n                OpenPositionByOrderParams({\\n                    sender: msg.sender,\\n                    order: order,\\n                    closeConditions: _closeConditions,\\n                    firstAssetRoutes: _params.firstAssetRoutes,\\n                    depositInThirdAssetRoutes: _params.depositInThirdAssetRoutes\\n                })\\n            );\\n        } else {\\n            _require(\\n                _params.depositInThirdAssetRoutes.length == 0,\\n                Errors.DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0.selector\\n            );\\n            vars.closeReason = CloseReason.FilledSwap;\\n            vars.amountIn = order.depositAmount;\\n\\n            // calculateFee is false so 'depositData' and 'priceOracle' are default values except 'protocolFee'\\n            PrimexPricingLibrary.payProtocolFee(\\n                PrimexPricingLibrary.ProtocolFeeParams({\\n                    depositData: PrimexPricingLibrary.DepositData({\\n                        protocolFee: order.protocolFee,\\n                        depositAsset: address(0),\\n                        depositAmount: 0,\\n                        leverage: 0\\n                    }),\\n                    feeToken: order.feeToken,\\n                    isSwapFromWallet: false,\\n                    calculateFee: false,\\n                    orderType: IPrimexDNSStorage.OrderType.SWAP_LIMIT_ORDER,\\n                    trader: order.trader,\\n                    priceOracle: address(0),\\n                    traderBalanceVault: traderBalanceVault,\\n                    primexDNS: primexDNS\\n                })\\n            );\\n\\n            traderBalanceVault.unlockAsset(\\n                ITraderBalanceVault.UnlockAssetParams({\\n                    trader: order.trader,\\n                    receiver: address(this),\\n                    asset: order.depositAsset,\\n                    amount: order.depositAmount\\n                })\\n            );\\n\\n            vars.amountOut = swapManager.swap(\\n                ISwapManager.SwapParams({\\n                    tokenA: order.depositAsset,\\n                    tokenB: order.positionAsset,\\n                    amountTokenA: order.depositAmount,\\n                    amountOutMin: 0,\\n                    routes: _params.firstAssetRoutes,\\n                    receiver: order.trader,\\n                    deadline: order.deadline,\\n                    isSwapFromWallet: false,\\n                    isSwapToWallet: false,\\n                    isSwapFeeInPmx: false,\\n                    payFeeFromWallet: false\\n                }),\\n                pm.getOracleTolerableLimit(order.depositAsset, order.positionAsset),\\n                true\\n            );\\n            uint256 multiplierDepositAsset = 10 ** (18 - IERC20Metadata(order.depositAsset).decimals());\\n            uint256 multiplierPositionAsset = 10 ** (18 - IERC20Metadata(order.positionAsset).decimals());\\n            vars.exchangeRate =\\n                (vars.amountIn * multiplierDepositAsset).wdiv(vars.amountOut * multiplierPositionAsset) /\\n                multiplierDepositAsset;\\n        }\\n\\n        vars.assetIn = isSpot ? order.depositAsset : address(order.bucket.borrowedAsset());\\n        vars.assetOut = order.positionAsset;\\n        return vars;\\n    }\\n\\n    /**\\n     * @notice Checks if an array of Condition structs has no duplicate manager types.\\n     * @param conditions The array of Condition structs to be checked.\\n     * @return bool Boolean value indicating whether the array has no duplicate manager types.\\n     */\\n    function hasNoConditionManagerTypeDuplicates(Condition[] memory conditions) public pure returns (bool) {\\n        if (conditions.length == 0) {\\n            return true;\\n        }\\n        for (uint256 i; i < conditions.length - 1; i++) {\\n            for (uint256 j = i + 1; j < conditions.length; j++) {\\n                if (conditions[i].managerType == conditions[j].managerType) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice This function is used to either deposit or unlock assets in the trader balance vault.\\n     * @param traderBalanceVault The instance of the trader balance vault.\\n     * @param _depositAsset The address of the asset to be deposited or unlocked.\\n     * @param _amount The amount of the asset to be deposited or unlocked.\\n     * @param _takeDepositFromWallet Boolean indicating whether to make a deposit or not.\\n     * @param _isAdd Boolean indicating whether to lock or unlock asset. Should lock asset, if true.\\n     */\\n    function depositLockOrUnlock(\\n        ITraderBalanceVault traderBalanceVault,\\n        address _depositAsset,\\n        uint256 _amount,\\n        bool _takeDepositFromWallet,\\n        bool _isAdd\\n    ) internal {\\n        if (!_isAdd) {\\n            traderBalanceVault.unlockAsset(\\n                ITraderBalanceVault.UnlockAssetParams(msg.sender, msg.sender, _depositAsset, _amount)\\n            );\\n            return;\\n        }\\n        if (_takeDepositFromWallet) {\\n            if (_depositAsset == NATIVE_CURRENCY) {\\n                _require(msg.value >= _amount, Errors.INSUFFICIENT_DEPOSIT.selector);\\n                traderBalanceVault.increaseLockedBalance{value: _amount}(msg.sender, _depositAsset, _amount);\\n                if (msg.value > _amount) {\\n                    uint256 rest = msg.value - _amount;\\n                    traderBalanceVault.topUpAvailableBalance{value: rest}(msg.sender, NATIVE_CURRENCY, rest);\\n                }\\n                return;\\n            }\\n            TokenTransfersLibrary.doTransferFromTo(_depositAsset, msg.sender, address(traderBalanceVault), _amount);\\n            traderBalanceVault.increaseLockedBalance(msg.sender, _depositAsset, _amount);\\n            return;\\n        }\\n        traderBalanceVault.useTraderAssets(\\n            ITraderBalanceVault.LockAssetParams(\\n                msg.sender,\\n                address(0),\\n                _depositAsset,\\n                _amount,\\n                ITraderBalanceVault.OpenType.CREATE_LIMIT_ORDER\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x809b1633cb9f2bee008b2cdcab6900a977ce546b7bcb8c4d3cc3db73ee8ae681\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/PositionLibrary.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport {WadRayMath} from \\\"./utils/WadRayMath.sol\\\";\\n\\nimport {PrimexPricingLibrary} from \\\"./PrimexPricingLibrary.sol\\\";\\nimport {TokenTransfersLibrary} from \\\"./TokenTransfersLibrary.sol\\\";\\nimport {LimitOrderLibrary} from \\\"./LimitOrderLibrary.sol\\\";\\nimport \\\"./Errors.sol\\\";\\n\\nimport {NATIVE_CURRENCY} from \\\"../Constants.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {IPrimexDNS} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IPrimexDNSStorage} from \\\"../PrimexDNS/IPrimexDNSStorage.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IBucket} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IConditionalClosingManager} from \\\"../interfaces/IConditionalClosingManager.sol\\\";\\nimport {ITakeProfitStopLossCCM} from \\\"../interfaces/ITakeProfitStopLossCCM.sol\\\";\\nimport {IKeeperRewardDistributorStorage} from \\\"../KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\\\";\\n\\nlibrary PositionLibrary {\\n    using WadRayMath for uint256;\\n\\n    event ClosePosition(\\n        uint256 indexed positionId,\\n        address indexed trader,\\n        address indexed closedBy,\\n        address bucketAddress,\\n        address soldAsset,\\n        address positionAsset,\\n        uint256 decreasePositionAmount,\\n        int256 profit,\\n        uint256 positionDebt,\\n        uint256 amountOut,\\n        PositionLibrary.CloseReason reason\\n    );\\n\\n    /**\\n     * @notice This struct represents a trading position\\n     * @param id unique identifier for the position\\n     * @param scaledDebtAmount scaled debt amount associated with the position\\n     * @param bucket instance of the Bucket associated for trading\\n     * @param soldAsset bucket asset in the case of margin trading or deposit asset in the case of spot trading\\n     * @param depositAmountInSoldAsset equivalent of trader deposit size (this deposit can be in any asset) in the sold asset\\n     * or just deposit amount for spot trading\\n     * @param positionAsset asset of the trading position\\n     * @param positionAmount amount of the trading position\\n     * @param trader address of the trader holding the position\\n     * @param openBorrowIndex variable borrow index when position was opened\\n     * @param createdAt timestamp when the position was created\\n     * @param updatedConditionsAt timestamp when the close condition was updated\\n     * @param extraParams byte-encoded params, can be used for future updates\\n     */\\n    struct Position {\\n        uint256 id;\\n        uint256 scaledDebtAmount;\\n        IBucket bucket;\\n        address soldAsset;\\n        uint256 depositAmountInSoldAsset;\\n        address positionAsset;\\n        uint256 positionAmount;\\n        address trader;\\n        uint256 openBorrowIndex;\\n        uint256 createdAt;\\n        uint256 updatedConditionsAt;\\n        bytes extraParams;\\n    }\\n\\n    struct IncreaseDepositParams {\\n        uint256 amount;\\n        address asset;\\n        bool takeDepositFromWallet;\\n        PrimexPricingLibrary.Route[] routes;\\n        IPrimexDNS primexDNS;\\n        IPriceOracle priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n        uint256 amountOutMin;\\n    }\\n\\n    struct DecreaseDepositParams {\\n        uint256 amount;\\n        IPrimexDNS primexDNS;\\n        IPriceOracle priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n        uint256 pairPriceDrop;\\n        uint256 securityBuffer;\\n        uint256 oracleTolerableLimit;\\n        uint256 maintenanceBuffer;\\n    }\\n\\n    struct MultiSwapParams {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amountTokenA;\\n        PrimexPricingLibrary.Route[] routes;\\n        address receiver;\\n        uint256 deadline;\\n        bool takeDepositFromWallet;\\n        IPrimexDNS primexDNS;\\n        IPriceOracle priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n    }\\n\\n    struct ClosePositionParams {\\n        uint256 closeAmount;\\n        uint256 depositDecrease;\\n        uint256 scaledDebtAmount;\\n        address depositReceiver;\\n        PrimexPricingLibrary.Route[] routes;\\n        uint256 amountOutMin;\\n        uint256 oracleTolerableLimit;\\n        IPrimexDNS primexDNS;\\n        IPriceOracle priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n        LimitOrderLibrary.Condition closeCondition;\\n        bytes ccmAdditionalParams;\\n        bool borrowedAmountIsNotZero;\\n        uint256 pairPriceDrop;\\n        uint256 securityBuffer;\\n        bool needOracleTolerableLimitCheck;\\n    }\\n\\n    struct ClosePositionVars {\\n        address dexAdapter;\\n        uint256 borowedAssetAmount;\\n        uint256 amountToReturn;\\n        uint256 permanentLoss;\\n        uint256 fee;\\n    }\\n\\n    struct ClosePositionEventData {\\n        int256 profit;\\n        uint256 debtAmount;\\n        uint256 amountOut;\\n        IKeeperRewardDistributorStorage.KeeperActionType actionType;\\n    }\\n\\n    struct OpenPositionVars {\\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\\n        PrimexPricingLibrary.DepositData depositData;\\n        address feeToken;\\n        uint256 borrowedAmount;\\n        uint256 amountOutMin;\\n        uint256 deadline;\\n        bool isSpot;\\n        bool isThirdAsset;\\n        bool takeDepositFromWallet;\\n        bool payFeeFromWallet;\\n        bool byOrder;\\n        address sender;\\n        LimitOrderLibrary.Condition[] closeConditions;\\n        bool needOracleTolerableLimitCheck;\\n    }\\n\\n    struct OpenPositionEventData {\\n        uint256 protocolFee;\\n        uint256 entryPrice;\\n        uint256 leverage;\\n    }\\n\\n    /**\\n     * The struct for openPosition function local vars\\n     */\\n    struct OpenPositionLocalData {\\n        uint256 amountToTransfer;\\n        address dexAdapter;\\n        address depositReceiver;\\n        uint256 depositInPositionAsset;\\n        bool isSpot;\\n    }\\n\\n    /**\\n     * @dev Structure for the OpenPositionParams when margin trading is activated\\n     * @param bucket The bucket, from which the loan will be taken\\n     * @param borrowedAmount The amount of tokens borrowed to be exchanged\\n     * @param depositInThirdAssetRoutes routes to swap deposit in third asset on dex\\n     */\\n    struct OpenPositionMarginParams {\\n        string bucket;\\n        uint256 borrowedAmount;\\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\\n    }\\n\\n    /**\\n     * @dev Structure for the openPosition with parameters necessary to open a position\\n     * @param marginParams margin trading related params\\n     * @param firstAssetRoutes routes to swap first asset on dex\\n     * (borrowedAmount + depositAmount if deposit in borrowedAsset)\\n     * @param depositAsset The address of the deposit token (collateral for margin trade or\\n     * locked funds for spot)\\n     * @param depositAmount The amount of deposit funds for deal\\n     * @param positionAsset The address output token for exchange\\n     * @param amountOutMin The minimum amount of output tokens\\n     * that must be received for the transaction not to revert.\\n     * @param deadline Unix timestamp after which the transaction will revert.\\n     * @param takeDepositFromWallet Bool, add a deposit within the current transaction\\n     * @param payFeeFromWallet Bool, add a fee  within the current transaction\\n     * @param closeConditions Array of conditions that position can be closed by\\n     */\\n    struct OpenPositionParams {\\n        OpenPositionMarginParams marginParams;\\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\\n        address depositAsset;\\n        uint256 depositAmount;\\n        address positionAsset;\\n        uint256 amountOutMin;\\n        uint256 deadline;\\n        bool takeDepositFromWallet;\\n        bool payFeeFromWallet;\\n        bool isProtocolFeeInPmx;\\n        LimitOrderLibrary.Condition[] closeConditions;\\n    }\\n    struct PositionManagerParams {\\n        IPrimexDNS primexDNS;\\n        IPriceOracle priceOracle;\\n        ITraderBalanceVault traderBalanceVault;\\n        uint256 oracleTolerableLimit;\\n        uint256 oracleTolerableLimitForThirdAsset;\\n        uint256 minPositionSize;\\n        address minPositionAsset;\\n        uint256 maxPositionSize;\\n    }\\n\\n    struct ScaledParams {\\n        uint256 decreasePercent;\\n        uint256 scaledDebtAmount;\\n        uint256 depositDecrease;\\n        bool borrowedAmountIsNotZero;\\n    }\\n\\n    enum CloseReason {\\n        CLOSE_BY_TRADER,\\n        RISKY_POSITION,\\n        BUCKET_DELISTED,\\n        LIMIT_CONDITION,\\n        BATCH_LIQUIDATION,\\n        BATCH_STOP_LOSS,\\n        BATCH_TAKE_PROFIT\\n    }\\n\\n    /**\\n     * @dev Increases the deposit amount for a position.\\n     * @param position The storage reference to the position.\\n     * @param params The parameters for increasing the deposit.\\n     * @return The amount of trader debtTokens burned.\\n     */\\n    function increaseDeposit(Position storage position, IncreaseDepositParams memory params) public returns (uint256) {\\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\\n        _require(position.scaledDebtAmount != 0, Errors.BORROWED_AMOUNT_IS_ZERO.selector);\\n        address borrowedAsset = position.soldAsset;\\n\\n        uint256 depositAmountInBorrowed;\\n        address depositReceiver = params.primexDNS.dexAdapter();\\n        if (params.asset == borrowedAsset) {\\n            depositReceiver = address(position.bucket);\\n            depositAmountInBorrowed = params.amount;\\n        }\\n\\n        if (params.takeDepositFromWallet) {\\n            TokenTransfersLibrary.doTransferFromTo(params.asset, msg.sender, depositReceiver, params.amount);\\n        } else {\\n            params.traderBalanceVault.useTraderAssets(\\n                ITraderBalanceVault.LockAssetParams(\\n                    msg.sender,\\n                    depositReceiver,\\n                    params.asset,\\n                    params.amount,\\n                    ITraderBalanceVault.OpenType.OPEN\\n                )\\n            );\\n        }\\n\\n        if (params.asset != borrowedAsset) {\\n            depositAmountInBorrowed = PrimexPricingLibrary.multiSwap(\\n                PrimexPricingLibrary.MultiSwapParams({\\n                    tokenA: params.asset,\\n                    tokenB: borrowedAsset,\\n                    amountTokenA: params.amount,\\n                    routes: params.routes,\\n                    dexAdapter: params.primexDNS.dexAdapter(),\\n                    receiver: address(position.bucket),\\n                    deadline: block.timestamp\\n                }),\\n                0,\\n                address(params.primexDNS),\\n                address(params.priceOracle),\\n                false // don't need oracle check. add amountOutMin?\\n            );\\n            _require(depositAmountInBorrowed >= params.amountOutMin, Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector);\\n        }\\n\\n        uint256 debt = getDebt(position);\\n        uint256 amountToTrader;\\n        uint256 debtToBurn = depositAmountInBorrowed;\\n\\n        if (depositAmountInBorrowed >= debt) {\\n            amountToTrader = depositAmountInBorrowed - debt;\\n            debtToBurn = debt;\\n            position.scaledDebtAmount = 0;\\n            if (amountToTrader > 0)\\n                params.traderBalanceVault.topUpAvailableBalance(position.trader, borrowedAsset, amountToTrader);\\n        } else {\\n            position.scaledDebtAmount =\\n                position.scaledDebtAmount -\\n                debtToBurn.rdiv(position.bucket.getNormalizedVariableDebt());\\n        }\\n\\n        position.depositAmountInSoldAsset += debtToBurn;\\n\\n        position.bucket.decreaseTraderDebt(\\n            position.trader,\\n            debtToBurn,\\n            address(params.traderBalanceVault),\\n            amountToTrader,\\n            0\\n        );\\n        return debtToBurn;\\n    }\\n\\n    /**\\n     * @dev Decreases the deposit amount for a position.\\n     * @param position The storage reference to the position.\\n     * @param params The parameters for the decrease deposit operation.\\n     */\\n    function decreaseDeposit(Position storage position, DecreaseDepositParams memory params) public {\\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\\n        _require(position.bucket != IBucket(address(0)), Errors.IS_SPOT_POSITION.selector);\\n        _require(position.bucket.isActive(), Errors.BUCKET_IS_NOT_ACTIVE.selector);\\n        _require(params.amount > 0, Errors.DECREASE_AMOUNT_IS_ZERO.selector);\\n        _require(params.amount <= position.depositAmountInSoldAsset, Errors.AMOUNT_IS_MORE_THAN_DEPOSIT.selector);\\n        position.depositAmountInSoldAsset -= params.amount;\\n        position.scaledDebtAmount =\\n            position.scaledDebtAmount +\\n            params.amount.rdiv(position.bucket.getNormalizedVariableDebt());\\n\\n        params.traderBalanceVault.topUpAvailableBalance(position.trader, position.soldAsset, params.amount);\\n\\n        _require(\\n            health(\\n                position,\\n                params.priceOracle,\\n                params.pairPriceDrop,\\n                params.securityBuffer,\\n                params.oracleTolerableLimit\\n            ) >= WadRayMath.WAD + params.maintenanceBuffer,\\n            Errors.INSUFFICIENT_DEPOSIT_SIZE.selector\\n        );\\n        position.bucket.increaseDebt(position.trader, params.amount, address(params.traderBalanceVault));\\n    }\\n\\n    /**\\n     * @notice Closes a position.\\n     * @param position The position to be closed.\\n     * @param params The parameters for closing the position.\\n     * @param reason The reason for closing the position.\\n     * @return posEventData The event data for the closed position.\\n     */\\n    function closePosition(\\n        Position memory position,\\n        ClosePositionParams memory params,\\n        CloseReason reason\\n    ) public returns (ClosePositionEventData memory) {\\n        ClosePositionEventData memory posEventData;\\n        ClosePositionVars memory vars;\\n\\n        if (params.borrowedAmountIsNotZero) {\\n            posEventData.debtAmount = params.scaledDebtAmount.rmul(position.bucket.getNormalizedVariableDebt());\\n        }\\n\\n        vars.dexAdapter = params.primexDNS.dexAdapter();\\n        TokenTransfersLibrary.doTransferOut(position.positionAsset, vars.dexAdapter, params.closeAmount);\\n        posEventData.amountOut = PrimexPricingLibrary.multiSwap(\\n            PrimexPricingLibrary.MultiSwapParams({\\n                tokenA: position.positionAsset,\\n                tokenB: position.soldAsset,\\n                amountTokenA: params.closeAmount,\\n                routes: params.routes,\\n                dexAdapter: vars.dexAdapter,\\n                receiver: params.borrowedAmountIsNotZero\\n                    ? address(position.bucket)\\n                    : address(params.traderBalanceVault),\\n                deadline: block.timestamp\\n            }),\\n            params.oracleTolerableLimit,\\n            address(params.primexDNS),\\n            address(params.priceOracle),\\n            params.needOracleTolerableLimitCheck\\n        );\\n\\n        _require(\\n            posEventData.amountOut >= params.amountOutMin && posEventData.amountOut > 0,\\n            Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector\\n        );\\n\\n        bool canBeClosed;\\n        if (reason == CloseReason.CLOSE_BY_TRADER) {\\n            canBeClosed = position.trader == msg.sender;\\n        } else if (reason == CloseReason.RISKY_POSITION) {\\n            canBeClosed =\\n                health(\\n                    position,\\n                    params.priceOracle,\\n                    params.pairPriceDrop,\\n                    params.securityBuffer,\\n                    params.oracleTolerableLimit\\n                ) <\\n                WadRayMath.WAD;\\n            posEventData.actionType = IKeeperRewardDistributorStorage.KeeperActionType.Liquidation;\\n        } else if (reason == CloseReason.LIMIT_CONDITION) {\\n            address cm = params.primexDNS.cmTypeToAddress(params.closeCondition.managerType);\\n            _require(cm != address(0), Errors.INCORRECT_CM_TYPE.selector);\\n\\n            canBeClosed = IConditionalClosingManager(cm).canBeClosedAfterSwap(\\n                position,\\n                params.closeCondition.params,\\n                params.ccmAdditionalParams,\\n                params.closeAmount,\\n                posEventData.amountOut\\n            );\\n            posEventData.actionType = IKeeperRewardDistributorStorage.KeeperActionType.StopLoss;\\n        } else if (reason == CloseReason.BUCKET_DELISTED) {\\n            canBeClosed = position.bucket != IBucket(address(0)) && position.bucket.isDelisted();\\n            posEventData.actionType = IKeeperRewardDistributorStorage.KeeperActionType.BucketDelisted;\\n        }\\n        _require(canBeClosed, Errors.POSITION_CANNOT_BE_CLOSED_FOR_THIS_REASON.selector);\\n\\n        uint256 permanentLoss;\\n        if (posEventData.amountOut > posEventData.debtAmount) {\\n            unchecked {\\n                vars.amountToReturn = posEventData.amountOut - posEventData.debtAmount;\\n            }\\n        } else {\\n            unchecked {\\n                permanentLoss = posEventData.debtAmount - posEventData.amountOut;\\n            }\\n        }\\n\\n        posEventData.profit = -int256(params.depositDecrease);\\n\\n        if (reason != CloseReason.RISKY_POSITION) {\\n            if (vars.amountToReturn > 0) {\\n                posEventData.profit += int256(vars.amountToReturn);\\n                params.traderBalanceVault.topUpAvailableBalance(\\n                    reason == CloseReason.CLOSE_BY_TRADER ? params.depositReceiver : position.trader,\\n                    position.soldAsset,\\n                    vars.amountToReturn\\n                );\\n            }\\n        }\\n\\n        if (params.borrowedAmountIsNotZero) {\\n            position.bucket.decreaseTraderDebt(\\n                position.trader,\\n                posEventData.debtAmount,\\n                reason == CloseReason.RISKY_POSITION ? params.primexDNS.treasury() : address(params.traderBalanceVault),\\n                vars.amountToReturn,\\n                permanentLoss\\n            );\\n        }\\n\\n        // to avoid stack to deep\\n        CloseReason _reason = reason;\\n        if (params.closeAmount == position.positionAmount) {\\n            emit ClosePosition({\\n                positionId: position.id,\\n                trader: position.trader,\\n                closedBy: msg.sender,\\n                bucketAddress: address(position.bucket),\\n                soldAsset: position.soldAsset,\\n                positionAsset: position.positionAsset,\\n                decreasePositionAmount: position.positionAmount,\\n                profit: posEventData.profit,\\n                positionDebt: posEventData.debtAmount,\\n                amountOut: posEventData.amountOut,\\n                reason: _reason\\n            });\\n        }\\n        return posEventData;\\n    }\\n\\n    /**\\n     * @dev Sets the maximum position size between two tokens.\\n     * @param maxPositionSize The storage mapping for maximum position sizes.\\n     * @param token0 The address of token0.\\n     * @param token1 The address of token1.\\n     * @param amountInToken0 The maximum position size in token0.\\n     * @param amountInToken1 The maximum position size in token1.\\n     */\\n    function setMaxPositionSize(\\n        mapping(address => mapping(address => uint256)) storage maxPositionSize,\\n        address token0,\\n        address token1,\\n        uint256 amountInToken0,\\n        uint256 amountInToken1\\n    ) public {\\n        _require(token0 != address(0) && token1 != address(0), Errors.TOKEN_ADDRESS_IS_ZERO.selector);\\n        _require(token0 != token1, Errors.IDENTICAL_ASSET_ADDRESSES.selector);\\n\\n        maxPositionSize[token1][token0] = amountInToken0;\\n        maxPositionSize[token0][token1] = amountInToken1;\\n    }\\n\\n    /**\\n     * @dev Sets the tolerable limit for an oracle between two assets.\\n     * @param oracleTolerableLimits The mapping to store oracle tolerable limits.\\n     * @param assetA The address of the first asset.\\n     * @param assetB The address of the second asset.\\n     * @param percent The percentage tolerable limit for the oracle in WAD format (1 WAD = 100%).\\n     */\\n    function setOracleTolerableLimit(\\n        mapping(address => mapping(address => uint256)) storage oracleTolerableLimits,\\n        address assetA,\\n        address assetB,\\n        uint256 percent\\n    ) public {\\n        _require(assetA != address(0) && assetB != address(0), Errors.ASSET_ADDRESS_NOT_SUPPORTED.selector);\\n        _require(assetA != assetB, Errors.IDENTICAL_ASSET_ADDRESSES.selector);\\n        _require(percent <= WadRayMath.WAD && percent > 0, Errors.INVALID_PERCENT_NUMBER.selector);\\n        oracleTolerableLimits[assetA][assetB] = percent;\\n        oracleTolerableLimits[assetB][assetA] = percent;\\n    }\\n\\n    /**\\n     * @dev Sets the close conditions for a given position.\\n     * @param position The position for which to set the close conditions.\\n     * @param closeConditionsMap The storage mapping of close conditions for each position ID.\\n     * @param closeConditions The array of close conditions to be set.\\n     * @param primexDNS The address of the IPrimexDNS contract.\\n     */\\n    function setCloseConditions(\\n        Position memory position,\\n        mapping(uint256 => LimitOrderLibrary.Condition[]) storage closeConditionsMap,\\n        LimitOrderLibrary.Condition[] memory closeConditions,\\n        IPrimexDNS primexDNS\\n    ) public {\\n        _require(\\n            LimitOrderLibrary.hasNoConditionManagerTypeDuplicates(closeConditions),\\n            Errors.SHOULD_NOT_HAVE_DUPLICATES.selector\\n        );\\n        if (closeConditionsMap[position.id].length > 0) {\\n            delete closeConditionsMap[position.id];\\n        }\\n        LimitOrderLibrary.Condition memory condition;\\n        for (uint256 i; i < closeConditions.length; i++) {\\n            condition = closeConditions[i];\\n            _require(\\n                IERC165Upgradeable(primexDNS.cmTypeToAddress(condition.managerType)).supportsInterface(\\n                    type(IConditionalClosingManager).interfaceId\\n                ),\\n                Errors.SHOULD_BE_CCM.selector\\n            );\\n\\n            closeConditionsMap[position.id].push(condition);\\n        }\\n    }\\n\\n    /**\\n     * @notice Opens a position by depositing assets and borrowing funds (except when the position is spot)\\n     * @param _position The position to be opened\\n     * @param _vars Variables related to the position opening\\n     * @param _pmParams Parameters for the PositionManager contract\\n     * @return The updated position and event data\\n     */\\n    function openPosition(\\n        Position memory _position,\\n        OpenPositionVars memory _vars,\\n        PositionManagerParams memory _pmParams\\n    ) public returns (Position memory, OpenPositionEventData memory) {\\n        PrimexPricingLibrary.validateMinPositionSize(\\n            _pmParams.minPositionSize,\\n            _pmParams.minPositionAsset,\\n            _vars.borrowedAmount + _position.depositAmountInSoldAsset,\\n            _position.soldAsset,\\n            address(_pmParams.priceOracle)\\n        );\\n        OpenPositionLocalData memory data;\\n        data.amountToTransfer = _vars.borrowedAmount;\\n        data.dexAdapter = _pmParams.primexDNS.dexAdapter();\\n        data.depositReceiver = data.dexAdapter;\\n        if (_vars.depositData.depositAsset == _position.positionAsset) {\\n            _position.positionAmount = _vars.depositData.depositAmount;\\n            data.depositInPositionAsset = _vars.depositData.depositAmount;\\n            data.depositReceiver = address(this);\\n        } else if (_vars.depositData.depositAsset == _position.soldAsset) {\\n            data.amountToTransfer += _vars.depositData.depositAmount;\\n        }\\n\\n        data.isSpot = _vars.borrowedAmount == 0;\\n        if (data.isSpot) _vars.depositData.depositAsset = _position.soldAsset;\\n\\n        if (_vars.takeDepositFromWallet) {\\n            TokenTransfersLibrary.doTransferFromTo(\\n                _vars.depositData.depositAsset,\\n                msg.sender,\\n                data.depositReceiver,\\n                _vars.depositData.depositAmount\\n            );\\n        } else {\\n            _pmParams.traderBalanceVault.useTraderAssets(\\n                ITraderBalanceVault.LockAssetParams({\\n                    trader: _position.trader,\\n                    depositReceiver: data.depositReceiver,\\n                    depositAsset: _vars.depositData.depositAsset,\\n                    depositAmount: _vars.depositData.depositAmount,\\n                    openType: _vars.byOrder\\n                        ? ITraderBalanceVault.OpenType.OPEN_BY_ORDER\\n                        : ITraderBalanceVault.OpenType.OPEN\\n                })\\n            );\\n        }\\n\\n        if (!data.isSpot) {\\n            _position.bucket.increaseDebt(_position.trader, _vars.borrowedAmount, data.dexAdapter);\\n            // @note You need to write index only after opening a position in bucket.\\n            // Since when opening position in the bucket, index becomes relevant (containing accumulated profit)\\n            _position.openBorrowIndex = _position.bucket.variableBorrowIndex();\\n            _position.scaledDebtAmount = _vars.borrowedAmount.rdiv(_position.openBorrowIndex);\\n        }\\n        if (_vars.isThirdAsset) {\\n            data.depositInPositionAsset = PrimexPricingLibrary.multiSwap(\\n                PrimexPricingLibrary.MultiSwapParams({\\n                    tokenA: _vars.depositData.depositAsset,\\n                    tokenB: _position.positionAsset,\\n                    amountTokenA: _vars.depositData.depositAmount,\\n                    routes: _vars.depositInThirdAssetRoutes,\\n                    dexAdapter: data.dexAdapter,\\n                    receiver: address(this),\\n                    deadline: _vars.deadline\\n                }),\\n                _pmParams.oracleTolerableLimitForThirdAsset,\\n                address(_pmParams.primexDNS),\\n                address(_pmParams.priceOracle),\\n                true\\n            );\\n            _position.positionAmount += data.depositInPositionAsset;\\n        } else {\\n            _require(\\n                _vars.depositInThirdAssetRoutes.length == 0,\\n                Errors.DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0.selector\\n            );\\n        }\\n\\n        uint256 borrowedAmountInPositionAsset = PrimexPricingLibrary.multiSwap(\\n            PrimexPricingLibrary.MultiSwapParams({\\n                tokenA: _position.soldAsset,\\n                tokenB: _position.positionAsset,\\n                amountTokenA: data.isSpot ? _vars.depositData.depositAmount : data.amountToTransfer,\\n                routes: _vars.firstAssetRoutes,\\n                dexAdapter: data.dexAdapter,\\n                receiver: address(this),\\n                deadline: _vars.deadline\\n            }),\\n            _pmParams.oracleTolerableLimit,\\n            address(_pmParams.primexDNS),\\n            address(_pmParams.priceOracle),\\n            _vars.needOracleTolerableLimitCheck\\n        );\\n        _position.positionAmount += borrowedAmountInPositionAsset;\\n        _require(_pmParams.maxPositionSize >= _position.positionAmount, Errors.POSITION_SIZE_EXCEEDED.selector);\\n        uint256 leverage = WadRayMath.WAD;\\n        if (!data.isSpot) {\\n            if (_vars.depositData.depositAsset == _position.soldAsset) {\\n                leverage = (_vars.borrowedAmount + _position.depositAmountInSoldAsset).wdiv(\\n                    _position.depositAmountInSoldAsset\\n                );\\n            } else {\\n                leverage = (borrowedAmountInPositionAsset + data.depositInPositionAsset).wdiv(\\n                    data.depositInPositionAsset\\n                );\\n            }\\n            _require(\\n                leverage <= _position.bucket.maxAssetLeverage(_position.positionAsset),\\n                Errors.INSUFFICIENT_DEPOSIT.selector\\n            );\\n        }\\n\\n        if (!_vars.byOrder) {\\n            _vars.depositData.leverage = leverage;\\n        }\\n\\n        _require(_position.positionAmount >= _vars.amountOutMin, Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector);\\n\\n        OpenPositionEventData memory posEventData;\\n\\n        posEventData.protocolFee = PrimexPricingLibrary.payProtocolFee(\\n            PrimexPricingLibrary.ProtocolFeeParams({\\n                depositData: _vars.depositData,\\n                feeToken: _vars.feeToken,\\n                isSwapFromWallet: _vars.payFeeFromWallet,\\n                calculateFee: !_vars.byOrder,\\n                orderType: _vars.byOrder\\n                    ? IPrimexDNSStorage.OrderType.LIMIT_ORDER\\n                    : IPrimexDNSStorage.OrderType.MARKET_ORDER,\\n                trader: _position.trader,\\n                priceOracle: address(_pmParams.priceOracle),\\n                traderBalanceVault: _pmParams.traderBalanceVault,\\n                primexDNS: _pmParams.primexDNS\\n            })\\n        );\\n\\n        uint256 multiplierBorrowedAsset = 10 ** (18 - IERC20Metadata(_position.soldAsset).decimals());\\n        uint256 multiplierPositionAsset = 10 ** (18 - IERC20Metadata(_position.positionAsset).decimals());\\n        posEventData.entryPrice =\\n            ((_vars.borrowedAmount + _position.depositAmountInSoldAsset) * multiplierBorrowedAsset).wdiv(\\n                _position.positionAmount * multiplierPositionAsset\\n            ) /\\n            multiplierBorrowedAsset;\\n        posEventData.leverage = _vars.depositData.leverage;\\n        return (_position, posEventData);\\n    }\\n\\n    /**\\n     * @dev Retrieves the debt amount for a given position.\\n     * @param position The Position struct representing the position to get the debt amount for.\\n     * @return The debt amount in debtTokens.\\n     */\\n    function getDebt(Position memory position) public view returns (uint256) {\\n        if (position.scaledDebtAmount == 0) return 0;\\n        return position.scaledDebtAmount.rmul(position.bucket.getNormalizedVariableDebt());\\n    }\\n\\n    /**\\n     * @dev Calculates the health of a position.\\n     * @dev health = ((1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - priceDrop) * borrowedAssetAmountOut) /\\n     (feeBuffer * debt)\\n     * @param position The position object containing relevant information.\\n     * @param priceOracle The price oracle contract used for obtaining asset prices.\\n     * @param pairPriceDrop The priceDrop in WAD format of the asset pair.\\n     * @param securityBuffer The security buffer in WAD format for the position.\\n     * @param oracleTolerableLimit The tolerable limit in WAD format for the price oracle.\\n     * @return The health value in WAD format of the position.\\n     */\\n    function health(\\n        Position memory position,\\n        IPriceOracle priceOracle,\\n        uint256 pairPriceDrop,\\n        uint256 securityBuffer,\\n        uint256 oracleTolerableLimit\\n    ) public view returns (uint256) {\\n        if (position.scaledDebtAmount == 0) return WadRayMath.WAD;\\n        return\\n            health(\\n                PrimexPricingLibrary.getOracleAmountsOut(\\n                    position.positionAsset,\\n                    position.soldAsset,\\n                    position.positionAmount,\\n                    address(priceOracle)\\n                ),\\n                pairPriceDrop,\\n                securityBuffer,\\n                oracleTolerableLimit,\\n                getDebt(position),\\n                position.bucket.feeBuffer()\\n            );\\n    }\\n\\n    /**\\n     * @dev Creates a new position based on the given parameters.\\n     * @param _params The input parameters for creating the position.\\n     * @param primexDNS The address of the PrimexDNS contract.\\n     * @param priceOracle The address of the PriceOracle contract.\\n     * @return position The created Position struct.\\n     * @return vars The OpenPositionVars struct.\\n     */\\n    function createPosition(\\n        OpenPositionParams calldata _params,\\n        IPrimexDNS primexDNS,\\n        IPriceOracle priceOracle\\n    ) public view returns (Position memory, OpenPositionVars memory) {\\n        OpenPositionVars memory vars = OpenPositionVars({\\n            firstAssetRoutes: _params.firstAssetRoutes,\\n            depositInThirdAssetRoutes: _params.marginParams.depositInThirdAssetRoutes,\\n            depositData: PrimexPricingLibrary.DepositData({\\n                protocolFee: 0,\\n                depositAsset: address(0),\\n                depositAmount: _params.depositAmount,\\n                leverage: 0\\n            }),\\n            feeToken: _params.isProtocolFeeInPmx ? primexDNS.pmx() : NATIVE_CURRENCY,\\n            borrowedAmount: _params.marginParams.borrowedAmount,\\n            amountOutMin: _params.amountOutMin,\\n            deadline: _params.deadline,\\n            isSpot: _params.marginParams.borrowedAmount == 0,\\n            isThirdAsset: false,\\n            takeDepositFromWallet: _params.takeDepositFromWallet,\\n            payFeeFromWallet: _params.payFeeFromWallet,\\n            byOrder: false,\\n            sender: address(0),\\n            closeConditions: _params.closeConditions,\\n            needOracleTolerableLimitCheck: _params.marginParams.borrowedAmount > 0\\n        });\\n        PositionLibrary.Position memory position = PositionLibrary.Position({\\n            id: 0,\\n            scaledDebtAmount: 0,\\n            bucket: IBucket(address(0)),\\n            soldAsset: address(0),\\n            depositAmountInSoldAsset: 0,\\n            positionAsset: _params.positionAsset,\\n            positionAmount: 0,\\n            trader: msg.sender,\\n            openBorrowIndex: 0,\\n            createdAt: block.timestamp,\\n            updatedConditionsAt: block.timestamp,\\n            extraParams: \\\"\\\"\\n        });\\n\\n        if (vars.isSpot) {\\n            _require(_params.depositAsset != _params.positionAsset, Errors.SHOULD_BE_DIFFERENT_ASSETS_IN_SPOT.selector);\\n            _require(bytes(_params.marginParams.bucket).length == 0, Errors.BUCKET_SHOULD_BE_UNDEFINED.selector);\\n            priceOracle.getPriceFeedsPair(_params.positionAsset, _params.depositAsset);\\n            position.soldAsset = _params.depositAsset;\\n            position.depositAmountInSoldAsset = vars.depositData.depositAmount;\\n            vars.depositData.leverage = WadRayMath.WAD;\\n        } else {\\n            position.bucket = IBucket(primexDNS.getBucketAddress(_params.marginParams.bucket));\\n            position.soldAsset = address(position.bucket.borrowedAsset());\\n            vars.depositData.depositAsset = _params.depositAsset;\\n            (, bool tokenAllowed) = position.bucket.allowedAssets(_params.positionAsset);\\n            _require(tokenAllowed, Errors.TOKEN_NOT_SUPPORTED.selector);\\n\\n            vars.isThirdAsset =\\n                _params.depositAsset != position.soldAsset &&\\n                _params.depositAsset != _params.positionAsset;\\n\\n            position.depositAmountInSoldAsset = PrimexPricingLibrary.getOracleAmountsOut(\\n                _params.depositAsset,\\n                position.soldAsset,\\n                _params.depositAmount,\\n                address(priceOracle)\\n            );\\n        }\\n\\n        return (position, vars);\\n    }\\n\\n    /**\\n     * @notice Creates a position based on the provided order parameters.\\n     * @dev This function calculates and returns a Position and OpenPositionVars struct.\\n     * @param _params The OpenPositionByOrderParams struct containing the order parameters.\\n     * @param priceOracle The price oracle contract used for retrieving asset prices.\\n     * @return position The Position struct representing the created position.\\n     * @return vars The OpenPositionVars struct containing additional variables related to the position.\\n     */\\n    function createPositionByOrder(\\n        LimitOrderLibrary.OpenPositionByOrderParams calldata _params,\\n        IPriceOracle priceOracle\\n    ) public view returns (Position memory, OpenPositionVars memory) {\\n        OpenPositionVars memory vars = OpenPositionVars({\\n            firstAssetRoutes: _params.firstAssetRoutes,\\n            depositInThirdAssetRoutes: _params.depositInThirdAssetRoutes,\\n            depositData: PrimexPricingLibrary.DepositData({\\n                protocolFee: _params.order.protocolFee,\\n                depositAsset: address(0),\\n                depositAmount: _params.order.depositAmount,\\n                leverage: _params.order.leverage\\n            }),\\n            feeToken: _params.order.feeToken,\\n            borrowedAmount: 0,\\n            amountOutMin: 0,\\n            deadline: _params.order.deadline,\\n            isSpot: _params.order.leverage == WadRayMath.WAD,\\n            isThirdAsset: false,\\n            takeDepositFromWallet: false,\\n            payFeeFromWallet: false,\\n            byOrder: true,\\n            sender: _params.sender,\\n            closeConditions: _params.closeConditions,\\n            needOracleTolerableLimitCheck: true\\n        });\\n\\n        Position memory position = Position({\\n            id: 0,\\n            scaledDebtAmount: 0,\\n            bucket: IBucket(address(0)),\\n            soldAsset: address(0),\\n            depositAmountInSoldAsset: 0,\\n            positionAsset: _params.order.positionAsset,\\n            positionAmount: 0,\\n            trader: _params.order.trader,\\n            openBorrowIndex: 0,\\n            createdAt: block.timestamp,\\n            updatedConditionsAt: block.timestamp,\\n            extraParams: \\\"\\\"\\n        });\\n\\n        if (vars.isSpot) {\\n            position.soldAsset = _params.order.depositAsset;\\n            position.depositAmountInSoldAsset = vars.depositData.depositAmount;\\n        } else {\\n            position.bucket = _params.order.bucket;\\n            position.soldAsset = address(position.bucket.borrowedAsset());\\n            vars.depositData.depositAsset = _params.order.depositAsset;\\n            vars.isThirdAsset =\\n                _params.order.depositAsset != position.soldAsset &&\\n                _params.order.depositAsset != _params.order.positionAsset;\\n\\n            position.depositAmountInSoldAsset = PrimexPricingLibrary.getOracleAmountsOut(\\n                _params.order.depositAsset,\\n                position.soldAsset,\\n                _params.order.depositAmount,\\n                address(priceOracle)\\n            );\\n            vars.borrowedAmount = position.depositAmountInSoldAsset.wmul(_params.order.leverage - WadRayMath.WAD);\\n        }\\n        return (position, vars);\\n    }\\n\\n    /**\\n     * @notice Calculates the health score for a position.\\n     * @param borrowedAssetAmountOut The amount of borrowed assets.\\n     * @param pairPriceDrop The priceDrop in WAD format of the pair.\\n     * @param securityBuffer The security buffer in WAD format.\\n     * @param oracleTolerableLimit The tolerable limit in WAD format for the oracle.\\n     * @param positionDebt The debt of the position.\\n     * @param feeBuffer The buffer for fees.\\n     * @return The health score of the position.\\n     */\\n    function health(\\n        uint256 borrowedAssetAmountOut,\\n        uint256 pairPriceDrop,\\n        uint256 securityBuffer,\\n        uint256 oracleTolerableLimit,\\n        uint256 positionDebt,\\n        uint256 feeBuffer\\n    ) public pure returns (uint256) {\\n        return\\n            (\\n                (WadRayMath.WAD - securityBuffer)\\n                    .wmul(WadRayMath.WAD - oracleTolerableLimit)\\n                    .wmul(WadRayMath.WAD - pairPriceDrop)\\n                    .wmul(borrowedAssetAmountOut)\\n            ).wdiv(feeBuffer.wmul(positionDebt));\\n    }\\n}\\n\",\"keccak256\":\"0x054406e5e1391057b1a19ba965ca7c68a4ef7c99b98e7c4b339935e8d471eedf\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/PrimexPricingLibrary.sol\":{\"content\":\"// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {BytesLib} from \\\"./utils/BytesLib.sol\\\";\\nimport {WadRayMath} from \\\"./utils/WadRayMath.sol\\\";\\n\\nimport {NATIVE_CURRENCY, USD, USD_MULTIPLIER} from \\\"../Constants.sol\\\";\\nimport {IDexAdapter} from \\\"../interfaces/IDexAdapter.sol\\\";\\nimport {IPriceOracle} from \\\"../PriceOracle/IPriceOracle.sol\\\";\\nimport {IPrimexDNS, IPrimexDNSV2, IPrimexDNSStorage} from \\\"../PrimexDNS/IPrimexDNS.sol\\\";\\nimport {IBucket} from \\\"../Bucket/IBucket.sol\\\";\\nimport {IPositionManager} from \\\"../PositionManager/IPositionManager.sol\\\";\\nimport {ITraderBalanceVault} from \\\"../TraderBalanceVault/ITraderBalanceVault.sol\\\";\\nimport {TokenTransfersLibrary} from \\\"./TokenTransfersLibrary.sol\\\";\\n\\nimport \\\"./Errors.sol\\\";\\n\\nlibrary PrimexPricingLibrary {\\n    using WadRayMath for uint256;\\n    using BytesLib for bytes;\\n\\n    struct Route {\\n        uint256 shares;\\n        SwapPath[] paths;\\n    }\\n\\n    struct SwapPath {\\n        string dexName;\\n        bytes encodedPath;\\n    }\\n\\n    struct MultiSwapParams {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amountTokenA;\\n        Route[] routes;\\n        address dexAdapter;\\n        address receiver;\\n        uint256 deadline;\\n    }\\n\\n    struct MultiSwapVars {\\n        uint256 sumOfShares;\\n        uint256 balance;\\n        uint256 amountOnDex;\\n        uint256 remainder;\\n        Route route;\\n    }\\n\\n    struct AmountParams {\\n        address tokenA;\\n        address tokenB;\\n        uint256 amount;\\n        Route[] routes;\\n        address dexAdapter;\\n        address primexDNS;\\n    }\\n\\n    struct LiquidationPriceCalculationParams {\\n        address bucket;\\n        address positionAsset;\\n        uint256 limitPrice;\\n        uint256 leverage;\\n    }\\n\\n    struct DepositData {\\n        uint256 protocolFee;\\n        address depositAsset;\\n        uint256 depositAmount;\\n        uint256 leverage;\\n    }\\n\\n    /**\\n     * @param depositData the deposit data through which the protocol fee can be calculated\\n     * if the position is opened through an order using deposit asset\\n     * @param feeToken An asset in which the fee will be paid. At this point it could be the pmx, the epmx or a native currency\\n     * @param isSwapFromWallet bool, the protocol fee is taken from the user wallet or from the Vault\\n     * @param trader trader address\\n     * @param priceOracle PriceOracle contract address\\n     * @param orderType Type of possible order in Primex protocol\\n     * @param traderBalanceVault TraderBalanceVault contract address\\n     * @param primexDNS PrimexDNS contract address\\n     */\\n    struct ProtocolFeeParams {\\n        DepositData depositData;\\n        address feeToken;\\n        bool isSwapFromWallet;\\n        address trader;\\n        address priceOracle;\\n        IPrimexDNSStorage.OrderType orderType;\\n        bool calculateFee;\\n        ITraderBalanceVault traderBalanceVault;\\n        IPrimexDNS primexDNS;\\n    }\\n\\n    /**\\n     * The struct for payProtocolFee function\\n     */\\n    struct ProtocolFeeVars {\\n        bool fromLocked;\\n        address treasury;\\n    }\\n\\n    /**\\n     * The struct for getLiquidationPrice and getLiquidationPriceByOrder functions\\n     */\\n    struct LiquidationPriceData {\\n        IBucket bucket;\\n        IPositionManager positionManager;\\n        IPriceOracle priceOracle;\\n        IERC20Metadata borrowedAsset;\\n    }\\n\\n    event Withdraw(\\n        address indexed withdrawer,\\n        address borrowAssetReceiver,\\n        address borrowedAsset,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Encodes the given parameters into a bytes array based on the specified DEX type.\\n     * @param path The token path for the swap.\\n     * @param dexRouter The address of the DEX router.\\n     * @param ancillaryData Additional data required for certain DEX types.\\n     * @param dexAdapter The address of the DEX adapter.\\n     * @param isAmountToBuy A flag indicating whether it is the path for the swap with fixed amountIn or amountOut.\\n     * Swap with fixed amountIn, if true.\\n     * @return The encoded bytes array.\\n     */\\n    function encodePath(\\n        address[] memory path,\\n        address dexRouter,\\n        bytes32 ancillaryData,\\n        address dexAdapter,\\n        bool isAmountToBuy\\n    ) external view returns (bytes memory) {\\n        IDexAdapter.DexType type_ = IDexAdapter(dexAdapter).dexType(dexRouter);\\n\\n        if (type_ == IDexAdapter.DexType.UniswapV2 || type_ == IDexAdapter.DexType.Meshswap) {\\n            return abi.encode(path);\\n        }\\n        if (type_ == IDexAdapter.DexType.UniswapV3) {\\n            if (isAmountToBuy)\\n                return bytes.concat(bytes20(path[1]), bytes3(uint24(uint256(ancillaryData))), bytes20(path[0]));\\n            return bytes.concat(bytes20(path[0]), bytes3(uint24(uint256(ancillaryData))), bytes20(path[1]));\\n        }\\n        if (type_ == IDexAdapter.DexType.AlgebraV3) {\\n            if (isAmountToBuy) return bytes.concat(bytes20(path[1]), bytes20(path[0]));\\n            return bytes.concat(bytes20(path[0]), bytes20(path[1]));\\n        }\\n        if (type_ == IDexAdapter.DexType.Curve) {\\n            address[] memory pools = new address[](1);\\n            pools[0] = address(uint160(uint256(ancillaryData)));\\n            return abi.encode(path, pools);\\n        }\\n        if (type_ == IDexAdapter.DexType.Balancer) {\\n            int256[] memory limits = new int256[](2);\\n            limits[0] = type(int256).max;\\n            bytes32[] memory pools = new bytes32[](1);\\n            pools[0] = ancillaryData;\\n            return abi.encode(path, pools, limits);\\n        }\\n        _revert(Errors.UNKNOWN_DEX_TYPE.selector);\\n    }\\n\\n    /**\\n     * @notice Wrapped getAmountsOut to the dex\\n     * @param _params parameters necessary to get amount out\\n     * @return the amount of `tokenB` by the amount of 'tokenA' on dexes\\n     */\\n    function getAmountOut(AmountParams memory _params) public returns (uint256) {\\n        _require(_params.tokenA != _params.tokenB, Errors.IDENTICAL_ASSETS.selector);\\n        _require(\\n            IERC165(address(_params.primexDNS)).supportsInterface(type(IPrimexDNS).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n\\n        uint256 sumOfShares;\\n        for (uint256 i; i < _params.routes.length; i++) {\\n            sumOfShares += _params.routes[i].shares;\\n        }\\n        _require(sumOfShares > 0, Errors.SUM_OF_SHARES_SHOULD_BE_GREATER_THAN_ZERO.selector);\\n\\n        uint256 remainder = _params.amount;\\n        uint256 sum;\\n        uint256 amountOnDex;\\n        Route memory route;\\n        IDexAdapter.GetAmountsParams memory getAmountsParams;\\n        address[] memory path;\\n\\n        for (uint256 i; i < _params.routes.length; i++) {\\n            route = _params.routes[i];\\n            amountOnDex = i == _params.routes.length - 1 ? remainder : (_params.amount * route.shares) / sumOfShares;\\n            remainder -= amountOnDex;\\n\\n            for (uint256 j; j < route.paths.length; j++) {\\n                getAmountsParams.encodedPath = route.paths[j].encodedPath;\\n                getAmountsParams.amount = amountOnDex;\\n                getAmountsParams.dexRouter = IPrimexDNS(_params.primexDNS).getDexAddress(route.paths[j].dexName);\\n                path = decodePath(getAmountsParams.encodedPath, getAmountsParams.dexRouter, _params.dexAdapter);\\n                _require(path.length >= 2, Errors.INCORRECT_PATH.selector);\\n                amountOnDex = IDexAdapter(_params.dexAdapter).getAmountsOut(getAmountsParams)[1];\\n            }\\n            sum += amountOnDex;\\n        }\\n\\n        return sum;\\n    }\\n\\n    /**\\n     * @notice Wrapped getAmountIn to the dex\\n     * @param _params parameters necessary to get amount in\\n     * @return the amount of `tokenA` by the amount of 'tokenB' on dexes\\n     */\\n    function getAmountIn(AmountParams memory _params) public returns (uint256) {\\n        _require(_params.tokenA != _params.tokenB, Errors.IDENTICAL_ASSETS.selector);\\n        _require(\\n            IERC165(address(_params.primexDNS)).supportsInterface(type(IPrimexDNS).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n\\n        uint256 sumOfShares;\\n        for (uint256 i; i < _params.routes.length; i++) {\\n            sumOfShares += _params.routes[i].shares;\\n        }\\n        _require(sumOfShares > 0, Errors.SUM_OF_SHARES_SHOULD_BE_GREATER_THAN_ZERO.selector);\\n\\n        uint256 remainder = _params.amount;\\n        uint256 sum;\\n        uint256 amountOnDex;\\n        Route memory route;\\n        IDexAdapter.GetAmountsParams memory getAmountsParams;\\n        address[] memory path;\\n\\n        for (uint256 i; i < _params.routes.length; i++) {\\n            route = _params.routes[i];\\n            amountOnDex = i == _params.routes.length - 1 ? remainder : (_params.amount * route.shares) / sumOfShares;\\n            remainder -= amountOnDex;\\n            for (uint256 j; j < route.paths.length; j++) {\\n                getAmountsParams.encodedPath = route.paths[route.paths.length - 1 - j].encodedPath;\\n                getAmountsParams.amount = amountOnDex;\\n                getAmountsParams.dexRouter = IPrimexDNS(_params.primexDNS).getDexAddress(\\n                    route.paths[route.paths.length - 1 - j].dexName\\n                );\\n                path = decodePath(getAmountsParams.encodedPath, getAmountsParams.dexRouter, _params.dexAdapter);\\n                _require(path.length >= 2, Errors.INCORRECT_PATH.selector);\\n                amountOnDex = IDexAdapter(_params.dexAdapter).getAmountsIn(getAmountsParams)[0];\\n            }\\n            sum += amountOnDex;\\n        }\\n\\n        return sum;\\n    }\\n\\n    /**\\n     * @notice Calculates the amount of deposit assets in borrowed assets.\\n     * @param _params The parameters for the calculation.\\n     * @param _isThirdAsset A flag indicating if deposit is in a third asset.\\n     * @param _priceOracle The address of the price oracle.\\n     * @return The amount of deposit assets is measured in borrowed assets.\\n     */\\n    function getDepositAmountInBorrowed(\\n        AmountParams memory _params,\\n        bool _isThirdAsset,\\n        address _priceOracle\\n    ) public returns (uint256) {\\n        _require(\\n            IERC165(_params.primexDNS).supportsInterface(type(IPrimexDNS).interfaceId) &&\\n                IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        if (_params.tokenA == _params.tokenB) {\\n            _require(_params.routes.length == 0, Errors.DEPOSITED_TO_BORROWED_ROUTES_LENGTH_SHOULD_BE_0.selector);\\n            return _params.amount;\\n        }\\n\\n        uint256 depositAmountInBorrowed = getAmountOut(_params);\\n        if (_isThirdAsset) {\\n            uint256 oracleDepositAmountOut = getOracleAmountsOut(\\n                _params.tokenA,\\n                _params.tokenB,\\n                _params.amount,\\n                _priceOracle\\n            );\\n            if (depositAmountInBorrowed > oracleDepositAmountOut) depositAmountInBorrowed = oracleDepositAmountOut;\\n        }\\n\\n        return depositAmountInBorrowed;\\n    }\\n\\n    /**\\n     * @notice Performs a multi-hop swap transaction using the specified parameters.\\n     * @dev This function executes a series of token swaps on different DEXs based on the provided routes.\\n     * @param _params The struct containing all the necessary parameters for the multi-hop swap.\\n     * @param _maximumOracleTolerableLimit The maximum tolerable limit in WAD format (1 WAD = 100%)\\n     * for the price difference between DEX and the oracle.\\n     * @param _primexDNS The address of the Primex DNS contract.\\n     * @param _priceOracle The address of the price oracle contract.\\n     * @param _needOracleTolerableLimitCheck Flag indicating whether to perform an oracle tolerable limit check.\\n     * @return The final balance of the _params.tokenB in the receiver's address after the multi-hop swap.\\n     */\\n    function multiSwap(\\n        MultiSwapParams memory _params,\\n        uint256 _maximumOracleTolerableLimit,\\n        address _primexDNS,\\n        address _priceOracle,\\n        bool _needOracleTolerableLimitCheck\\n    ) public returns (uint256) {\\n        _require(\\n            IERC165(_primexDNS).supportsInterface(type(IPrimexDNS).interfaceId) &&\\n                IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        MultiSwapVars memory vars;\\n        vars.balance = IERC20Metadata(_params.tokenB).balanceOf(_params.receiver);\\n        for (uint256 i; i < _params.routes.length; i++) {\\n            vars.sumOfShares += _params.routes[i].shares;\\n        }\\n        _require(vars.sumOfShares > 0, Errors.SUM_OF_SHARES_SHOULD_BE_GREATER_THAN_ZERO.selector);\\n\\n        vars.remainder = _params.amountTokenA;\\n        IDexAdapter.SwapParams memory swapParams;\\n        swapParams.deadline = _params.deadline;\\n\\n        for (uint256 i; i < _params.routes.length; i++) {\\n            vars.route = _params.routes[i];\\n            vars.amountOnDex = i == _params.routes.length - 1\\n                ? vars.remainder\\n                : (_params.amountTokenA * vars.route.shares) / vars.sumOfShares;\\n            vars.remainder -= vars.amountOnDex;\\n            swapParams.to = _params.dexAdapter;\\n\\n            for (uint256 j; j < vars.route.paths.length; j++) {\\n                swapParams.encodedPath = vars.route.paths[j].encodedPath;\\n                swapParams.amountIn = vars.amountOnDex;\\n                swapParams.dexRouter = IPrimexDNS(_primexDNS).getDexAddress(vars.route.paths[j].dexName);\\n                if (j == vars.route.paths.length - 1) {\\n                    swapParams.to = _params.receiver;\\n                }\\n                vars.amountOnDex = IDexAdapter(_params.dexAdapter).swapExactTokensForTokens(swapParams)[1];\\n            }\\n        }\\n\\n        vars.balance = IERC20Metadata(_params.tokenB).balanceOf(_params.receiver) - vars.balance;\\n        if (_needOracleTolerableLimitCheck) {\\n            _require(\\n                vars.balance >=\\n                    getOracleAmountsOut(_params.tokenA, _params.tokenB, _params.amountTokenA, _priceOracle).wmul(\\n                        WadRayMath.WAD - _maximumOracleTolerableLimit\\n                    ),\\n                Errors.DIFFERENT_PRICE_DEX_AND_ORACLE.selector\\n            );\\n        }\\n\\n        return vars.balance;\\n    }\\n\\n    /**\\n     * @notice Pays the protocol fee.\\n     * @dev This function transfers the protocol fee from the trader to the protocol treasury.\\n     * @param params The parameters for paying the protocol fee.\\n     * @return protocolFee The amount of the protocol fee in PMX or NATIVE_CURRENCY paid.\\n     */\\n    function payProtocolFee(ProtocolFeeParams memory params) public returns (uint256 protocolFee) {\\n        if (!params.isSwapFromWallet || params.feeToken != NATIVE_CURRENCY) {\\n            _require(msg.value == 0, Errors.DISABLED_TRANSFER_NATIVE_CURRENCY.selector);\\n        }\\n        ProtocolFeeVars memory vars;\\n        vars.treasury = params.primexDNS.treasury();\\n        vars.fromLocked = true;\\n\\n        protocolFee = params.depositData.protocolFee;\\n        if (params.calculateFee) {\\n            protocolFee = calculateProtocolFee(\\n                params.depositData,\\n                params.primexDNS,\\n                params.priceOracle,\\n                params.orderType,\\n                params.feeToken\\n            );\\n            if (protocolFee == 0) return 0;\\n            vars.fromLocked = false;\\n            if (params.isSwapFromWallet) {\\n                if (params.feeToken == NATIVE_CURRENCY) {\\n                    _require(msg.value >= protocolFee, Errors.INSUFFICIENT_DEPOSIT.selector);\\n                    TokenTransfersLibrary.doTransferOutETH(vars.treasury, protocolFee);\\n                    if (msg.value > protocolFee) {\\n                        uint256 rest = msg.value - protocolFee;\\n                        params.traderBalanceVault.topUpAvailableBalance{value: rest}(msg.sender, NATIVE_CURRENCY, rest);\\n                    }\\n                } else {\\n                    TokenTransfersLibrary.doTransferFromTo(params.feeToken, params.trader, vars.treasury, protocolFee);\\n                }\\n                return protocolFee;\\n            }\\n        }\\n\\n        params.traderBalanceVault.withdrawFrom(\\n            params.trader,\\n            vars.treasury,\\n            params.feeToken,\\n            protocolFee,\\n            vars.fromLocked\\n        );\\n    }\\n\\n    /**\\n     * @notice Calculate and return protocol fee\\n     * @param _depositData The deposit data through which the protocol fee can be calculated.\\n     * @param _primexDNS The address of the PrimexDNS contract.\\n     * @param _priceOracle The address of the PriceOracle contract.\\n     * @param _orderType Type of possible order in Primex protocol\\n     * @param _feeToken An asset in which the fee will be paid. At this point it could be the pmx, the epmx or a native currency\\n     * @return The amount of the protocol fee in '_feeToken' which needs to be paid according to the specified deposit parameters.\\n     */\\n    function calculateProtocolFee(\\n        DepositData memory _depositData,\\n        IPrimexDNS _primexDNS,\\n        address _priceOracle,\\n        IPrimexDNSStorage.OrderType _orderType,\\n        address _feeToken\\n    ) public view returns (uint256) {\\n        uint256 feeRate = _primexDNS.feeRates(_orderType, _feeToken);\\n        if (feeRate == 0) return 0;\\n        uint256 nativeFeeRate = _feeToken == NATIVE_CURRENCY\\n            ? feeRate\\n            : _primexDNS.feeRates(_orderType, NATIVE_CURRENCY);\\n\\n        _depositData.protocolFee = getOracleAmountsOut(\\n            _depositData.depositAsset,\\n            NATIVE_CURRENCY,\\n            _depositData.depositAmount.wmul(_depositData.leverage).wmul(nativeFeeRate),\\n            _priceOracle\\n        );\\n\\n        (uint256 minFee, uint256 maxFee) = IPrimexDNSV2(address(_primexDNS)).feeRestrictions(_orderType);\\n        if (minFee > _depositData.protocolFee) {\\n            _depositData.protocolFee = minFee;\\n        } else if (maxFee < _depositData.protocolFee) {\\n            _depositData.protocolFee = maxFee;\\n        }\\n\\n        if (_feeToken != NATIVE_CURRENCY) {\\n            _require(nativeFeeRate != 0, Errors.FEE_RATE_IN_NATIVE_IS_ZERO.selector);\\n            uint256 discountMultiplier = feeRate.wdiv(nativeFeeRate);\\n            _depositData.protocolFee = getOracleAmountsOut(\\n                NATIVE_CURRENCY,\\n                _feeToken,\\n                _depositData.protocolFee.wmul(discountMultiplier),\\n                _priceOracle\\n            );\\n        }\\n\\n        return _depositData.protocolFee;\\n    }\\n\\n    /**\\n     * @param _tokenA asset for sell\\n     * @param _tokenB asset to buy\\n     * @param _amountAssetA Amount tokenA to sell\\n     * @param _priceOracle PriceOracle contract address\\n     * @return returns the amount of `tokenB` by the `amountAssetA` by the price of the oracle\\n     */\\n    function getOracleAmountsOut(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _amountAssetA,\\n        address _priceOracle\\n    ) public view returns (uint256) {\\n        _require(\\n            IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        if (_tokenA == _tokenB) {\\n            return _amountAssetA;\\n        }\\n        (uint256 exchangeRate, bool isForward) = IPriceOracle(_priceOracle).getExchangeRate(_tokenA, _tokenB);\\n        uint256 amountAssetB;\\n        uint256 multiplier1 = _getAssetMultiplier(_tokenA);\\n        uint256 multiplier2 = _getAssetMultiplier(_tokenB);\\n\\n        if (isForward) {\\n            amountAssetB = (_amountAssetA * multiplier1).wmul(exchangeRate) / multiplier2;\\n        } else {\\n            amountAssetB = (_amountAssetA * multiplier1).wdiv(exchangeRate) / multiplier2;\\n        }\\n        return amountAssetB;\\n    }\\n\\n    /**\\n     * @param _tokenA asset for sell\\n     * @param _tokenB asset to buy\\n     * @param _amountsAssetA An array of amounts of tokenA to sell\\n     * @param _priceOracle PriceOracle contract address\\n     * @return returns an array of amounts of `tokenB` by the `amountsAssetA` by the price of the oracle\\n     */\\n    function getBatchOracleAmountsOut(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256[] memory _amountsAssetA,\\n        address _priceOracle\\n    ) public view returns (uint256[] memory) {\\n        _require(\\n            IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\\n            Errors.ADDRESS_NOT_SUPPORTED.selector\\n        );\\n        if (_tokenA == _tokenB) {\\n            return _amountsAssetA;\\n        }\\n        uint256[] memory amountsAssetB = new uint256[](_amountsAssetA.length);\\n        (uint256 exchangeRate, bool isForward) = IPriceOracle(_priceOracle).getExchangeRate(_tokenA, _tokenB);\\n        uint256 multiplier1 = 10 ** (18 - IERC20Metadata(_tokenA).decimals());\\n        uint256 multiplier2 = 10 ** (18 - IERC20Metadata(_tokenB).decimals());\\n\\n        if (isForward) {\\n            for (uint256 i; i < _amountsAssetA.length; i++) {\\n                amountsAssetB[i] = (_amountsAssetA[i] * multiplier1).wmul(exchangeRate) / multiplier2;\\n            }\\n        } else {\\n            for (uint256 i; i < _amountsAssetA.length; i++) {\\n                amountsAssetB[i] = (_amountsAssetA[i] * multiplier1).wdiv(exchangeRate) / multiplier2;\\n            }\\n        }\\n        return amountsAssetB;\\n    }\\n\\n    /**\\n     * @notice Calculates the liquidation price for a position.\\n     * @dev liquidationPrice = (feeBuffer * debt) /\\n     * ((1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - priceDrop) * positionAmount))\\n     * @param _bucket The address of the related bucket.\\n     * @param _positionAsset The address of the position asset.\\n     * @param _positionAmount The size of the opened position.\\n     * @param _positionDebt The debt amount in debtTokens associated with the position.\\n     * @return The calculated liquidation price in borrowed asset.\\n     */\\n    function getLiquidationPrice(\\n        address _bucket,\\n        address _positionAsset,\\n        uint256 _positionAmount,\\n        uint256 _positionDebt\\n    ) public view returns (uint256) {\\n        _require(_positionAsset != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\\n        LiquidationPriceData memory data;\\n        data.bucket = IBucket(_bucket);\\n\\n        (, bool tokenAllowed) = data.bucket.allowedAssets(_positionAsset);\\n        _require(tokenAllowed, Errors.TOKEN_NOT_SUPPORTED.selector);\\n\\n        data.positionManager = data.bucket.positionManager();\\n        data.borrowedAsset = data.bucket.borrowedAsset();\\n        data.priceOracle = data.positionManager.priceOracle();\\n\\n        uint256 multiplier1 = 10 ** (18 - data.borrowedAsset.decimals());\\n        uint256 denominator = (WadRayMath.WAD - data.positionManager.securityBuffer())\\n            .wmul(\\n                WadRayMath.WAD -\\n                    data.positionManager.getOracleTolerableLimit(_positionAsset, address(data.borrowedAsset))\\n            )\\n            .wmul(WadRayMath.WAD - data.priceOracle.getPairPriceDrop(_positionAsset, address(data.borrowedAsset)))\\n            .wmul(_positionAmount) * 10 ** (18 - IERC20Metadata(_positionAsset).decimals());\\n        // numerator = data.bucket.feeBuffer().wmul(_positionDebt) * multiplier1;\\n        return (data.bucket.feeBuffer().wmul(_positionDebt) * multiplier1).wdiv(denominator) / multiplier1;\\n    }\\n\\n    /**\\n     * @notice Validates if a position meets the minimum size requirement.\\n     * @param _minPositionSize The minimum position size.\\n     * @param _minPositionAsset The asset associated with the minimum position size.\\n     * @param _amount The amount of the asset in the position.\\n     * @param _asset The asset associated with the position.\\n     * @param _priceOracle The address of the price oracle contract.\\n     */\\n    function validateMinPositionSize(\\n        uint256 _minPositionSize,\\n        address _minPositionAsset,\\n        uint256 _amount,\\n        address _asset,\\n        address _priceOracle\\n    ) public view {\\n        _require(\\n            isCorrespondsMinPositionSize(_minPositionSize, _minPositionAsset, _asset, _amount, _priceOracle),\\n            Errors.INSUFFICIENT_POSITION_SIZE.selector\\n        );\\n    }\\n\\n    /**\\n     * @notice Checks if the given amount of _asset corresponds to the minimum position size _minPositionSize,\\n     * based on the _minPositionAsset and the provided _priceOracle.\\n     * Returns true if the amount corresponds to or exceeds the minimum position size, otherwise returns false.\\n     * @param _minPositionSize The minimum position size required.\\n     * @param _minPositionAsset The address of the asset used for determining the minimum position size.\\n     * @param _asset The address of the asset being checked.\\n     * @param _amount The amount of _asset being checked.\\n     * @param _priceOracle The address of the price oracle contract.\\n     * @return A boolean value indicating whether the amount corresponds to or exceeds the minimum position size.\\n     */\\n    function isCorrespondsMinPositionSize(\\n        uint256 _minPositionSize,\\n        address _minPositionAsset,\\n        address _asset,\\n        uint256 _amount,\\n        address _priceOracle\\n    ) public view returns (bool) {\\n        if (_minPositionSize == 0) return true;\\n\\n        uint256 amountInMinPositionAsset = getOracleAmountsOut(_asset, _minPositionAsset, _amount, _priceOracle);\\n        return amountInMinPositionAsset >= _minPositionSize;\\n    }\\n\\n    /**\\n     * @notice Decodes an encoded path and returns an array of addresses.\\n     * @param encodedPath The encoded path to be decoded.\\n     * @param dexRouter The address of the DEX router.\\n     * @param dexAdapter The address of the DEX adapter.\\n     * @return path An array of addresses representing the decoded path.\\n     */\\n    function decodePath(\\n        bytes memory encodedPath,\\n        address dexRouter,\\n        address dexAdapter\\n    ) public view returns (address[] memory path) {\\n        IDexAdapter.DexType type_ = IDexAdapter(dexAdapter).dexType(dexRouter);\\n\\n        if (type_ == IDexAdapter.DexType.UniswapV2 || type_ == IDexAdapter.DexType.Meshswap) {\\n            path = abi.decode(encodedPath, (address[]));\\n        } else if (type_ == IDexAdapter.DexType.UniswapV3) {\\n            uint256 skip;\\n            uint256 offsetSize = 23; // address size(20) + fee size(3)\\n            uint256 pathLength = encodedPath.length / offsetSize + 1;\\n            path = new address[](pathLength);\\n            for (uint256 i; i < pathLength; i++) {\\n                path[i] = encodedPath.toAddress(skip, encodedPath.length);\\n                skip += offsetSize;\\n            }\\n        } else if (type_ == IDexAdapter.DexType.Curve) {\\n            (path, ) = abi.decode(encodedPath, (address[], address[]));\\n        } else if (type_ == IDexAdapter.DexType.Balancer) {\\n            (path, , ) = abi.decode(encodedPath, (address[], bytes32[], int256[]));\\n        } else if (type_ == IDexAdapter.DexType.AlgebraV3) {\\n            uint256 skip;\\n            uint256 offsetSize = 20; // address size(20)\\n            uint256 pathLength = encodedPath.length / offsetSize;\\n            path = new address[](pathLength);\\n            for (uint256 i; i < pathLength; i++) {\\n                path[i] = encodedPath.toAddress(skip, encodedPath.length);\\n                skip += offsetSize;\\n            }\\n        } else {\\n            _revert(Errors.UNKNOWN_DEX_TYPE.selector);\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves the price from two price feeds.\\n     * @dev This function returns the price ratio between the base price and the quote price.\\n     * @param basePriceFeed The address of the base price feed (AggregatorV3Interface).\\n     * @param quotePriceFeed The address of the quote price feed (AggregatorV3Interface).\\n     * @param roundBaseFeed The round ID of the base price feed.\\n     * @param roundQuoteFeed The round ID of the quote price feed.\\n     * @param checkedTimestamp The timestamp used to filter relevant prices. Set to 0 to consider all prices.\\n     * @return The price ratio in WAD format between the base price and the quote price, and the timestamp of the latest price.\\n     */\\n    function getPriceFromFeeds(\\n        AggregatorV3Interface basePriceFeed,\\n        AggregatorV3Interface quotePriceFeed,\\n        uint80 roundBaseFeed,\\n        uint80 roundQuoteFeed,\\n        uint256 checkedTimestamp\\n    ) internal view returns (uint256, uint256) {\\n        (, int256 basePrice, , uint256 basePriceUpdatedAt, ) = basePriceFeed.getRoundData(roundBaseFeed);\\n        (, , , uint256 basePriceUpdatedAtNext, ) = basePriceFeed.getRoundData(roundBaseFeed + 1);\\n        // update to current timestamp if roundBaseFeed is last round\\n        if (basePriceUpdatedAtNext == 0) basePriceUpdatedAtNext = block.timestamp;\\n\\n        (, int256 quotePrice, , uint256 quotePriceUpdatedAt, ) = quotePriceFeed.getRoundData(roundQuoteFeed);\\n        (, , , uint256 quotePriceUpdatedAtNext, ) = quotePriceFeed.getRoundData(roundQuoteFeed + 1);\\n        // update to current timestamp if roundQuoteFeed is last round\\n        if (quotePriceUpdatedAtNext == 0) quotePriceUpdatedAtNext = block.timestamp;\\n\\n        _require(basePriceUpdatedAt > 0 && quotePriceUpdatedAt > 0, Errors.DATA_FOR_ROUND_DOES_NOT_EXIST.selector);\\n\\n        // we work only with prices that were relevant after position creation\\n        _require(\\n            checkedTimestamp == 0 ||\\n                (basePriceUpdatedAtNext > checkedTimestamp && quotePriceUpdatedAtNext > checkedTimestamp),\\n            Errors.HIGH_PRICE_TIMESTAMP_IS_INCORRECT.selector\\n        );\\n        // there should be an intersection between their duration\\n        _require(\\n            quotePriceUpdatedAt < basePriceUpdatedAtNext && basePriceUpdatedAt < quotePriceUpdatedAtNext,\\n            Errors.NO_PRICE_FEED_INTERSECTION.selector\\n        );\\n        //the return value will always be 18 decimals if the basePrice and quotePrice have the same decimals\\n        return (\\n            uint256(basePrice).wdiv(uint256(quotePrice)),\\n            quotePriceUpdatedAt < basePriceUpdatedAt ? quotePriceUpdatedAt : basePriceUpdatedAt\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the asset multiplier for a given asset.\\n     * @dev If the asset is the native currency, the function returns 1.\\n     * If the asset is USD, the function returns the value stored in the constant USD_MULTIPLIER.\\n     * For any other asset, the function calculates the multiplier based on the number of decimals of the token.\\n     * @param _asset The address of the asset.\\n     * @return The asset multiplier. It is a number with 10 raised to a power of decimals of a given asset.\\n     */\\n    function _getAssetMultiplier(address _asset) internal view returns (uint256) {\\n        if (_asset == NATIVE_CURRENCY) return 1;\\n        if (_asset == USD) return USD_MULTIPLIER;\\n\\n        return 10 ** (18 - IERC20Metadata(_asset).decimals());\\n    }\\n}\\n\",\"keccak256\":\"0x809e37adba4a9add4c4586267bcee279140cf4a2d419ac81f33b5b929429b441\",\"license\":\"BUSL-1.1\"},\"contracts/libraries/TokenTransfersLibrary.sol\":{\"content\":\"// Copyright 2020 Compound Labs, Inc.\\n// (c) 2023 Primex.finance\\n// SPDX-License-Identifier: BSD-3-Clause\\n\\n// Modified version of token transfer logic that allows working with non-standart ERC-20 tokens, added method doTransferFromTo,\\n// modified doTransferIn\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./Errors.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {EIP20NonStandardInterface} from \\\"../interfaces/EIP20NonStandardInterface.sol\\\";\\n\\nlibrary TokenTransfersLibrary {\\n    function doTransferIn(address token, address from, uint256 amount) public returns (uint256) {\\n        return doTransferFromTo(token, from, address(this), amount);\\n    }\\n\\n    function doTransferFromTo(address token, address from, address to, uint256 amount) public returns (uint256) {\\n        uint256 balanceBefore = IERC20(token).balanceOf(to);\\n        // The returned value is checked in the assembly code below.\\n        // Arbitrary `from` should be checked at a higher level. The library function cannot be called by the user.\\n        // slither-disable-next-line unchecked-transfer arbitrary-send-erc20\\n        EIP20NonStandardInterface(token).transferFrom(from, to, amount);\\n\\n        bool success;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            switch returndatasize()\\n            case 0 {\\n                // This is a non-standard ERC-20\\n                success := not(0) // set success to true\\n            }\\n            case 32 {\\n                // This is a compliant ERC-20\\n                returndatacopy(0, 0, 32)\\n                success := mload(0) // Set `success = returndata` of external call\\n            }\\n            default {\\n                // This is an excessively non-compliant ERC-20, revert.\\n                revert(0, 0)\\n            }\\n        }\\n        _require(success, Errors.TOKEN_TRANSFER_IN_FAILED.selector);\\n\\n        // Calculate the amount that was *actually* transferred\\n        uint256 balanceAfter = IERC20(token).balanceOf(to);\\n        _require(balanceAfter >= balanceBefore, Errors.TOKEN_TRANSFER_IN_OVERFLOW.selector);\\n\\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\\n    }\\n\\n    function doTransferOut(address token, address to, uint256 amount) public {\\n        // The returned value is checked in the assembly code below.\\n        // slither-disable-next-line unchecked-transfer\\n        EIP20NonStandardInterface(token).transfer(to, amount);\\n\\n        bool success;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            switch returndatasize()\\n            case 0 {\\n                // This is a non-standard ERC-20\\n                success := not(0) // set success to true\\n            }\\n            case 32 {\\n                // This is a complaint ERC-20\\n                returndatacopy(0, 0, 32)\\n                success := mload(0) // Set `success = returndata` of external call\\n            }\\n            default {\\n                // This is an excessively non-compliant ERC-20, revert.\\n                revert(0, 0)\\n            }\\n        }\\n        _require(success, Errors.TOKEN_TRANSFER_OUT_FAILED.selector);\\n    }\\n\\n    function doTransferOutETH(address to, uint256 value) internal {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        _require(success, Errors.NATIVE_TOKEN_TRANSFER_FAILED.selector);\\n    }\\n}\\n\",\"keccak256\":\"0x055c6c72633f72ec523e7b74a58549f12e8c92320a6a06ae74503f637cb2ab97\",\"license\":\"BSD-3-Clause\"},\"contracts/libraries/utils/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// A modified version of BytesLib\\n// Origin: https://github.com/1inch/universal-router/blob/b972662f8d3f0ba55ef99411720f613f77c3fab5/contracts/modules/uniswap/v3/BytesLib.sol\\n// Unused methods and constants were removed\\npragma solidity 0.8.18;\\n\\nlibrary BytesLib {\\n    error ToAddressOverflow();\\n    error ToAddressOutOfBounds();\\n\\n    /// @notice Returns the address starting at byte `_start`\\n    /// @dev _bytesLength must equal _bytes.length for this to function correctly\\n    /// @param _bytes The input bytes string to slice\\n    /// @param _start The starting index of the address\\n    /// @param _bytesLength The length of _bytes\\n    /// @return tempAddress The address starting at _start\\n    function toAddress(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _bytesLength\\n    ) internal pure returns (address tempAddress) {\\n        unchecked {\\n            if (_start + 20 < _start) revert ToAddressOverflow();\\n            if (_bytesLength < _start + 20) revert ToAddressOutOfBounds();\\n        }\\n\\n        assembly {\\n            tempAddress := mload(add(add(_bytes, 0x14), _start))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x15247d5d083082fd3ada31426c5c355a35606682f4587132c847c63c74d23315\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/utils/WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n// A modified version of ds-math library\\n// Origin: https://github.com/dapphub/ds-math/blob/master/src/math.sol\\n// Unused methods were removed, errors changed\\n\\npragma solidity 0.8.18;\\nerror DS_MATH_ADD_OVERFLOW();\\nerror DS_MATH_MUL_OVERFLOW();\\n\\nlibrary WadRayMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        if ((z = x + y) < x) revert DS_MATH_ADD_OVERFLOW();\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        if (!(y == 0 || (z = x * y) / y == x)) revert DS_MATH_MUL_OVERFLOW();\\n    }\\n\\n    uint256 internal constant WAD = 10 ** 18;\\n    uint256 internal constant RAY = 10 ** 27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    //rounds to zero if x*y < RAY / 2\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n}\\n\",\"keccak256\":\"0xb0991b2c77df3496e4595618675a4279bd187aa4968bfbcf3be47f80c49280b3\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60808060405234620000c6576000549060ff8260081c1662000074575060ff8082160362000038575b604051615cd99081620000cc8239f35b60ff90811916176000557f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498602060405160ff8152a13862000028565b62461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b6064820152608490fd5b600080fdfe608080604052600436101561001357600080fd5b600090813560e01c90816301ffc9a714614063575080630224f16a1461400e57806306fdde0314613f375780631003d99d14613d1b57806313a1fcb914613cfa578063165e780514613cd957806318f88b6d14613bb257806322f3e2d414613b1e578063235f17f5146137ab57806327c37b251461378a578063298410e5146137605780632a5ad159146136865780632acabb11146135ab5780632e51d3ed14613573578063304fe59814612ab057806330db585614612a8d5780633e07460814612a645780633edd112814612874578063478827851461285657806347e7ef24146126a15780634872d3271461266b5780634a5e42b1146125235780634ad09aa5146124695780634f43f2391461235157806358a06f071461232857806358d7bf801461230a57806368d0612f146122b357806371a6cab714612295578063743753591461227a578063791b98bc146122515780637b10399914612228578063883c6b24146122055780638eed7780146121dc578063905e3837146121bb57806398cc6b1e146120b85780639b622c0214612093578063a00622dc14612075578063a223f82114612057578063a4c1cccb1461200f578063ac1e502514611fb1578063b28f7a1d14611f93578063bbf44f3314611f6c578063bd449dde14611f45578063bda896c414611191578063c07dc61414611109578063c717823014611044578063cd3293de1461101b578063d0b6543d14610ef4578063e526e4ab14610e83578063eae12b7f14610bbf578063ef379d1714610b96578063f066eea014610ad0578063f3fef3a31461046b578063f5bfeb441461044d578063f8190a46146102e6578063f8d89898146102bd5763febb0f7e1461029457600080fd5b346102ba57806003193601126102ba5760206001600160801b03606d5416604051908152f35b80fd5b50346102ba57806003193601126102ba57606a546040516001600160a01b039091168152602090f35b50346102ba5760603660031901126102ba576103006141b5565b60243561030b6141cb565b91610314615a9d565b60ff607b5460a01c161561043b57606b5484936001600160a01b0391734FFa6c545a6249baF2D66ce21CeF3D2C2cCa69D091908316823b1561043757604051636336129b60e11b81526001600160a01b0391821660048201529116602482015260448101859052908590829060649082905af490811561042c578591610413575b505061039f614c64565b606a5416606f5460801c90803b1561040f576103d59385809460405196879586948593630ab714fb60e11b8552600485016144f7565b03925af18015610404576103f0575b506103ed615378565b80f35b6103f99061410a565b6102ba5780386103e4565b6040513d84823e3d90fd5b8480fd5b61041c9061410a565b610427578338610395565b505050fd5b6040513d87823e3d90fd5b8680fd5b6040516379bb149f60e11b8152600490fd5b50346102ba57806003193601126102ba576020607754604051908152f35b50346102ba5760403660031901126102ba576104856141b5565b60248035916104926143fb565b61049a615b05565b83607b5460ff8160a01c161560001461099f576001600160a01b0316803b1561099b578160405180926308f57fc760e11b8252606060048301528183816104e360648201614465565b338b8301528b604483015203925af1801561040457610983575b50505b60ff607b5460a01c16610976575b60018060a01b038060695416926001600160801b03606f5416946040518095637a94c56560e11b825281898161054c60209b8c9733600485016144f7565b03925af193841561075f578694610947575b50607354670de0b6b3a7640000908103818111610934576105828661058792615bf5565b615b92565b0461059281866142a5565b60ff607b5460a01c161580610928575b8061091d575b6107f2575b83606b5416928760405180926370a0823160e01b825230600483015281875afa9081156107e75789916107b5575b5086116107a3578792734FFa6c545a6249baF2D66ce21CeF3D2C2cCa69D0916004898760835416604051928380926361d027b360e01b82525afa90811561075f57869161076e575b50833b1561076a57604051636336129b60e11b8082526001600160a01b03948516600483015291909316602484015260448301829052918581606481875af490811561075f57869161074b575b50506040519081527f590e5a1563e349794fdcc066c4d5047f5e478f9e41707fc1bbad830146b7a177893392a284606b541691803b1561040f576040519182526001600160a01b039283166004830152918616602482015260448101929092528290829060649082905af4801561040457610737575b50507f9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb9160ff607b5460a01c1661072a575b60405193845216923392a36001805580f35b610732615378565b610718565b6107409061410a565b61040f5784386106e6565b6107549061410a565b61040f578438610670565b6040513d88823e3d90fd5b8580fd5b90508981813d831161079c575b6107858183614154565b8101031261076a5761079690614451565b38610623565b503d61077b565b604051630d5f777560e21b8152600490fd5b90508781813d83116107e0575b6107cc8183614154565b810103126107db5751386105db565b600080fd5b503d6107c2565b6040513d8b823e3d90fd5b607d5442111561080957610804614eba565b6105ad565b60048785608354166040519283809263a03e4bc360e01b82525afa80156107e75785918a916108e1575b501684606b541660405190631a4ca37b60e21b82526004820152878582015230604482015288816064818d865af19081156108d65789916108ad575b507f6407790cdabc5d219eaf901091d6beccc475533065c2fbd374c8a32b1c66795890604051898152a26108a5866077546142a5565b6077556105ad565b813d83116108cf575b6108c08183614154565b810103126107db57873861086f565b503d6108b6565b6040513d8c823e3d90fd5b809250898092503d8311610916575b6108fa8183614154565b810103126109125761090c8591614451565b38610833565b8880fd5b503d6108f0565b5060775415156105a8565b5060ff607854166105a2565b634e487b7160e01b885260116004528288fd5b9093508481813d831161096f575b61095f8183614154565b810103126107db5751923861055e565b503d610955565b61097e614c64565b61050e565b61098c9061410a565b6109975783386104fd565b8380fd5b5080fd5b9050607f5442106109b1575b50610500565b6069546040516370a0823160e01b81523360048201526020916001600160a01b039190839082908890829086165afa918215610ac55783918993610a94575b506040519485809263be5daee560e01b82526040600483015281610a1660448201614465565b338c8301520392165afa918215610a89578792610a57575b50610a3992506142a5565b8311610a4557386109ab565b6040516342b0cbe760e11b8152600490fd5b90915082813d8311610a82575b610a6e8183614154565b810103126107db57610a3991519038610a2e565b503d610a64565b6040513d89823e3d90fd5b8281939294503d8311610abe575b610aac8183614154565b810103126107db5782905191386109f0565b503d610aa2565b6040513d8a823e3d90fd5b50346102ba57806003193601126102ba576040518091607a549081835260208093018092607a83527ff0440771a29e57e18c66727944770b82cc77924aef333c927ce6bdd2cdb3ae0390835b818110610b795750505084610b32910385614154565b60405193838594850191818652518092526040850193925b828110610b5957505050500390f35b83516001600160a01b031685528695509381019392810192600101610b4a565b82546001600160a01b031684529286019260019283019201610b1c565b50346102ba57806003193601126102ba576074546040516001600160a01b039091168152602090f35b50346102ba576003199060c0368301126102ba576001600160401b03600435818111610e7f57610bf390369060040161420e565b9160243590811161099757610c0c90369060040161420e565b90610c156141cb565b606654604051632474521560e21b81527f28eb28c26cbbd48a6bfad016505ccf4a189452995f59d16217af8920961ed25c6004820152336024820152608435966001600160a01b039660209490939192606435928690829060449082908d165afa908115610e7357600091610e3e575b5015610e2c5781610dad575b5050610c9b614c64565b85606a541692606f5491843b15610da95760405163eb1738e560e01b815260806004820152608481018290529760a489019491908b905b828210610d85575050505086830390990160248701528482529697959688966001600160fb1b038611610d815786809581948a9894899560051b80938684013760801c604484015260a4356064840152010301925af1801561040457610d6d575b5050610d3d615378565b80610d46575080f35b610d5f610d67916001600160801b03606f541690615c2c565b607154614298565b60715580f35b610d769061410a565b61099b578138610d33565b8780fd5b909192958635908282168092036107db579081528401958401929160010190610cd2565b8980fd5b734FFa6c545a6249baF2D66ce21CeF3D2C2cCa69D09088606b5416823b15610e2857604051636336129b60e11b81526001600160a01b0391821660048201529116602482015260448101929092528990829060649082905af480156107e75790899115610c9157610e1d9061410a565b610d81578738610c91565b8b80fd5b60405163036be76f60e61b8152600490fd5b908682813d8311610e6c575b610e548183614154565b810103126102ba5750610e669061423e565b38610c85565b503d610e4a565b6040513d6000823e3d90fd5b8280fd5b50346102ba5760203660031901126102ba57600435610ea0615a54565b670de0b6b3a7640000811015610ee2576020817fb2429786195476a340c6c3ff6be51a0d28d9ea08dea6c91a0720b1e200400e8c92607255604051908152a180f35b604051631757762160e01b8152600490fd5b50346102ba5760a03660031901126102ba57610f0e6141b5565b81610f176141cb565b6084359290606435610f27615a9d565b80610f8f575b5050610f37614c64565b60018060a01b03606a541690606f5460801c823b1561099757610f7792849283604051809681958294637a94c56560e11b845260243590600485016144f7565b03925af1801561040457610d6d575050610d3d615378565b606b546001600160a01b031690734FFa6c545a6249baF2D66ce21CeF3D2C2cCa69D0803b1561076a57604051636336129b60e11b81526001600160a01b03938416600482015293909216602484015260448301528390829060649082905af490811561101057839115610f2d576110059061410a565b61099b578138610f2d565b6040513d85823e3d90fd5b50346102ba57806003193601126102ba576068546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba5760835460405163481d98fb60e11b815260206004820152919060809083906001600160a01b0316818061108a60248201614465565b03915afa9182156110fc5781926110c8575b5060038210156110b457602082600260405191148152f35b634e487b7160e01b81526021600452602490fd5b6110ea91925060803d81116110f5575b6110e28183614154565b81019061457f565b50509050903861109c565b503d6110d8565b50604051903d90823e3d90fd5b50346102ba5760203660031901126102ba5760043561112661594a565b670de0b6b3a7640000811180611180575b1561116e576020817f6db5a699a2b18e7a2568814d453dff8a78eb41c9daf9d45bdeab3824f49c941592606c55604051908152a180f35b60405163c42aecdf60e01b8152600490fd5b50670e043da6172500008110611137565b50346102ba5760031960403682011261099b576001600160401b036004351161099b5761030090600435360301126102ba57602435906001600160a01b03821682036107db5780549160ff8360081c161592838094611f38575b8015611f21575b15611ec55760ff198116600117835583611eb4575b506040516301ffc9a760e01b8152637965db0b60e01b60048201526020816024816001600160a01b0386165afa908115611010578391611e7a575b5080611dee575b80611d61575b80611cd4575b80611c47575b80611bba575b80611b2d575b80611a9f575b80611a12575b15611a0057600460206001600160a01b0361129283356101240161424b565b166040519283809263313ce56760e01b82525afa9081156110105760129160ff9185916119d1575b5016116119bf5767016345785d8a00006101646004350135116119ad57670de0b6b3a76400008061014460043501351180611995575b1561116e5761018460043501351015610ee2576102e4600435013515611983576004356101c401356117cd57607b805460ff60a01b1916600160a01b1790557f5023432d2ef8583c6eb5ee4501bf4740bf68b6fe4823da8f19ddedd1135f2a648280a15b6004356102e48101356079556001600160a01b0390611376906102240161424b565b1661138c6102c4600435016004356004016142c6565b8291923b1561040f579184916113c19383604051809681958294632acabb1160e01b84526020600485015260248401916142f8565b03925af18015611010579083916117b9575b506113e490506004803501806142c6565b906001600160401b0382116117a55781906114006065546140d0565b601f8111611733575b508490601f83116001146116bf5785926116b4575b50508160011b916000199060031b1c191617606555915b6001600160a01b0361144b60043560240161424b565b16906bffffffffffffffffffffffff60a01b9182606954161760695560018060a01b0361147c60a46004350161424b565b1682608354161760835560018060a01b0361149b60646004350161424b565b1682606754161760675560018060a01b036114ba60846004350161424b565b1682608454161760845560018060a01b036114d960446004350161424b565b1682606a541617606a5560018060a01b036114f860c46004350161424b565b1682606854161760685560018060a01b0361151760e46004350161424b565b1682607454161760745560018060a01b036115376101246004350161424b565b1682606b541617606b556101446004350135606c5561016460043501356073556101846004350135607255829161010460043501925b61157c84600435600401614319565b90508110156115f45761159484600435600401614319565b8210156115e057600582901b01356001600160a01b038116810361076a576115bb90615576565b60001981146115cc5760010161156d565b634e487b7160e01b85526011600452602485fd5b634e487b7160e01b86526032600452602486fd5b8483838860018060a01b031681606654161760665560018060a01b0361161f6102246004350161424b565b169060765416176076557b033b2e3c9fd0803ce800000000000000033b2e3c9fd0803ce800000082606f541617606f5581549061167760ff8360081c166116658161434e565b61166e8161434e565b6001805561434e565b61167f575080f35b61ff00191681557f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498602060405160018152a180f35b01359050388061141e565b60658652859350600080516020615c64833981519152915b601f198416851061171b576001945083601f19811610611701575b505050811b0160655591611435565b0135600019600384901b60f8161c191690553880806116f2565b818101358355602094850194600190930192016116d7565b90915060658552601f830160051c600080516020615c648339815191520160208410611790575b908392915b601f820160051c600080516020615c648339815191520181106117825750611409565b86815584935060010161175f565b50600080516020615c6483398151915261175a565b634e487b7160e01b84526041600452602484fd5b6117c29061410a565b61099b5781386113d3565b426101e4600435013511806118f5575b806118e5575b156118d457610204600435013561180f611804826101e46004350135614298565b8060825542906142a5565b6081556001600160a01b036118296004356101a40161424b565b166bffffffffffffffffffffffff60a01b607b541617607b556101c46004350135607c556101e46004350135607d55607e5561028460043501356080556001600160801b0361187d610244600435016142b2565b606e549116836fffffffffffffffffffffffffffffffff196118a4600435610264016142b2565b60801b1692161717606e556102a46004350135801515809103610e7f5760ff801960785416911617607855611354565b604051627706c160e81b8152600490fd5b50610284600435013515156117e3565b50602460206001600160a01b036119116004356101a40161424b565b6040516301ffc9a760e01b815263edebbfe960e01b600482015293849290918391165afa908115611010578391611949575b506117dd565b90506020813d60201161197b575b8161196460209383614154565b81010312610e7f576119759061423e565b38611943565b3d9150611957565b604051637ed7b9ab60e11b8152600490fd5b50670e043da6172500006101446004350135106112f0565b60405163766a53cb60e01b8152600490fd5b60405163b7c73c5d60e01b8152600490fd5b6119f3915060203d6020116119f9575b6119eb8183614154565b81019061425f565b386112ba565b503d6119e1565b60405163044aa57560e41b8152600490fd5b50602460206001600160a01b03611a2d60043560e40161424b565b6040516301ffc9a760e01b8152633df6cef760e01b600482015293849290918391165afa908115611010578391611a65575b50611273565b90506020813d602011611a97575b81611a8060209383614154565b81010312610e7f57611a919061423e565b38611a5f565b3d9150611a73565b50602460206001600160a01b03611abb6004356102240161424b565b6040516301ffc9a760e01b8152633983653f60e21b600482015293849290918391165afa908115611010578391611af3575b5061126d565b90506020813d602011611b25575b81611b0e60209383614154565b81010312610e7f57611b1f9061423e565b38611aed565b3d9150611b01565b50602460206001600160a01b03611b4860043560c40161424b565b6040516301ffc9a760e01b815263d4cb1bcb60e01b600482015293849290918391165afa908115611010578391611b80575b50611267565b90506020813d602011611bb2575b81611b9b60209383614154565b81010312610e7f57611bac9061423e565b38611b7a565b3d9150611b8e565b50602460206001600160a01b03611bd560043560840161424b565b6040516301ffc9a760e01b81526341636c7560e11b600482015293849290918391165afa908115611010578391611c0d575b50611261565b90506020813d602011611c3f575b81611c2860209383614154565b81010312610e7f57611c399061423e565b38611c07565b3d9150611c1b565b50602460206001600160a01b03611c6260043560640161424b565b6040516301ffc9a760e01b81526306cc15a560e11b600482015293849290918391165afa908115611010578391611c9a575b5061125b565b90506020813d602011611ccc575b81611cb560209383614154565b81010312610e7f57611cc69061423e565b38611c94565b3d9150611ca8565b50602460206001600160a01b03611cef60043560440161424b565b6040516301ffc9a760e01b8152633d5b079f60e11b600482015293849290918391165afa908115611010578391611d27575b50611255565b90506020813d602011611d59575b81611d4260209383614154565b81010312610e7f57611d539061423e565b38611d21565b3d9150611d35565b50602460206001600160a01b03611d7c60043560a40161424b565b6040516301ffc9a760e01b815263fa6ab0ef60e01b600482015293849290918391165afa908115611010578391611db4575b5061124f565b90506020813d602011611de6575b81611dcf60209383614154565b81010312610e7f57611de09061423e565b38611dae565b3d9150611dc2565b50602460206001600160a01b03611e08600435840161424b565b6040516301ffc9a760e01b81526337a557d360e01b600482015293849290918391165afa908115611010578391611e40575b50611249565b90506020813d602011611e72575b81611e5b60209383614154565b81010312610e7f57611e6c9061423e565b38611e3a565b3d9150611e4e565b90506020813d602011611eac575b81611e9560209383614154565b81010312610e7f57611ea69061423e565b38611242565b3d9150611e88565b61ffff191661010117825538611207565b60405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b50303b1580156111f25750600160ff8216146111f2565b50600160ff8216106111eb565b50346102ba57806003193601126102ba5760206001600160801b03606e5416604051908152f35b50346102ba57806003193601126102ba5760206001600160801b03606f5416604051908152f35b50346102ba57806003193601126102ba576020607154604051908152f35b50346102ba5760203660031901126102ba57600435611fce615a54565b67016345785d8a000081116119ad576020817ffc1353e6b18ce07b5a979c8edf77a87455939a17a9eebbb084dcde5bfb3b19ac92607355604051908152a180f35b50346102ba5760203660031901126102ba5760409081906001600160a01b036120366141b5565b16815260756020522060ff6001825492015416825191825215156020820152f35b50346102ba57806003193601126102ba576020607354604051908152f35b50346102ba57806003193601126102ba576020606c54604051908152f35b50346102ba57806003193601126102ba5760206120ae6145b1565b6040519015158152f35b50346102ba57806003193601126102ba57604051610120916120d98261411d565b8082528060208301528060408301528060608301528060808301528060a08301528060c08301528060e0830152610100809201526040519061211a8261411d565b607b549160018060a01b0383169283825260ff602083019160a01c1615158152607c5460408301908152607d5460608401908152607e5460808501908152607f549160a086019283526080549360c087019485526081549560e08801968752886082549801978852604051998a5251151560208a01525160408901525160608801525160808701525160a08601525160c08501525160e08401525190820152f35b50346102ba57806003193601126102ba576020606d5460801c604051908152f35b50346102ba57806003193601126102ba57606b546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba576020612220614651565b604051908152f35b50346102ba57806003193601126102ba576066546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba576067546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba57602061222061468b565b50346102ba57806003193601126102ba576020607954604051908152f35b50346102ba57806003193601126102ba576020676765c793fa10079d601b1b6123016122fc6122f06001600160801b03606d541660705490615853565b606f5460801c90615bf5565b615bc0565b04604051908152f35b50346102ba57806003193601126102ba576020607254604051908152f35b50346102ba57806003193601126102ba576069546040516001600160a01b039091168152602090f35b50346102ba5760203660031901126102ba5760043561236e6143fb565b6123888161237a615b05565b612382614651565b90615c2c565b8015612457576123ea9160209160715480821161242c575b036071556069546001600160a01b03166123b8614651565b604051637a94c56560e11b81523360048201526024810193909352604483015290928391908290869082906064820190565b03925af1801561040457612401575b506001805580f35b602090813d8111612425575b6124178183614154565b810103126107db57386123f9565b503d61240d565b91505080676765c793fa10079d601b1b6124506122fc61244a614651565b85615bf5565b04916123a0565b604051637c123f8b60e01b8152600490fd5b50346102ba57806003193601126102ba5760835460405163481d98fb60e11b815260206004820152919060809083906001600160a01b031681806124af60248201614465565b03915afa90811561251757809281926124f0575b5060038310156110b4575060026020921490816124e6575b506040519015158152f35b90504211386124db565b90925061250b915060803d81116110f5576110e28183614154565b509291509190386124c3565b604051903d90823e3d90fd5b50346102ba5760203660031901126102ba5761253d6141b5565b6125456159ec565b6001600160a01b03908116808352607560205260408320600181015491929160ff161561265957607a5460001992908381019081116126455761258882916143ae565b90549060031b1c16926125be8461259f85546143ae565b90919082549060031b9160018060a01b03809116831b921b1916179055565b607a54801561263157917fa48303bd6cd678b9b13454996417095d2d282db59c4db9ba88df8c82d04869789593916020959301906125fb826143ae565b909182549160031b1b19169055607a5554908552607583526040852055808452836001604082208281550155604051908152a180f35b634e487b7160e01b87526031600452602487fd5b634e487b7160e01b86526011600452602486fd5b60405163b7addff360e01b8152600490fd5b50346102ba57806003193601126102ba576020676765c793fa10079d601b1b6123016122fc60715461269b614651565b90615bf5565b50346102ba5760403660031901126102ba576126bb6141b5565b6024356126c66143fb565b6126ce615b05565b6069546040516318160ddd60e01b8152602093916001600160a01b03919085908290600490829086165afa801561075f5784908790612825575b6127129250614298565b607954111561281357606b5460405163c37f7f7f60e01b81529082166001600160a01b0316600482015233602482015260448101849052848180606481015b0381734FFa6c545a6249baF2D66ce21CeF3D2C2cCa69D05af490811561075f5785916127ea575b5050607b5460a01c60ff16156127b557816127a284600080516020615c8483398151915294614709565b5060405193845216923392a36001805580f35b33818316036127d8578161073284600080516020615c8483398151915294614833565b60405163217fe6c760e11b8152600490fd5b813d831161280c575b6127fd8183614154565b810103126107db578338612778565b503d6127f3565b604051630a5a765f60e31b8152600490fd5b50508481813d831161284f575b61283c8183614154565b810103126107db57836127129151612708565b503d612832565b50346102ba57806003193601126102ba576020607054604051908152f35b50346102ba5760603660031901126102ba5761288e6141b5565b602435604435918215158303610997576128a66143fb565b6128ae615b05565b6069546040516318160ddd60e01b81526020946001600160a01b039290919086908290600490829087165afa8015610a895785908890612a33575b6128f39250614298565b6079541115612813571561296357606b5460405163c37f7f7f60e01b81529082166001600160a01b031660048201523360248201526044810184905284818060648101612751565b607b5460a01c60ff16156127b557816127a284600080516020615c8483398151915294614709565b84600485836067541660405192838092634cb4430f60e11b82525afa801561040457839183916129f9575b501682606b5416813b15610e7f57829160a48392604051948593849263c268dd3160e01b845233600485015230602485015260448401528a60648401528160848401525af18015610404576129e5575b505061293b565b6129ee9061410a565b61040f5784386129de565b809250878092503d8311612a2c575b612a128183614154565b8101031261099b5751828116810361099b5782903861298e565b503d612a08565b50508581813d8311612a5d575b612a4a8183614154565b810103126107db57846128f391516128e9565b503d612a40565b50346102ba57806003193601126102ba576076546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba57602060ff607854166040519015158152f35b50346102ba5760803660031901126102ba576004356001600160401b03811161099b57612ae19036906004016141e1565b6024356001600160a01b0381168103610997576044356001600160401b03811161040f57612b1390369060040161420e565b612b1b6143fb565b612b23615b05565b60ff607b5460a01c161580613568575b1561355657859460ff607854168061354b575b61353e575b60835460405163af9a2aa760e01b815260206004820181905290969187906001600160a01b03168180612b826024820187896142f8565b03915afa958615610a89578796613502575b50607b54604051634c66358f60e11b81526001600160a01b03918216929161012090829060049082908c165afa80156107e7578990613452575b602091500151151591607d5493813b15610da95789612c2293819560405197889687958694638f8ebe1560e01b865260a06004870152612c1060a48701614465565b868103600319016024880152916142f8565b913360448501526064840152608483015203925af190811561075f57869161343e575b5050606954606f54604051637a94c56560e11b815233600482015260001960248201526001600160801b0390911660448201529660209188916064918391906001600160a01b03165af195861561042c57859661340a575b5060405186815286906001600160a01b0386169033907f9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb90602090a360405163011ddaef60e71b8152966020886004816001600160a01b038a165afa978815610a895787986133c6575b50606b546001600160a01b039081169089168114613331575050606654604051632474521560e21b81527fe965846df3dd5b1dfa65f58e31477079e90140e0908b6dd31b5aead5a57cf36560048201526001600160a01b038681166024830152909160209183916044918391165afa908115610a895787916132f7575b5015610e2c57606b5460405163095ea7b360e01b81526001600160a01b038681166004830152602482018490529091602091839160449183918c91165af18015610a89576132be575b50606b5460405197906001600160a01b03166001600160401b036101608a01908111908a11176132a8576101608901604052885260018060a01b0316602088015260408701526064356060870152612e2481614522565b91612e326040519384614154565b8183526020830190368360051b8201116104375780915b8360051b820183106130f45750505050608085019081526001600160a01b0383811660a08701524260c0870152600160e0870181905261010087015261012086018590526101408601859052604080516373cb40a560e11b81526060600482018190528851841660648301526020808a015190941660848301529188015160a48201529087015160c4820152915161016060e484015280516101c484018190529293926101e4600582901b86018101939290920191879086015b82821061304957505050506020918386818094610140839b60018060a01b0360a08201511661010485015260c081015161012485015260e0810151151561014485015261010081015115156101648501526101208101511515610184850152015115156101a4830152826024830152826044830152039260018060a01b03165af1908115611010578391613014575b50905b607e54916001600160a01b0382163b15610427578391604051938492631003d99d60e01b84523360048501526024840152604483015260806064830152818381612fe160848201614465565b03926001600160a01b03165af180156104045761300057506001805580f35b6130099061410a565b6102ba5780386123f9565b9250506020823d602011613041575b8161303060209383614154565b810103126107db5782915138612f92565b3d9150613023565b909192936101e31987820301825284519060206040820192805183520151916040602083015282518091526060820190602060608260051b8501019401928c5b8281106130a9575050505050602080600192960192019201909291612f03565b90919293946020806130e7600193605f19878203018952895190836130d78351604084526040840190614175565b9201519084818403910152614175565b9701950193929101613089565b6001600160401b03833511610d8157604083358301360312610d815760405161311c81614139565b8335830180358252602001356001600160401b038111610da95736601f828735870101011215610da9578085358501013561315681614522565b916131646040519384614154565b81835260208301903660208460051b838b358b01010101116132a457602081893589010101915b60208460051b838b358b0101010183106131b8575050505091816020938480940152815201920191612e49565b6001600160401b038335116132a05760408935890183018435013603601f1901126132a0576040516131e981614139565b60208435848c358c01010101356001600160401b03811161329c57368b358b0185018635018201603f01121561329c576132379036908c358c01860187350101602081013590604001614539565b815260408435848c358c01010101356001600160401b03811161329c57368b358b0185018635018201603f01121561329c576020928392909161328d9036908e358e018801893501018086013590604001614539565b8382015281520192019161318b565b8f80fd5b8d80fd5b8c80fd5b634e487b7160e01b600052604160045260246000fd5b6020813d6020116132ef575b816132d760209383614154565b81010312610437576132e89061423e565b5038612dcd565b3d91506132ca565b90506020813d602011613329575b8161331260209383614154565b81010312610437576133239061423e565b38612d84565b3d9150613305565b92509493509150849550734FFa6c545a6249baF2D66ce21CeF3D2C2cCa69D091823b1561076a57604051636336129b60e11b81526001600160a01b03928316600482015291841660248301526044820152908490829060649082905af49081156133bb5784916133a3575b5050612f95565b6133ac9061410a565b6133b757823861339c565b5050fd5b6040513d86823e3d90fd5b9097506020813d602011613402575b816133e260209383614154565b8101031261043757516001600160a01b0381168103610437579638612d07565b3d91506133d5565b9095506020813d602011613436575b8161342660209383614154565b810103126107db57519438612c9d565b3d9150613419565b6134479061410a565b61040f578438612c45565b50610120813d610120116134fa575b8161346f6101209383614154565b81010312610912576040516134838161411d565b8151916001600160a01b03831683036134f65760209282526134a683820161423e565b8383015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c081015160c083015260e081015160e08301526101008091015190820152612bce565b8a80fd5b3d9150613461565b9095506020813d602011613536575b8161351e60209383614154565b810103126104375761352f90614451565b9438612b94565b3d9150613511565b613546614eba565b612b4b565b506077541515612b46565b604051634288230360e01b8152600490fd5b50607d544211612b33565b50346102ba57806003193601126102ba5760ff607b5460a01c16806135a0575b6020906040519015158152f35b50607f544211613593565b50346102ba5760203660031901126102ba576004356001600160401b03811161099b576135dc9036906004016141e1565b906135e5615a54565b60765483906001600160a01b0316803b1561099b57816040518092632acabb1160e01b825260206004830152818381613622602482018b8b6142f8565b03925af1801561040457613672575b50507f1ec1ec5da499bc02a52ae44524fff931d2e18c66681bc49118287b566c20174c9161366c6040519283926020845260208401916142f8565b0390a180f35b61367b9061410a565b610e7f578238613631565b50346102ba5760208060031936011261099b576136a16141b5565b6136a9615a54565b6040516301ffc9a760e01b8152633983653f60e21b60048201526001600160a01b039190911691908181602481865afa9081156133bb57849161372b575b5015611a0057607680546001600160a01b031916831790556040519182527f34f2d9c40aeb8886df9cdf9e12d06e2eba1c570a1b296552fe70f037e72bf12c91a180f35b90508181813d8311613759575b6137428183614154565b81010312610997576137539061423e565b386136e7565b503d613738565b50346102ba5760203660031901126102ba576103ed61377d6141b5565b61378561594a565b615576565b50346102ba57806003193601126102ba576020606e5460801c604051908152f35b50346102ba57602090816003193601126102ba576137c76141b5565b6001600160a01b0380821683526075845260408320600101549192909160ff1615612659578160675416906040519363084b557b60e21b85528585600481865afa948515610404578295613aef575b50670de0b6b3a764000094850193848611613adb578561384a610582606c5483613843610582838c615bf5565b0498615bf5565b04936040516301ddf49360e61b81528881600481855afa90811561042c578591613aae575b5087038781116115cc57608454606b54604051631dae49b960e21b81526001600160a01b0387811660048301529186169182166024820152909490918b9183916044918391165afa90811561075f578691613a81575b508803908882116126455761058289926138de92615bf5565b60405163a8905dab60e01b8082526001600160a01b038681166004840152871660248301529592909104908a81604481875afa908115610a89578791613a54575b50890390898211613a4057918961393f6105828d96946139719896615bf5565b6040519788526001600160a01b0392831660048901529390911660248701529091049392839190829081906044820190565b03915afa908115611010578391613a13575b508503918583116139ff57506139a16105826139a894938793615bf5565b04906142a5565b90828102928184048114821517156139e9578304036139d7576139d2612220928260011c90615be0565b614278565b604051631550e8b760e01b8152600490fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b81526011600452602490fd5b90508681813d8311613a39575b613a2a8183614154565b810103126107db575138613983565b503d613a20565b634e487b7160e01b87526011600452602487fd5b90508a81813d8311613a7a575b613a6b8183614154565b810103126107db57513861391f565b503d613a61565b90508981813d8311613aa7575b613a988183614154565b810103126107db5751386138c5565b503d613a8e565b90508881813d8311613ad4575b613ac58183614154565b810103126107db57513861386f565b503d613abb565b634e487b7160e01b83526011600452602483fd5b9094508581813d8311613b17575b613b078183614154565b810103126107db57519338613816565b503d613afd565b50346102ba57806003193601126102ba5760835460405163481d98fb60e11b815260206004820152919060809083906001600160a01b03168180613b6460248201614465565b03915afa9182156110fc578192613b8e575b5060038210156110b457602082600160405191148152f35b613ba791925060803d81116110f5576110e28183614154565b505090509038613b76565b50346102ba5760203660031901126102ba57613bcc615a54565b613bd46145b1565b15613cc857606b546083546040516361d027b360e01b81528392734FFa6c545a6249baF2D66ce21CeF3D2C2cCa69D0926001600160a01b039182169160209184916004918391165afa9182156133bb578492613c8d575b50823b1561042757604051636336129b60e11b81526001600160a01b0391821660048083019190915292909116602482015290356044820152908290829060649082905af4801561040457613c7d5750f35b613c869061410a565b6102ba5780f35b9091506020813d8211613cc0575b81613ca860209383614154565b8101031261042757613cb990614451565b9038613c2b565b3d9150613c9b565b60405162a5e71360e71b8152600490fd5b50346102ba57806003193601126102ba576020606f5460801c604051908152f35b50346102ba57806003193601126102ba57613d136159ec565b6103ed614eba565b50346102ba5760803660031901126102ba57613d356141b5565b6024356044356064356001600160401b03811161040f57613d5a9036906004016141e1565b939091613d656143fb565b6069546040516318160ddd60e01b81526020966001600160a01b0395929091908890829060049082908a165afa80156107e75787908a90613f06575b613dab9250614298565b607954111561281357613de391879186608354169060405180958194829363af9a2aa760e01b845287600485015260248401916142f8565b03915afa908115610a89578791613ed1575b508333911603610e2c57607b5460a01c60ff1615613eb55780613e37575b5090600080516020615c848339815191529160405193845216923392a36001805580f35b85836069541691613e488685614709565b92803b15610e7f57604051632fc3a4b160e21b81526001600160a01b0386166004820152602481019490945260448401919091528290606490829084905af1801561075f5715613e135794613ead600080516020615c8483398151915293929661410a565b949091613e13565b50908161073284600080516020615c8483398151915294614833565b90508581813d8311613eff575b613ee88183614154565b8101031261043757613ef990614451565b38613df5565b503d613ede565b50508781813d8311613f30575b613f1d8183614154565b810103126109125786613dab9151613da1565b503d613f13565b50346102ba57806003193601126102ba576040519080606554613f59816140d0565b80855291600191808316908115613fe45750600114613f9b575b613f9785613f8381870382614154565b604051918291602083526020830190614175565b0390f35b925060658352600080516020615c648339815191525b828410613fcc575050508101602001613f8382613f97613f73565b80546020858701810191909152909301928101613fb1565b869550613f9796935060209250613f8394915060ff191682840152151560051b8201019293613f73565b50346102ba5760203660031901126102ba5760043561402b61594a565b8015611983576020817fd2c55fe32fb2122608950e8daf3216fe57018c4ae02a3b66132249300e8702ed92607955604051908152a180f35b90503461099b57602036600319011261099b5760043563ffffffff60e01b8116809103610e7f57602092506307dba22560e31b81149081156140bf575b81156140ae575b5015158152f35b6301ffc9a760e01b149050386140a7565b63cad9e0d360e01b811491506140a0565b90600182811c92168015614100575b60208310146140ea57565b634e487b7160e01b600052602260045260246000fd5b91607f16916140df565b6001600160401b0381116132a857604052565b61012081019081106001600160401b038211176132a857604052565b604081019081106001600160401b038211176132a857604052565b90601f801991011681019081106001600160401b038211176132a857604052565b919082519283825260005b8481106141a1575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201614180565b600435906001600160a01b03821682036107db57565b604435906001600160a01b03821682036107db57565b9181601f840112156107db578235916001600160401b0383116107db57602083818601950101116107db57565b9181601f840112156107db578235916001600160401b0383116107db576020808501948460051b0101116107db57565b519081151582036107db57565b356001600160a01b03811681036107db5790565b908160209103126107db575160ff811681036107db5790565b8115614282570490565b634e487b7160e01b600052601260045260246000fd5b919082018092116139e957565b919082039182116139e957565b356001600160801b03811681036107db5790565b903590601e19813603018212156107db57018035906001600160401b0382116107db576020019181360383136107db57565b908060209392818452848401376000828201840152601f01601f1916010190565b903590601e19813603018212156107db57018035906001600160401b0382116107db57602001918160051b360383136107db57565b1561435557565b60405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608490fd5b607a548110156143e557607a6000527ff0440771a29e57e18c66727944770b82cc77924aef333c927ce6bdd2cdb3ae030190600090565b634e487b7160e01b600052603260045260246000fd5b60026001541461440c576002600155565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b51906001600160a01b03821682036107db57565b60655460009291614475826140d0565b808252916001908181169081156144da575060011461449357505050565b919293506065600052600080516020615c64833981519152916000925b8484106144c257505060209250010190565b805460208585018101919091529093019281016144b0565b915050602093945060ff929192191683830152151560051b010190565b6001600160a01b03909116815260208101919091526001600160801b03909116604082015260600190565b6001600160401b0381116132a85760051b60200190565b9291926001600160401b0382116132a85760405191614562601f8201601f191660200184614154565b8294818452818301116107db578281602093846000960137010152565b91908260809103126107db5761459482614451565b91602081015160038110156107db57916060604083015192015190565b60835460405163481d98fb60e11b8152602060048201529060809082906001600160a01b031681806145e560248201614465565b03915afa908115610e7357600090819261462e575b506003811015614618576002149081614611575090565b9050421190565b634e487b7160e01b600052602160045260246000fd5b9050614648915060803d81116110f5576110e28183614154565b925050386145fa565b676765c793fa10079d601b1b6146876122fc614675606d5460801c60705490615821565b6001600160801b03606f541690615bf5565b0490565b606b546040516370a0823160e01b815230600482015290602090829060249082906001600160a01b03165afa8015610e73576000906146d6575b6146d3915060775490614298565b90565b6020823d8211614701575b816146ee60209383614154565b810103126102ba57506146d390516146c5565b3d91506146e1565b60835460405163af9a2aa760e01b8152602060048201819052926001600160a01b0392909190849082908516818061474360248201614465565b03915afa908115610e73576000916147fe575b5082309116036147ec5761479f93839261476e614c64565b606954169060006001600160801b03606f54169360405197889586948593630ab714fb60e11b8552600485016144f7565b03925af1908115610e73576000916147c0575b509050906147be615378565b565b82813d83116147e5575b6147d48183614154565b810103126102ba57505180386147b2565b503d6147ca565b604051636f2f995760e01b8152600490fd5b908482813d831161482c575b6148148183614154565b810103126102ba575061482690614451565b38614756565b503d61480a565b607d54916000924211614c52576148518161484c61468b565b6142a5565b906148968360018060a01b03928360695416946001600160801b03606f54169560409687518092630ab714fb60e11b8252818c8160209a8b968a60049c8d85016144f7565b03925af18015614bff57908591614c29575b5050607c54811015614c19576148c090607c546142a5565b81811115614c0957509260ff607854166149fb575b80607b54169280865180809463be5daee560e01b825289878301526148fc60448301614465565b9a16998a60248301520381875afa9081156149f15790859189916149be575b506149269250614298565b608054106149b05760825494608154833b15610d81578794939260c09286928851998a978896879563e976e18b60e01b875286015261496760c48601614465565b9360248601526044850152606484015260848301524260a483015203925af19081156149a75750614996575050565b6149a0829161410a565b6102ba5750565b513d84823e3d90fd5b835163c7e138ed60e01b8152fd5b8092508391503d83116149ea575b6149d68183614154565b810103126107db578361492691513861491b565b503d6149cc565b86513d8a823e3d90fd5b606b5485516370a0823160e01b815230848201529082168482602481845afa918215614bff579084918a93614bcc575b50614a3883607754614298565b60775585846083541689519384809263a03e4bc360e01b82525afa918215614b52578a92614b95575b50875163095ea7b360e01b81526001600160a01b038316868201908152602081018590529091879183919082908e90829060400103925af18015614b525790849291614b5c575b50169082606b5416823b15610da95787519063617ba03760e01b825285820152816024820152306044820152896064820152898160848183875af18015614b5257614b1d575b50847f3b1270fa6f77c9af94834571cf5274944e8712de6cebea9ec3d8b3452c053308918851908152a26148d5565b7f3b1270fa6f77c9af94834571cf5274944e8712de6cebea9ec3d8b3452c0533089199614b4a879261410a565b999150614aee565b88513d8c823e3d90fd5b9091508581813d8311614b8e575b614b748183614154565b81010312610da95790614b87849261423e565b5038614aa8565b503d614b6a565b9091508581813d8311614bc5575b614bad8183614154565b81010312610da957614bbe90614451565b9038614a61565b503d614ba3565b86809294508193503d8311614bf8575b614be68183614154565b81010312610912578390519138614a2b565b503d614bdc565b87513d8b823e3d90fd5b905092614c14614e44565b6148d5565b50505050505050506147be614e44565b813d8311614c4b575b614c3c8183614154565b81010312610d815783386148a8565b503d614c32565b604051639a9a6f1760e01b8152600490fd5b606d5490607054614c78818460801c615821565b92606f54676765c793fa10079d601b1b9283614ca26122fc6001600160801b039889861690615bf5565b0490868211614d77578680614cb993169416615853565b92614cd86122fc846001600160801b03198095161760801c8096615bf5565b04948511614d655760049460801b16179081606f5542607055602060018060a01b03606a54166040519586809263b1bf962d60e01b82525afa918215610e7357600092614d2f575b6147be93945060801c91614d89565b91936020813d8211614d5d575b81614d4960209383614154565b8101031261040f5751929350839291614d20565b3d9150614d3c565b60405163306e92a960e11b8152600490fd5b604051632db5409f60e21b8152600490fd5b9190916072548015614e3e57610582614de991614de4670de0b6b3a7640000946122fc6139a16122fc60018060a01b039a8b606954169b606854169a614ddd676765c793fa10079d601b1b95869288615bf5565b0494615bf5565b615bf5565b04916001600160801b03606f541690803b156107db57614e249360008094604051968795869485936327883e6160e21b8552600485016144f7565b03925af18015610e7357614e355750565b6147be9061410a565b50505050565b607b805460ff60a01b1916600160a01b179055607e54614e649042614298565b607f5560ff60785416614e99575b7f5023432d2ef8583c6eb5ee4501bf4740bf68b6fe4823da8f19ddedd1135f2a64600080a1565b614ea1614eba565b614e72565b51906001600160801b03821682036107db57565b6083546040805163a03e4bc360e01b815290916000916004916020916001600160a01b0391839082908690829086165afa9081156150f4579082918691615340575b50169281606b54168651906335ea6a7560e01b825280838301526101e080836024818a5afa92831561513557869186918a956151ab575b50506101006024940151168951938480926370a0823160e01b825230888301525afa91821561516857879261517c575b5060ff19607854166078558115615172578751631a4ca37b60e21b815283810191909152600019602482015230604482015284816064818a8a5af180156151685790859161513f575b507f6407790cdabc5d219eaf901091d6beccc475533065c2fbd374c8a32b1c66795886918951848152a260775490818111614fef575b5050505050509050607755565b90614ff9916142a5565b91734FFa6c545a6249baF2D66ce21CeF3D2C2cCa69D090828582606b541692608354168a51958680926361d027b360e01b82525afa9384156151355788946150fe575b50823b15610d81578851636336129b60e11b81526001600160a01b0392831691810191825293909116602082015260408101849052869183918290819060600103915af480156150f4576150c1575b507f590e5a1563e349794fdcc066c4d5047f5e478f9e41707fc1bbad830146b7a17792939451908152a280388080808080614fe2565b936150ed7f590e5a1563e349794fdcc066c4d5047f5e478f9e41707fc1bbad830146b7a177949561410a565b939261508b565b86513d87823e3d90fd5b9093508581813d831161512e575b6151168183614154565b81010312610d815761512790614451565b923861503c565b503d61510c565b89513d8a823e3d90fd5b813d8311615161575b6151528183614154565b8101031261076a578338614fac565b503d615148565b88513d89823e3d90fd5b5050505050505050565b9091508481813d83116151a4575b6151948183614154565b8101031261043757519038614f63565b503d61518a565b9250809394508291503d8411615339575b6151c68183614154565b810103828112610912578951928301906001600160401b039084831082841117615326578813610da957610200840190811182821017615313578a52815181528252615213868201614ea6565b86830152615222898201614ea6565b8983015261523260608201614ea6565b606083015261524360808201614ea6565b608083015261525460a08201614ea6565b60a083015260c081015164ffffffffff811681036109125760c083015260e081015161ffff8116810361091257610100838893889360e06024989701528261529d818301614451565b908301526101206152af818301614451565b908301526101406152c1818301614451565b908301526101606152d3818301614451565b908301526101806152e5818301614ea6565b908301526101a06152f7818301614ea6565b908301526153096101c0809201614ea6565b9082015294614f33565b634e487b7160e01b8a526041865260248afd5b634e487b7160e01b8b526041875260248bfd5b503d6151bc565b809250848092503d8311615371575b6153598183614154565b8101031261040f5761536b8291614451565b38614efc565b503d61534f565b606a54604080516318160ddd60e01b81526020926001600160a01b039084908390600490829085165afa91821561556b5760009261553c575b506153c3826153be61468b565b614298565b908161542e575050507f9cf6ed4d2e86c73a9ce91a9baa90bb3a472323bb366819d0934e0d95d3e7500e9160a0916000606d555b606d5490606f54908051936001600160801b0393848116865260801c908501528160801c90840152166060820152426080820152a1565b839161543e916076541693615c2c565b604460725491600084519586948593630884b37d60e11b8552600485015260248401525af19081156155315760009081926154bd575b50917f9cf6ed4d2e86c73a9ce91a9baa90bb3a472323bb366819d0934e0d95d3e7500e93916001600160801b0360a09416906001600160801b03199060801b1617606d556153f7565b91508282813d831161552a575b6154d48183614154565b810103126102ba57509160a091836001600160801b0361551f846155187f9cf6ed4d2e86c73a9ce91a9baa90bb3a472323bb366819d0934e0d95d3e7500e98614ea6565b9301614ea6565b939550509092615474565b503d6154ca565b82513d6000823e3d90fd5b90918482813d8311615564575b6155538183614154565b810103126102ba57505190386153b1565b503d615549565b83513d6000823e3d90fd5b6001600160a01b03919082811680156157fc576000918183526020926075845260409160ff60018484200154166157eb57825163313ce56760e01b81526004979086818a81895afa9081156157e15760129160ff9186916157c4575b5016116157b457608454606b548551634858138f60e01b81526001600160a01b038581168c830190815292851690811660208401529390921691908890829081906040010381855afa9081156150f4578591615787575b5015615777578451632bd3159f60e21b81526001600160a01b03808516828c019081529316602084015291859183918290819060400103915afa801561576d5761572d575b50607a546801000000000000000081101561571a579061259f8260016156979401607a556143ae565b607a546000198101908111615707577fb38e19e04618f9502008311560587c597fe11e8867226353a0c01aab7e4df2939596506001908351906156d982614139565b81528386820193838552868152607588522090518155019051151560ff8019835416911617905551908152a1565b634e487b7160e01b825260118752602482fd5b634e487b7160e01b835260418852602483fd5b8381813d8311615766575b6157428183614154565b81010312610e7f57858161575861575f93614451565b5001614451565b503861566e565b503d615738565b84513d85823e3d90fd5b8451633c15d6ff60e21b81528990fd5b90508781813d83116157ad575b61579e8183614154565b8101031261040f575138615629565b503d615794565b835163b7c73c5d60e01b81528890fd5b6157db9150893d8b116119f9576119eb8183614154565b386155d2565b85513d86823e3d90fd5b8251632d6c6ae560e01b8152600490fd5b6040516346ec28e560e11b8152600490fd5b818102929181159184041417156139e957565b61583a906158346301e1338093426142a5565b9061580e565b04676765c793fa10079d601b1b81018091116139e95790565b9061585e90426142a5565b908115615939576000198201918083116139e9576000600282111561592a575060011981018181116139e9576159136301e1338091925b600661590c876158fd676765c793fa10079d601b1b976158fd6159028b6158fd6906a4334962924ee000008d6158f46122fc66038882915c4000836158dd6122fc8980615bf5565b040495836158ee6122fc8380615bf5565b04615bf5565b0404968a61580e565b61580e565b60011c9b8761580e565b049461580e565b0481018091116139e9576146d3926153be91614298565b6159136301e133809192615895565b5050676765c793fa10079d601b1b90565b606654604051632474521560e21b81527fc0fc8e4dc5cff6febdf550b80d566f654e2baf1a02ea1060208c2f8ab2dd1b63600482015233602482015290602090829060449082906001600160a01b03165afa908115610e73576000916159b3575b5015610e2c57565b906020823d82116159e4575b816159cc60209383614154565b810103126102ba57506159de9061423e565b386159ab565b3d91506159bf565b606654604051632474521560e21b81527f5a7d4408f4759dddd7fdfd0d21abd99341dc2f52cda14804988a9b2df20766d8600482015233602482015290602090829060449082906001600160a01b03165afa908115610e73576000916159b3575015610e2c57565b606654604051632474521560e21b81526000600482015233602482015290602090829060449082906001600160a01b03165afa908115610e73576000916159b3575015610e2c57565b606654604051632474521560e21b81527f5580ea9b7f9becaa48a78f506a2019ea24794b7a717ee6a4b9f62e36b94c25a6600482015233602482015290602090829060449082906001600160a01b03165afa908115610e73576000916159b3575015610e2c57565b607454604051630723eb0360e51b815233600482015290602090829060249082906001600160a01b03165afa908115610e7357600091615b59575b50615b4757565b6040516333df015b60e01b8152600490fd5b906020823d8211615b8a575b81615b7260209383614154565b810103126102ba5750615b849061423e565b38615b40565b3d9150615b65565b906706f05b59d3b200008201918281116139e9578210615bae57565b604051630a77254f60e01b8152600490fd5b906b019d971e4fe8401e740000008201918281116139e9578210615bae57565b9190615bec9083614298565b918210615bae57565b600092918015918215615c0c575b5050156139d757565b91509250615c24615c1d848361580e565b9384614278565b143880615c03565b90676765c793fa10079d601b1b91828102928184048114821517156139e9578304036139d7576139d26146d3928260011c90615be056fe8ff97419363ffd7000167f130ef7168fbea05faf9251824ca5043f113cc6a7c75548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62a26469706673582212205938e49a0e919051e6fc2b2cbc83cbd0b27d8576a8efa50530ccb5622f17433164736f6c63430008120033",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b600090813560e01c90816301ffc9a714614063575080630224f16a1461400e57806306fdde0314613f375780631003d99d14613d1b57806313a1fcb914613cfa578063165e780514613cd957806318f88b6d14613bb257806322f3e2d414613b1e578063235f17f5146137ab57806327c37b251461378a578063298410e5146137605780632a5ad159146136865780632acabb11146135ab5780632e51d3ed14613573578063304fe59814612ab057806330db585614612a8d5780633e07460814612a645780633edd112814612874578063478827851461285657806347e7ef24146126a15780634872d3271461266b5780634a5e42b1146125235780634ad09aa5146124695780634f43f2391461235157806358a06f071461232857806358d7bf801461230a57806368d0612f146122b357806371a6cab714612295578063743753591461227a578063791b98bc146122515780637b10399914612228578063883c6b24146122055780638eed7780146121dc578063905e3837146121bb57806398cc6b1e146120b85780639b622c0214612093578063a00622dc14612075578063a223f82114612057578063a4c1cccb1461200f578063ac1e502514611fb1578063b28f7a1d14611f93578063bbf44f3314611f6c578063bd449dde14611f45578063bda896c414611191578063c07dc61414611109578063c717823014611044578063cd3293de1461101b578063d0b6543d14610ef4578063e526e4ab14610e83578063eae12b7f14610bbf578063ef379d1714610b96578063f066eea014610ad0578063f3fef3a31461046b578063f5bfeb441461044d578063f8190a46146102e6578063f8d89898146102bd5763febb0f7e1461029457600080fd5b346102ba57806003193601126102ba5760206001600160801b03606d5416604051908152f35b80fd5b50346102ba57806003193601126102ba57606a546040516001600160a01b039091168152602090f35b50346102ba5760603660031901126102ba576103006141b5565b60243561030b6141cb565b91610314615a9d565b60ff607b5460a01c161561043b57606b5484936001600160a01b039173__$183737d697d7aa9b5df9988cbe11bc4947$__91908316823b1561043757604051636336129b60e11b81526001600160a01b0391821660048201529116602482015260448101859052908590829060649082905af490811561042c578591610413575b505061039f614c64565b606a5416606f5460801c90803b1561040f576103d59385809460405196879586948593630ab714fb60e11b8552600485016144f7565b03925af18015610404576103f0575b506103ed615378565b80f35b6103f99061410a565b6102ba5780386103e4565b6040513d84823e3d90fd5b8480fd5b61041c9061410a565b610427578338610395565b505050fd5b6040513d87823e3d90fd5b8680fd5b6040516379bb149f60e11b8152600490fd5b50346102ba57806003193601126102ba576020607754604051908152f35b50346102ba5760403660031901126102ba576104856141b5565b60248035916104926143fb565b61049a615b05565b83607b5460ff8160a01c161560001461099f576001600160a01b0316803b1561099b578160405180926308f57fc760e11b8252606060048301528183816104e360648201614465565b338b8301528b604483015203925af1801561040457610983575b50505b60ff607b5460a01c16610976575b60018060a01b038060695416926001600160801b03606f5416946040518095637a94c56560e11b825281898161054c60209b8c9733600485016144f7565b03925af193841561075f578694610947575b50607354670de0b6b3a7640000908103818111610934576105828661058792615bf5565b615b92565b0461059281866142a5565b60ff607b5460a01c161580610928575b8061091d575b6107f2575b83606b5416928760405180926370a0823160e01b825230600483015281875afa9081156107e75789916107b5575b5086116107a357879273__$183737d697d7aa9b5df9988cbe11bc4947$__916004898760835416604051928380926361d027b360e01b82525afa90811561075f57869161076e575b50833b1561076a57604051636336129b60e11b8082526001600160a01b03948516600483015291909316602484015260448301829052918581606481875af490811561075f57869161074b575b50506040519081527f590e5a1563e349794fdcc066c4d5047f5e478f9e41707fc1bbad830146b7a177893392a284606b541691803b1561040f576040519182526001600160a01b039283166004830152918616602482015260448101929092528290829060649082905af4801561040457610737575b50507f9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb9160ff607b5460a01c1661072a575b60405193845216923392a36001805580f35b610732615378565b610718565b6107409061410a565b61040f5784386106e6565b6107549061410a565b61040f578438610670565b6040513d88823e3d90fd5b8580fd5b90508981813d831161079c575b6107858183614154565b8101031261076a5761079690614451565b38610623565b503d61077b565b604051630d5f777560e21b8152600490fd5b90508781813d83116107e0575b6107cc8183614154565b810103126107db5751386105db565b600080fd5b503d6107c2565b6040513d8b823e3d90fd5b607d5442111561080957610804614eba565b6105ad565b60048785608354166040519283809263a03e4bc360e01b82525afa80156107e75785918a916108e1575b501684606b541660405190631a4ca37b60e21b82526004820152878582015230604482015288816064818d865af19081156108d65789916108ad575b507f6407790cdabc5d219eaf901091d6beccc475533065c2fbd374c8a32b1c66795890604051898152a26108a5866077546142a5565b6077556105ad565b813d83116108cf575b6108c08183614154565b810103126107db57873861086f565b503d6108b6565b6040513d8c823e3d90fd5b809250898092503d8311610916575b6108fa8183614154565b810103126109125761090c8591614451565b38610833565b8880fd5b503d6108f0565b5060775415156105a8565b5060ff607854166105a2565b634e487b7160e01b885260116004528288fd5b9093508481813d831161096f575b61095f8183614154565b810103126107db5751923861055e565b503d610955565b61097e614c64565b61050e565b61098c9061410a565b6109975783386104fd565b8380fd5b5080fd5b9050607f5442106109b1575b50610500565b6069546040516370a0823160e01b81523360048201526020916001600160a01b039190839082908890829086165afa918215610ac55783918993610a94575b506040519485809263be5daee560e01b82526040600483015281610a1660448201614465565b338c8301520392165afa918215610a89578792610a57575b50610a3992506142a5565b8311610a4557386109ab565b6040516342b0cbe760e11b8152600490fd5b90915082813d8311610a82575b610a6e8183614154565b810103126107db57610a3991519038610a2e565b503d610a64565b6040513d89823e3d90fd5b8281939294503d8311610abe575b610aac8183614154565b810103126107db5782905191386109f0565b503d610aa2565b6040513d8a823e3d90fd5b50346102ba57806003193601126102ba576040518091607a549081835260208093018092607a83527ff0440771a29e57e18c66727944770b82cc77924aef333c927ce6bdd2cdb3ae0390835b818110610b795750505084610b32910385614154565b60405193838594850191818652518092526040850193925b828110610b5957505050500390f35b83516001600160a01b031685528695509381019392810192600101610b4a565b82546001600160a01b031684529286019260019283019201610b1c565b50346102ba57806003193601126102ba576074546040516001600160a01b039091168152602090f35b50346102ba576003199060c0368301126102ba576001600160401b03600435818111610e7f57610bf390369060040161420e565b9160243590811161099757610c0c90369060040161420e565b90610c156141cb565b606654604051632474521560e21b81527f28eb28c26cbbd48a6bfad016505ccf4a189452995f59d16217af8920961ed25c6004820152336024820152608435966001600160a01b039660209490939192606435928690829060449082908d165afa908115610e7357600091610e3e575b5015610e2c5781610dad575b5050610c9b614c64565b85606a541692606f5491843b15610da95760405163eb1738e560e01b815260806004820152608481018290529760a489019491908b905b828210610d85575050505086830390990160248701528482529697959688966001600160fb1b038611610d815786809581948a9894899560051b80938684013760801c604484015260a4356064840152010301925af1801561040457610d6d575b5050610d3d615378565b80610d46575080f35b610d5f610d67916001600160801b03606f541690615c2c565b607154614298565b60715580f35b610d769061410a565b61099b578138610d33565b8780fd5b909192958635908282168092036107db579081528401958401929160010190610cd2565b8980fd5b73__$183737d697d7aa9b5df9988cbe11bc4947$__9088606b5416823b15610e2857604051636336129b60e11b81526001600160a01b0391821660048201529116602482015260448101929092528990829060649082905af480156107e75790899115610c9157610e1d9061410a565b610d81578738610c91565b8b80fd5b60405163036be76f60e61b8152600490fd5b908682813d8311610e6c575b610e548183614154565b810103126102ba5750610e669061423e565b38610c85565b503d610e4a565b6040513d6000823e3d90fd5b8280fd5b50346102ba5760203660031901126102ba57600435610ea0615a54565b670de0b6b3a7640000811015610ee2576020817fb2429786195476a340c6c3ff6be51a0d28d9ea08dea6c91a0720b1e200400e8c92607255604051908152a180f35b604051631757762160e01b8152600490fd5b50346102ba5760a03660031901126102ba57610f0e6141b5565b81610f176141cb565b6084359290606435610f27615a9d565b80610f8f575b5050610f37614c64565b60018060a01b03606a541690606f5460801c823b1561099757610f7792849283604051809681958294637a94c56560e11b845260243590600485016144f7565b03925af1801561040457610d6d575050610d3d615378565b606b546001600160a01b03169073__$183737d697d7aa9b5df9988cbe11bc4947$__803b1561076a57604051636336129b60e11b81526001600160a01b03938416600482015293909216602484015260448301528390829060649082905af490811561101057839115610f2d576110059061410a565b61099b578138610f2d565b6040513d85823e3d90fd5b50346102ba57806003193601126102ba576068546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba5760835460405163481d98fb60e11b815260206004820152919060809083906001600160a01b0316818061108a60248201614465565b03915afa9182156110fc5781926110c8575b5060038210156110b457602082600260405191148152f35b634e487b7160e01b81526021600452602490fd5b6110ea91925060803d81116110f5575b6110e28183614154565b81019061457f565b50509050903861109c565b503d6110d8565b50604051903d90823e3d90fd5b50346102ba5760203660031901126102ba5760043561112661594a565b670de0b6b3a7640000811180611180575b1561116e576020817f6db5a699a2b18e7a2568814d453dff8a78eb41c9daf9d45bdeab3824f49c941592606c55604051908152a180f35b60405163c42aecdf60e01b8152600490fd5b50670e043da6172500008110611137565b50346102ba5760031960403682011261099b576001600160401b036004351161099b5761030090600435360301126102ba57602435906001600160a01b03821682036107db5780549160ff8360081c161592838094611f38575b8015611f21575b15611ec55760ff198116600117835583611eb4575b506040516301ffc9a760e01b8152637965db0b60e01b60048201526020816024816001600160a01b0386165afa908115611010578391611e7a575b5080611dee575b80611d61575b80611cd4575b80611c47575b80611bba575b80611b2d575b80611a9f575b80611a12575b15611a0057600460206001600160a01b0361129283356101240161424b565b166040519283809263313ce56760e01b82525afa9081156110105760129160ff9185916119d1575b5016116119bf5767016345785d8a00006101646004350135116119ad57670de0b6b3a76400008061014460043501351180611995575b1561116e5761018460043501351015610ee2576102e4600435013515611983576004356101c401356117cd57607b805460ff60a01b1916600160a01b1790557f5023432d2ef8583c6eb5ee4501bf4740bf68b6fe4823da8f19ddedd1135f2a648280a15b6004356102e48101356079556001600160a01b0390611376906102240161424b565b1661138c6102c4600435016004356004016142c6565b8291923b1561040f579184916113c19383604051809681958294632acabb1160e01b84526020600485015260248401916142f8565b03925af18015611010579083916117b9575b506113e490506004803501806142c6565b906001600160401b0382116117a55781906114006065546140d0565b601f8111611733575b508490601f83116001146116bf5785926116b4575b50508160011b916000199060031b1c191617606555915b6001600160a01b0361144b60043560240161424b565b16906bffffffffffffffffffffffff60a01b9182606954161760695560018060a01b0361147c60a46004350161424b565b1682608354161760835560018060a01b0361149b60646004350161424b565b1682606754161760675560018060a01b036114ba60846004350161424b565b1682608454161760845560018060a01b036114d960446004350161424b565b1682606a541617606a5560018060a01b036114f860c46004350161424b565b1682606854161760685560018060a01b0361151760e46004350161424b565b1682607454161760745560018060a01b036115376101246004350161424b565b1682606b541617606b556101446004350135606c5561016460043501356073556101846004350135607255829161010460043501925b61157c84600435600401614319565b90508110156115f45761159484600435600401614319565b8210156115e057600582901b01356001600160a01b038116810361076a576115bb90615576565b60001981146115cc5760010161156d565b634e487b7160e01b85526011600452602485fd5b634e487b7160e01b86526032600452602486fd5b8483838860018060a01b031681606654161760665560018060a01b0361161f6102246004350161424b565b169060765416176076557b033b2e3c9fd0803ce800000000000000033b2e3c9fd0803ce800000082606f541617606f5581549061167760ff8360081c166116658161434e565b61166e8161434e565b6001805561434e565b61167f575080f35b61ff00191681557f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498602060405160018152a180f35b01359050388061141e565b60658652859350600080516020615c64833981519152915b601f198416851061171b576001945083601f19811610611701575b505050811b0160655591611435565b0135600019600384901b60f8161c191690553880806116f2565b818101358355602094850194600190930192016116d7565b90915060658552601f830160051c600080516020615c648339815191520160208410611790575b908392915b601f820160051c600080516020615c648339815191520181106117825750611409565b86815584935060010161175f565b50600080516020615c6483398151915261175a565b634e487b7160e01b84526041600452602484fd5b6117c29061410a565b61099b5781386113d3565b426101e4600435013511806118f5575b806118e5575b156118d457610204600435013561180f611804826101e46004350135614298565b8060825542906142a5565b6081556001600160a01b036118296004356101a40161424b565b166bffffffffffffffffffffffff60a01b607b541617607b556101c46004350135607c556101e46004350135607d55607e5561028460043501356080556001600160801b0361187d610244600435016142b2565b606e549116836fffffffffffffffffffffffffffffffff196118a4600435610264016142b2565b60801b1692161717606e556102a46004350135801515809103610e7f5760ff801960785416911617607855611354565b604051627706c160e81b8152600490fd5b50610284600435013515156117e3565b50602460206001600160a01b036119116004356101a40161424b565b6040516301ffc9a760e01b815263edebbfe960e01b600482015293849290918391165afa908115611010578391611949575b506117dd565b90506020813d60201161197b575b8161196460209383614154565b81010312610e7f576119759061423e565b38611943565b3d9150611957565b604051637ed7b9ab60e11b8152600490fd5b50670e043da6172500006101446004350135106112f0565b60405163766a53cb60e01b8152600490fd5b60405163b7c73c5d60e01b8152600490fd5b6119f3915060203d6020116119f9575b6119eb8183614154565b81019061425f565b386112ba565b503d6119e1565b60405163044aa57560e41b8152600490fd5b50602460206001600160a01b03611a2d60043560e40161424b565b6040516301ffc9a760e01b8152633df6cef760e01b600482015293849290918391165afa908115611010578391611a65575b50611273565b90506020813d602011611a97575b81611a8060209383614154565b81010312610e7f57611a919061423e565b38611a5f565b3d9150611a73565b50602460206001600160a01b03611abb6004356102240161424b565b6040516301ffc9a760e01b8152633983653f60e21b600482015293849290918391165afa908115611010578391611af3575b5061126d565b90506020813d602011611b25575b81611b0e60209383614154565b81010312610e7f57611b1f9061423e565b38611aed565b3d9150611b01565b50602460206001600160a01b03611b4860043560c40161424b565b6040516301ffc9a760e01b815263d4cb1bcb60e01b600482015293849290918391165afa908115611010578391611b80575b50611267565b90506020813d602011611bb2575b81611b9b60209383614154565b81010312610e7f57611bac9061423e565b38611b7a565b3d9150611b8e565b50602460206001600160a01b03611bd560043560840161424b565b6040516301ffc9a760e01b81526341636c7560e11b600482015293849290918391165afa908115611010578391611c0d575b50611261565b90506020813d602011611c3f575b81611c2860209383614154565b81010312610e7f57611c399061423e565b38611c07565b3d9150611c1b565b50602460206001600160a01b03611c6260043560640161424b565b6040516301ffc9a760e01b81526306cc15a560e11b600482015293849290918391165afa908115611010578391611c9a575b5061125b565b90506020813d602011611ccc575b81611cb560209383614154565b81010312610e7f57611cc69061423e565b38611c94565b3d9150611ca8565b50602460206001600160a01b03611cef60043560440161424b565b6040516301ffc9a760e01b8152633d5b079f60e11b600482015293849290918391165afa908115611010578391611d27575b50611255565b90506020813d602011611d59575b81611d4260209383614154565b81010312610e7f57611d539061423e565b38611d21565b3d9150611d35565b50602460206001600160a01b03611d7c60043560a40161424b565b6040516301ffc9a760e01b815263fa6ab0ef60e01b600482015293849290918391165afa908115611010578391611db4575b5061124f565b90506020813d602011611de6575b81611dcf60209383614154565b81010312610e7f57611de09061423e565b38611dae565b3d9150611dc2565b50602460206001600160a01b03611e08600435840161424b565b6040516301ffc9a760e01b81526337a557d360e01b600482015293849290918391165afa908115611010578391611e40575b50611249565b90506020813d602011611e72575b81611e5b60209383614154565b81010312610e7f57611e6c9061423e565b38611e3a565b3d9150611e4e565b90506020813d602011611eac575b81611e9560209383614154565b81010312610e7f57611ea69061423e565b38611242565b3d9150611e88565b61ffff191661010117825538611207565b60405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b50303b1580156111f25750600160ff8216146111f2565b50600160ff8216106111eb565b50346102ba57806003193601126102ba5760206001600160801b03606e5416604051908152f35b50346102ba57806003193601126102ba5760206001600160801b03606f5416604051908152f35b50346102ba57806003193601126102ba576020607154604051908152f35b50346102ba5760203660031901126102ba57600435611fce615a54565b67016345785d8a000081116119ad576020817ffc1353e6b18ce07b5a979c8edf77a87455939a17a9eebbb084dcde5bfb3b19ac92607355604051908152a180f35b50346102ba5760203660031901126102ba5760409081906001600160a01b036120366141b5565b16815260756020522060ff6001825492015416825191825215156020820152f35b50346102ba57806003193601126102ba576020607354604051908152f35b50346102ba57806003193601126102ba576020606c54604051908152f35b50346102ba57806003193601126102ba5760206120ae6145b1565b6040519015158152f35b50346102ba57806003193601126102ba57604051610120916120d98261411d565b8082528060208301528060408301528060608301528060808301528060a08301528060c08301528060e0830152610100809201526040519061211a8261411d565b607b549160018060a01b0383169283825260ff602083019160a01c1615158152607c5460408301908152607d5460608401908152607e5460808501908152607f549160a086019283526080549360c087019485526081549560e08801968752886082549801978852604051998a5251151560208a01525160408901525160608801525160808701525160a08601525160c08501525160e08401525190820152f35b50346102ba57806003193601126102ba576020606d5460801c604051908152f35b50346102ba57806003193601126102ba57606b546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba576020612220614651565b604051908152f35b50346102ba57806003193601126102ba576066546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba576067546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba57602061222061468b565b50346102ba57806003193601126102ba576020607954604051908152f35b50346102ba57806003193601126102ba576020676765c793fa10079d601b1b6123016122fc6122f06001600160801b03606d541660705490615853565b606f5460801c90615bf5565b615bc0565b04604051908152f35b50346102ba57806003193601126102ba576020607254604051908152f35b50346102ba57806003193601126102ba576069546040516001600160a01b039091168152602090f35b50346102ba5760203660031901126102ba5760043561236e6143fb565b6123888161237a615b05565b612382614651565b90615c2c565b8015612457576123ea9160209160715480821161242c575b036071556069546001600160a01b03166123b8614651565b604051637a94c56560e11b81523360048201526024810193909352604483015290928391908290869082906064820190565b03925af1801561040457612401575b506001805580f35b602090813d8111612425575b6124178183614154565b810103126107db57386123f9565b503d61240d565b91505080676765c793fa10079d601b1b6124506122fc61244a614651565b85615bf5565b04916123a0565b604051637c123f8b60e01b8152600490fd5b50346102ba57806003193601126102ba5760835460405163481d98fb60e11b815260206004820152919060809083906001600160a01b031681806124af60248201614465565b03915afa90811561251757809281926124f0575b5060038310156110b4575060026020921490816124e6575b506040519015158152f35b90504211386124db565b90925061250b915060803d81116110f5576110e28183614154565b509291509190386124c3565b604051903d90823e3d90fd5b50346102ba5760203660031901126102ba5761253d6141b5565b6125456159ec565b6001600160a01b03908116808352607560205260408320600181015491929160ff161561265957607a5460001992908381019081116126455761258882916143ae565b90549060031b1c16926125be8461259f85546143ae565b90919082549060031b9160018060a01b03809116831b921b1916179055565b607a54801561263157917fa48303bd6cd678b9b13454996417095d2d282db59c4db9ba88df8c82d04869789593916020959301906125fb826143ae565b909182549160031b1b19169055607a5554908552607583526040852055808452836001604082208281550155604051908152a180f35b634e487b7160e01b87526031600452602487fd5b634e487b7160e01b86526011600452602486fd5b60405163b7addff360e01b8152600490fd5b50346102ba57806003193601126102ba576020676765c793fa10079d601b1b6123016122fc60715461269b614651565b90615bf5565b50346102ba5760403660031901126102ba576126bb6141b5565b6024356126c66143fb565b6126ce615b05565b6069546040516318160ddd60e01b8152602093916001600160a01b03919085908290600490829086165afa801561075f5784908790612825575b6127129250614298565b607954111561281357606b5460405163c37f7f7f60e01b81529082166001600160a01b0316600482015233602482015260448101849052848180606481015b038173__$183737d697d7aa9b5df9988cbe11bc4947$__5af490811561075f5785916127ea575b5050607b5460a01c60ff16156127b557816127a284600080516020615c8483398151915294614709565b5060405193845216923392a36001805580f35b33818316036127d8578161073284600080516020615c8483398151915294614833565b60405163217fe6c760e11b8152600490fd5b813d831161280c575b6127fd8183614154565b810103126107db578338612778565b503d6127f3565b604051630a5a765f60e31b8152600490fd5b50508481813d831161284f575b61283c8183614154565b810103126107db57836127129151612708565b503d612832565b50346102ba57806003193601126102ba576020607054604051908152f35b50346102ba5760603660031901126102ba5761288e6141b5565b602435604435918215158303610997576128a66143fb565b6128ae615b05565b6069546040516318160ddd60e01b81526020946001600160a01b039290919086908290600490829087165afa8015610a895785908890612a33575b6128f39250614298565b6079541115612813571561296357606b5460405163c37f7f7f60e01b81529082166001600160a01b031660048201523360248201526044810184905284818060648101612751565b607b5460a01c60ff16156127b557816127a284600080516020615c8483398151915294614709565b84600485836067541660405192838092634cb4430f60e11b82525afa801561040457839183916129f9575b501682606b5416813b15610e7f57829160a48392604051948593849263c268dd3160e01b845233600485015230602485015260448401528a60648401528160848401525af18015610404576129e5575b505061293b565b6129ee9061410a565b61040f5784386129de565b809250878092503d8311612a2c575b612a128183614154565b8101031261099b5751828116810361099b5782903861298e565b503d612a08565b50508581813d8311612a5d575b612a4a8183614154565b810103126107db57846128f391516128e9565b503d612a40565b50346102ba57806003193601126102ba576076546040516001600160a01b039091168152602090f35b50346102ba57806003193601126102ba57602060ff607854166040519015158152f35b50346102ba5760803660031901126102ba576004356001600160401b03811161099b57612ae19036906004016141e1565b6024356001600160a01b0381168103610997576044356001600160401b03811161040f57612b1390369060040161420e565b612b1b6143fb565b612b23615b05565b60ff607b5460a01c161580613568575b1561355657859460ff607854168061354b575b61353e575b60835460405163af9a2aa760e01b815260206004820181905290969187906001600160a01b03168180612b826024820187896142f8565b03915afa958615610a89578796613502575b50607b54604051634c66358f60e11b81526001600160a01b03918216929161012090829060049082908c165afa80156107e7578990613452575b602091500151151591607d5493813b15610da95789612c2293819560405197889687958694638f8ebe1560e01b865260a06004870152612c1060a48701614465565b868103600319016024880152916142f8565b913360448501526064840152608483015203925af190811561075f57869161343e575b5050606954606f54604051637a94c56560e11b815233600482015260001960248201526001600160801b0390911660448201529660209188916064918391906001600160a01b03165af195861561042c57859661340a575b5060405186815286906001600160a01b0386169033907f9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb90602090a360405163011ddaef60e71b8152966020886004816001600160a01b038a165afa978815610a895787986133c6575b50606b546001600160a01b039081169089168114613331575050606654604051632474521560e21b81527fe965846df3dd5b1dfa65f58e31477079e90140e0908b6dd31b5aead5a57cf36560048201526001600160a01b038681166024830152909160209183916044918391165afa908115610a895787916132f7575b5015610e2c57606b5460405163095ea7b360e01b81526001600160a01b038681166004830152602482018490529091602091839160449183918c91165af18015610a89576132be575b50606b5460405197906001600160a01b03166001600160401b036101608a01908111908a11176132a8576101608901604052885260018060a01b0316602088015260408701526064356060870152612e2481614522565b91612e326040519384614154565b8183526020830190368360051b8201116104375780915b8360051b820183106130f45750505050608085019081526001600160a01b0383811660a08701524260c0870152600160e0870181905261010087015261012086018590526101408601859052604080516373cb40a560e11b81526060600482018190528851841660648301526020808a015190941660848301529188015160a48201529087015160c4820152915161016060e484015280516101c484018190529293926101e4600582901b86018101939290920191879086015b82821061304957505050506020918386818094610140839b60018060a01b0360a08201511661010485015260c081015161012485015260e0810151151561014485015261010081015115156101648501526101208101511515610184850152015115156101a4830152826024830152826044830152039260018060a01b03165af1908115611010578391613014575b50905b607e54916001600160a01b0382163b15610427578391604051938492631003d99d60e01b84523360048501526024840152604483015260806064830152818381612fe160848201614465565b03926001600160a01b03165af180156104045761300057506001805580f35b6130099061410a565b6102ba5780386123f9565b9250506020823d602011613041575b8161303060209383614154565b810103126107db5782915138612f92565b3d9150613023565b909192936101e31987820301825284519060206040820192805183520151916040602083015282518091526060820190602060608260051b8501019401928c5b8281106130a9575050505050602080600192960192019201909291612f03565b90919293946020806130e7600193605f19878203018952895190836130d78351604084526040840190614175565b9201519084818403910152614175565b9701950193929101613089565b6001600160401b03833511610d8157604083358301360312610d815760405161311c81614139565b8335830180358252602001356001600160401b038111610da95736601f828735870101011215610da9578085358501013561315681614522565b916131646040519384614154565b81835260208301903660208460051b838b358b01010101116132a457602081893589010101915b60208460051b838b358b0101010183106131b8575050505091816020938480940152815201920191612e49565b6001600160401b038335116132a05760408935890183018435013603601f1901126132a0576040516131e981614139565b60208435848c358c01010101356001600160401b03811161329c57368b358b0185018635018201603f01121561329c576132379036908c358c01860187350101602081013590604001614539565b815260408435848c358c01010101356001600160401b03811161329c57368b358b0185018635018201603f01121561329c576020928392909161328d9036908e358e018801893501018086013590604001614539565b8382015281520192019161318b565b8f80fd5b8d80fd5b8c80fd5b634e487b7160e01b600052604160045260246000fd5b6020813d6020116132ef575b816132d760209383614154565b81010312610437576132e89061423e565b5038612dcd565b3d91506132ca565b90506020813d602011613329575b8161331260209383614154565b81010312610437576133239061423e565b38612d84565b3d9150613305565b9250949350915084955073__$183737d697d7aa9b5df9988cbe11bc4947$__91823b1561076a57604051636336129b60e11b81526001600160a01b03928316600482015291841660248301526044820152908490829060649082905af49081156133bb5784916133a3575b5050612f95565b6133ac9061410a565b6133b757823861339c565b5050fd5b6040513d86823e3d90fd5b9097506020813d602011613402575b816133e260209383614154565b8101031261043757516001600160a01b0381168103610437579638612d07565b3d91506133d5565b9095506020813d602011613436575b8161342660209383614154565b810103126107db57519438612c9d565b3d9150613419565b6134479061410a565b61040f578438612c45565b50610120813d610120116134fa575b8161346f6101209383614154565b81010312610912576040516134838161411d565b8151916001600160a01b03831683036134f65760209282526134a683820161423e565b8383015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c081015160c083015260e081015160e08301526101008091015190820152612bce565b8a80fd5b3d9150613461565b9095506020813d602011613536575b8161351e60209383614154565b810103126104375761352f90614451565b9438612b94565b3d9150613511565b613546614eba565b612b4b565b506077541515612b46565b604051634288230360e01b8152600490fd5b50607d544211612b33565b50346102ba57806003193601126102ba5760ff607b5460a01c16806135a0575b6020906040519015158152f35b50607f544211613593565b50346102ba5760203660031901126102ba576004356001600160401b03811161099b576135dc9036906004016141e1565b906135e5615a54565b60765483906001600160a01b0316803b1561099b57816040518092632acabb1160e01b825260206004830152818381613622602482018b8b6142f8565b03925af1801561040457613672575b50507f1ec1ec5da499bc02a52ae44524fff931d2e18c66681bc49118287b566c20174c9161366c6040519283926020845260208401916142f8565b0390a180f35b61367b9061410a565b610e7f578238613631565b50346102ba5760208060031936011261099b576136a16141b5565b6136a9615a54565b6040516301ffc9a760e01b8152633983653f60e21b60048201526001600160a01b039190911691908181602481865afa9081156133bb57849161372b575b5015611a0057607680546001600160a01b031916831790556040519182527f34f2d9c40aeb8886df9cdf9e12d06e2eba1c570a1b296552fe70f037e72bf12c91a180f35b90508181813d8311613759575b6137428183614154565b81010312610997576137539061423e565b386136e7565b503d613738565b50346102ba5760203660031901126102ba576103ed61377d6141b5565b61378561594a565b615576565b50346102ba57806003193601126102ba576020606e5460801c604051908152f35b50346102ba57602090816003193601126102ba576137c76141b5565b6001600160a01b0380821683526075845260408320600101549192909160ff1615612659578160675416906040519363084b557b60e21b85528585600481865afa948515610404578295613aef575b50670de0b6b3a764000094850193848611613adb578561384a610582606c5483613843610582838c615bf5565b0498615bf5565b04936040516301ddf49360e61b81528881600481855afa90811561042c578591613aae575b5087038781116115cc57608454606b54604051631dae49b960e21b81526001600160a01b0387811660048301529186169182166024820152909490918b9183916044918391165afa90811561075f578691613a81575b508803908882116126455761058289926138de92615bf5565b60405163a8905dab60e01b8082526001600160a01b038681166004840152871660248301529592909104908a81604481875afa908115610a89578791613a54575b50890390898211613a4057918961393f6105828d96946139719896615bf5565b6040519788526001600160a01b0392831660048901529390911660248701529091049392839190829081906044820190565b03915afa908115611010578391613a13575b508503918583116139ff57506139a16105826139a894938793615bf5565b04906142a5565b90828102928184048114821517156139e9578304036139d7576139d2612220928260011c90615be0565b614278565b604051631550e8b760e01b8152600490fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b81526011600452602490fd5b90508681813d8311613a39575b613a2a8183614154565b810103126107db575138613983565b503d613a20565b634e487b7160e01b87526011600452602487fd5b90508a81813d8311613a7a575b613a6b8183614154565b810103126107db57513861391f565b503d613a61565b90508981813d8311613aa7575b613a988183614154565b810103126107db5751386138c5565b503d613a8e565b90508881813d8311613ad4575b613ac58183614154565b810103126107db57513861386f565b503d613abb565b634e487b7160e01b83526011600452602483fd5b9094508581813d8311613b17575b613b078183614154565b810103126107db57519338613816565b503d613afd565b50346102ba57806003193601126102ba5760835460405163481d98fb60e11b815260206004820152919060809083906001600160a01b03168180613b6460248201614465565b03915afa9182156110fc578192613b8e575b5060038210156110b457602082600160405191148152f35b613ba791925060803d81116110f5576110e28183614154565b505090509038613b76565b50346102ba5760203660031901126102ba57613bcc615a54565b613bd46145b1565b15613cc857606b546083546040516361d027b360e01b8152839273__$183737d697d7aa9b5df9988cbe11bc4947$__926001600160a01b039182169160209184916004918391165afa9182156133bb578492613c8d575b50823b1561042757604051636336129b60e11b81526001600160a01b0391821660048083019190915292909116602482015290356044820152908290829060649082905af4801561040457613c7d5750f35b613c869061410a565b6102ba5780f35b9091506020813d8211613cc0575b81613ca860209383614154565b8101031261042757613cb990614451565b9038613c2b565b3d9150613c9b565b60405162a5e71360e71b8152600490fd5b50346102ba57806003193601126102ba576020606f5460801c604051908152f35b50346102ba57806003193601126102ba57613d136159ec565b6103ed614eba565b50346102ba5760803660031901126102ba57613d356141b5565b6024356044356064356001600160401b03811161040f57613d5a9036906004016141e1565b939091613d656143fb565b6069546040516318160ddd60e01b81526020966001600160a01b0395929091908890829060049082908a165afa80156107e75787908a90613f06575b613dab9250614298565b607954111561281357613de391879186608354169060405180958194829363af9a2aa760e01b845287600485015260248401916142f8565b03915afa908115610a89578791613ed1575b508333911603610e2c57607b5460a01c60ff1615613eb55780613e37575b5090600080516020615c848339815191529160405193845216923392a36001805580f35b85836069541691613e488685614709565b92803b15610e7f57604051632fc3a4b160e21b81526001600160a01b0386166004820152602481019490945260448401919091528290606490829084905af1801561075f5715613e135794613ead600080516020615c8483398151915293929661410a565b949091613e13565b50908161073284600080516020615c8483398151915294614833565b90508581813d8311613eff575b613ee88183614154565b8101031261043757613ef990614451565b38613df5565b503d613ede565b50508781813d8311613f30575b613f1d8183614154565b810103126109125786613dab9151613da1565b503d613f13565b50346102ba57806003193601126102ba576040519080606554613f59816140d0565b80855291600191808316908115613fe45750600114613f9b575b613f9785613f8381870382614154565b604051918291602083526020830190614175565b0390f35b925060658352600080516020615c648339815191525b828410613fcc575050508101602001613f8382613f97613f73565b80546020858701810191909152909301928101613fb1565b869550613f9796935060209250613f8394915060ff191682840152151560051b8201019293613f73565b50346102ba5760203660031901126102ba5760043561402b61594a565b8015611983576020817fd2c55fe32fb2122608950e8daf3216fe57018c4ae02a3b66132249300e8702ed92607955604051908152a180f35b90503461099b57602036600319011261099b5760043563ffffffff60e01b8116809103610e7f57602092506307dba22560e31b81149081156140bf575b81156140ae575b5015158152f35b6301ffc9a760e01b149050386140a7565b63cad9e0d360e01b811491506140a0565b90600182811c92168015614100575b60208310146140ea57565b634e487b7160e01b600052602260045260246000fd5b91607f16916140df565b6001600160401b0381116132a857604052565b61012081019081106001600160401b038211176132a857604052565b604081019081106001600160401b038211176132a857604052565b90601f801991011681019081106001600160401b038211176132a857604052565b919082519283825260005b8481106141a1575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201614180565b600435906001600160a01b03821682036107db57565b604435906001600160a01b03821682036107db57565b9181601f840112156107db578235916001600160401b0383116107db57602083818601950101116107db57565b9181601f840112156107db578235916001600160401b0383116107db576020808501948460051b0101116107db57565b519081151582036107db57565b356001600160a01b03811681036107db5790565b908160209103126107db575160ff811681036107db5790565b8115614282570490565b634e487b7160e01b600052601260045260246000fd5b919082018092116139e957565b919082039182116139e957565b356001600160801b03811681036107db5790565b903590601e19813603018212156107db57018035906001600160401b0382116107db576020019181360383136107db57565b908060209392818452848401376000828201840152601f01601f1916010190565b903590601e19813603018212156107db57018035906001600160401b0382116107db57602001918160051b360383136107db57565b1561435557565b60405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608490fd5b607a548110156143e557607a6000527ff0440771a29e57e18c66727944770b82cc77924aef333c927ce6bdd2cdb3ae030190600090565b634e487b7160e01b600052603260045260246000fd5b60026001541461440c576002600155565b60405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606490fd5b51906001600160a01b03821682036107db57565b60655460009291614475826140d0565b808252916001908181169081156144da575060011461449357505050565b919293506065600052600080516020615c64833981519152916000925b8484106144c257505060209250010190565b805460208585018101919091529093019281016144b0565b915050602093945060ff929192191683830152151560051b010190565b6001600160a01b03909116815260208101919091526001600160801b03909116604082015260600190565b6001600160401b0381116132a85760051b60200190565b9291926001600160401b0382116132a85760405191614562601f8201601f191660200184614154565b8294818452818301116107db578281602093846000960137010152565b91908260809103126107db5761459482614451565b91602081015160038110156107db57916060604083015192015190565b60835460405163481d98fb60e11b8152602060048201529060809082906001600160a01b031681806145e560248201614465565b03915afa908115610e7357600090819261462e575b506003811015614618576002149081614611575090565b9050421190565b634e487b7160e01b600052602160045260246000fd5b9050614648915060803d81116110f5576110e28183614154565b925050386145fa565b676765c793fa10079d601b1b6146876122fc614675606d5460801c60705490615821565b6001600160801b03606f541690615bf5565b0490565b606b546040516370a0823160e01b815230600482015290602090829060249082906001600160a01b03165afa8015610e73576000906146d6575b6146d3915060775490614298565b90565b6020823d8211614701575b816146ee60209383614154565b810103126102ba57506146d390516146c5565b3d91506146e1565b60835460405163af9a2aa760e01b8152602060048201819052926001600160a01b0392909190849082908516818061474360248201614465565b03915afa908115610e73576000916147fe575b5082309116036147ec5761479f93839261476e614c64565b606954169060006001600160801b03606f54169360405197889586948593630ab714fb60e11b8552600485016144f7565b03925af1908115610e73576000916147c0575b509050906147be615378565b565b82813d83116147e5575b6147d48183614154565b810103126102ba57505180386147b2565b503d6147ca565b604051636f2f995760e01b8152600490fd5b908482813d831161482c575b6148148183614154565b810103126102ba575061482690614451565b38614756565b503d61480a565b607d54916000924211614c52576148518161484c61468b565b6142a5565b906148968360018060a01b03928360695416946001600160801b03606f54169560409687518092630ab714fb60e11b8252818c8160209a8b968a60049c8d85016144f7565b03925af18015614bff57908591614c29575b5050607c54811015614c19576148c090607c546142a5565b81811115614c0957509260ff607854166149fb575b80607b54169280865180809463be5daee560e01b825289878301526148fc60448301614465565b9a16998a60248301520381875afa9081156149f15790859189916149be575b506149269250614298565b608054106149b05760825494608154833b15610d81578794939260c09286928851998a978896879563e976e18b60e01b875286015261496760c48601614465565b9360248601526044850152606484015260848301524260a483015203925af19081156149a75750614996575050565b6149a0829161410a565b6102ba5750565b513d84823e3d90fd5b835163c7e138ed60e01b8152fd5b8092508391503d83116149ea575b6149d68183614154565b810103126107db578361492691513861491b565b503d6149cc565b86513d8a823e3d90fd5b606b5485516370a0823160e01b815230848201529082168482602481845afa918215614bff579084918a93614bcc575b50614a3883607754614298565b60775585846083541689519384809263a03e4bc360e01b82525afa918215614b52578a92614b95575b50875163095ea7b360e01b81526001600160a01b038316868201908152602081018590529091879183919082908e90829060400103925af18015614b525790849291614b5c575b50169082606b5416823b15610da95787519063617ba03760e01b825285820152816024820152306044820152896064820152898160848183875af18015614b5257614b1d575b50847f3b1270fa6f77c9af94834571cf5274944e8712de6cebea9ec3d8b3452c053308918851908152a26148d5565b7f3b1270fa6f77c9af94834571cf5274944e8712de6cebea9ec3d8b3452c0533089199614b4a879261410a565b999150614aee565b88513d8c823e3d90fd5b9091508581813d8311614b8e575b614b748183614154565b81010312610da95790614b87849261423e565b5038614aa8565b503d614b6a565b9091508581813d8311614bc5575b614bad8183614154565b81010312610da957614bbe90614451565b9038614a61565b503d614ba3565b86809294508193503d8311614bf8575b614be68183614154565b81010312610912578390519138614a2b565b503d614bdc565b87513d8b823e3d90fd5b905092614c14614e44565b6148d5565b50505050505050506147be614e44565b813d8311614c4b575b614c3c8183614154565b81010312610d815783386148a8565b503d614c32565b604051639a9a6f1760e01b8152600490fd5b606d5490607054614c78818460801c615821565b92606f54676765c793fa10079d601b1b9283614ca26122fc6001600160801b039889861690615bf5565b0490868211614d77578680614cb993169416615853565b92614cd86122fc846001600160801b03198095161760801c8096615bf5565b04948511614d655760049460801b16179081606f5542607055602060018060a01b03606a54166040519586809263b1bf962d60e01b82525afa918215610e7357600092614d2f575b6147be93945060801c91614d89565b91936020813d8211614d5d575b81614d4960209383614154565b8101031261040f5751929350839291614d20565b3d9150614d3c565b60405163306e92a960e11b8152600490fd5b604051632db5409f60e21b8152600490fd5b9190916072548015614e3e57610582614de991614de4670de0b6b3a7640000946122fc6139a16122fc60018060a01b039a8b606954169b606854169a614ddd676765c793fa10079d601b1b95869288615bf5565b0494615bf5565b615bf5565b04916001600160801b03606f541690803b156107db57614e249360008094604051968795869485936327883e6160e21b8552600485016144f7565b03925af18015610e7357614e355750565b6147be9061410a565b50505050565b607b805460ff60a01b1916600160a01b179055607e54614e649042614298565b607f5560ff60785416614e99575b7f5023432d2ef8583c6eb5ee4501bf4740bf68b6fe4823da8f19ddedd1135f2a64600080a1565b614ea1614eba565b614e72565b51906001600160801b03821682036107db57565b6083546040805163a03e4bc360e01b815290916000916004916020916001600160a01b0391839082908690829086165afa9081156150f4579082918691615340575b50169281606b54168651906335ea6a7560e01b825280838301526101e080836024818a5afa92831561513557869186918a956151ab575b50506101006024940151168951938480926370a0823160e01b825230888301525afa91821561516857879261517c575b5060ff19607854166078558115615172578751631a4ca37b60e21b815283810191909152600019602482015230604482015284816064818a8a5af180156151685790859161513f575b507f6407790cdabc5d219eaf901091d6beccc475533065c2fbd374c8a32b1c66795886918951848152a260775490818111614fef575b5050505050509050607755565b90614ff9916142a5565b9173__$183737d697d7aa9b5df9988cbe11bc4947$__90828582606b541692608354168a51958680926361d027b360e01b82525afa9384156151355788946150fe575b50823b15610d81578851636336129b60e11b81526001600160a01b0392831691810191825293909116602082015260408101849052869183918290819060600103915af480156150f4576150c1575b507f590e5a1563e349794fdcc066c4d5047f5e478f9e41707fc1bbad830146b7a17792939451908152a280388080808080614fe2565b936150ed7f590e5a1563e349794fdcc066c4d5047f5e478f9e41707fc1bbad830146b7a177949561410a565b939261508b565b86513d87823e3d90fd5b9093508581813d831161512e575b6151168183614154565b81010312610d815761512790614451565b923861503c565b503d61510c565b89513d8a823e3d90fd5b813d8311615161575b6151528183614154565b8101031261076a578338614fac565b503d615148565b88513d89823e3d90fd5b5050505050505050565b9091508481813d83116151a4575b6151948183614154565b8101031261043757519038614f63565b503d61518a565b9250809394508291503d8411615339575b6151c68183614154565b810103828112610912578951928301906001600160401b039084831082841117615326578813610da957610200840190811182821017615313578a52815181528252615213868201614ea6565b86830152615222898201614ea6565b8983015261523260608201614ea6565b606083015261524360808201614ea6565b608083015261525460a08201614ea6565b60a083015260c081015164ffffffffff811681036109125760c083015260e081015161ffff8116810361091257610100838893889360e06024989701528261529d818301614451565b908301526101206152af818301614451565b908301526101406152c1818301614451565b908301526101606152d3818301614451565b908301526101806152e5818301614ea6565b908301526101a06152f7818301614ea6565b908301526153096101c0809201614ea6565b9082015294614f33565b634e487b7160e01b8a526041865260248afd5b634e487b7160e01b8b526041875260248bfd5b503d6151bc565b809250848092503d8311615371575b6153598183614154565b8101031261040f5761536b8291614451565b38614efc565b503d61534f565b606a54604080516318160ddd60e01b81526020926001600160a01b039084908390600490829085165afa91821561556b5760009261553c575b506153c3826153be61468b565b614298565b908161542e575050507f9cf6ed4d2e86c73a9ce91a9baa90bb3a472323bb366819d0934e0d95d3e7500e9160a0916000606d555b606d5490606f54908051936001600160801b0393848116865260801c908501528160801c90840152166060820152426080820152a1565b839161543e916076541693615c2c565b604460725491600084519586948593630884b37d60e11b8552600485015260248401525af19081156155315760009081926154bd575b50917f9cf6ed4d2e86c73a9ce91a9baa90bb3a472323bb366819d0934e0d95d3e7500e93916001600160801b0360a09416906001600160801b03199060801b1617606d556153f7565b91508282813d831161552a575b6154d48183614154565b810103126102ba57509160a091836001600160801b0361551f846155187f9cf6ed4d2e86c73a9ce91a9baa90bb3a472323bb366819d0934e0d95d3e7500e98614ea6565b9301614ea6565b939550509092615474565b503d6154ca565b82513d6000823e3d90fd5b90918482813d8311615564575b6155538183614154565b810103126102ba57505190386153b1565b503d615549565b83513d6000823e3d90fd5b6001600160a01b03919082811680156157fc576000918183526020926075845260409160ff60018484200154166157eb57825163313ce56760e01b81526004979086818a81895afa9081156157e15760129160ff9186916157c4575b5016116157b457608454606b548551634858138f60e01b81526001600160a01b038581168c830190815292851690811660208401529390921691908890829081906040010381855afa9081156150f4578591615787575b5015615777578451632bd3159f60e21b81526001600160a01b03808516828c019081529316602084015291859183918290819060400103915afa801561576d5761572d575b50607a546801000000000000000081101561571a579061259f8260016156979401607a556143ae565b607a546000198101908111615707577fb38e19e04618f9502008311560587c597fe11e8867226353a0c01aab7e4df2939596506001908351906156d982614139565b81528386820193838552868152607588522090518155019051151560ff8019835416911617905551908152a1565b634e487b7160e01b825260118752602482fd5b634e487b7160e01b835260418852602483fd5b8381813d8311615766575b6157428183614154565b81010312610e7f57858161575861575f93614451565b5001614451565b503861566e565b503d615738565b84513d85823e3d90fd5b8451633c15d6ff60e21b81528990fd5b90508781813d83116157ad575b61579e8183614154565b8101031261040f575138615629565b503d615794565b835163b7c73c5d60e01b81528890fd5b6157db9150893d8b116119f9576119eb8183614154565b386155d2565b85513d86823e3d90fd5b8251632d6c6ae560e01b8152600490fd5b6040516346ec28e560e11b8152600490fd5b818102929181159184041417156139e957565b61583a906158346301e1338093426142a5565b9061580e565b04676765c793fa10079d601b1b81018091116139e95790565b9061585e90426142a5565b908115615939576000198201918083116139e9576000600282111561592a575060011981018181116139e9576159136301e1338091925b600661590c876158fd676765c793fa10079d601b1b976158fd6159028b6158fd6906a4334962924ee000008d6158f46122fc66038882915c4000836158dd6122fc8980615bf5565b040495836158ee6122fc8380615bf5565b04615bf5565b0404968a61580e565b61580e565b60011c9b8761580e565b049461580e565b0481018091116139e9576146d3926153be91614298565b6159136301e133809192615895565b5050676765c793fa10079d601b1b90565b606654604051632474521560e21b81527fc0fc8e4dc5cff6febdf550b80d566f654e2baf1a02ea1060208c2f8ab2dd1b63600482015233602482015290602090829060449082906001600160a01b03165afa908115610e73576000916159b3575b5015610e2c57565b906020823d82116159e4575b816159cc60209383614154565b810103126102ba57506159de9061423e565b386159ab565b3d91506159bf565b606654604051632474521560e21b81527f5a7d4408f4759dddd7fdfd0d21abd99341dc2f52cda14804988a9b2df20766d8600482015233602482015290602090829060449082906001600160a01b03165afa908115610e73576000916159b3575015610e2c57565b606654604051632474521560e21b81526000600482015233602482015290602090829060449082906001600160a01b03165afa908115610e73576000916159b3575015610e2c57565b606654604051632474521560e21b81527f5580ea9b7f9becaa48a78f506a2019ea24794b7a717ee6a4b9f62e36b94c25a6600482015233602482015290602090829060449082906001600160a01b03165afa908115610e73576000916159b3575015610e2c57565b607454604051630723eb0360e51b815233600482015290602090829060249082906001600160a01b03165afa908115610e7357600091615b59575b50615b4757565b6040516333df015b60e01b8152600490fd5b906020823d8211615b8a575b81615b7260209383614154565b810103126102ba5750615b849061423e565b38615b40565b3d9150615b65565b906706f05b59d3b200008201918281116139e9578210615bae57565b604051630a77254f60e01b8152600490fd5b906b019d971e4fe8401e740000008201918281116139e9578210615bae57565b9190615bec9083614298565b918210615bae57565b600092918015918215615c0c575b5050156139d757565b91509250615c24615c1d848361580e565b9384614278565b143880615c03565b90676765c793fa10079d601b1b91828102928184048114821517156139e9578304036139d7576139d26146d3928260011c90615be056fe8ff97419363ffd7000167f130ef7168fbea05faf9251824ca5043f113cc6a7c75548c837ab068cf56a2c2479df0882a4922fd203edb7517321831d95078c5f62a26469706673582212205938e49a0e919051e6fc2b2cbc83cbd0b27d8576a8efa50530ccb5622f17433164736f6c63430008120033",
  "libraries": {
    "TokenTransfersLibrary": "0x4FFa6c545a6249baF2D66ce21CeF3D2C2cCa69D0"
  },
  "devdoc": {
    "events": {
      "Initialized(uint8)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "kind": "dev",
    "methods": {
      "addAsset(address)": {
        "details": "Function to add new trading asset for this bucketOnly callable by the MEDIUM_TIMELOCK_ADMIN role.",
        "params": {
          "_newAsset": "The address of trading asset"
        }
      },
      "availableLiquidity()": {
        "details": "Returns current avalable liquidity of borrowedAsset for trading.",
        "returns": {
          "_0": "The amount of available borrowedAsset"
        }
      },
      "batchDecreaseTradersDebt(address[],uint256[],address,uint256,uint256,uint256)": {
        "details": "This function can only be called by the BATCH_MANAGER_ROLE.",
        "params": {
          "_amountToReturn": "The amount to be returned.",
          "_debtsToBurn": "An array of uint256 values representing the debts to burn for each trader.",
          "_length": "The length of the traders array.",
          "_permanentLossAmount": "The amount of permanent loss.",
          "_receiverOfAmountToReturn": "The address that will receive the amount to be returned.",
          "_traders": "An array of addresses representing the traders."
        }
      },
      "decreaseTraderDebt(address,uint256,address,uint256,uint256)": {
        "details": "Function to update rates and indexes. Burns debt tokens of trader. Called only by positionManager contract.",
        "params": {
          "_amountToReturn": "Amount to transfer from bucket",
          "_debtToBurn": "The 'amount' of trader's debtTokens will be burned by the trader.",
          "_permanentLossAmount": "The amount of the protocol's debt to creditors accrued for this position",
          "_receiverOfAmountToReturn": "Treasury in case of liquidation. TraderBalanceVault in other cases",
          "_trader": "The address of the trader, who opened position."
        }
      },
      "deposit(address,uint256)": {
        "details": "Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.",
        "params": {
          "_amount": "The amount of underlying tokens to be deposited",
          "_pTokenReceiver": "The address to receive the deposited pTokens."
        }
      },
      "deposit(address,uint256,bool)": {
        "details": "Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.",
        "params": {
          "_amount": "The amount of underlying tokens to be deposited",
          "_pTokenReceiver": "The address to receive the deposited pTokens.",
          "_takeDepositFromWallet": "A flag indicating whether to make the deposit from user wallet"
        }
      },
      "depositFromBucket(string,address,(uint256,(string,bytes)[])[],uint256)": {
        "params": {
          "_amountOutMin": "The minimum amount of tokens to receive from the swap.",
          "_bucketTo": "The name of the destination bucket.",
          "_swapManager": "The address of the swap manager.",
          "routes": "The array of routes for swapping tokens."
        }
      },
      "getAllowedAssets()": {
        "details": "Returns allowed trading assets for current bucket",
        "returns": {
          "_0": "List of addresses of allowed assets"
        }
      },
      "getLiquidityMiningParams()": {
        "details": "Returns the parameters for liquidity mining.",
        "returns": {
          "_0": "LMparams The liquidity mining parameters."
        }
      },
      "getNormalizedIncome()": {
        "details": "Returns the normalized income per unit of underlying asset, expressed in ray",
        "returns": {
          "_0": "The normalized income per unit of underlying asset, expressed in ray"
        }
      },
      "getNormalizedVariableDebt()": {
        "details": "Returns the normalized variable debt per unit of underlying asset, expressed in ray"
      },
      "increaseDebt(address,uint256,address)": {
        "details": "Function to update rates and indexes when a trader opens a trading position. Mints debt tokens to trader. Calls only by positionManager contract.",
        "params": {
          "_amount": "The 'amount' for which the deal is open, and 'amount' of debtTokens will be minted to the trader.",
          "_to": "The address to transfer the borrowed asset to.",
          "_trader": "The address of the trader, who opens position."
        }
      },
      "initialize((string,address,address,address,address,address,address,address,address[],address,uint256,uint256,uint256,address,uint256,uint256,uint256,address,uint128,uint128,uint256,bool,bytes,uint256),address)": {
        "details": "Initializes the contract with the given parameters.",
        "params": {
          "_params": "The ConstructorParams struct containing initialization parameters.",
          "_registry": "The address of the registry contract."
        }
      },
      "isActive()": {
        "details": "Checks if this bucket is active in the protocol.",
        "returns": {
          "_0": "bool True if the bucket is active, false otherwise."
        }
      },
      "isBucketStable()": {
        "details": "Returns a boolean value indicating whether the bucket is stable in the liquidity mining event.",
        "returns": {
          "_0": "A boolean value representing the stability of the bucket."
        }
      },
      "isDelisted()": {
        "details": "Returns a boolean value indicating whether the bucket is delisted.",
        "returns": {
          "_0": "True if the bucket is delisted, otherwise false."
        }
      },
      "isDeprecated()": {
        "details": "Checks if the bucket is deprecated in the protocol.",
        "returns": {
          "_0": "Whether the bucket is deprecated or not."
        }
      },
      "isWithdrawAfterDelistingAvailable()": {
        "details": "Checks if an admin can withdraw from the bucket after delisting.",
        "returns": {
          "_0": "A boolean indicating whether withdrawal is available."
        }
      },
      "maxAssetLeverage(address)": {
        "details": "Calculates the max leverage according to the following formula: ((1 + maintenanceBuffer) * feeBuffer) / ((1 + maintenanceBuffer) * feeBuffer - (1 - securityBuffer) * (1 - pairPriceDropBA) * (1 - oracleTolerableLimitAB) * (1 - oracleTolerableLimitBA))",
        "params": {
          "_asset": "The address of trading asset"
        },
        "returns": {
          "_0": "The maximum leverage as a uint256 value."
        }
      },
      "paybackPermanentLoss(uint256)": {
        "params": {
          "amount": "The amount of pTokens to be burned to pay back the permanent loss."
        }
      },
      "permanentLoss()": {
        "details": "Calculates the permanent loss based on the scaled permanent loss and the normalized income.",
        "returns": {
          "_0": "The amount of permanent loss."
        }
      },
      "receiveDeposit(address,uint256,uint256,string)": {
        "details": "Receives a deposit and distributes it to the specified pToken receiver.Can be called only by another bucket.",
        "params": {
          "_amount": "The amount of tokens being deposited.",
          "_bucketFrom": "The name of the bucket from which the deposit is being made.",
          "_duration": "The blocking time for a fixed-term deposit (if it's 0, then it will be a usual deposit)",
          "_pTokenReceiver": "The address of the recipient of the pToken."
        }
      },
      "removeAsset(address)": {
        "details": "Only callable by the SMALL_TIMELOCK_ADMIN role.",
        "params": {
          "_assetToDelete": "The address of the asset to be removed."
        }
      },
      "returnLiquidityFromAaveToBucket()": {
        "details": "Allows the SMALL_TIMELOCK_ADMIN to withdraw all liquidity from Aave to Bucket."
      },
      "setFeeBuffer(uint256)": {
        "details": "Sets the new fee buffer.Only callable by the MEDIUM_TIMELOCK_ADMIN role.",
        "params": {
          "_feeBuffer": "The new fee buffer value."
        }
      },
      "setInterestRateStrategy(address)": {
        "details": "Sets the interest rate strategy contract address.Only callable by the BIG_TIMELOCK_ADMIN role.",
        "params": {
          "_interestRateStrategy": "The address of the interest rate strategy contract."
        }
      },
      "setMaxTotalDeposit(uint256)": {
        "params": {
          "_maxTotalDeposit": "The amount of max total deposit for the bucket"
        }
      },
      "setReserveRate(uint256)": {
        "details": "Sets the reserve rate.Only callable by the BIG_TIMELOCK_ADMIN role.",
        "params": {
          "_reserveRate": "The new reserve rate value."
        }
      },
      "setWithdrawalFee(uint256)": {
        "details": "Sets the withdrawal fee.Only callable by the BIG_TIMELOCK_ADMIN role.",
        "params": {
          "_withdrawalFee": "The new withdrawal fee value."
        }
      },
      "withdraw(address,uint256)": {
        "details": "Withdraws the 'amount' of underlying asset from the bucket. The 'amount' of overlying pTokens will be burned.",
        "params": {
          "_borrowAssetReceiver": "The address of receiver of the borrowed asset.",
          "amount": "The amount of underlying tokens to be withdrawn."
        }
      },
      "withdrawAfterDelisting(uint256)": {
        "params": {
          "_amount": "The amount of tokens to withdraw."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "bar()": {
        "notice": "bar = borrowing annual rate (originally APR)"
      },
      "batchDecreaseTradersDebt(address[],uint256[],address,uint256,uint256,uint256)": {
        "notice": "Batch decreases the debt of multiple traders."
      },
      "depositFromBucket(string,address,(uint256,(string,bytes)[])[],uint256)": {
        "notice": "Deposits (reinvests) funds from a bucket to another bucket. Used only in the case of failed liquidity mining in the bucket from where the transfer happens."
      },
      "lar()": {
        "notice": "lar = lending annual rate (originally APY)"
      },
      "paybackPermanentLoss(uint256)": {
        "notice": "This function allows a user to pay back a permanent loss by burning his pTokens."
      },
      "removeAsset(address)": {
        "notice": "Removes a trading asset from this bucket."
      },
      "setMaxTotalDeposit(uint256)": {
        "notice": "The function sets the max total deposit for the particular bucket"
      },
      "supportsInterface(bytes4)": {
        "notice": "Interface checker"
      },
      "withdrawAfterDelisting(uint256)": {
        "notice": "Allows the BIG_TIMELOCK_ADMIN role to withdraw a specified amount of tokens after delisting."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2890,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 2893,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 3193,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 3262,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "__gap",
        "offset": 0,
        "slot": "2",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 6506,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "__gap",
        "offset": 0,
        "slot": "51",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 25110,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "name",
        "offset": 0,
        "slot": "101",
        "type": "t_string_storage"
      },
      {
        "astId": 25113,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "registry",
        "offset": 0,
        "slot": "102",
        "type": "t_address"
      },
      {
        "astId": 25117,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "positionManager",
        "offset": 0,
        "slot": "103",
        "type": "t_contract(IPositionManager)39871"
      },
      {
        "astId": 25121,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "reserve",
        "offset": 0,
        "slot": "104",
        "type": "t_contract(IReserve)47515"
      },
      {
        "astId": 25125,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "pToken",
        "offset": 0,
        "slot": "105",
        "type": "t_contract(IPToken)37558"
      },
      {
        "astId": 25129,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "debtToken",
        "offset": 0,
        "slot": "106",
        "type": "t_contract(IDebtToken)27792"
      },
      {
        "astId": 25133,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "borrowedAsset",
        "offset": 0,
        "slot": "107",
        "type": "t_contract(IERC20Metadata)10876"
      },
      {
        "astId": 25136,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "feeBuffer",
        "offset": 0,
        "slot": "108",
        "type": "t_uint256"
      },
      {
        "astId": 25139,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "bar",
        "offset": 0,
        "slot": "109",
        "type": "t_uint128"
      },
      {
        "astId": 25142,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "lar",
        "offset": 16,
        "slot": "109",
        "type": "t_uint128"
      },
      {
        "astId": 25145,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "estimatedBar",
        "offset": 0,
        "slot": "110",
        "type": "t_uint128"
      },
      {
        "astId": 25148,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "estimatedLar",
        "offset": 16,
        "slot": "110",
        "type": "t_uint128"
      },
      {
        "astId": 25151,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "liquidityIndex",
        "offset": 0,
        "slot": "111",
        "type": "t_uint128"
      },
      {
        "astId": 25154,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "variableBorrowIndex",
        "offset": 16,
        "slot": "111",
        "type": "t_uint128"
      },
      {
        "astId": 25156,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "lastUpdatedBlockTimestamp",
        "offset": 0,
        "slot": "112",
        "type": "t_uint256"
      },
      {
        "astId": 25159,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "permanentLossScaled",
        "offset": 0,
        "slot": "113",
        "type": "t_uint256"
      },
      {
        "astId": 25161,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "reserveRate",
        "offset": 0,
        "slot": "114",
        "type": "t_uint256"
      },
      {
        "astId": 25164,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "withdrawalFeeRate",
        "offset": 0,
        "slot": "115",
        "type": "t_uint256"
      },
      {
        "astId": 25168,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "whiteBlackList",
        "offset": 0,
        "slot": "116",
        "type": "t_contract(IWhiteBlackList)54241"
      },
      {
        "astId": 25174,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "allowedAssets",
        "offset": 0,
        "slot": "117",
        "type": "t_mapping(t_address,t_struct(Asset)26162_storage)"
      },
      {
        "astId": 25177,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "interestRateStrategy",
        "offset": 0,
        "slot": "118",
        "type": "t_contract(IInterestRateStrategy)57222"
      },
      {
        "astId": 25179,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "aaveDeposit",
        "offset": 0,
        "slot": "119",
        "type": "t_uint256"
      },
      {
        "astId": 25181,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "isReinvestToAaveEnabled",
        "offset": 0,
        "slot": "120",
        "type": "t_bool"
      },
      {
        "astId": 25184,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "maxTotalDeposit",
        "offset": 0,
        "slot": "121",
        "type": "t_uint256"
      },
      {
        "astId": 25187,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "assets",
        "offset": 0,
        "slot": "122",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 25190,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "LMparams",
        "offset": 0,
        "slot": "123",
        "type": "t_struct(LiquidityMiningParams)26157_storage"
      },
      {
        "astId": 25193,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "dns",
        "offset": 0,
        "slot": "131",
        "type": "t_contract(IPrimexDNS)43597"
      },
      {
        "astId": 25196,
        "contract": "contracts/Bucket/Bucket.sol:Bucket",
        "label": "priceOracle",
        "offset": 0,
        "slot": "132",
        "type": "t_contract(IPriceOracle)42543"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IDebtToken)27792": {
        "encoding": "inplace",
        "label": "contract IDebtToken",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20Metadata)10876": {
        "encoding": "inplace",
        "label": "contract IERC20Metadata",
        "numberOfBytes": "20"
      },
      "t_contract(IInterestRateStrategy)57222": {
        "encoding": "inplace",
        "label": "contract IInterestRateStrategy",
        "numberOfBytes": "20"
      },
      "t_contract(ILiquidityMiningRewardDistributor)35104": {
        "encoding": "inplace",
        "label": "contract ILiquidityMiningRewardDistributor",
        "numberOfBytes": "20"
      },
      "t_contract(IPToken)37558": {
        "encoding": "inplace",
        "label": "contract IPToken",
        "numberOfBytes": "20"
      },
      "t_contract(IPositionManager)39871": {
        "encoding": "inplace",
        "label": "contract IPositionManager",
        "numberOfBytes": "20"
      },
      "t_contract(IPriceOracle)42543": {
        "encoding": "inplace",
        "label": "contract IPriceOracle",
        "numberOfBytes": "20"
      },
      "t_contract(IPrimexDNS)43597": {
        "encoding": "inplace",
        "label": "contract IPrimexDNS",
        "numberOfBytes": "20"
      },
      "t_contract(IReserve)47515": {
        "encoding": "inplace",
        "label": "contract IReserve",
        "numberOfBytes": "20"
      },
      "t_contract(IWhiteBlackList)54241": {
        "encoding": "inplace",
        "label": "contract IWhiteBlackList",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(Asset)26162_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct IBucketStorage.Asset)",
        "numberOfBytes": "32",
        "value": "t_struct(Asset)26162_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Asset)26162_storage": {
        "encoding": "inplace",
        "label": "struct IBucketStorage.Asset",
        "members": [
          {
            "astId": 26159,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "index",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 26161,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "isSupported",
            "offset": 0,
            "slot": "1",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(LiquidityMiningParams)26157_storage": {
        "encoding": "inplace",
        "label": "struct IBucketStorage.LiquidityMiningParams",
        "members": [
          {
            "astId": 26140,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "liquidityMiningRewardDistributor",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(ILiquidityMiningRewardDistributor)35104"
          },
          {
            "astId": 26142,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "isBucketLaunched",
            "offset": 20,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 26144,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "accumulatingAmount",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 26146,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "deadlineTimestamp",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 26148,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "stabilizationDuration",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 26150,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "stabilizationEndTimestamp",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 26152,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "maxAmountPerUser",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 26154,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "maxDuration",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 26156,
            "contract": "contracts/Bucket/Bucket.sol:Bucket",
            "label": "maxStabilizationEndTimestamp",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "256"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}