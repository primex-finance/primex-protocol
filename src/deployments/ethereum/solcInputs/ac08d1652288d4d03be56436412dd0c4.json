{
  "language": "Solidity",
  "sources": {
    "@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IAaveIncentivesController\n * @author Aave\n * @notice Defines the basic interface for an Aave Incentives Controller.\n * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.\n */\ninterface IAaveIncentivesController {\n  /**\n   * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\n   * @dev The units of `totalSupply` and `userBalance` should be the same.\n   * @param user The address of the user whose asset balance has changed\n   * @param totalSupply The total supply of the asset prior to user balance change\n   * @param userBalance The previous user balance prior to balance change\n   */\n  function handleAction(\n    address user,\n    uint256 totalSupply,\n    uint256 userBalance\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\nimport {IInitializableAToken} from './IInitializableAToken.sol';\n\n/**\n * @title IAToken\n * @author Aave\n * @notice Defines the basic interface for an AToken.\n */\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n  /**\n   * @dev Emitted during the transfer action\n   * @param from The user whose tokens are being transferred\n   * @param to The recipient\n   * @param value The scaled amount being transferred\n   * @param index The next liquidity index of the reserve\n   */\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n  /**\n   * @notice Mints `amount` aTokens to `user`\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted aTokens\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   * @return `true` if the the previous balance of the user was 0\n   */\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external returns (bool);\n\n  /**\n   * @notice Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n   * @dev In some instances, the mint event could be emitted from a burn transaction\n   * if the amount to burn is less than the interest that the user accrued\n   * @param from The address from which the aTokens will be burned\n   * @param receiverOfUnderlying The address that will receive the underlying\n   * @param amount The amount being burned\n   * @param index The next liquidity index of the reserve\n   */\n  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external;\n\n  /**\n   * @notice Mints aTokens to the reserve treasury\n   * @param amount The amount of tokens getting minted\n   * @param index The next liquidity index of the reserve\n   */\n  function mintToTreasury(uint256 amount, uint256 index) external;\n\n  /**\n   * @notice Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n   * @param from The address getting liquidated, current owner of the aTokens\n   * @param to The recipient\n   * @param value The amount of tokens getting transferred\n   */\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external;\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external;\n\n  /**\n   * @notice Handles the underlying received by the aToken after the transfer has been completed.\n   * @dev The default implementation is empty as with standard ERC20 tokens, nothing needs to be done after the\n   * transfer is concluded. However in the future there may be aTokens that allow for example to stake the underlying\n   * to receive LM rewards. In that case, `handleRepayment()` would perform the staking of the underlying asset.\n   * @param user The user executing the repayment\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed\n   * @param amount The amount getting repaid\n   */\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Allow passing a signed message to approve spending\n   * @dev implements the permit function as for\n   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n   * @param owner The owner of the funds\n   * @param spender The spender\n   * @param value The amount\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n   * @param v Signature param\n   * @param s Signature param\n   * @param r Signature param\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @return The address of the underlying asset\n   */\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Returns the address of the Aave treasury, receiving the fees on this aToken.\n   * @return Address of the Aave treasury\n   */\n  function RESERVE_TREASURY_ADDRESS() external view returns (address);\n\n  /**\n   * @notice Get the domain separator for the token\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n   * @return The domain separator of the token at current chain\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice Returns the nonce for owner.\n   * @param owner The address of the owner\n   * @return The nonce of the owner\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IInitializableAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol';\nimport {IPool} from './IPool.sol';\n\n/**\n * @title IInitializableAToken\n * @author Aave\n * @notice Interface for the initialize function on AToken\n */\ninterface IInitializableAToken {\n  /**\n   * @dev Emitted when an aToken is initialized\n   * @param underlyingAsset The address of the underlying asset\n   * @param pool The address of the associated pool\n   * @param treasury The address of the treasury\n   * @param incentivesController The address of the incentives controller for this aToken\n   * @param aTokenDecimals The decimals of the underlying\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  event Initialized(\n    address indexed underlyingAsset,\n    address indexed pool,\n    address treasury,\n    address incentivesController,\n    uint8 aTokenDecimals,\n    string aTokenName,\n    string aTokenSymbol,\n    bytes params\n  );\n\n  /**\n   * @notice Initializes the aToken\n   * @param pool The pool contract that is initializing this contract\n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n   * @param incentivesController The smart contract managing potential incentives distribution\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n   * @param aTokenName The name of the aToken\n   * @param aTokenSymbol The symbol of the aToken\n   * @param params A set of encoded parameters for additional initialization\n   */\n  function initialize(\n    IPool pool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   */\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   */\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   */\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   */\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   */\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   */\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   */\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   */\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   */\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   */\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   */\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   */\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   * @return The backed amount\n   */\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external returns (uint256);\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   */\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   */\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   */\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   */\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   */\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   */\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   */\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   */\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   */\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   */\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://docs.aave.com/developers/\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   */\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   */\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   */\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   */\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   */\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\n    external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   */\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   */\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n   * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n   * moment (approx. a borrower would get if opening a position). This means that is always used in\n   * combination with variable debt supply/balances.\n   * If using this function externally, consider that is possible to have an increasing normalized\n   * variable debt that is not equivalent to how the variable debt index would be updated in storage\n   * (e.g. only updates with non-zero variable debt supply)\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   */\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the underlying assets of all the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the underlying assets of the initialized reserves\n   */\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n   * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n   * @return The address of the reserve associated with id\n   */\n  function getReserveAddressById(uint16 id) external view returns (address);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   */\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   */\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   */\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   */\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   */\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   */\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   */\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   */\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   */\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   */\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   */\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IScaledBalanceToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IScaledBalanceToken\n * @author Aave\n * @notice Defines the basic interface for a scaled-balance token.\n */\ninterface IScaledBalanceToken {\n  /**\n   * @dev Emitted after the mint action\n   * @param caller The address performing the mint\n   * @param onBehalfOf The address of the user that will receive the minted tokens\n   * @param value The scaled-up amount being minted (based on user entered amount and balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'onBehalfOf'\n   * @param index The next liquidity index of the reserve\n   */\n  event Mint(\n    address indexed caller,\n    address indexed onBehalfOf,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @dev Emitted after the burn action\n   * @dev If the burn function does not involve a transfer of the underlying asset, the target defaults to zero address\n   * @param from The address from which the tokens will be burned\n   * @param target The address that will receive the underlying, if any\n   * @param value The scaled-up amount being burned (user entered amount - balance increase from interest)\n   * @param balanceIncrease The increase in scaled-up balance since the last action of 'from'\n   * @param index The next liquidity index of the reserve\n   */\n  event Burn(\n    address indexed from,\n    address indexed target,\n    uint256 value,\n    uint256 balanceIncrease,\n    uint256 index\n  );\n\n  /**\n   * @notice Returns the scaled balance of the user.\n   * @dev The scaled balance is the sum of all the updated stored balance divided by the reserve's liquidity index\n   * at the moment of the update\n   * @param user The user whose balance is calculated\n   * @return The scaled balance of the user\n   */\n  function scaledBalanceOf(address user) external view returns (uint256);\n\n  /**\n   * @notice Returns the scaled balance of the user and the scaled total supply.\n   * @param user The address of the user\n   * @return The scaled balance of the user\n   * @return The scaled total supply\n   */\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n  /**\n   * @notice Returns the scaled total supply of the scaled balance token. Represents sum(debt/index)\n   * @return The scaled total supply\n   */\n  function scaledTotalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns last index interest was accrued to the user's balance\n   * @param user The address of the user\n   * @return The last index interest was accrued to the user's balance, expressed in ray\n   */\n  function getPreviousIndex(address user) external view returns (uint256);\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/core/callback/IAlgebraSwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/// @title Callback for IAlgebraPoolActions#swap\r\n/// @notice Any contract that calls IAlgebraPoolActions#swap must implement this interface\r\ninterface IAlgebraSwapCallback {\r\n  /// @notice Called to `msg.sender` after executing a swap via IAlgebraPool#swap.\r\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\r\n  /// The caller of this method must be checked to be a AlgebraPool deployed by the canonical AlgebraFactory.\r\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\r\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\r\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\r\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\r\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\r\n  /// @param data Any data passed through by the caller via the IAlgebraPoolActions#swap call\r\n  function algebraSwapCallback(\r\n    int256 amount0Delta,\r\n    int256 amount1Delta,\r\n    bytes calldata data\r\n  ) external;\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/core/IAlgebraPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\nimport './pool/IAlgebraPoolImmutables.sol';\r\nimport './pool/IAlgebraPoolState.sol';\r\nimport './pool/IAlgebraPoolDerivedState.sol';\r\nimport './pool/IAlgebraPoolActions.sol';\r\nimport './pool/IAlgebraPoolPermissionedActions.sol';\r\nimport './pool/IAlgebraPoolEvents.sol';\r\n\r\n/**\r\n * @title The interface for a Algebra Pool\r\n * @dev The pool interface is broken up into many smaller pieces\r\n */\r\ninterface IAlgebraPool is\r\n  IAlgebraPoolImmutables,\r\n  IAlgebraPoolState,\r\n  IAlgebraPoolDerivedState,\r\n  IAlgebraPoolActions,\r\n  IAlgebraPoolPermissionedActions,\r\n  IAlgebraPoolEvents\r\n{\r\n  // used only for combining interfaces\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/core/IDataStorageOperator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\npragma abicoder v2;\r\n\r\ninterface IDataStorageOperator {\r\n  // alpha1 + alpha2 + baseFee must be <= type(uint16).max\r\n  struct FeeConfig {\r\n    uint16 alpha1; // max value of the first sigmoid\r\n    uint16 alpha2; // max value of the second sigmoid\r\n    uint32 beta1; // shift along the x-axis for the first sigmoid\r\n    uint32 beta2; // shift along the x-axis for the second sigmoid\r\n    uint16 gamma1; // horizontal stretch factor for the first sigmoid\r\n    uint16 gamma2; // horizontal stretch factor for the second sigmoid\r\n    uint32 volumeBeta; // shift along the x-axis for the outer volume-sigmoid\r\n    uint16 volumeGamma; // horizontal stretch factor the outer volume-sigmoid\r\n    uint16 baseFee; // minimum possible fee\r\n  }\r\n\r\n  event FeeConfiguration(FeeConfig feeConfig);\r\n\r\n  /**\r\n   * @notice Returns data belonging to a certain timepoint\r\n   * @param index The index of timepoint in the array\r\n   * @dev There is more convenient function to fetch a timepoint: observe(). Which requires not an index but seconds\r\n   * @return initialized Whether the timepoint has been initialized and the values are safe to use,\r\n   * blockTimestamp The timestamp of the observation,\r\n   * tickCumulative The tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp,\r\n   * secondsPerLiquidityCumulative The seconds per in range liquidity for the life of the pool as of the timepoint timestamp,\r\n   * volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp,\r\n   * averageTick Time-weighted average tick,\r\n   * volumePerLiquidityCumulative Cumulative swap volume per liquidity for the life of the pool as of the timepoint timestamp\r\n   */\r\n  function timepoints(uint256 index)\r\n    external\r\n    view\r\n    returns (\r\n      bool initialized,\r\n      uint32 blockTimestamp,\r\n      int56 tickCumulative,\r\n      uint160 secondsPerLiquidityCumulative,\r\n      uint88 volatilityCumulative,\r\n      int24 averageTick,\r\n      uint144 volumePerLiquidityCumulative\r\n    );\r\n\r\n  /// @notice Initialize the dataStorage array by writing the first slot. Called once for the lifecycle of the timepoints array\r\n  /// @param time The time of the dataStorage initialization, via block.timestamp truncated to uint32\r\n  /// @param tick Initial tick\r\n  function initialize(uint32 time, int24 tick) external;\r\n\r\n  /// @dev Reverts if an timepoint at or before the desired timepoint timestamp does not exist.\r\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\r\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\r\n  /// at exactly the timestamp between the two timepoints.\r\n  /// @param time The current block timestamp\r\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an timepoint\r\n  /// @param tick The current tick\r\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param liquidity The current in-range pool liquidity\r\n  /// @return tickCumulative The cumulative tick since the pool was first initialized, as of `secondsAgo`\r\n  /// @return secondsPerLiquidityCumulative The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\r\n  /// @return volatilityCumulative The cumulative volatility value since the pool was first initialized, as of `secondsAgo`\r\n  /// @return volumePerAvgLiquidity The cumulative volume per liquidity value since the pool was first initialized, as of `secondsAgo`\r\n  function getSingleTimepoint(\r\n    uint32 time,\r\n    uint32 secondsAgo,\r\n    int24 tick,\r\n    uint16 index,\r\n    uint128 liquidity\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      int56 tickCumulative,\r\n      uint160 secondsPerLiquidityCumulative,\r\n      uint112 volatilityCumulative,\r\n      uint256 volumePerAvgLiquidity\r\n    );\r\n\r\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\r\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\r\n  /// @param time The current block.timestamp\r\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an timepoint\r\n  /// @param tick The current tick\r\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param liquidity The current in-range pool liquidity\r\n  /// @return tickCumulatives The cumulative tick since the pool was first initialized, as of each `secondsAgo`\r\n  /// @return secondsPerLiquidityCumulatives The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\r\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\r\n  /// @return volumePerAvgLiquiditys The cumulative volume per liquidity values since the pool was first initialized, as of each `secondsAgo`\r\n  function getTimepoints(\r\n    uint32 time,\r\n    uint32[] memory secondsAgos,\r\n    int24 tick,\r\n    uint16 index,\r\n    uint128 liquidity\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      int56[] memory tickCumulatives,\r\n      uint160[] memory secondsPerLiquidityCumulatives,\r\n      uint112[] memory volatilityCumulatives,\r\n      uint256[] memory volumePerAvgLiquiditys\r\n    );\r\n\r\n  /// @notice Returns average volatility in the range from time-WINDOW to time\r\n  /// @param time The current block.timestamp\r\n  /// @param tick The current tick\r\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param liquidity The current in-range pool liquidity\r\n  /// @return TWVolatilityAverage The average volatility in the recent range\r\n  /// @return TWVolumePerLiqAverage The average volume per liquidity in the recent range\r\n  function getAverages(\r\n    uint32 time,\r\n    int24 tick,\r\n    uint16 index,\r\n    uint128 liquidity\r\n  ) external view returns (uint112 TWVolatilityAverage, uint256 TWVolumePerLiqAverage);\r\n\r\n  /// @notice Writes an dataStorage timepoint to the array\r\n  /// @dev Writable at most once per block. Index represents the most recently written element. index must be tracked externally.\r\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param blockTimestamp The timestamp of the new timepoint\r\n  /// @param tick The active tick at the time of the new timepoint\r\n  /// @param liquidity The total in-range liquidity at the time of the new timepoint\r\n  /// @param volumePerLiquidity The gmean(volumes)/liquidity at the time of the new timepoint\r\n  /// @return indexUpdated The new index of the most recently written element in the dataStorage array\r\n  function write(\r\n    uint16 index,\r\n    uint32 blockTimestamp,\r\n    int24 tick,\r\n    uint128 liquidity,\r\n    uint128 volumePerLiquidity\r\n  ) external returns (uint16 indexUpdated);\r\n\r\n  /// @notice Changes fee configuration for the pool\r\n  function changeFeeConfiguration(FeeConfig calldata feeConfig) external;\r\n\r\n  /// @notice Calculates gmean(volume/liquidity) for block\r\n  /// @param liquidity The current in-range pool liquidity\r\n  /// @param amount0 Total amount of swapped token0\r\n  /// @param amount1 Total amount of swapped token1\r\n  /// @return volumePerLiquidity gmean(volume/liquidity) capped by 100000 << 64\r\n  function calculateVolumePerLiquidity(\r\n    uint128 liquidity,\r\n    int256 amount0,\r\n    int256 amount1\r\n  ) external pure returns (uint128 volumePerLiquidity);\r\n\r\n  /// @return windowLength Length of window used to calculate averages\r\n  function window() external view returns (uint32 windowLength);\r\n\r\n  /// @notice Calculates fee based on combination of sigmoids\r\n  /// @param time The current block.timestamp\r\n  /// @param tick The current tick\r\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\r\n  /// @param liquidity The current in-range pool liquidity\r\n  /// @return fee The fee in hundredths of a bip, i.e. 1e-6\r\n  function getFee(\r\n    uint32 time,\r\n    int24 tick,\r\n    uint16 index,\r\n    uint128 liquidity\r\n  ) external view returns (uint16 fee);\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/core/pool/IAlgebraPoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n// @title Permissionless pool actions\r\ninterface IAlgebraPoolActions {\r\n  /**\r\n   * @notice Sets the initial price for the pool\r\n   * @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\r\n   * @param price the initial sqrt price of the pool as a Q64.96\r\n   */\r\n  function initialize(uint160 price) external;\r\n\r\n  /**\r\n   * @notice Adds liquidity for the given recipient/bottomTick/topTick position\r\n   * @dev The caller of this method receives a callback in the form of IAlgebraMintCallback# AlgebraMintCallback\r\n   * in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\r\n   * on bottomTick, topTick, the amount of liquidity, and the current price.\r\n   * @param sender The address which will receive potential surplus of paid tokens\r\n   * @param recipient The address for which the liquidity will be created\r\n   * @param bottomTick The lower tick of the position in which to add liquidity\r\n   * @param topTick The upper tick of the position in which to add liquidity\r\n   * @param amount The desired amount of liquidity to mint\r\n   * @param data Any data that should be passed through to the callback\r\n   * @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n   * @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\r\n   * @return liquidityActual The actual minted amount of liquidity\r\n   */\r\n  function mint(\r\n    address sender,\r\n    address recipient,\r\n    int24 bottomTick,\r\n    int24 topTick,\r\n    uint128 amount,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    returns (\r\n      uint256 amount0,\r\n      uint256 amount1,\r\n      uint128 liquidityActual\r\n    );\r\n\r\n  /**\r\n   * @notice Collects tokens owed to a position\r\n   * @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\r\n   * Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\r\n   * amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\r\n   * actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\r\n   * @param recipient The address which should receive the fees collected\r\n   * @param bottomTick The lower tick of the position for which to collect fees\r\n   * @param topTick The upper tick of the position for which to collect fees\r\n   * @param amount0Requested How much token0 should be withdrawn from the fees owed\r\n   * @param amount1Requested How much token1 should be withdrawn from the fees owed\r\n   * @return amount0 The amount of fees collected in token0\r\n   * @return amount1 The amount of fees collected in token1\r\n   */\r\n  function collect(\r\n    address recipient,\r\n    int24 bottomTick,\r\n    int24 topTick,\r\n    uint128 amount0Requested,\r\n    uint128 amount1Requested\r\n  ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n  /**\r\n   * @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\r\n   * @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\r\n   * @dev Fees must be collected separately via a call to #collect\r\n   * @param bottomTick The lower tick of the position for which to burn liquidity\r\n   * @param topTick The upper tick of the position for which to burn liquidity\r\n   * @param amount How much liquidity to burn\r\n   * @return amount0 The amount of token0 sent to the recipient\r\n   * @return amount1 The amount of token1 sent to the recipient\r\n   */\r\n  function burn(\r\n    int24 bottomTick,\r\n    int24 topTick,\r\n    uint128 amount\r\n  ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n  /**\r\n   * @notice Swap token0 for token1, or token1 for token0\r\n   * @dev The caller of this method receives a callback in the form of IAlgebraSwapCallback# AlgebraSwapCallback\r\n   * @param recipient The address to receive the output of the swap\r\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\r\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\r\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\r\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\r\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\r\n   * SwapRouter#SwapCallbackData\r\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\r\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\r\n   */\r\n  function swap(\r\n    address recipient,\r\n    bool zeroToOne,\r\n    int256 amountSpecified,\r\n    uint160 limitSqrtPrice,\r\n    bytes calldata data\r\n  ) external returns (int256 amount0, int256 amount1);\r\n\r\n  /**\r\n   * @notice Swap token0 for token1, or token1 for token0 (tokens that have fee on transfer)\r\n   * @dev The caller of this method receives a callback in the form of I AlgebraSwapCallback# AlgebraSwapCallback\r\n   * @param sender The address called this function (Comes from the Router)\r\n   * @param recipient The address to receive the output of the swap\r\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\r\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\r\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\r\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\r\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\r\n   * SwapRouter#SwapCallbackData\r\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\r\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\r\n   */\r\n  function swapSupportingFeeOnInputTokens(\r\n    address sender,\r\n    address recipient,\r\n    bool zeroToOne,\r\n    int256 amountSpecified,\r\n    uint160 limitSqrtPrice,\r\n    bytes calldata data\r\n  ) external returns (int256 amount0, int256 amount1);\r\n\r\n  /**\r\n   * @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\r\n   * @dev The caller of this method receives a callback in the form of IAlgebraFlashCallback# AlgebraFlashCallback\r\n   * @dev All excess tokens paid in the callback are distributed to liquidity providers as an additional fee. So this method can be used\r\n   * to donate underlying tokens to currently in-range liquidity providers by calling with 0 amount{0,1} and sending\r\n   * the donation amount(s) from the callback\r\n   * @param recipient The address which will receive the token0 and token1 amounts\r\n   * @param amount0 The amount of token0 to send\r\n   * @param amount1 The amount of token1 to send\r\n   * @param data Any data to be passed through to the callback\r\n   */\r\n  function flash(\r\n    address recipient,\r\n    uint256 amount0,\r\n    uint256 amount1,\r\n    bytes calldata data\r\n  ) external;\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/core/pool/IAlgebraPoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @title Pool state that is not stored\r\n * @notice Contains view functions to provide information about the pool that is computed rather than stored on the\r\n * blockchain. The functions here may have variable gas costs.\r\n */\r\ninterface IAlgebraPoolDerivedState {\r\n  /**\r\n   * @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\r\n   * @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\r\n   * the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\r\n   * you must call it with secondsAgos = [3600, 0].\r\n   * @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\r\n   * log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\r\n   * @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\r\n   * @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\r\n   * @return secondsPerLiquidityCumulatives Cumulative seconds per liquidity-in-range value as of each `secondsAgos`\r\n   * from the current block timestamp\r\n   * @return volatilityCumulatives Cumulative standard deviation as of each `secondsAgos`\r\n   * @return volumePerAvgLiquiditys Cumulative swap volume per liquidity as of each `secondsAgos`\r\n   */\r\n  function getTimepoints(uint32[] calldata secondsAgos)\r\n    external\r\n    view\r\n    returns (\r\n      int56[] memory tickCumulatives,\r\n      uint160[] memory secondsPerLiquidityCumulatives,\r\n      uint112[] memory volatilityCumulatives,\r\n      uint256[] memory volumePerAvgLiquiditys\r\n    );\r\n\r\n  /**\r\n   * @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\r\n   * @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\r\n   * I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\r\n   * snapshot is taken and the second snapshot is taken.\r\n   * @param bottomTick The lower tick of the range\r\n   * @param topTick The upper tick of the range\r\n   * @return innerTickCumulative The snapshot of the tick accumulator for the range\r\n   * @return innerSecondsSpentPerLiquidity The snapshot of seconds per liquidity for the range\r\n   * @return innerSecondsSpent The snapshot of the number of seconds during which the price was in this range\r\n   */\r\n  function getInnerCumulatives(int24 bottomTick, int24 topTick)\r\n    external\r\n    view\r\n    returns (\r\n      int56 innerTickCumulative,\r\n      uint160 innerSecondsSpentPerLiquidity,\r\n      uint32 innerSecondsSpent\r\n    );\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/core/pool/IAlgebraPoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n// @title Events emitted by a pool\r\ninterface IAlgebraPoolEvents {\r\n  /**\r\n   * @notice Emitted exactly once by a pool when #initialize is first called on the pool\r\n   * @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\r\n   * @param price The initial sqrt price of the pool, as a Q64.96\r\n   * @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\r\n   */\r\n  event Initialize(uint160 price, int24 tick);\r\n\r\n  /**\r\n   * @notice Emitted when liquidity is minted for a given position\r\n   * @param sender The address that minted the liquidity\r\n   * @param owner The owner of the position and recipient of any minted liquidity\r\n   * @param bottomTick The lower tick of the position\r\n   * @param topTick The upper tick of the position\r\n   * @param liquidityAmount The amount of liquidity minted to the position range\r\n   * @param amount0 How much token0 was required for the minted liquidity\r\n   * @param amount1 How much token1 was required for the minted liquidity\r\n   */\r\n  event Mint(\r\n    address sender,\r\n    address indexed owner,\r\n    int24 indexed bottomTick,\r\n    int24 indexed topTick,\r\n    uint128 liquidityAmount,\r\n    uint256 amount0,\r\n    uint256 amount1\r\n  );\r\n\r\n  /**\r\n   * @notice Emitted when fees are collected by the owner of a position\r\n   * @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\r\n   * @param owner The owner of the position for which fees are collected\r\n   * @param recipient The address that received fees\r\n   * @param bottomTick The lower tick of the position\r\n   * @param topTick The upper tick of the position\r\n   * @param amount0 The amount of token0 fees collected\r\n   * @param amount1 The amount of token1 fees collected\r\n   */\r\n  event Collect(address indexed owner, address recipient, int24 indexed bottomTick, int24 indexed topTick, uint128 amount0, uint128 amount1);\r\n\r\n  /**\r\n   * @notice Emitted when a position's liquidity is removed\r\n   * @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\r\n   * @param owner The owner of the position for which liquidity is removed\r\n   * @param bottomTick The lower tick of the position\r\n   * @param topTick The upper tick of the position\r\n   * @param liquidityAmount The amount of liquidity to remove\r\n   * @param amount0 The amount of token0 withdrawn\r\n   * @param amount1 The amount of token1 withdrawn\r\n   */\r\n  event Burn(address indexed owner, int24 indexed bottomTick, int24 indexed topTick, uint128 liquidityAmount, uint256 amount0, uint256 amount1);\r\n\r\n  /**\r\n   * @notice Emitted by the pool for any swaps between token0 and token1\r\n   * @param sender The address that initiated the swap call, and that received the callback\r\n   * @param recipient The address that received the output of the swap\r\n   * @param amount0 The delta of the token0 balance of the pool\r\n   * @param amount1 The delta of the token1 balance of the pool\r\n   * @param price The sqrt(price) of the pool after the swap, as a Q64.96\r\n   * @param liquidity The liquidity of the pool after the swap\r\n   * @param tick The log base 1.0001 of price of the pool after the swap\r\n   */\r\n  event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 price, uint128 liquidity, int24 tick);\r\n\r\n  /**\r\n   * @notice Emitted by the pool for any flashes of token0/token1\r\n   * @param sender The address that initiated the swap call, and that received the callback\r\n   * @param recipient The address that received the tokens from flash\r\n   * @param amount0 The amount of token0 that was flashed\r\n   * @param amount1 The amount of token1 that was flashed\r\n   * @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\r\n   * @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\r\n   */\r\n  event Flash(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1);\r\n\r\n  /**\r\n   * @notice Emitted when the community fee is changed by the pool\r\n   * @param communityFee0New The updated value of the token0 community fee percent\r\n   * @param communityFee1New The updated value of the token1 community fee percent\r\n   */\r\n  event CommunityFee(uint8 communityFee0New, uint8 communityFee1New);\r\n\r\n  /**\r\n   * @notice Emitted when new activeIncentive is set\r\n   * @param virtualPoolAddress The address of a virtual pool associated with the current active incentive\r\n   */\r\n  event Incentive(address indexed virtualPoolAddress);\r\n\r\n  /**\r\n   * @notice Emitted when the fee changes\r\n   * @param fee The value of the token fee\r\n   */\r\n  event Fee(uint16 fee);\r\n\r\n  /**\r\n   * @notice Emitted when the LiquidityCooldown changes\r\n   * @param liquidityCooldown The value of locktime for added liquidity\r\n   */\r\n  event LiquidityCooldown(uint32 liquidityCooldown);\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/core/pool/IAlgebraPoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\nimport '../IDataStorageOperator.sol';\r\n\r\n// @title Pool state that never changes\r\ninterface IAlgebraPoolImmutables {\r\n  /**\r\n   * @notice The contract that stores all the timepoints and can perform actions with them\r\n   * @return The operator address\r\n   */\r\n  function dataStorageOperator() external view returns (address);\r\n\r\n  /**\r\n   * @notice The contract that deployed the pool, which must adhere to the IAlgebraFactory interface\r\n   * @return The contract address\r\n   */\r\n  function factory() external view returns (address);\r\n\r\n  /**\r\n   * @notice The first of the two tokens of the pool, sorted by address\r\n   * @return The token contract address\r\n   */\r\n  function token0() external view returns (address);\r\n\r\n  /**\r\n   * @notice The second of the two tokens of the pool, sorted by address\r\n   * @return The token contract address\r\n   */\r\n  function token1() external view returns (address);\r\n\r\n  /**\r\n   * @notice The pool tick spacing\r\n   * @dev Ticks can only be used at multiples of this value\r\n   * e.g.: a tickSpacing of 60 means ticks can be initialized every 60th tick, i.e., ..., -120, -60, 0, 60, 120, ...\r\n   * This value is an int24 to avoid casting even though it is always positive.\r\n   * @return The tick spacing\r\n   */\r\n  function tickSpacing() external view returns (int24);\r\n\r\n  /**\r\n   * @notice The maximum amount of position liquidity that can use any tick in the range\r\n   * @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\r\n   * also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\r\n   * @return The max amount of liquidity per tick\r\n   */\r\n  function maxLiquidityPerTick() external view returns (uint128);\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/core/pool/IAlgebraPoolPermissionedActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @title Permissioned pool actions\r\n * @notice Contains pool methods that may only be called by the factory owner or tokenomics\r\n */\r\ninterface IAlgebraPoolPermissionedActions {\r\n  /**\r\n   * @notice Set the community's % share of the fees. Cannot exceed 25% (250)\r\n   * @param communityFee0 new community fee percent for token0 of the pool in thousandths (1e-3)\r\n   * @param communityFee1 new community fee percent for token1 of the pool in thousandths (1e-3)\r\n   */\r\n  function setCommunityFee(uint8 communityFee0, uint8 communityFee1) external;\r\n\r\n  /**\r\n   * @notice Sets an active incentive\r\n   * @param virtualPoolAddress The address of a virtual pool associated with the incentive\r\n   */\r\n  function setIncentive(address virtualPoolAddress) external;\r\n\r\n  /**\r\n   * @notice Sets new lock time for added liquidity\r\n   * @param newLiquidityCooldown The time in seconds\r\n   */\r\n  function setLiquidityCooldown(uint32 newLiquidityCooldown) external;\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/core/pool/IAlgebraPoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.5.0;\r\n\r\n// @title Pool state that can change\r\ninterface IAlgebraPoolState {\r\n  /**\r\n   * @notice The globalState structure in the pool stores many values but requires only one slot\r\n   * and is exposed as a single method to save gas when accessed externally.\r\n   * @return price The current price of the pool as a sqrt(token1/token0) Q64.96 value\r\n   * @return tick The current tick of the pool, i.e. according to the last tick transition that was run.\r\n   * This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick\r\n   * boundary.\r\n   * @return fee The last pool fee value in hundredths of a bip, i.e. 1e-6\r\n   * @return timepointIndex The index of the last written timepoint\r\n   * @return communityFeeToken0 The community fee percentage of the swap fee in thousandths (1e-3) for token0\r\n   * @return communityFeeToken1 The community fee percentage of the swap fee in thousandths (1e-3) for token1\r\n   * @return unlocked Whether the pool is currently locked to reentrancy\r\n   */\r\n  function globalState()\r\n    external\r\n    view\r\n    returns (\r\n      uint160 price,\r\n      int24 tick,\r\n      uint16 fee,\r\n      uint16 timepointIndex,\r\n      uint8 communityFeeToken0,\r\n      uint8 communityFeeToken1,\r\n      bool unlocked\r\n    );\r\n\r\n  /**\r\n   * @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\r\n   * @dev This value can overflow the uint256\r\n   */\r\n  function totalFeeGrowth0Token() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\r\n   * @dev This value can overflow the uint256\r\n   */\r\n  function totalFeeGrowth1Token() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice The currently in range liquidity available to the pool\r\n   * @dev This value has no relationship to the total liquidity across all ticks.\r\n   * Returned value cannot exceed type(uint128).max\r\n   */\r\n  function liquidity() external view returns (uint128);\r\n\r\n  /**\r\n   * @notice Look up information about a specific tick in the pool\r\n   * @param tick The tick to look up\r\n   * @return liquidityTotal the total amount of position liquidity that uses the pool either as tick lower or\r\n   * tick upper\r\n   * @return liquidityDelta how much liquidity changes when the pool price crosses the tick\r\n   * @return outerFeeGrowth0Token the fee growth on the other side of the tick from the current tick in token0\r\n   * @return outerFeeGrowth1Token the fee growth on the other side of the tick from the current tick in token1\r\n   * @return outerTickCumulative the cumulative tick value on the other side of the tick from the current tick\r\n   * @return outerSecondsPerLiquidity the seconds spent per liquidity on the other side of the tick from the current tick\r\n   * @return outerSecondsSpent the seconds spent on the other side of the tick from the current tick\r\n   * @return initialized Set to true if the tick is initialized, i.e. liquidityTotal is greater than 0\r\n   * otherwise equal to false. Outside values can only be used if the tick is initialized.\r\n   * In addition, these values are only relative and must be used only in comparison to previous snapshots for\r\n   * a specific position.\r\n   */\r\n  function ticks(int24 tick)\r\n    external\r\n    view\r\n    returns (\r\n      uint128 liquidityTotal,\r\n      int128 liquidityDelta,\r\n      uint256 outerFeeGrowth0Token,\r\n      uint256 outerFeeGrowth1Token,\r\n      int56 outerTickCumulative,\r\n      uint160 outerSecondsPerLiquidity,\r\n      uint32 outerSecondsSpent,\r\n      bool initialized\r\n    );\r\n\r\n  /** @notice Returns 256 packed tick initialized boolean values. See TickTable for more information */\r\n  function tickTable(int16 wordPosition) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Returns the information about a position by the position's key\r\n   * @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\r\n   * @return liquidityAmount The amount of liquidity in the position,\r\n   * lastLiquidityAddTimestamp Timestamp of last adding of liquidity,\r\n   * innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke,\r\n   * innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke,\r\n   * fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke,\r\n   * fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\r\n   */\r\n  function positions(bytes32 key)\r\n    external\r\n    view\r\n    returns (\r\n      uint128 liquidityAmount,\r\n      uint32 lastLiquidityAddTimestamp,\r\n      uint256 innerFeeGrowth0Token,\r\n      uint256 innerFeeGrowth1Token,\r\n      uint128 fees0,\r\n      uint128 fees1\r\n    );\r\n\r\n  /**\r\n   * @notice Returns data about a specific timepoint index\r\n   * @param index The element of the timepoints array to fetch\r\n   * @dev You most likely want to use #getTimepoints() instead of this method to get an timepoint as of some amount of time\r\n   * ago, rather than at a specific index in the array.\r\n   * @return initialized whether the timepoint has been initialized and the values are safe to use\r\n   * @return blockTimestamp The timestamp of the timepoint\r\n   * @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp\r\n   * @return secondsPerLiquidityCumulative the seconds per in range liquidity for the life of the pool as of the timepoint timestamp\r\n   * @return volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp\r\n   * @return averageTick Time-weighted average tick\r\n   * @return volumePerLiquidityCumulative Cumulative swap volume per liquidity for the life of the pool as of the timepoint timestamp\r\n   */\r\n  function timepoints(uint256 index)\r\n    external\r\n    view\r\n    returns (\r\n      bool initialized,\r\n      uint32 blockTimestamp,\r\n      int56 tickCumulative,\r\n      uint160 secondsPerLiquidityCumulative,\r\n      uint88 volatilityCumulative,\r\n      int24 averageTick,\r\n      uint144 volumePerLiquidityCumulative\r\n    );\r\n\r\n  /**\r\n   * @notice Returns the information about active incentive\r\n   * @dev if there is no active incentive at the moment, virtualPool,endTimestamp,startTimestamp would be equal to 0\r\n   * @return virtualPool The address of a virtual pool associated with the current active incentive\r\n   */\r\n  function activeIncentive() external view returns (address virtualPool);\r\n\r\n  /**\r\n   * @notice Returns the lock time for added liquidity\r\n   */\r\n  function liquidityCooldown() external view returns (uint32 cooldownInSeconds);\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/periphery/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n/// @title Quoter Interface\r\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\r\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\r\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\r\ninterface IQuoter {\r\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair\r\n    /// @param amountIn The amount of the first token to swap\r\n    /// @return amountOut The amount of the last token that would be received\r\n    function quoteExactInput(bytes memory path, uint256 amountIn)\r\n        external\r\n        returns (uint256 amountOut, uint16[] memory fees);\r\n\r\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\r\n    /// @param tokenIn The token being swapped in\r\n    /// @param tokenOut The token being swapped out\r\n    /// @param amountIn The desired input amount\r\n    /// @param limitSqrtPrice The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountOut The amount of `tokenOut` that would be received\r\n    function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint160 limitSqrtPrice\r\n    ) external returns (uint256 amountOut, uint16 fee);\r\n\r\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair. Path must be provided in reverse order\r\n    /// @param amountOut The amount of the last token to receive\r\n    /// @return amountIn The amount of first token required to be paid\r\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\r\n        external\r\n        returns (uint256 amountIn, uint16[] memory fees);\r\n\r\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\r\n    /// @param tokenIn The token being swapped in\r\n    /// @param tokenOut The token being swapped out\r\n    /// @param amountOut The desired output amount\r\n    /// @param limitSqrtPrice The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\r\n    function quoteExactOutputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountOut,\r\n        uint160 limitSqrtPrice\r\n    ) external returns (uint256 amountIn, uint16 fee);\r\n}\r\n"
    },
    "@cryptoalgebra/solidity-interfaces/contracts/periphery/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\nimport '../core/callback/IAlgebraSwapCallback.sol';\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Algebra\r\ninterface ISwapRouter is IAlgebraSwapCallback {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 limitSqrtPrice;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 limitSqrtPrice;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @dev Unlike standard swaps, handles transferring from user before the actual swap.\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingleSupportingFeeOnTransferTokens(ExactInputSingleParams calldata params)\r\n        external\r\n        returns (uint256 amountOut);\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../token/ERC721/IERC721Receiver.sol\";\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl, IERC721Receiver, IERC1155Receiver {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\n     */\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _setupRole(TIMELOCK_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, AccessControl) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to become valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@uniswap/swap-router-contracts/contracts/interfaces/IImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IImmutableState {\n    /// @return Returns the address of the Uniswap V2 factory\n    function factoryV2() external view returns (address);\n\n    /// @return Returns the address of Uniswap V3 NFT position manager\n    function positionManager() external view returns (address);\n}\n"
    },
    "@uniswap/swap-router-contracts/contracts/interfaces/IMixedRouteQuoterV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title MixedRouteQuoterV1 Interface\n/// @notice Supports quoting the calculated amounts for exact input swaps. Is specialized for routes containing a mix of V2 and V3 liquidity.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IMixedRouteQuoterV1 {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    /// @return v3SqrtPriceX96AfterList List of the sqrt price after the swap for each v3 pool in the path, 0 for v2 pools\n    /// @return v3InitializedTicksCrossedList List of the initialized ticks that the swap crossed for each v3 pool in the path, 0 for v2 pools\n    /// @return v3SwapGasEstimate The estimate of the gas that the v3 swaps in the path consume\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory v3SqrtPriceX96AfterList,\n            uint32[] memory v3InitializedTicksCrossedList,\n            uint256 v3SwapGasEstimate\n        );\n\n    struct QuoteExactInputSingleV3Params {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct QuoteExactInputSingleV2Params {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// fee The fee of the token pool to consider for the pair\n    /// amountIn The desired input amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInputSingleV3(QuoteExactInputSingleV3Params memory params)\n        external\n        returns (\n            uint256 amountOut,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single V2 pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleV2Params`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// amountIn The desired input amount\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingleV2(QuoteExactInputSingleV2Params memory params) external returns (uint256 amountOut);\n\n    /// @dev ExactOutput swaps are not supported by this new Quoter which is specialized for supporting routes\n    ///      crossing both V2 liquidity pairs and V3 pools.\n    /// @deprecated quoteExactOutputSingle and exactOutput. Use QuoterV2 instead.\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (address);\n\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (address);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Quoter Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoter {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountIn The desired input amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountOut The desired output amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/ActivityRewardDistributor/ActivityRewardDistributor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport \"./ActivityRewardDistributorStorage.sol\";\nimport {MEDIUM_TIMELOCK_ADMIN, BIG_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN, SECONDS_PER_DAY} from \"../Constants.sol\";\nimport {IActivityRewardDistributor, IBucket, IPausable} from \"./IActivityRewardDistributor.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {ITreasury} from \"../Treasury/ITreasury.sol\";\n\ncontract ActivityRewardDistributor is IActivityRewardDistributor, ActivityRewardDistributorStorage {\n    using WadRayMath for uint256;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    modifier notBlackListed() {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function initialize(\n        IERC20 _pmx,\n        IPrimexDNS _dns,\n        address _registry,\n        address _treasury,\n        ITraderBalanceVault _traderBalanceVault,\n        IWhiteBlackList _whiteBlackList\n    ) external override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(address(_dns)).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165Upgradeable(address(_traderBalanceVault)).supportsInterface(\n                    type(ITraderBalanceVault).interfaceId\n                ) &&\n                IERC165Upgradeable(address(_pmx)).supportsInterface(type(IERC20).interfaceId) &&\n                IERC165Upgradeable(address(_whiteBlackList)).supportsInterface(type(IWhiteBlackList).interfaceId) &&\n                IERC165Upgradeable(_treasury).supportsInterface(type(ITreasury).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        whiteBlackList = _whiteBlackList;\n        registry = _registry;\n        dns = _dns;\n        pmx = _pmx;\n        traderBalanceVault = _traderBalanceVault;\n        treasury = _treasury;\n        __ReentrancyGuard_init();\n        __Pausable_init();\n        __ERC165_init();\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function claimReward(\n        BucketWithRole[] calldata bucketsArray\n    ) external override nonReentrant whenNotPaused notBlackListed {\n        uint256 totalReward;\n\n        for (uint256 i; i < bucketsArray.length; i++) {\n            BucketInfo storage bucketInfo = buckets[bucketsArray[i].bucketAddress][uint256(bucketsArray[i].role)];\n            _require(bucketInfo.totalReward > 0, Errors.TOTAL_REWARD_AMOUNT_IS_ZERO.selector);\n            UserInfo storage userInfo = bucketInfo.users[msg.sender];\n            uint256 reward = userInfo.fixedReward;\n            if (userInfo.oldBalance != 0) {\n                if (!bucketInfo.isFinished) {\n                    uint256 timestamp = block.timestamp;\n                    // there is no need to check that \"rewardPerToken\" is 0 and raise \"endTimestamp\",\n                    // because \"rewardPerToken\" is 0 can be in two cases.\n                    // The first case is when all funds are withdrawn from the bucket,\n                    // but in this case \"userInfo.oldBalance != 0\" check will work,\n                    // The second case is when rewardPerDay is set to 0, but then bucketInfo.endTimestamp = type(uint256).max\n                    if (timestamp >= bucketInfo.endTimestamp) {\n                        bucketInfo.isFinished = true;\n                        timestamp = bucketInfo.endTimestamp;\n                    }\n                    bucketInfo.rewardIndex += _accumulatedRewardIndex(\n                        bucketInfo.rewardPerToken,\n                        timestamp,\n                        bucketInfo.lastUpdatedTimestamp\n                    );\n                    bucketInfo.lastUpdatedTimestamp = timestamp;\n                }\n\n                reward += _calculateUserAccumulatedReward(\n                    userInfo.oldBalance,\n                    bucketInfo.rewardIndex,\n                    userInfo.lastUpdatedRewardIndex\n                );\n                userInfo.lastUpdatedRewardIndex = bucketInfo.rewardIndex;\n            }\n            _require(reward > 0, Errors.REWARD_AMOUNT_IS_ZERO.selector);\n\n            totalReward += reward;\n\n            delete userInfo.fixedReward;\n            emit ClaimReward(msg.sender, bucketsArray[i].bucketAddress, bucketsArray[i].role, reward);\n        }\n\n        pmx.transfer(address(traderBalanceVault), totalReward);\n        traderBalanceVault.topUpAvailableBalance(msg.sender, address(pmx), totalReward);\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function setupBucket(\n        address bucket,\n        Role role,\n        uint256 increaseAmount,\n        uint256 rewardPerDay\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        BucketInfo storage bucketInfo = buckets[bucket][uint256(role)];\n        uint256 fixedReward = getBucketAccumulatedReward(bucket, role);\n        if (bucketInfo.rewardPerDay != rewardPerDay) {\n            bucketInfo.fixedReward = fixedReward;\n            uint256 timestamp = bucketInfo.totalReward > fixedReward ? block.timestamp : bucketInfo.endTimestamp;\n            bucketInfo.rewardIndex += _accumulatedRewardIndex(\n                bucketInfo.rewardPerToken,\n                timestamp,\n                bucketInfo.lastUpdatedTimestamp\n            );\n            bucketInfo.lastUpdatedTimestamp = block.timestamp;\n            bucketInfo.rewardPerDay = rewardPerDay;\n            bucketInfo.rewardPerToken = _calculateRewardPerToken(rewardPerDay, bucketInfo.scaledTotalSupply);\n            bucketInfo.lastUpdatedRewardTimestamp = block.timestamp;\n        }\n\n        if (increaseAmount > 0) {\n            if (bucketInfo.totalReward == fixedReward) {\n                bucketInfo.lastUpdatedTimestamp = block.timestamp;\n                bucketInfo.fixedReward = fixedReward;\n                bucketInfo.lastUpdatedRewardTimestamp = block.timestamp;\n                bucketInfo.isFinished = false;\n            }\n\n            bucketInfo.totalReward += increaseAmount;\n            pmx.transferFrom(msg.sender, address(this), increaseAmount);\n        }\n\n        bucketInfo.endTimestamp = bucketInfo.rewardPerDay == 0\n            ? type(uint256).max\n            : block.timestamp +\n                ((bucketInfo.totalReward - bucketInfo.fixedReward) * SECONDS_PER_DAY) /\n                bucketInfo.rewardPerDay;\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function decreaseRewardPerDay(\n        address bucket,\n        Role role,\n        uint256 rewardPerDay\n    ) external override onlyRole(EMERGENCY_ADMIN) {\n        BucketInfo storage bucketInfo = buckets[bucket][uint256(role)];\n        _require(rewardPerDay < bucketInfo.rewardPerDay, Errors.REWARD_PER_DAY_IS_NOT_CORRECT.selector);\n\n        bucketInfo.fixedReward = getBucketAccumulatedReward(bucket, role);\n        uint256 timestamp = bucketInfo.totalReward > bucketInfo.fixedReward ? block.timestamp : bucketInfo.endTimestamp;\n        bucketInfo.rewardIndex += _accumulatedRewardIndex(\n            bucketInfo.rewardPerToken,\n            timestamp,\n            bucketInfo.lastUpdatedTimestamp\n        );\n        bucketInfo.lastUpdatedTimestamp = block.timestamp;\n        bucketInfo.rewardPerDay = rewardPerDay;\n        bucketInfo.rewardPerToken = _calculateRewardPerToken(rewardPerDay, bucketInfo.scaledTotalSupply);\n        bucketInfo.lastUpdatedRewardTimestamp = block.timestamp;\n        bucketInfo.endTimestamp = rewardPerDay == 0\n            ? type(uint256).max\n            : block.timestamp +\n                ((bucketInfo.totalReward - bucketInfo.fixedReward) * SECONDS_PER_DAY) /\n                bucketInfo.rewardPerDay;\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function withdrawPmx(address bucket, Role role, uint256 amount) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        BucketInfo storage bucketInfo = buckets[bucket][uint256(role)];\n        uint256 fixedReward = getBucketAccumulatedReward(bucket, role);\n        _require(bucketInfo.totalReward - fixedReward >= amount, Errors.AMOUNT_EXCEEDS_AVAILABLE_BALANCE.selector);\n        bucketInfo.totalReward -= amount;\n        bucketInfo.endTimestamp = bucketInfo.rewardPerDay == 0\n            ? type(uint256).max\n            : block.timestamp + ((bucketInfo.totalReward - fixedReward) * SECONDS_PER_DAY) / bucketInfo.rewardPerDay;\n        IERC20(pmx).transfer(treasury, amount);\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function updateUserActivity(IBucket bucket, address user, uint256 newBalance, Role role) public override {\n        (address bucketAddress, , , ) = dns.buckets(bucket.name());\n        _require(bucketAddress != address(0), Errors.ZERO_BUCKET_ADDRESS.selector);\n        _require(msg.sender == _getToken(bucketAddress, role), Errors.FORBIDDEN.selector);\n\n        BucketInfo storage bucketInfo = buckets[bucketAddress][uint256(role)];\n        if (bucketInfo.totalReward == 0 || bucketInfo.isFinished || bucketInfo.rewardPerDay == 0) return;\n\n        address[] memory users = new address[](1);\n        users[0] = user;\n        uint256[] memory newBalances = new uint256[](1);\n        newBalances[0] = newBalance;\n        _updateBucketInfo(bucketInfo, users, newBalances, 1, true);\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function updateUsersActivities(\n        IBucket bucket,\n        address[] calldata users,\n        uint256[] calldata newBalances,\n        uint256 length,\n        Role role\n    ) public override {\n        (address bucketAddress, , , ) = dns.buckets(bucket.name());\n        _require(msg.sender == _getToken(bucketAddress, role), Errors.FORBIDDEN.selector);\n\n        BucketInfo storage bucketInfo = buckets[bucketAddress][uint256(role)];\n        if (bucketInfo.totalReward == 0 || bucketInfo.isFinished || bucketInfo.rewardPerDay == 0) return;\n        _updateBucketInfo(bucketInfo, users, newBalances, length, role == Role.TRADER);\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function getBucketAccumulatedReward(address bucket, Role role) public view override returns (uint256) {\n        BucketInfo storage currentBucket = buckets[bucket][uint256(role)];\n        if (currentBucket.lastUpdatedRewardTimestamp == 0) return 0;\n\n        uint256 lastUpdatedRewardTimestamp = currentBucket.lastUpdatedRewardTimestamp;\n        uint256 endTimestamp = currentBucket.endTimestamp;\n\n        if (currentBucket.rewardPerToken == 0) {\n            uint256 unusedTime = block.timestamp - currentBucket.lastUpdatedTimestamp;\n            lastUpdatedRewardTimestamp += unusedTime;\n            if (endTimestamp != type(uint256).max) {\n                endTimestamp += unusedTime;\n            }\n        }\n        if (block.timestamp >= endTimestamp) return currentBucket.totalReward;\n\n        return\n            currentBucket.fixedReward +\n            ((block.timestamp - lastUpdatedRewardTimestamp) * currentBucket.rewardPerDay) /\n            SECONDS_PER_DAY;\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function getClaimableReward(\n        BucketWithRole[] calldata bucketsArray,\n        address user\n    ) public view override returns (uint256) {\n        uint256 reward;\n        for (uint256 i; i < bucketsArray.length; i++) {\n            BucketInfo storage bucketInfo = buckets[bucketsArray[i].bucketAddress][uint256(bucketsArray[i].role)];\n            if (bucketInfo.totalReward == 0) continue;\n\n            UserInfo storage userInfo = bucketInfo.users[user];\n            if (userInfo.oldBalance == 0) {\n                reward += userInfo.fixedReward;\n                continue;\n            }\n\n            uint256 rewardIndex = bucketInfo.rewardIndex;\n            if (!bucketInfo.isFinished) {\n                uint256 timestamp = block.timestamp;\n                if (timestamp >= bucketInfo.endTimestamp) {\n                    timestamp = bucketInfo.endTimestamp;\n                }\n                rewardIndex += _accumulatedRewardIndex(\n                    bucketInfo.rewardPerToken,\n                    timestamp,\n                    bucketInfo.lastUpdatedTimestamp\n                );\n            }\n            reward += (userInfo.fixedReward +\n                _calculateUserAccumulatedReward(userInfo.oldBalance, rewardIndex, userInfo.lastUpdatedRewardIndex));\n        }\n        return reward;\n    }\n\n    /**\n     * @inheritdoc IActivityRewardDistributor\n     */\n    function getUserInfoFromBucket(\n        address bucket,\n        Role role,\n        address user\n    ) public view override returns (UserInfo memory) {\n        return buckets[bucket][uint256(role)].users[user];\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\n        return _interfaceId == type(IActivityRewardDistributor).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Updates information in UserInfo struct\n     * @param bucketInfo  The storage reference to BucketInfo struct\n     * @param user  User address\n     * @param newBalance  User balance of PToken or DebtToken after action\n     */\n    function _fixUserReward(BucketInfo storage bucketInfo, address user, uint256 newBalance) internal {\n        UserInfo storage userInfo = bucketInfo.users[user];\n        userInfo.fixedReward += _calculateUserAccumulatedReward(\n            userInfo.oldBalance,\n            bucketInfo.rewardIndex,\n            userInfo.lastUpdatedRewardIndex\n        );\n        userInfo.lastUpdatedRewardIndex = bucketInfo.rewardIndex;\n        userInfo.oldBalance = newBalance;\n    }\n\n    /**\n     * @notice Updates BucketInfo struct\n     * @param bucketInfo  The storage reference to BucketInfo struct\n     * @param needUpdateRPT  Scaled totalSupply of PToken or DebtToken\n     */\n    function _updateBucketInfo(\n        BucketInfo storage bucketInfo,\n        address[] memory users,\n        uint256[] memory newBalances,\n        uint256 length,\n        bool needUpdateRPT\n    ) internal {\n        uint256 timestamp = block.timestamp;\n        if (bucketInfo.rewardPerToken == 0) {\n            uint256 unusedTime = timestamp - bucketInfo.lastUpdatedTimestamp;\n            bucketInfo.endTimestamp += unusedTime;\n            bucketInfo.lastUpdatedRewardTimestamp += unusedTime;\n        } else {\n            if (timestamp >= bucketInfo.endTimestamp) {\n                bucketInfo.isFinished = true;\n                timestamp = bucketInfo.endTimestamp;\n            }\n            bucketInfo.rewardIndex += _accumulatedRewardIndex(\n                bucketInfo.rewardPerToken,\n                timestamp,\n                bucketInfo.lastUpdatedTimestamp\n            );\n        }\n        bucketInfo.lastUpdatedTimestamp = timestamp;\n        if (needUpdateRPT) {\n            for (uint256 i; i < length; i++) {\n                bucketInfo.scaledTotalSupply =\n                    bucketInfo.scaledTotalSupply +\n                    newBalances[i] -\n                    bucketInfo.users[users[i]].oldBalance;\n                _fixUserReward(bucketInfo, users[i], newBalances[i]);\n            }\n            bucketInfo.rewardPerToken = _calculateRewardPerToken(bucketInfo.rewardPerDay, bucketInfo.scaledTotalSupply);\n        } else {\n            for (uint256 i; i < length; i++) {\n                _fixUserReward(bucketInfo, users[i], newBalances[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the token address for a specific bucket and role.\n     * @param bucket The address of the bucket for which to retrieve the token.\n     * @param role The role associated with the user\n     * @return tokenAddress The address of the token\n     */\n    function _getToken(address bucket, Role role) internal view returns (address tokenAddress) {\n        if (role == Role.LENDER) {\n            tokenAddress = address(IBucket(bucket).pToken());\n        } else {\n            tokenAddress = address(IBucket(bucket).debtToken());\n        }\n    }\n\n    /**\n     * @notice Calculates reward in PMX per token\n     * @dev decimals of rewardPerDay is 18 (PMX decimals)\n     * X - decimality of the token whose scaledTotalSupply\n     * decimals of output is 18+18(from WadRayMath wdiv) - X\n     * @param rewardPerDay  Current reward in PMX per day\n     * @param scaledTotalSupply  Scaled totalSupply of PToken or DebtToken\n     * @return uint256  reward in PMX per token\n     */\n    function _calculateRewardPerToken(uint256 rewardPerDay, uint256 scaledTotalSupply) internal pure returns (uint256) {\n        // wdiv without rounding up\n        return scaledTotalSupply == 0 ? 0 : ((rewardPerDay / SECONDS_PER_DAY) * WadRayMath.WAD) / (scaledTotalSupply);\n    }\n\n    /**\n     * @notice Calculates rewardIndex for specific rewardPerToken and timestamps\n     * @dev decimals of output is decimals of _calculateRewardPerToken output\n     * @param rewardPerToken  Current reward in PMX per token\n     * @param currentTimestamp  Current timestamp of the block\n     * @param bucketLastUpdatedTimestamp  Last updated timestamp\n     * @return uint256  Calculated rewardIndex\n     */\n    function _accumulatedRewardIndex(\n        uint256 rewardPerToken,\n        uint256 currentTimestamp,\n        uint256 bucketLastUpdatedTimestamp\n    ) internal pure returns (uint256) {\n        return rewardPerToken * (currentTimestamp - bucketLastUpdatedTimestamp);\n    }\n\n    /**\n     * @notice Calculates the accumulated reward for a user based on their old balance, new rewardIndex, and old rewardIndex.\n     * @dev decimals of output is decimals of _accumulatedRewardIndex output + X - 18(from WadRayMath wmul)\n     * decimals of output is (18+18-X)+X-18 = 18 PMX decimals\n     * @param _oldBalance The user's previous balance.\n     * @param _newRewardIndex The new reward index.\n     * @param _oldRewardIndex The old reward index.\n     * @return The accumulated reward for the user.\n     */\n    function _calculateUserAccumulatedReward(\n        uint256 _oldBalance,\n        uint256 _newRewardIndex,\n        uint256 _oldRewardIndex\n    ) internal pure returns (uint256) {\n        // wmul without rounding up\n        return (_oldBalance * (_newRewardIndex - _oldRewardIndex)) / WadRayMath.WAD;\n    }\n}\n"
    },
    "contracts/ActivityRewardDistributor/ActivityRewardDistributorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport {IActivityRewardDistributorStorage, IERC20, IPrimexDNS, ITraderBalanceVault} from \"./IActivityRewardDistributorStorage.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\n\nabstract contract ActivityRewardDistributorStorage is\n    IActivityRewardDistributorStorage,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    ERC165Upgradeable\n{\n    IERC20 public override pmx;\n    IPrimexDNS public override dns;\n    address public override registry;\n    address public override treasury;\n    ITraderBalanceVault public override traderBalanceVault;\n    mapping(address => BucketInfo[2]) public buckets;\n    IWhiteBlackList internal whiteBlackList;\n}\n"
    },
    "contracts/ActivityRewardDistributor/IActivityRewardDistributor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IActivityRewardDistributorStorage, IERC20, IPrimexDNS, ITraderBalanceVault} from \"./IActivityRewardDistributorStorage.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface IActivityRewardDistributor is IActivityRewardDistributorStorage, IPausable {\n    enum Role {\n        LENDER,\n        TRADER\n    }\n\n    struct BucketWithRole {\n        address bucketAddress;\n        Role role;\n    }\n\n    /**\n     * @notice Emitted on claimReward()\n     * @param user The address of the user who claimed reward\n     * @param bucket The address of the bucket this reward is related to\n     * @param role User role - TRADER or LENDER\n     * @param amount Claimed amount\n     */\n    event ClaimReward(address indexed user, address indexed bucket, Role indexed role, uint256 amount);\n\n    /**\n     * @notice  Initializes the ActivityRewardDistributor contract.\n     * @dev This function should only be called once during the initial setup of the contract.\n     * @param _pmx The address of the PMXToken contract.\n     * @param _dns The address of the PrimexDNS contract.\n     * @param _registry The address of the PrimexRegistry contract.\n     * @param _treasury The address of the treasury where fees will be collected.\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\n     */\n    function initialize(\n        IERC20 _pmx,\n        IPrimexDNS _dns,\n        address _registry,\n        address _treasury,\n        ITraderBalanceVault _traderBalanceVault,\n        IWhiteBlackList _whiteBlackList\n    ) external;\n\n    /**\n     * @notice  Saves user activity in the protocol for reward calculation\n     * @param   bucket  The address of the bucket\n     * @param   user  User address\n     * @param   newBalance  User balance after action\n     * @param   role  User role - TRADER or LENDER\n     */\n    function updateUserActivity(IBucket bucket, address user, uint256 newBalance, Role role) external;\n\n    /**\n     * @notice  Saves activity of multiple users in the protocol for reward calculation\n     * @param   bucket  The address of the bucket\n     * @param   users  Array of user addresses\n     * @param   newBalances  Array of users balances after action\n     * @param   length  The length of the users and oldBalances arrays\n     * @param   role  User role - TRADER or LENDER\n     */\n    function updateUsersActivities(\n        IBucket bucket,\n        address[] calldata users,\n        uint256[] calldata newBalances,\n        uint256 length,\n        Role role\n    ) external;\n\n    /**\n     * @notice Allows the caller to claim their accumulated reward from the specified buckets.\n     * @param bucketsArray The array of BucketWithRole objects containing the buckets from which to claim the rewards.\n     */\n    function claimReward(BucketWithRole[] calldata bucketsArray) external;\n\n    /**\n     * @notice Sets up activity rewards distribution in bucket with the specified role and reward parameters.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param bucket The address of the bucket to set up.\n     * @param role The role associated with the bucket.\n     * @param increaseAmount The amount by which to increase the total reward for the bucket (in PMX).\n     * Adds specified amount to totalReward of the bucket. Initial value of totalReward is 0.\n     * @param rewardPerDay The reward amount per day for the bucket.\n     */\n    function setupBucket(address bucket, Role role, uint256 increaseAmount, uint256 rewardPerDay) external;\n\n    /**\n     * @notice Allows the caller to withdraw PMX tokens from a specific bucket.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param bucket The address of the bucket from which to withdraw PMX tokens.\n     * @param role The role associated with the bucket.\n     * @param amount The amount of PMX tokens to withdraw.\n     */\n    function withdrawPmx(address bucket, Role role, uint256 amount) external;\n\n    /**\n     * @notice Decreases the reward per day for a bucket and role.\n     * @dev Only callable by the EMERGENCY_ADMIN role.\n     * @param bucket The address of the bucket for which to decrease the reward per day.\n     * @param role The role associated with the bucket.\n     * @param rewardPerDay The amount by which to decrease the reward per day.\n     */\n    function decreaseRewardPerDay(address bucket, Role role, uint256 rewardPerDay) external;\n\n    /**\n     * @notice Returns the accumulated reward for a specific bucket and role.\n     * @param bucket The address of the bucket for which to retrieve the accumulated reward.\n     * @param role The role associated with the bucket.\n     * @return The accumulated reward for the specified bucket and role.\n     */\n    function getBucketAccumulatedReward(address bucket, Role role) external view returns (uint256);\n\n    /**\n     * @notice Returns the claimable reward for a user across multiple buckets.\n     * @param bucketsArray The array of BucketWithRole objects containing the buckets to check for claimable rewards.\n     * @param user The address of the user for whom to calculate the claimable reward.\n     * @return The total claimable reward for the specified user across all provided buckets.\n     */\n    function getClaimableReward(BucketWithRole[] calldata bucketsArray, address user) external view returns (uint256);\n\n    /**\n     * @notice Retrieves the user information from a specific bucket and role.\n     * @param bucket The address of the bucket from which to retrieve the user information.\n     * @param role The role associated with the bucket.\n     * @param user The address of the user for whom to retrieve the information.\n     * @return A UserInfo struct containing the user information.\n     */\n    function getUserInfoFromBucket(address bucket, Role role, address user) external view returns (UserInfo memory);\n}\n"
    },
    "contracts/ActivityRewardDistributor/IActivityRewardDistributorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\n\ninterface IActivityRewardDistributorStorage {\n    /*\n     * @param oldBalance last updated balance for user\n     * @param fixedReward the accumulated value of the reward at the time lastUpdatedRewardIndex\n     * @param lastUpdatedRewardIndex last index with which the user's reward was accumulated\n     */\n    struct UserInfo {\n        uint256 fixedReward;\n        uint256 lastUpdatedRewardIndex;\n        uint256 oldBalance;\n    }\n\n    /*\n     * @param users data to calculate users rewards in this bucket\n     * @param rewardIndex an index that accumulates user rewards\n     * @param lastUpdatedTimestamp timestamp of the last update of user activity\n     * @param rewardPerToken current reward for one token(PToken or DebtToken of bucket)\n     * @param isFinished Shows that the bucket has distributed all the rewards\n     * @param fixedReward reward distributed by a bucket over the past period\n     * with a certain reward per day or with the entire reward fully distributed\n     * @param lastUpdatedRewardTimestamp timestamp of last fixed reward update\n     * @param rewardPerDay current reward distributed for 1 day\n     * @param totalReward Full distributable reward\n     * @param endTimestamp end time of the distribution of rewards, which is calculated relative to the rewardPerDay and totalReward\n     */\n    struct BucketInfo {\n        mapping(address => UserInfo) users;\n        //accumulated reward per token\n        uint256 rewardIndex;\n        uint256 lastUpdatedTimestamp;\n        uint256 rewardPerToken;\n        uint256 scaledTotalSupply;\n        bool isFinished;\n        // setted by admin's actions\n        uint256 fixedReward;\n        uint256 lastUpdatedRewardTimestamp;\n        uint256 rewardPerDay;\n        uint256 totalReward;\n        uint256 endTimestamp;\n    }\n\n    function pmx() external returns (IERC20);\n\n    function dns() external returns (IPrimexDNS);\n\n    function registry() external returns (address);\n\n    function traderBalanceVault() external returns (ITraderBalanceVault);\n\n    function treasury() external view returns (address);\n}\n"
    },
    "contracts/BatchManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {WadRayMath} from \"./libraries/utils/WadRayMath.sol\";\n\nimport {PositionLibrary} from \"./libraries/PositionLibrary.sol\";\nimport {LimitOrderLibrary} from \"./libraries/LimitOrderLibrary.sol\";\nimport {PrimexPricingLibrary} from \"./libraries/PrimexPricingLibrary.sol\";\nimport \"./libraries/Errors.sol\";\n\nimport {SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \"./Constants.sol\";\nimport {IPositionManager} from \"./PositionManager/IPositionManager.sol\";\nimport {IPriceOracle} from \"./PriceOracle/IPriceOracle.sol\";\nimport {ITakeProfitStopLossCCM} from \"./interfaces/ITakeProfitStopLossCCM.sol\";\nimport {ITraderBalanceVault} from \"./TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IBucket} from \"./Bucket/IBucket.sol\";\nimport {IBatchManager, IPausable} from \"./interfaces/IBatchManager.sol\";\nimport {IWhiteBlackList} from \"./WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IKeeperRewardDistributorStorage} from \"./KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\";\nimport {IKeeperRewardDistributor} from \"./KeeperRewardDistributor/IKeeperRewardDistributor.sol\";\n\ncontract BatchManager is IBatchManager, ReentrancyGuard, Pausable {\n    using WadRayMath for uint256;\n    using SafeCast for uint256;\n\n    IPositionManager public immutable override positionManager;\n    IPriceOracle public immutable override priceOracle;\n    IWhiteBlackList public immutable override whiteBlackList;\n    address public immutable override registry;\n\n    /**\n     * @dev Throws if caller is not granted with _role\n     * @param _role The role that is being checked for a function caller\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    modifier notBlackListed() {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n        _;\n    }\n\n    constructor(\n        IPositionManager _positionManager,\n        IPriceOracle _priceOracle,\n        IWhiteBlackList _whiteBlackList,\n        address _registry\n    ) {\n        _require(\n            IERC165Upgradeable(address(_positionManager)).supportsInterface(type(IPositionManager).interfaceId) &&\n                IERC165Upgradeable(address(_priceOracle)).supportsInterface(type(IPriceOracle).interfaceId) &&\n                IERC165Upgradeable(address(_whiteBlackList)).supportsInterface(type(IWhiteBlackList).interfaceId) &&\n                IERC165Upgradeable(address(_registry)).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        whiteBlackList = _whiteBlackList;\n        positionManager = _positionManager;\n        priceOracle = _priceOracle;\n        registry = _registry;\n    }\n\n    /**\n     * @inheritdoc IBatchManager\n     */\n    function closeBatchPositions(\n        uint256[] calldata _ids,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        address _positionAsset,\n        address _soldAsset,\n        IBucket _bucket,\n        uint256[] calldata _conditionIndexes,\n        PositionLibrary.CloseReason _closeReason\n    ) external override nonReentrant notBlackListed whenNotPaused {\n        uint256 initialGasleft = gasleft();\n        _require(_ids.length > 0, Errors.THERE_MUST_BE_AT_LEAST_ONE_POSITION.selector);\n        if (\n            _closeReason == PositionLibrary.CloseReason.BATCH_STOP_LOSS ||\n            _closeReason == PositionLibrary.CloseReason.BATCH_TAKE_PROFIT\n        ) {\n            _require(_ids.length == _conditionIndexes.length, Errors.PARAMS_LENGTH_MISMATCH.selector);\n        }\n\n        CloseBatchPositionsVars memory vars = CloseBatchPositionsVars({\n            ids: new uint256[](_ids.length),\n            traders: new address[](_ids.length),\n            positionAmounts: new uint256[](_ids.length),\n            debts: new uint256[](_ids.length),\n            depositsDecrease: new uint256[](_ids.length),\n            decreasingCounter: new uint256[](uint256(type(IKeeperRewardDistributorStorage.DecreasingReason).max) + 1),\n            actionType: IKeeperRewardDistributorStorage.KeeperActionType.OpenByOrder, //default value\n            numberOfPositions: 0,\n            oracleTolerableLimit: positionManager.getOracleTolerableLimit(_soldAsset, _positionAsset),\n            securityBuffer: positionManager.securityBuffer(),\n            positionManager: positionManager,\n            primexDNS: positionManager.primexDNS(),\n            priceOracle: priceOracle,\n            traderBalanceVault: positionManager.traderBalanceVault(),\n            pairPriceDrop: priceOracle.getPairPriceDrop(_positionAsset, _soldAsset),\n            closeConditions: new LimitOrderLibrary.Condition[](_ids.length),\n            borrowedAmountIsNotZero: address(_bucket) != address(0),\n            bucket: address(_bucket),\n            totalCloseAmount: 0,\n            uncoveredAmount: 0, // a position amount for which the keeper will NOT get the rewards.\n            totalDebt: 0,\n            adapter: address(0),\n            returnedToTraders: new uint256[](0),\n            amountToReturn: 0,\n            borrowedAssetAmountOut: 0,\n            normalizedVariableDebt: 0,\n            permanentLoss: 0,\n            shareOfBorrowedAssetAmount: new uint256[](0),\n            isLiquidation: false\n        });\n\n        if (vars.borrowedAmountIsNotZero) {\n            _require(address(_bucket.borrowedAsset()) == _soldAsset, Errors.ASSET_ADDRESS_NOT_SUPPORTED.selector);\n            vars.normalizedVariableDebt = _bucket.getNormalizedVariableDebt();\n        }\n\n        for (uint256 i; i < _ids.length; i++) {\n            PositionLibrary.Position memory position;\n            //This call can be revert if the id doesn't exist\n            try positionManager.getPosition(_ids[i]) returns (PositionLibrary.Position memory _position) {\n                position = _position;\n            } catch {\n                // сounter increase depending on closeReason\n                vars.decreasingCounter[\n                    uint8(\n                        _closeReason == PositionLibrary.CloseReason.BATCH_LIQUIDATION\n                            ? IKeeperRewardDistributorStorage.DecreasingReason.NonExistentIdForLiquidation\n                            : IKeeperRewardDistributorStorage.DecreasingReason.NonExistentIdForSLOrTP\n                    )\n                ]++;\n                continue;\n            }\n            if (!vars.borrowedAmountIsNotZero) {\n                _require(position.soldAsset == _soldAsset, Errors.SOLD_ASSET_IS_INCORRECT.selector);\n            }\n            _require(position.bucket == _bucket, Errors.POSITION_BUCKET_IS_INCORRECT.selector);\n            vars.ids[vars.numberOfPositions] = _ids[i];\n            _require(position.positionAsset == _positionAsset, Errors.ASSET_ADDRESS_NOT_SUPPORTED.selector);\n            vars.positionAmounts[vars.numberOfPositions] = position.positionAmount;\n            vars.debts[vars.numberOfPositions] = vars.borrowedAmountIsNotZero\n                ? position.scaledDebtAmount.rmul(vars.normalizedVariableDebt)\n                : 0;\n            vars.depositsDecrease[vars.numberOfPositions] = position.depositAmountInSoldAsset;\n            vars.traders[vars.numberOfPositions] = position.trader;\n            if (\n                _closeReason == PositionLibrary.CloseReason.BATCH_STOP_LOSS ||\n                _closeReason == PositionLibrary.CloseReason.BATCH_TAKE_PROFIT\n            ) {\n                vars.closeConditions[vars.numberOfPositions] = positionManager.getCloseCondition(\n                    _ids[i],\n                    _conditionIndexes[i]\n                );\n                // to avoid abuse of the reward system, we will not pay the reward to\n                // the keeper if the position closes in the same block as the close conditions change\n                if (position.updatedConditionsAt == block.timestamp) {\n                    vars.decreasingCounter[\n                        uint8(IKeeperRewardDistributorStorage.DecreasingReason.ClosePostionInTheSameBlock)\n                    ]++;\n                    vars.uncoveredAmount += vars.positionAmounts[vars.numberOfPositions];\n                }\n            }\n            vars.numberOfPositions++;\n        }\n\n        vars.adapter = vars.primexDNS.dexAdapter();\n\n        if (_closeReason == PositionLibrary.CloseReason.BATCH_LIQUIDATION) {\n            uint256 feeBuffer = _bucket.feeBuffer();\n            uint256[] memory borrowedAssetAmounts = PrimexPricingLibrary.getBatchOracleAmountsOut(\n                _positionAsset,\n                _soldAsset,\n                vars.positionAmounts,\n                address(vars.priceOracle)\n            );\n            for (uint256 i; i < vars.numberOfPositions; ) {\n                // if the current position is risky that's ok and we increase the counter,\n                // if not we have to check this index again because this will be the last position\n                if (\n                    vars.debts[i] > 0 &&\n                    PositionLibrary.health(\n                        borrowedAssetAmounts[i],\n                        vars.pairPriceDrop,\n                        vars.securityBuffer,\n                        vars.oracleTolerableLimit,\n                        vars.debts[i],\n                        feeBuffer\n                    ) <\n                    WadRayMath.WAD\n                ) {\n                    vars.totalCloseAmount += vars.positionAmounts[i];\n                    vars.totalDebt += vars.debts[i];\n                    unchecked {\n                        i++;\n                    }\n                } else {\n                    vars.decreasingCounter[\n                        uint8(IKeeperRewardDistributorStorage.DecreasingReason.IncorrectConditionForLiquidation)\n                    ]++;\n                    _removeBatchItem(vars, i);\n                }\n            }\n            vars.actionType = IKeeperRewardDistributorStorage.KeeperActionType.Liquidation;\n        } else if (_closeReason == PositionLibrary.CloseReason.BATCH_STOP_LOSS) {\n            (uint256 exchangeRate, bool isForward) = vars.priceOracle.getExchangeRate(_positionAsset, _soldAsset);\n            if (!isForward) exchangeRate = WadRayMath.WAD.wdiv(exchangeRate);\n            uint256 managerType = vars.closeConditions[0].managerType;\n            address cm = vars.primexDNS.cmTypeToAddress(managerType);\n            _require(\n                cm != address(0) && IERC165Upgradeable(cm).supportsInterface(type(ITakeProfitStopLossCCM).interfaceId),\n                Errors.CLOSE_CONDITION_IS_NOT_CORRECT.selector\n            );\n            LimitOrderLibrary.Condition memory condition;\n            for (uint256 i; i < vars.numberOfPositions; ) {\n                condition = vars.closeConditions[i];\n                if (\n                    condition.managerType == managerType &&\n                    ITakeProfitStopLossCCM(cm).isStopLossReached(condition.params, exchangeRate)\n                ) {\n                    vars.totalCloseAmount += vars.positionAmounts[i];\n                    vars.totalDebt += vars.debts[i];\n                    unchecked {\n                        i++;\n                    }\n                } else {\n                    vars.decreasingCounter[\n                        uint8(IKeeperRewardDistributorStorage.DecreasingReason.IncorrectConditionForSL)\n                    ]++;\n                    _removeBatchItem(vars, i);\n                }\n            }\n            vars.actionType = IKeeperRewardDistributorStorage.KeeperActionType.StopLoss;\n        } else if (_closeReason == PositionLibrary.CloseReason.BATCH_TAKE_PROFIT) {\n            for (uint256 i; i < vars.numberOfPositions; i++) {\n                vars.totalCloseAmount += vars.positionAmounts[i];\n                vars.totalDebt += vars.debts[i];\n            }\n            vars.actionType = IKeeperRewardDistributorStorage.KeeperActionType.TakeProfit;\n        } else if (_closeReason == PositionLibrary.CloseReason.BUCKET_DELISTED) {\n            _require(_bucket.isDelisted(), Errors.POSITION_CANNOT_BE_CLOSED_FOR_THIS_REASON.selector);\n            for (uint256 i; i < vars.numberOfPositions; i++) {\n                vars.totalCloseAmount += vars.positionAmounts[i];\n                vars.totalDebt += vars.debts[i];\n            }\n            vars.actionType = IKeeperRewardDistributorStorage.KeeperActionType.BucketDelisted;\n        } else {\n            _revert(Errors.BATCH_CANNOT_BE_CLOSED_FOR_THIS_REASON.selector);\n        }\n        _require(vars.numberOfPositions > 0, Errors.NOTHING_TO_CLOSE.selector);\n        vars.positionManager.doTransferOut(_positionAsset, vars.adapter, vars.totalCloseAmount);\n        // overwrite the previous variable from oracle\n        vars.borrowedAssetAmountOut = PrimexPricingLibrary.multiSwap(\n            PrimexPricingLibrary.MultiSwapParams({\n                tokenA: _positionAsset,\n                tokenB: _soldAsset,\n                amountTokenA: vars.totalCloseAmount,\n                routes: _routes,\n                dexAdapter: vars.adapter,\n                receiver: vars.borrowedAmountIsNotZero ? address(_bucket) : address(vars.traderBalanceVault),\n                deadline: block.timestamp\n            }),\n            vars.oracleTolerableLimit,\n            address(vars.primexDNS),\n            address(vars.priceOracle),\n            true\n        );\n\n        // We check TAKE_PROFIT condition only after swap\n        if (_closeReason == PositionLibrary.CloseReason.BATCH_TAKE_PROFIT) {\n            uint256 multiplierPositionAsset = 10 ** (18 - IERC20Metadata(_positionAsset).decimals());\n            uint256 multiplierBorrowedAsset = 10 ** (18 - IERC20Metadata(_soldAsset).decimals());\n            uint256 exchangeRate = (vars.borrowedAssetAmountOut * multiplierBorrowedAsset).wdiv(\n                vars.totalCloseAmount * multiplierPositionAsset\n            );\n            uint256 managerType = vars.closeConditions[0].managerType;\n            address cm = vars.primexDNS.cmTypeToAddress(managerType);\n            _require(\n                cm != address(0) && IERC165Upgradeable(cm).supportsInterface(type(ITakeProfitStopLossCCM).interfaceId),\n                Errors.CLOSE_CONDITION_IS_NOT_CORRECT.selector\n            );\n            LimitOrderLibrary.Condition memory condition;\n            for (uint256 i; i < vars.numberOfPositions; i++) {\n                condition = vars.closeConditions[i];\n                _require(\n                    condition.managerType == managerType &&\n                        ITakeProfitStopLossCCM(cm).isTakeProfitReached(condition.params, exchangeRate),\n                    Errors.POSITION_CANNOT_BE_CLOSED_FOR_THIS_REASON.selector\n                );\n            }\n        }\n\n        vars.returnedToTraders = new uint256[](vars.numberOfPositions);\n        vars.shareOfBorrowedAssetAmount = new uint256[](vars.numberOfPositions);\n        vars.isLiquidation = _closeReason == PositionLibrary.CloseReason.BATCH_LIQUIDATION;\n        for (uint256 i; i < vars.numberOfPositions; i++) {\n            vars.shareOfBorrowedAssetAmount[i] =\n                (vars.positionAmounts[i] * vars.borrowedAssetAmountOut) /\n                vars.totalCloseAmount;\n            if (vars.isLiquidation) continue;\n            if (vars.shareOfBorrowedAssetAmount[i] > vars.debts[i]) {\n                unchecked {\n                    vars.returnedToTraders[i] = vars.shareOfBorrowedAssetAmount[i] - vars.debts[i];\n                }\n            } else {\n                unchecked {\n                    vars.permanentLoss += vars.debts[i] - vars.shareOfBorrowedAssetAmount[i];\n                }\n            }\n            vars.amountToReturn += vars.returnedToTraders[i];\n        }\n\n        if (vars.isLiquidation) {\n            if (vars.borrowedAssetAmountOut > vars.totalDebt) {\n                unchecked {\n                    vars.amountToReturn = vars.borrowedAssetAmountOut - vars.totalDebt;\n                }\n            } else {\n                unchecked {\n                    vars.permanentLoss = vars.totalDebt - vars.borrowedAssetAmountOut;\n                }\n            }\n        } else {\n            vars.traderBalanceVault.batchTopUpAvailableBalance(\n                ITraderBalanceVault.BatchTopUpAvailableBalanceParams({\n                    traders: vars.traders,\n                    asset: _soldAsset,\n                    amounts: vars.returnedToTraders,\n                    length: vars.numberOfPositions\n                })\n            );\n        }\n\n        if (vars.borrowedAmountIsNotZero) {\n            _bucket.batchDecreaseTradersDebt(\n                vars.traders,\n                vars.debts,\n                vars.isLiquidation ? vars.primexDNS.treasury() : address(vars.traderBalanceVault),\n                vars.amountToReturn,\n                vars.permanentLoss,\n                vars.numberOfPositions\n            );\n        }\n\n        positionManager.deletePositions(vars.ids, vars.traders, vars.numberOfPositions, vars.bucket);\n        for (uint256 i; i < vars.numberOfPositions; i++) {\n            emit PositionLibrary.ClosePosition({\n                positionId: vars.ids[i],\n                trader: vars.traders[i],\n                closedBy: msg.sender,\n                bucketAddress: address(_bucket),\n                soldAsset: _soldAsset,\n                positionAsset: _positionAsset,\n                decreasePositionAmount: vars.positionAmounts[i],\n                profit: vars.returnedToTraders[i].toInt256() - vars.depositsDecrease[i].toInt256(),\n                positionDebt: vars.debts[i],\n                amountOut: vars.shareOfBorrowedAssetAmount[i],\n                reason: _closeReason\n            });\n        }\n        if (vars.totalCloseAmount.toInt256() - vars.uncoveredAmount.toInt256() > 0) {\n            positionManager.keeperRewardDistributor().updateReward(\n                IKeeperRewardDistributor.UpdateRewardParams({\n                    keeper: msg.sender,\n                    positionAsset: _positionAsset,\n                    positionSize: vars.totalCloseAmount - vars.uncoveredAmount,\n                    action: vars.actionType,\n                    numberOfActions: vars.numberOfPositions,\n                    gasSpent: initialGasleft - gasleft(),\n                    decreasingCounter: vars.decreasingCounter,\n                    routesLength: abi.encode(_routes).length\n                })\n            );\n        }\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @notice Removes item from array\n     * @dev The item is not deleted but swapped with the last item\n     * @param  vars  The struct containing arrays to update\n     * @param  index  The index of the item to remove\n     */\n    function _removeBatchItem(CloseBatchPositionsVars memory vars, uint256 index) internal pure {\n        //swap with the last one\n        vars.ids[index] = vars.ids[vars.numberOfPositions - 1];\n        vars.traders[index] = vars.traders[vars.numberOfPositions - 1];\n        vars.positionAmounts[index] = vars.positionAmounts[vars.numberOfPositions - 1];\n        vars.debts[index] = vars.debts[vars.numberOfPositions - 1];\n        vars.depositsDecrease[index] = vars.depositsDecrease[vars.numberOfPositions - 1];\n        //this will work like pop() for an array\n        unchecked {\n            vars.numberOfPositions--;\n        }\n    }\n}\n"
    },
    "contracts/BonusExecutor/BonusExecutor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \"../Constants.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IPMXBonusNFT} from \"../PMXBonusNFT/IPMXBonusNFT.sol\";\nimport {IReserve} from \"../Reserve/IReserve.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IDebtToken} from \"../DebtToken/IDebtToken.sol\";\nimport {IBonusExecutor, IPausable} from \"./IBonusExecutor.sol\";\n\nabstract contract BonusExecutor is IBonusExecutor, ReentrancyGuardUpgradeable, PausableUpgradeable, ERC165Upgradeable {\n    IPMXBonusNFT public override nft;\n    address public registry;\n    // Mapping from bucket to BonusCount\n    mapping(address => BonusCount) public bucketBonusCount;\n    IWhiteBlackList internal whiteBlackList;\n\n    //to new variables without shifting down storage in the inheritance chain.\n    uint256[50] private __gap;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Throws if called by any account other than the NFT.\n     */\n    modifier onlyNFT() {\n        _require(address(nft) == msg.sender, Errors.CALLER_IS_NOT_NFT.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    modifier notBlackListed() {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc IBonusExecutor\n     */\n    function setMaxBonusCount(address _bucket, uint256 _maxCount) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        bucketBonusCount[_bucket].maxCount = _maxCount;\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /// @notice Interface checker\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(_interfaceId) || _interfaceId == type(IBonusExecutor).interfaceId;\n    }\n\n    /**\n     * @dev Initializes the BonusExecutor contract.\n     * @param _nft The address of the IPMXBonusNFT contract.\n     * @param _registry The address of the registry contract.\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\n     * @notice This function is internal and can only be called during initialization.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __BonusExecutor_init(\n        IPMXBonusNFT _nft,\n        address _registry,\n        IWhiteBlackList _whiteBlackList\n    ) internal onlyInitializing {\n        _require(\n            IERC165Upgradeable(address(_nft)).supportsInterface(type(IPMXBonusNFT).interfaceId) &&\n                IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(address(_whiteBlackList)).supportsInterface(type(IWhiteBlackList).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n        nft = _nft;\n        whiteBlackList = _whiteBlackList;\n        __ReentrancyGuard_init();\n        __Pausable_init();\n        __ERC165_init();\n    }\n}\n"
    },
    "contracts/BonusExecutor/FeeDecreaser.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"../libraries/Errors.sol\";\n\nimport {FeeExecutor, IFeeExecutor, IBonusExecutor} from \"./FeeExecutor.sol\";\nimport {IPMXBonusNFT} from \"../PMXBonusNFT/IPMXBonusNFT.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\n\ncontract FeeDecreaser is FeeExecutor {\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializes the contract.\n     * @param _nft The address of the IPMXBonusNFT contract.\n     * @param _registry The address of the registry contract.\n     * @param _primexDNS The address of the PrimexDNS contract.\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\n     */\n    function initialize(\n        IPMXBonusNFT _nft,\n        address _registry,\n        address _primexDNS,\n        IWhiteBlackList _whiteBlackList\n    ) external override initializer {\n        __FeeExecutor_init(_nft, _registry, _primexDNS, _whiteBlackList);\n    }\n\n    /**\n     * @inheritdoc IBonusExecutor\n     */\n    function activateBonus(\n        uint256 _nftId,\n        uint256 _tier,\n        address _bucket,\n        address _owner\n    ) external override onlyNFT whenNotPaused {\n        _require(\n            address(bonuses[_owner][_bucket].bucket) == address(0),\n            Errors.BONUS_FOR_BUCKET_ALREADY_ACTIVATED.selector\n        );\n        uint256 index = IBucket(_bucket).getNormalizedVariableDebt();\n        _updateIndex(index, _bucket);\n        _activateBonus(_tier, _bucket, _nftId, _owner, index);\n    }\n\n    /**\n     * @inheritdoc IFeeExecutor\n     */\n    function updateBonus(uint256 _nftId) external override whenNotPaused notBlackListed {\n        ActivatedBonus memory bonus = bonuses[msg.sender][(nft.getNft(_nftId)).bucket];\n        _require(address(bonus.bucket) != address(0) && bonus.nftId == _nftId, Errors.BONUS_DOES_NOT_EXIST.selector);\n        uint256 index = bonus.bucket.getNormalizedVariableDebt();\n        _updateIndex(index, address(bonus.bucket));\n        _updateBonus(bonus, msg.sender, bonus.bucket.debtToken().scaledBalanceOf(msg.sender), index);\n    }\n\n    /**\n     * @inheritdoc IBonusExecutor\n     */\n    function claim(uint256 _amount, uint256 _nftId) external override nonReentrant whenNotPaused notBlackListed {\n        _require(_amount != 0, Errors.AMOUNT_IS_0.selector);\n        ActivatedBonus memory bonus = bonuses[msg.sender][(nft.getNft(_nftId)).bucket];\n        _require(address(bonus.bucket) != address(0) && bonus.nftId == _nftId, Errors.BONUS_DOES_NOT_EXIST.selector);\n        uint256 index = bonus.bucket.getNormalizedVariableDebt();\n        _updateIndex(index, address(bonus.bucket));\n        if (_canUpdateBonus(bonus)) {\n            if (bonus.deadline < block.timestamp) {\n                index = _searchApproxIndex(bonus.deadline, index, address(bonus.bucket));\n                bonus.deadline = type(uint256).max; // a magic number\n            }\n            if (index > bonus.lastUpdatedIndex) {\n                bonus.accumulatedAmount = _calculateAccumulatedAmount(\n                    bonus,\n                    index,\n                    bonus.bucket.debtToken().scaledBalanceOf(msg.sender)\n                );\n                bonus.lastUpdatedIndex = index;\n            }\n        }\n        _claim(bonus, _amount);\n    }\n\n    /**\n     * @inheritdoc IFeeExecutor\n     */\n    function updateBonus(\n        address _user,\n        uint256 _oldScaledBalance,\n        address _bucket,\n        uint256 _currentIndex\n    ) public override {\n        if (paused()) return;\n        if (address(bonuses[_user][_bucket].bucket) == address(0)) {\n            address bucket = IPrimexDNS(primexDNS).getBucketAddress(IBucket(_bucket).name());\n            _require(address(IBucket(bucket).debtToken()) == msg.sender, Errors.CALLER_IS_NOT_DEBT_TOKEN.selector);\n            _updateIndex(_currentIndex, _bucket);\n            return;\n        }\n        ActivatedBonus memory bonus = bonuses[_user][_bucket];\n        _require(address(bonus.bucket.debtToken()) == msg.sender, Errors.CALLER_IS_NOT_DEBT_TOKEN.selector);\n        _updateIndex(_currentIndex, _bucket);\n        _updateBonus(bonus, _user, _oldScaledBalance, _currentIndex);\n    }\n\n    /**\n     * @inheritdoc IFeeExecutor\n     */\n    function getAccumulatedAmount(address _user, uint256 _nftId) public view override returns (uint256) {\n        ActivatedBonus memory bonus = bonuses[_user][(nft.getNft(_nftId)).bucket];\n        if (address(bonus.bucket) == address(0)) {\n            return 0;\n        }\n        return\n            _getAccumulatedAmount(\n                bonus,\n                bonus.bucket.getNormalizedVariableDebt(),\n                bonus.bucket.debtToken().scaledBalanceOf(_user)\n            );\n    }\n}\n"
    },
    "contracts/BonusExecutor/FeeExecutor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport \"./FeeExecutorStorage.sol\";\nimport {BonusExecutor, IBonusExecutor, BIG_TIMELOCK_ADMIN} from \"./BonusExecutor.sol\";\nimport {HOUR} from \"../Constants.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IPMXBonusNFT} from \"../PMXBonusNFT/IPMXBonusNFT.sol\";\nimport {IReserve} from \"../Reserve/IReserve.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IDebtToken} from \"../DebtToken/IDebtToken.sol\";\nimport {IFeeExecutor} from \"./IFeeExecutor.sol\";\n\nabstract contract FeeExecutor is IFeeExecutor, BonusExecutor, FeeExecutorStorage {\n    using WadRayMath for uint256;\n\n    //In case the child contracts get their own storage (e.g FeeExecutor) and we can't update storage of this contract.\n    //You don't need to move this in the FeeExecutorStorage{version} contracts.\n    uint256[50] private __gap;\n\n    function initialize(\n        IPMXBonusNFT _nft,\n        address _registry,\n        address _primexDNS,\n        IWhiteBlackList _whiteBlackList\n    ) external virtual;\n\n    /**\n     * @inheritdoc IFeeExecutor\n     */\n    function setTierBonus(\n        address _bucket,\n        uint256[] calldata _tiers,\n        NFTBonusParams[] calldata _bonuses\n    ) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(_tiers.length == _bonuses.length, Errors.WRONG_LENGTH.selector);\n\n        for (uint256 i; i < _tiers.length; i++) {\n            _require(_bonuses[i].percent != 0, Errors.BONUS_PERCENT_IS_ZERO.selector);\n            tierBonus[_bucket][_tiers[i]] = _bonuses[i];\n        }\n    }\n\n    /**\n     * @inheritdoc IBonusExecutor\n     */\n    function deactivateBonus(address _user, address _bucket) external override onlyNFT {\n        delete bonuses[_user][_bucket];\n    }\n\n    /**\n     * @inheritdoc IFeeExecutor\n     */\n    function updateBonuses(\n        address[] memory _users,\n        uint256[] memory _oldBalances,\n        address _bucket,\n        uint256 _currentIndex\n    ) external override {\n        for (uint256 i; i < _users.length; i++) {\n            updateBonus(_users[i], _oldBalances[i], _bucket, _currentIndex);\n        }\n    }\n\n    /**\n     * @inheritdoc IFeeExecutor\n     */\n    function getBonus(address _user, uint256 _nftId) external view override returns (ActivatedBonus memory) {\n        ActivatedBonus memory bonus = bonuses[_user][(nft.getNft(_nftId)).bucket];\n        bonus.accumulatedAmount = getAccumulatedAmount(_user, _nftId);\n        return bonus;\n    }\n\n    /**\n     * @inheritdoc IFeeExecutor\n     */\n    function getAvailableAmount(address _user, uint256 _nftId) external view override returns (uint256) {\n        ActivatedBonus storage bonus = bonuses[_user][(nft.getNft(_nftId)).bucket];\n        return getAccumulatedAmount(_user, _nftId) - bonus.claimedAmount;\n    }\n\n    /**\n     * @inheritdoc IFeeExecutor\n     */\n    function updateBonus(\n        address _user,\n        uint256 _oldScaledBalance,\n        address _bucket,\n        uint256 _currentIndex\n    ) public virtual;\n\n    /**\n     * @inheritdoc IFeeExecutor\n     */\n    function getAccumulatedAmount(address _user, uint256 _nftId) public view virtual returns (uint256);\n\n    /// @notice Interface checker\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(_interfaceId) || _interfaceId == type(IFeeExecutor).interfaceId;\n    }\n\n    /**\n     * @dev Initializes the FeeExecutor contract.\n     * @param _nft The address of the IPMXBonusNFT contract.\n     * @param _registry The address of the registry contract.\n     * @param _primexDNS The address of the PrimexDNS contract.\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __FeeExecutor_init(\n        IPMXBonusNFT _nft,\n        address _registry,\n        address _primexDNS,\n        IWhiteBlackList _whiteBlackList\n    ) internal onlyInitializing {\n        primexDNS = _primexDNS;\n        __BonusExecutor_init(_nft, _registry, _whiteBlackList);\n    }\n\n    /**\n     * @dev Internal function to activate a bonus for a user.\n     * @param _tier The tier of the bonus.\n     * @param _bucket The address of the bucket.\n     * @param _nftId The ID of the NFT.\n     * @param _user The address of the user.\n     */\n    function _activateBonus(uint256 _tier, address _bucket, uint256 _nftId, address _user, uint256 _index) internal {\n        BonusCount storage bonusCount = bucketBonusCount[_bucket];\n        _require(bonusCount.count < bonusCount.maxCount, Errors.MAX_BONUS_COUNT_EXCEEDED.selector);\n        NFTBonusParams storage bonus = tierBonus[_bucket][_tier];\n        _require(bonus.percent != 0, Errors.TIER_IS_NOT_ACTIVE.selector);\n        bonuses[_user][_bucket] = ActivatedBonus({\n            nftId: _nftId,\n            bucket: IBucket(_bucket),\n            percent: bonus.percent,\n            maxAmount: bonus.maxAmount,\n            accumulatedAmount: 0,\n            lastUpdatedIndex: _index,\n            deadline: bonus.duration > 0 ? block.timestamp + bonus.duration : 0,\n            claimedAmount: 0\n        });\n        bonusCount.count++;\n    }\n\n    /**\n     * @dev Internal function to update the bonus for a user.\n     * @param _bonus The activated bonus for the user.\n     * @param _user The user's address.\n     * @param _scaledBalance The scaled balance of the user.\n     * @param _currentIndex The current index of the bonus update.\n     */\n    function _updateBonus(\n        ActivatedBonus memory _bonus,\n        address _user,\n        uint256 _scaledBalance,\n        uint256 _currentIndex\n    ) internal {\n        if (_canUpdateBonus(_bonus)) {\n            ActivatedBonus storage bonus = bonuses[_user][address(_bonus.bucket)];\n\n            if (_bonus.deadline < block.timestamp) {\n                _currentIndex = _searchApproxIndex(_bonus.deadline, _currentIndex, address(_bonus.bucket));\n                bonus.deadline = type(uint256).max; // a magic number\n                // it can happen when the index grew unevenly in this case we do not update the accumulatedAmount\n                if (_currentIndex <= _bonus.lastUpdatedIndex) return;\n            }\n            bonus.accumulatedAmount = _calculateAccumulatedAmount(_bonus, _currentIndex, _scaledBalance);\n            bonus.lastUpdatedIndex = _currentIndex;\n        }\n    }\n\n    /**\n     * @dev Updates the index with the given timestamp.\n     * @param _index The index to be updated.\n     * @param _bucket The bucket address for which index is being updated.\n     */\n    function _updateIndex(uint256 _index, address _bucket) internal {\n        if (\n            updatedTimestamps[_bucket].length == 0 ||\n            updatedTimestamps[_bucket][updatedTimestamps[_bucket].length - 1] + HOUR <= block.timestamp\n        ) {\n            updatedTimestamps[_bucket].push(block.timestamp);\n            indexes[_bucket][block.timestamp] = _index;\n        }\n    }\n\n    /**\n     * @dev Internal function to claim a bonus for a given ActivatedBonus and amount.\n     * @param _bonus The ActivatedBonus struct containing bonus information.\n     * @param _amount The amount to claim.\n     */\n    function _claim(ActivatedBonus memory _bonus, uint256 _amount) internal {\n        if (_bonus.accumulatedAmount > _bonus.claimedAmount) {\n            uint256 transferAmount = _bonus.claimedAmount + _amount > _bonus.accumulatedAmount\n                ? _bonus.accumulatedAmount - _bonus.claimedAmount\n                : _amount;\n            _bonus.claimedAmount += transferAmount;\n            _bonus.bucket.reserve().payBonus(_bonus.bucket.name(), msg.sender, transferAmount);\n        }\n        if ((!_canUpdateBonus(_bonus) && _bonus.claimedAmount == _bonus.accumulatedAmount)) {\n            delete bonuses[msg.sender][address(_bonus.bucket)];\n            bucketBonusCount[address(_bonus.bucket)].count--;\n        } else {\n            bonuses[msg.sender][address(_bonus.bucket)] = _bonus;\n        }\n    }\n\n    /**\n     * @dev Retrieves the accumulated amount for a given bonus.\n     * @param _bonus The ActivatedBonus struct containing bonus information.\n     * @param _currentIndex The current index.\n     * @param _scaledBalance The scaled balance.\n     * @return The accumulated amount.\n     */\n    function _getAccumulatedAmount(\n        ActivatedBonus memory _bonus,\n        uint256 _currentIndex,\n        uint256 _scaledBalance\n    ) internal view returns (uint256) {\n        if (_bonus.deadline > 0) {\n            if (_bonus.deadline == type(uint256).max) {\n                return _bonus.accumulatedAmount;\n            }\n            if (_bonus.deadline < block.timestamp) {\n                _currentIndex = _searchApproxIndex(_bonus.deadline, _currentIndex, address(_bonus.bucket));\n                // it can happen when the index grew unevenly in this case we do not update the accumulatedAmount\n                if (_currentIndex <= _bonus.lastUpdatedIndex) return _bonus.accumulatedAmount;\n            }\n        }\n        return _calculateAccumulatedAmount(_bonus, _currentIndex, _scaledBalance);\n    }\n\n    /**\n     * @dev Returns the approximate index for a given bonus deadline and current index.\n     * @param _bonusDeadline The bonus deadline to search for.\n     * @param _currentIndex The current index to compare with.\n     * @param _bucket The bucket address for which an index is being searched.\n     * @return The approximate index.\n     */\n    function _searchApproxIndex(\n        uint256 _bonusDeadline,\n        uint256 _currentIndex,\n        address _bucket\n    ) internal view returns (uint256) {\n        // at this moment the length of the updatedTimestamps array mast be > 0 and the first element is less than the _bonusDeadline\n        uint256 lowest;\n        uint256 highest = updatedTimestamps[_bucket].length - 1;\n        uint256 highestTimestamp = updatedTimestamps[_bucket][highest];\n        // _bonus.deadline < block.timestamp)\n        if (_bonusDeadline > highestTimestamp || lowest == highest) {\n            return\n                _calculateApproxIndex(\n                    indexes[_bucket][highestTimestamp],\n                    _currentIndex,\n                    highestTimestamp,\n                    block.timestamp,\n                    _bonusDeadline\n                );\n        }\n        //\n        while (lowest < highest) {\n            if (lowest == highest - 1) break;\n            uint256 mid = (lowest + highest) / 2;\n            uint256 midTimestamp = updatedTimestamps[_bucket][mid];\n            if (_bonusDeadline < midTimestamp) {\n                highest = mid;\n            } else if (_bonusDeadline > midTimestamp) {\n                lowest = mid;\n            } else {\n                return indexes[_bucket][midTimestamp];\n            }\n        }\n        //if _bonusDeadline is between the lowest and highest timestamps we calculate the approx value that could be in that timestamp\n        uint256 lowestTimestamp = updatedTimestamps[_bucket][lowest];\n        highestTimestamp = updatedTimestamps[_bucket][highest];\n        return\n            _calculateApproxIndex(\n                indexes[_bucket][lowestTimestamp],\n                indexes[_bucket][highestTimestamp],\n                lowestTimestamp,\n                highestTimestamp,\n                _bonusDeadline\n            );\n    }\n\n    /**\n     * @dev Calculates the accumulated amount for a bonus based on the provided parameters.\n     * @param _bonus The activated bonus.\n     * @param _currentIndex The current index.\n     * @param _scaledBalance The scaled balance.\n     * @return The calculated accumulated amount.\n     */\n    function _calculateAccumulatedAmount(\n        ActivatedBonus memory _bonus,\n        uint256 _currentIndex,\n        uint256 _scaledBalance\n    ) internal pure returns (uint256) {\n        uint256 bonusIncrement = _bonus.percent.wmul(_scaledBalance).rmul(_currentIndex - _bonus.lastUpdatedIndex);\n        if (_bonus.maxAmount > 0) {\n            return\n                (_bonus.accumulatedAmount + bonusIncrement >= _bonus.maxAmount)\n                    ? _bonus.maxAmount\n                    : _bonus.accumulatedAmount + bonusIncrement;\n        }\n        return _bonus.accumulatedAmount + bonusIncrement;\n    }\n\n    /**\n     * @dev Checks if a bonus can be updated.\n     * @param _bonus The ActivatedBonus struct representing the bonus.\n     * @return A boolean value indicating whether the bonus can be updated or not.\n     */\n    function _canUpdateBonus(ActivatedBonus memory _bonus) internal pure returns (bool) {\n        if (_bonus.maxAmount > 0) {\n            if (_bonus.accumulatedAmount >= _bonus.maxAmount) return false;\n        }\n        if (_bonus.deadline > 0) {\n            if (_bonus.deadline == type(uint256).max) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Calculates the approximate index based on given parameters.\n     * @param _lowestIndex The lowest index value.\n     * @param _highestIndex The highest index value.\n     * @param _lowestTimestamp The lowest timestamp value.\n     * @param _highestTimestamp The highest timestamp value.\n     * @param _bonusDeadline The bonus deadline timestamp.\n     * @return The calculated approximate index.\n     */\n    function _calculateApproxIndex(\n        uint256 _lowestIndex,\n        uint256 _highestIndex,\n        uint256 _lowestTimestamp,\n        uint256 _highestTimestamp,\n        uint256 _bonusDeadline\n    ) internal pure returns (uint256) {\n        // lowestIndex + (highestIndex - lowestIndex) * ((bonusDeadline - lowestTimestamp) / (highestTimestamp - lowestTimestamp))\n        return\n            _lowestIndex +\n            (_highestIndex - _lowestIndex).rmul(\n                ((_bonusDeadline - _lowestTimestamp).rdiv(_highestTimestamp - _lowestTimestamp))\n            );\n    }\n}\n"
    },
    "contracts/BonusExecutor/FeeExecutorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IFeeExecutorStorage} from \"./IFeeExecutorStorage.sol\";\n\nabstract contract FeeExecutorStorage is IFeeExecutorStorage {\n    address public primexDNS;\n\n    // Mapping from bucket to tier's bonus\n    mapping(address => mapping(uint256 => NFTBonusParams)) public tierBonus;\n    // Mapping (bucket-address => mapping (timestamp => corresponding-debt/income-index))\n    mapping(address => mapping(uint256 => uint256)) public indexes;\n    // Mapping (bucket-address => updatedTimestamps-of-this-bucket)\n    mapping(address => uint256[]) public updatedTimestamps;\n    // Mapping from owner to list of buckets with user bonuses\n    mapping(address => mapping(address => ActivatedBonus)) internal bonuses;\n}\n"
    },
    "contracts/BonusExecutor/IBonusExecutor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IPMXBonusNFT} from \"../PMXBonusNFT/IPMXBonusNFT.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface IBonusExecutor is IPausable {\n    struct BonusCount {\n        uint256 count;\n        uint256 maxCount;\n    }\n\n    /**\n     * @dev Creates the ActivatedBonus bonus entity in the bonuses mapping. Called by NFT only\n     * @param _nftId Id of activated token\n     * @param _tier The nft tier\n     * @param _bucket The bucket for activation\n     * @param _owner The owner of the nft token\n     */\n    function activateBonus(uint256 _nftId, uint256 _tier, address _bucket, address _owner) external;\n\n    /**\n     * @dev Deactivates a bonus for a user in a specific bucket.\n     * @param _user The address of the user.\n     * @param _bucket The address of the bonus bucket.\n     */\n    function deactivateBonus(address _user, address _bucket) external;\n\n    /**\n     * @dev Claims tokens that users have accrued. Called by the user\n     * @param _amount Amount of p-tokens to claim\n     * @param _nftId Id of activated token\n     **/\n    function claim(uint256 _amount, uint256 _nftId) external;\n\n    /**\n     * @dev Sets the maximum bonus count for a specific bucket.\n     * @param _bucket The address of the bucket.\n     * @param _maxCount The maximum bonus count to be set.\n     */\n    function setMaxBonusCount(address _bucket, uint256 _maxCount) external;\n\n    function nft() external view returns (IPMXBonusNFT);\n}\n"
    },
    "contracts/BonusExecutor/IFeeExecutor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IFeeExecutorStorage} from \"./IFeeExecutorStorage.sol\";\n\ninterface IFeeExecutor is IFeeExecutorStorage {\n    /**\n     * @dev Sets tier bonuses for a specific bucket.\n     * @param _bucket The address of the bucket.\n     * @param _tiers The array of tier values.\n     * @param _bonuses The array of NFT bonus parameters.\n     */\n    function setTierBonus(address _bucket, uint256[] calldata _tiers, NFTBonusParams[] calldata _bonuses) external;\n\n    /**\n     * @dev Updates the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called by the Debt-Token\n     * @param _user User for which the bonus will be updated. If user doesn't have the bonus for paused\n     * @param _oldScaledBalance Balance of the user before the operation at which the updateBonus function was called (e.g mint/burn)\n     * @param _bucket The Bucket to which the ActivatedBonus relates\n     **/\n    function updateBonus(address _user, uint256 _oldScaledBalance, address _bucket, uint256 _currentIndex) external;\n\n    /**\n     * @dev Updates the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called directly by the user\n     * @param _nftId Id of activated token\n     **/\n    function updateBonus(uint256 _nftId) external;\n\n    /**\n     * @dev Updates the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called by the P-Token or Debt-Token\n     * @param _users Array of the users for whom the bonus will be updated.\n     * @param _oldBalances Array of the balances before the operation at which the updateBonus function was called (e.g mint/transfer)\n     * @param _bucket The Bucket to which the ActivatedBonus relates\n     **/\n    function updateBonuses(\n        address[] memory _users,\n        uint256[] memory _oldBalances,\n        address _bucket,\n        uint256 _currentIndex\n    ) external;\n\n    /**\n     * @dev Returns accumulated amount of p-tokens at the moment\n     * @param _user The user for which the accumatedAmount will return. If the bonus does not exist will return 0.\n     * If the NFT does not exist will throw an error\n     * @param _nftId Id of activated token\n     * @return The accumulated amount.\n     */\n    function getAccumulatedAmount(address _user, uint256 _nftId) external returns (uint256);\n\n    /**\n     * @dev Returns the available amount (accumulated - claimedAmount) of p-tokens at the moment.\n     * @param _user The user for which the available amount will return. If the bonus does not exist will return 0.\n     * If the NFT does not exist will throw an error\n     * @param _nftId Id of activated token\n     **/\n    function getAvailableAmount(address _user, uint256 _nftId) external returns (uint256);\n\n    /**\n     * @dev Retrieves the bonus information for a user and NFT.\n     * @param _user The address of the user.\n     * @param _nftId The ID of the NFT.\n     * @return bonus The activated bonus information.\n     */\n    function getBonus(address _user, uint256 _nftId) external view returns (ActivatedBonus memory);\n}\n"
    },
    "contracts/BonusExecutor/IFeeExecutorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IBucket} from \"../Bucket/IBucket.sol\";\n\ninterface IFeeExecutorStorage {\n    struct ActivatedBonus {\n        uint256 nftId;\n        IBucket bucket;\n        uint256 percent;\n        uint256 maxAmount;\n        uint256 accumulatedAmount;\n        uint256 lastUpdatedIndex;\n        uint256 deadline;\n        //if we allow to claim funds before the end of the bonus\n        uint256 claimedAmount;\n    }\n\n    struct NFTBonusParams {\n        uint256 percent;\n        uint256 maxAmount;\n        uint256 duration;\n    }\n}\n"
    },
    "contracts/BonusExecutor/InterestIncreaser.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"../libraries/Errors.sol\";\n\nimport {FeeExecutor} from \"./FeeExecutor.sol\";\nimport {IPMXBonusNFT} from \"../PMXBonusNFT/IPMXBonusNFT.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\n\ncontract InterestIncreaser is FeeExecutor {\n    /**\n     * @dev Initializes the contract.\n     * @param _nft The address of the IPMXBonusNFT contract.\n     * @param _registry The address of the registry contract.\n     * @param _primexDNS The address of the PrimexDNS contract.\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\n     */\n    function initialize(\n        IPMXBonusNFT _nft,\n        address _registry,\n        address _primexDNS,\n        IWhiteBlackList _whiteBlackList\n    ) external override initializer {\n        __FeeExecutor_init(_nft, _registry, _primexDNS, _whiteBlackList);\n    }\n\n    /**\n     * @dev Creates the ActivatedBonus bonus entity in the bonuses mapping. Called by NFT only\n     * @param _nftId Id of activated token\n     * @param _tier The nft tier\n     * @param _bucket The bucket for activation\n     * @param _owner The owner of the nft token\n     */\n    function activateBonus(\n        uint256 _nftId,\n        uint256 _tier,\n        address _bucket,\n        address _owner\n    ) external override onlyNFT whenNotPaused {\n        _require(\n            address(bonuses[_owner][_bucket].bucket) == address(0),\n            Errors.BONUS_FOR_BUCKET_ALREADY_ACTIVATED.selector\n        );\n        uint256 index = IBucket(_bucket).getNormalizedIncome();\n        _updateIndex(index, address(_bucket));\n        _activateBonus(_tier, _bucket, _nftId, _owner, index);\n    }\n\n    /**\n     * @dev Update the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called directly by the user\n     * @param _nftId Id of activated token\n     */\n    function updateBonus(uint256 _nftId) external override whenNotPaused notBlackListed {\n        ActivatedBonus memory bonus = bonuses[msg.sender][(nft.getNft(_nftId)).bucket];\n        _require(address(bonus.bucket) != address(0) && bonus.nftId == _nftId, Errors.BONUS_DOES_NOT_EXIST.selector);\n        uint256 index = bonus.bucket.getNormalizedIncome();\n        _updateIndex(index, address(bonus.bucket));\n        _updateBonus(bonus, msg.sender, bonus.bucket.pToken().scaledBalanceOf(msg.sender), index);\n    }\n\n    /**\n     * @dev Claim tokens that users have accrued. Called by the user\n     * @param _amount Amount of p-tokens to claim\n     * @param _nftId Id of activated token\n     */\n    function claim(uint256 _amount, uint256 _nftId) external override nonReentrant whenNotPaused notBlackListed {\n        _require(_amount > 0, Errors.AMOUNT_IS_0.selector);\n        ActivatedBonus memory bonus = bonuses[msg.sender][(nft.getNft(_nftId)).bucket];\n        _require(address(bonus.bucket) != address(0) && bonus.nftId == _nftId, Errors.BONUS_DOES_NOT_EXIST.selector);\n        uint256 index = bonus.bucket.getNormalizedIncome();\n        _updateIndex(index, address(bonus.bucket));\n        if (_canUpdateBonus(bonus)) {\n            if (bonus.deadline < block.timestamp) {\n                index = _searchApproxIndex(bonus.deadline, index, address(bonus.bucket));\n                bonus.deadline = type(uint256).max; // a magic number\n            }\n            if (index > bonus.lastUpdatedIndex) {\n                bonus.accumulatedAmount = _calculateAccumulatedAmount(\n                    bonus,\n                    index,\n                    bonus.bucket.pToken().scaledBalanceOf(msg.sender)\n                );\n                bonus.lastUpdatedIndex = index;\n            }\n        }\n        _claim(bonus, _amount);\n    }\n\n    /**\n     * @dev Update the accumulatedAmount and the lastUpdatedIndex of the existing ActivatedBonus. Called by the P-Token\n     * @param _user User for which the bonus will be updated. If user doesn't have the bonus for pussed\n     * @param _oldScaledBalance Balance of the user before the operation at which the updateBonus function was called (e.g mint/transfer)\n     * @param _bucket The Bucket to which the ActivatedBonus relates\n     */\n    function updateBonus(\n        address _user,\n        uint256 _oldScaledBalance,\n        address _bucket,\n        uint256 _currentIndex\n    ) public override {\n        if (paused()) return;\n        if (address(bonuses[_user][_bucket].bucket) == address(0)) {\n            address bucket = IPrimexDNS(primexDNS).getBucketAddress(IBucket(_bucket).name());\n            _require(address(IBucket(bucket).pToken()) == msg.sender, Errors.CALLER_IS_NOT_P_TOKEN.selector);\n            _updateIndex(_currentIndex, _bucket);\n            return;\n        }\n        ActivatedBonus memory bonus = bonuses[_user][_bucket];\n        _require(address(bonus.bucket.pToken()) == msg.sender, Errors.CALLER_IS_NOT_P_TOKEN.selector);\n        _updateIndex(_currentIndex, _bucket);\n        _updateBonus(bonus, _user, _oldScaledBalance, _currentIndex);\n    }\n\n    /**\n     * @dev Returns accumulated amount of p-tokens at the moment\n     * @param _user The user for which the accumatedAmount will return. if the bonus does not exist will return 0.\n     * If the NFT does not exist will throw\n     * @param _nftId Id of activated token\n     */\n    function getAccumulatedAmount(address _user, uint256 _nftId) public view override returns (uint256) {\n        ActivatedBonus memory bonus = bonuses[_user][(nft.getNft(_nftId)).bucket];\n        if (address(bonus.bucket) == address(0)) {\n            return 0;\n        }\n        return\n            _getAccumulatedAmount(\n                bonus,\n                bonus.bucket.getNormalizedIncome(),\n                bonus.bucket.pToken().scaledBalanceOf(_user)\n            );\n    }\n}\n"
    },
    "contracts/Bucket/Bucket.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {TokenTransfersLibrary} from \"../libraries/TokenTransfersLibrary.sol\";\n\nimport \"./BucketStorage.sol\";\nimport {VAULT_ACCESS_ROLE, PM_ROLE, BATCH_MANAGER_ROLE, MAX_ASSET_DECIMALS, SECONDS_PER_YEAR} from \"../Constants.sol\";\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN} from \"../Constants.sol\";\nimport {IBucket, IBucketV2} from \"./IBucket.sol\";\n\n/* solhint-disable max-states-count */\ncontract Bucket is IBucketV2, BucketStorage {\n    using WadRayMath for uint256;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function initialize(ConstructorParams calldata _params, address _registry) public override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(address(_params.pToken)).supportsInterface(type(IPToken).interfaceId) &&\n                IERC165Upgradeable(address(_params.dns)).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165Upgradeable(address(_params.debtToken)).supportsInterface(type(IDebtToken).interfaceId) &&\n                IERC165Upgradeable(address(_params.positionManager)).supportsInterface(\n                    type(IPositionManager).interfaceId\n                ) &&\n                IERC165Upgradeable(address(_params.priceOracle)).supportsInterface(type(IPriceOracle).interfaceId) &&\n                IERC165Upgradeable(address(_params.reserve)).supportsInterface(type(IReserve).interfaceId) &&\n                IERC165Upgradeable(address(_params.interestRateStrategy)).supportsInterface(\n                    type(IInterestRateStrategy).interfaceId\n                ) &&\n                IERC165Upgradeable(address(_params.whiteBlackList)).supportsInterface(\n                    type(IWhiteBlackList).interfaceId\n                ),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        _require(\n            _params.borrowedAsset.decimals() <= MAX_ASSET_DECIMALS,\n            Errors.ASSET_DECIMALS_EXCEEDS_MAX_VALUE.selector\n        );\n        _require(_params.withdrawalFeeRate <= WadRayMath.WAD / 10, Errors.WITHDRAW_RATE_IS_MORE_10_PERCENT.selector);\n        _require(\n            _params.feeBuffer > WadRayMath.WAD && _params.feeBuffer < WadRayMath.WAD + WadRayMath.WAD / 100,\n            Errors.INVALID_FEE_BUFFER.selector\n        );\n        _require(_params.reserveRate < WadRayMath.WAD, Errors.RESERVE_RATE_SHOULD_BE_LESS_THAN_1.selector);\n        _require(_params.maxTotalDeposit > 0, Errors.MAX_TOTAL_DEPOSIT_IS_ZERO.selector);\n\n        if (_params.liquidityMiningAmount == 0) {\n            LMparams.isBucketLaunched = true;\n            emit BucketLaunched();\n        } else {\n            _require(\n                _params.liquidityMiningDeadline > block.timestamp &&\n                    IERC165Upgradeable(address(_params.liquidityMiningRewardDistributor)).supportsInterface(\n                        type(ILiquidityMiningRewardDistributor).interfaceId\n                    ) &&\n                    _params.maxAmountPerUser > 0,\n                Errors.INCORRECT_LIQUIDITY_MINING_PARAMS.selector\n            );\n            LMparams.maxStabilizationEndTimestamp = _params.liquidityMiningDeadline + _params.stabilizationDuration;\n            LMparams.maxDuration = LMparams.maxStabilizationEndTimestamp - block.timestamp;\n            LMparams.liquidityMiningRewardDistributor = _params.liquidityMiningRewardDistributor;\n            LMparams.accumulatingAmount = _params.liquidityMiningAmount;\n            LMparams.deadlineTimestamp = _params.liquidityMiningDeadline;\n            LMparams.stabilizationDuration = _params.stabilizationDuration;\n            LMparams.maxAmountPerUser = _params.maxAmountPerUser;\n            estimatedBar = _params.estimatedBar;\n            estimatedLar = _params.estimatedLar;\n            isReinvestToAaveEnabled = _params.isReinvestToAaveEnabled;\n        }\n        maxTotalDeposit = _params.maxTotalDeposit;\n        _params.interestRateStrategy.setBarCalculationParams(_params.barCalcParams);\n        name = _params.name;\n        pToken = _params.pToken;\n        dns = _params.dns;\n        positionManager = _params.positionManager;\n        priceOracle = _params.priceOracle;\n        debtToken = _params.debtToken;\n        reserve = _params.reserve;\n        whiteBlackList = _params.whiteBlackList;\n        borrowedAsset = _params.borrowedAsset;\n        feeBuffer = _params.feeBuffer;\n        withdrawalFeeRate = _params.withdrawalFeeRate;\n        reserveRate = _params.reserveRate;\n\n        for (uint256 i; i < _params.assets.length; i++) {\n            _addAsset(_params.assets[i]);\n        }\n        registry = _registry;\n        interestRateStrategy = _params.interestRateStrategy;\n        liquidityIndex = 1e27;\n        variableBorrowIndex = 1e27;\n        __ReentrancyGuard_init();\n        __ERC165_init();\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function addAsset(address _newAsset) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _addAsset(_newAsset);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function removeAsset(address _assetToDelete) external override {\n        _onlyRole(SMALL_TIMELOCK_ADMIN);\n        Asset storage assetToDelete = allowedAssets[_assetToDelete];\n        _require(assetToDelete.isSupported, Errors.ASSET_IS_NOT_SUPPORTED.selector);\n\n        address assetToMove = assets[assets.length - 1];\n        assets[assetToDelete.index] = assetToMove;\n        assets.pop();\n\n        allowedAssets[assetToMove].index = assetToDelete.index;\n        delete allowedAssets[_assetToDelete];\n\n        emit RemoveAsset(_assetToDelete);\n    }\n\n    function setBarCalculationParams(bytes calldata _params) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        interestRateStrategy.setBarCalculationParams(_params);\n        emit BarCalculationParamsChanged(_params);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function setReserveRate(uint256 _reserveRate) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        _require(_reserveRate < WadRayMath.WAD, Errors.RESERVE_RATE_SHOULD_BE_LESS_THAN_1.selector);\n        reserveRate = _reserveRate;\n        emit ReserveRateChanged(_reserveRate);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function setFeeBuffer(uint256 _feeBuffer) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(\n            _feeBuffer > WadRayMath.WAD && _feeBuffer < WadRayMath.WAD + WadRayMath.WAD / 100,\n            Errors.INVALID_FEE_BUFFER.selector\n        );\n        feeBuffer = _feeBuffer;\n        emit FeeBufferChanged(_feeBuffer);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function setWithdrawalFee(uint256 _withdrawalFeeRate) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        _require(_withdrawalFeeRate <= WadRayMath.WAD / 10, Errors.WITHDRAW_RATE_IS_MORE_10_PERCENT.selector);\n        withdrawalFeeRate = _withdrawalFeeRate;\n        emit WithdrawalFeeChanged(_withdrawalFeeRate);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function setInterestRateStrategy(address _interestRateStrategy) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        _require(\n            IERC165Upgradeable(_interestRateStrategy).supportsInterface(type(IInterestRateStrategy).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        interestRateStrategy = IInterestRateStrategy(_interestRateStrategy);\n        emit InterestRateStrategyChanged(_interestRateStrategy);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function setMaxTotalDeposit(uint256 _maxTotalDeposit) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(_maxTotalDeposit > 0, Errors.MAX_TOTAL_DEPOSIT_IS_ZERO.selector);\n        maxTotalDeposit = _maxTotalDeposit;\n        emit MaxTotalDepositChanged(_maxTotalDeposit);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function deposit(address _pTokenReceiver, uint256 _amount) external override {\n        deposit(_pTokenReceiver, _amount, true);\n    }\n\n    /**\n     * @inheritdoc IBucketV2\n     */\n    function deposit(\n        address _pTokenReceiver,\n        uint256 _amount,\n        bool _takeDepositFromWallet\n    ) public override nonReentrant {\n        _notBlackListed();\n        _require(pToken.totalSupply() + _amount < maxTotalDeposit, Errors.DEPOSIT_EXCEEDS_MAX_TOTAL_DEPOSIT.selector);\n        if (_takeDepositFromWallet) {\n            TokenTransfersLibrary.doTransferIn(address(borrowedAsset), msg.sender, _amount);\n        } else {\n            positionManager.traderBalanceVault().withdrawFrom(\n                msg.sender,\n                address(this),\n                address(borrowedAsset),\n                _amount,\n                false\n            );\n        }\n        if (LMparams.isBucketLaunched) {\n            _deposit(_pTokenReceiver, _amount);\n        } else {\n            _require(_pTokenReceiver == msg.sender, Errors.CALLER_IS_NOT_P_TOKEN_RECEIVER.selector);\n            _depositLM(_pTokenReceiver, _amount);\n        }\n        emit Deposit(msg.sender, _pTokenReceiver, _amount);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function withdrawAfterDelisting(uint256 _amount) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        _require(isWithdrawAfterDelistingAvailable(), Errors.WITHDRAWAL_NOT_ALLOWED.selector);\n        TokenTransfersLibrary.doTransferOut(address(borrowedAsset), dns.treasury(), _amount);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function receiveDeposit(\n        address _pTokenReceiver,\n        uint256 _amount,\n        uint256 _duration,\n        string calldata _bucketFrom\n    ) external override nonReentrant {\n        _require(pToken.totalSupply() + _amount < maxTotalDeposit, Errors.DEPOSIT_EXCEEDS_MAX_TOTAL_DEPOSIT.selector);\n        _require(dns.getBucketAddress(_bucketFrom) == msg.sender, Errors.FORBIDDEN.selector);\n        if (LMparams.isBucketLaunched) {\n            if (_duration > 0) pToken.lockDeposit(_pTokenReceiver, _deposit(_pTokenReceiver, _amount), _duration);\n        } else {\n            _depositLM(_pTokenReceiver, _amount);\n        }\n        emit Deposit(msg.sender, _pTokenReceiver, _amount);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function depositFromBucket(\n        string calldata _bucketTo,\n        ISwapManager _swapManager,\n        PrimexPricingLibrary.Route[] calldata routes,\n        uint256 _amountOutMin\n    ) external override nonReentrant {\n        _notBlackListed();\n        // don't need check that _bucketTo isn't this bucket name\n        // tx will be reverted by ReentrancyGuard\n        _require(\n            !LMparams.isBucketLaunched && block.timestamp > LMparams.deadlineTimestamp,\n            Errors.DEADLINE_IS_NOT_PASSED.selector\n        );\n        if (isReinvestToAaveEnabled && aaveDeposit > 0) {\n            _withdrawBucketLiquidityFromAave();\n        }\n        IBucket receiverBucket = IBucket(dns.getBucketAddress(_bucketTo));\n\n        LMparams.liquidityMiningRewardDistributor.reinvest(\n            name,\n            _bucketTo,\n            msg.sender,\n            receiverBucket.getLiquidityMiningParams().isBucketLaunched,\n            LMparams.deadlineTimestamp\n        );\n\n        uint256 allUserBalance = pToken.burn(msg.sender, type(uint256).max, liquidityIndex);\n        emit Withdraw(msg.sender, address(receiverBucket), allUserBalance);\n        IERC20Metadata bucketToAsset = receiverBucket.borrowedAsset();\n        if (bucketToAsset != borrowedAsset) {\n            // Need this check that _swapManager is legit.\n            // Without it, user can specify any address of _swapManager to withdraw their funds with an extra reward\n            _require(\n                IAccessControl(registry).hasRole(VAULT_ACCESS_ROLE, address(_swapManager)),\n                Errors.FORBIDDEN.selector\n            );\n            borrowedAsset.approve(address(_swapManager), allUserBalance);\n            allUserBalance = _swapManager.swap(\n                ISwapManager.SwapParams({\n                    tokenA: address(borrowedAsset),\n                    tokenB: address(bucketToAsset),\n                    amountTokenA: allUserBalance,\n                    amountOutMin: _amountOutMin,\n                    routes: routes,\n                    receiver: address(receiverBucket),\n                    deadline: block.timestamp,\n                    isSwapFromWallet: true,\n                    isSwapToWallet: true,\n                    isSwapFeeInPmx: false,\n                    payFeeFromWallet: false\n                }),\n                0,\n                false\n            );\n        } else {\n            TokenTransfersLibrary.doTransferOut(address(borrowedAsset), address(receiverBucket), allUserBalance);\n        }\n\n        receiverBucket.receiveDeposit(msg.sender, allUserBalance, LMparams.stabilizationDuration, name);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function returnLiquidityFromAaveToBucket() external override {\n        _onlyRole(SMALL_TIMELOCK_ADMIN);\n        _withdrawBucketLiquidityFromAave();\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function withdraw(address _borrowAssetReceiver, uint256 _amount) external override nonReentrant {\n        _notBlackListed();\n        if (!LMparams.isBucketLaunched) {\n            LMparams.liquidityMiningRewardDistributor.removePoints(name, msg.sender, _amount);\n        } else if (block.timestamp < LMparams.stabilizationEndTimestamp) {\n            _require(\n                _amount <=\n                    pToken.balanceOf(msg.sender) -\n                        LMparams.liquidityMiningRewardDistributor.getLenderAmountInMining(name, msg.sender),\n                Errors.MINING_AMOUNT_WITHDRAW_IS_LOCKED_ON_STABILIZATION_PERIOD.selector\n            );\n        }\n\n        if (LMparams.isBucketLaunched) _updateIndexes();\n        uint256 amountToWithdraw = pToken.burn(msg.sender, _amount, liquidityIndex);\n        uint256 amountToLender = (WadRayMath.WAD - withdrawalFeeRate).wmul(amountToWithdraw);\n        uint256 amountToTreasury = amountToWithdraw - amountToLender;\n        if (!LMparams.isBucketLaunched && isReinvestToAaveEnabled && aaveDeposit > 0) {\n            // if liquidity mining failed, take all tokens from aave during first withdraw from bucket\n            if (block.timestamp > LMparams.deadlineTimestamp) {\n                _withdrawBucketLiquidityFromAave();\n            } else {\n                // if liquidity mining is in progress, withdraw needed amount from aave\n                address aavePool = dns.aavePool();\n                IPool(aavePool).withdraw(address(borrowedAsset), amountToWithdraw, address(this));\n                emit WithdrawFromAave(aavePool, amountToWithdraw);\n                aaveDeposit -= amountToWithdraw;\n            }\n        }\n\n        _require(\n            amountToWithdraw <= borrowedAsset.balanceOf(address(this)),\n            Errors.NOT_ENOUGH_LIQUIDITY_IN_THE_BUCKET.selector\n        );\n\n        TokenTransfersLibrary.doTransferOut(address(borrowedAsset), dns.treasury(), amountToTreasury);\n        emit TopUpTreasury(msg.sender, amountToTreasury);\n\n        TokenTransfersLibrary.doTransferOut(address(borrowedAsset), _borrowAssetReceiver, amountToLender);\n        if (LMparams.isBucketLaunched) _updateRates();\n\n        emit Withdraw(msg.sender, _borrowAssetReceiver, amountToWithdraw);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function increaseDebt(address _trader, uint256 _amount, address _to) external override {\n        _onlyRole(PM_ROLE);\n        _require(LMparams.isBucketLaunched, Errors.BUCKET_IS_NOT_LAUNCHED.selector);\n        TokenTransfersLibrary.doTransferOut(address(borrowedAsset), _to, _amount);\n        _updateIndexes();\n        debtToken.mint(_trader, _amount, variableBorrowIndex);\n        _updateRates();\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function decreaseTraderDebt(\n        address _trader,\n        uint256 _debtToBurn,\n        address _receiverOfAmountToReturn,\n        uint256 _amountToReturn,\n        uint256 _permanentLossAmount\n    ) external override {\n        _onlyRole(PM_ROLE);\n        // don't need require on isBucketLaunched,\n        // because if we can't openPosition in this bucket then we can't closePosition in this bucket\n        if (_amountToReturn > 0) {\n            TokenTransfersLibrary.doTransferOut(address(borrowedAsset), _receiverOfAmountToReturn, _amountToReturn);\n        }\n        _updateIndexes();\n        debtToken.burn(_trader, _debtToBurn, variableBorrowIndex);\n        _updateRates();\n        if (_permanentLossAmount > 0) {\n            permanentLossScaled += _permanentLossAmount.rdiv(liquidityIndex);\n        }\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function batchDecreaseTradersDebt(\n        address[] calldata _traders,\n        uint256[] calldata _debtsToBurn,\n        address _receiverOfAmountToReturn,\n        uint256 _amountToReturn,\n        uint256 _permanentLossAmount,\n        uint256 _length\n    ) external override {\n        _onlyRole(BATCH_MANAGER_ROLE);\n        // don't need require on isBucketLaunched,\n        // because if we can't openPosition in this bucket then we can't closePosition in this bucket\n        if (_amountToReturn > 0) {\n            TokenTransfersLibrary.doTransferOut(address(borrowedAsset), _receiverOfAmountToReturn, _amountToReturn);\n        }\n        _updateIndexes();\n        debtToken.batchBurn(_traders, _debtsToBurn, variableBorrowIndex, _length);\n        _updateRates();\n        if (_permanentLossAmount > 0) {\n            permanentLossScaled += _permanentLossAmount.rdiv(liquidityIndex);\n        }\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function getLiquidityMiningParams() external view override returns (LiquidityMiningParams memory) {\n        return LMparams;\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function isDeprecated() external view override returns (bool) {\n        (, IPrimexDNSStorage.Status status, , ) = dns.buckets(name);\n        return status == IPrimexDNSStorage.Status.Deprecated;\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function isActive() external view override returns (bool) {\n        (, IPrimexDNSStorage.Status status, , ) = dns.buckets(name);\n        return status == IPrimexDNSStorage.Status.Active;\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function isDelisted() external view override returns (bool) {\n        (, IPrimexDNSStorage.Status status, uint256 delistingDeadline, ) = dns.buckets(name);\n        return status == IPrimexDNSStorage.Status.Deprecated && delistingDeadline < block.timestamp;\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function isBucketStable() external view override returns (bool) {\n        return LMparams.isBucketLaunched && block.timestamp > LMparams.stabilizationEndTimestamp;\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function maxAssetLeverage(address _asset) external view override returns (uint256) {\n        _require(allowedAssets[_asset].isSupported, Errors.ASSET_IS_NOT_SUPPORTED.selector);\n        uint256 maintenanceBuffer = positionManager.maintenanceBuffer();\n        //  The formula is:\n        //  (WAD + maintenanceBuffer) feeBuffer /\n        //  ((WAD + maintenanceBuffer) feeBuffer) -\n        //  (WAD - securityBuffer) (WAD - pairPriceDropBA) (WAD - oracleTolerableLimitAB) (WAD - oracleTolerableLimitBA)\n        return\n            (WadRayMath.WAD + maintenanceBuffer).wmul(feeBuffer).wdiv(\n                (WadRayMath.WAD + maintenanceBuffer).wmul(feeBuffer) -\n                    (WadRayMath.WAD - positionManager.securityBuffer())\n                        .wmul(WadRayMath.WAD - priceOracle.getPairPriceDrop(_asset, address(borrowedAsset)))\n                        .wmul(WadRayMath.WAD - positionManager.getOracleTolerableLimit(address(borrowedAsset), _asset))\n                        .wmul(WadRayMath.WAD - positionManager.getOracleTolerableLimit(_asset, address(borrowedAsset)))\n            );\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function getNormalizedVariableDebt() external view override returns (uint256) {\n        return _calculateCompoundedInterest(bar, lastUpdatedBlockTimestamp).rmul(variableBorrowIndex);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function getAllowedAssets() external view override returns (address[] memory) {\n        return assets;\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function paybackPermanentLoss(uint256 amount) public override nonReentrant {\n        _notBlackListed();\n        uint256 amountScaled = amount.rdiv(getNormalizedIncome());\n        _require(amountScaled > 0, Errors.AMOUNT_SCALED_SHOULD_BE_GREATER_THAN_ZERO.selector);\n        if (amountScaled > permanentLossScaled) {\n            amountScaled = permanentLossScaled;\n            amount = permanentLoss();\n        }\n        unchecked {\n            permanentLossScaled -= amountScaled;\n        }\n        pToken.burn(msg.sender, amount, getNormalizedIncome());\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function isWithdrawAfterDelistingAvailable() public view override returns (bool) {\n        (, IPrimexDNSStorage.Status status, , uint256 adminDeadline) = dns.buckets(name);\n        return status == IPrimexDNSStorage.Status.Deprecated && adminDeadline < block.timestamp;\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function permanentLoss() public view override returns (uint256) {\n        return permanentLossScaled.rmul(getNormalizedIncome());\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function getNormalizedIncome() public view override returns (uint256) {\n        return _calculateLinearInterest(lar, lastUpdatedBlockTimestamp).rmul(liquidityIndex);\n    }\n\n    /**\n     * @inheritdoc IBucket\n     */\n    function availableLiquidity() public view override returns (uint256) {\n        return borrowedAsset.balanceOf(address(this)) + aaveDeposit;\n    }\n\n    /// @notice Interface checker\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IBucketV2).interfaceId ||\n            _interfaceId == type(IBucket).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @dev Internal function to deposit funds into the bucket.\n     * @param _pTokenReceiver The address to receive the pTokens.\n     * @param _amount The amount of funds to deposit.\n     * @return _mintedAmount The amount of pTokens minted during deposit\n     */\n    function _deposit(address _pTokenReceiver, uint256 _amount) internal returns (uint256 _mintedAmount) {\n        // launched phase\n        // here it's also checked that the bucket is active\n        _require(dns.getBucketAddress(name) == address(this), Errors.BUCKET_OUTSIDE_PRIMEX_PROTOCOL.selector);\n        _updateIndexes();\n        _mintedAmount = pToken.mint(_pTokenReceiver, _amount, liquidityIndex);\n        _updateRates();\n    }\n\n    /**\n     * @notice Internal function for depositing during liquidity mining period.\n     * @param _pTokenReceiver The address of the receiver of the pToken.\n     * @param _amount The amount of tokens to be deposited.\n     */\n    function _depositLM(address _pTokenReceiver, uint256 _amount) internal {\n        // liquidity mining phase\n        _require(block.timestamp <= LMparams.deadlineTimestamp, Errors.DEADLINE_IS_PASSED.selector);\n\n        uint256 _availableLiquidityBeforeTransfer = availableLiquidity() - _amount;\n\n        // we don't need update rates and indexes because\n        // they're zero and 1 ray accordingly while no one borrow\n        pToken.mint(_pTokenReceiver, _amount, liquidityIndex);\n\n        if (_availableLiquidityBeforeTransfer >= LMparams.accumulatingAmount) {\n            _launchBucket();\n            return;\n        }\n        uint256 tokensLeft = LMparams.accumulatingAmount - _availableLiquidityBeforeTransfer;\n        uint256 miningAmount;\n        if (tokensLeft > _amount) {\n            miningAmount = _amount;\n            if (isReinvestToAaveEnabled) {\n                uint256 bucketBalance = borrowedAsset.balanceOf(address(this));\n                aaveDeposit += bucketBalance;\n                address aavePool = dns.aavePool();\n                borrowedAsset.approve(aavePool, bucketBalance);\n                IPool(aavePool).supply(address(borrowedAsset), bucketBalance, address(this), 0);\n                emit DepositToAave(aavePool, bucketBalance);\n            }\n        } else {\n            miningAmount = tokensLeft;\n            _launchBucket();\n        }\n\n        _require(\n            LMparams.liquidityMiningRewardDistributor.getLenderAmountInMining(name, _pTokenReceiver) + miningAmount <=\n                LMparams.maxAmountPerUser,\n            Errors.DEPOSIT_IS_MORE_AMOUNT_PER_USER.selector\n        );\n\n        // save lender activity for future reward distribution\n        LMparams.liquidityMiningRewardDistributor.addPoints(\n            name,\n            _pTokenReceiver,\n            miningAmount,\n            LMparams.maxStabilizationEndTimestamp,\n            LMparams.maxDuration,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Updates the liquidityIndex and variableBorrowIndex\n     */\n    function _updateIndexes() internal {\n        uint256 newLiquidityIndex = _calculateLinearInterest(lar, lastUpdatedBlockTimestamp).rmul(liquidityIndex);\n        _require(newLiquidityIndex <= type(uint128).max, Errors.LIQUIDITY_INDEX_OVERFLOW.selector);\n        liquidityIndex = uint128(newLiquidityIndex);\n\n        uint256 newVariableBorrowIndex = _calculateCompoundedInterest(bar, lastUpdatedBlockTimestamp).rmul(\n            variableBorrowIndex\n        );\n        _require(newVariableBorrowIndex <= type(uint128).max, Errors.BORROW_INDEX_OVERFLOW.selector);\n        uint256 previousVariableBorrowIndex = variableBorrowIndex;\n        variableBorrowIndex = uint128(newVariableBorrowIndex);\n\n        lastUpdatedBlockTimestamp = block.timestamp;\n        _mintToReserve(debtToken.scaledTotalSupply(), previousVariableBorrowIndex, variableBorrowIndex);\n    }\n\n    /**\n     * @dev Mints portion of the interest that goes to the Primex Reserve\n     */\n    function _mintToReserve(\n        uint256 _scaledVariableDebt,\n        uint256 _previousVariableBorrowIndex,\n        uint256 _newVariableBorrowIndex\n    ) internal {\n        if (reserveRate == 0) {\n            return;\n        }\n        // debt accrued is the current debt minus the debt at the last update\n        // percentage multiplied\n        pToken.mintToReserve(\n            address(reserve),\n            (_scaledVariableDebt.rmul(_newVariableBorrowIndex) - _scaledVariableDebt.rmul(_previousVariableBorrowIndex))\n                .wmul(reserveRate),\n            liquidityIndex\n        );\n    }\n\n    /**\n     * @notice Internal function to set the isBucketLaunched flag to true.\n     * Set the stabilizationPeriodEnd timestamp.\n     * If investment is enabled withdraw all liquidity from Aave.\n     */\n\n    function _launchBucket() internal {\n        LMparams.isBucketLaunched = true;\n        LMparams.stabilizationEndTimestamp = block.timestamp + LMparams.stabilizationDuration;\n        if (isReinvestToAaveEnabled) {\n            _withdrawBucketLiquidityFromAave();\n        }\n        emit BucketLaunched();\n    }\n\n    /**\n     * @notice Internal function to withdraw all liquidity from Aave\n     */\n    function _withdrawBucketLiquidityFromAave() internal {\n        address aavePool = dns.aavePool();\n        uint256 aaveBalance = IAToken(IPool(aavePool).getReserveData(address(borrowedAsset)).aTokenAddress).balanceOf(\n            address(this)\n        );\n        isReinvestToAaveEnabled = false;\n        if (aaveBalance == 0) return;\n\n        IPool(aavePool).withdraw(address(borrowedAsset), type(uint256).max, address(this));\n        emit WithdrawFromAave(aavePool, aaveBalance);\n\n        // if there is earned interest, withdraw it to treasury\n        if (aaveBalance > aaveDeposit) {\n            uint256 interest = aaveBalance - aaveDeposit;\n            TokenTransfersLibrary.doTransferOut(address(borrowedAsset), dns.treasury(), interest);\n            emit TopUpTreasury(aavePool, interest);\n        }\n        aaveDeposit = 0;\n    }\n\n    /**\n     * @dev Updates bucket's BAR and LAR.\n     */\n    function _updateRates() internal {\n        uint256 totalDemand = debtToken.totalSupply();\n        uint256 totalDeposit = availableLiquidity() + totalDemand;\n        if (totalDeposit == 0) {\n            bar = 0;\n            lar = 0;\n        } else {\n            (bar, lar) = interestRateStrategy.calculateInterestRates(totalDemand.rdiv(totalDeposit), reserveRate);\n        }\n        emit RatesIndexesUpdated(bar, lar, variableBorrowIndex, liquidityIndex, block.timestamp);\n    }\n\n    /**\n     * @dev Internal function to add a new asset to the allowed assets list.\n     * @param _newAsset The address of the new asset to be added.\n     */\n    function _addAsset(address _newAsset) internal {\n        _require(_newAsset != address(0), Errors.CAN_NOT_ADD_WITH_ZERO_ADDRESS.selector);\n        _require(!allowedAssets[_newAsset].isSupported, Errors.ASSET_ALREADY_SUPPORTED.selector);\n        _require(\n            IERC20Metadata(_newAsset).decimals() <= MAX_ASSET_DECIMALS,\n            Errors.ASSET_DECIMALS_EXCEEDS_MAX_VALUE.selector\n        );\n        _require(\n            priceOracle.pairPriceDrops(_newAsset, address(borrowedAsset)) > 0,\n            Errors.PAIR_PRICE_DROP_IS_NOT_CORRECT.selector\n        );\n        // Check that both the new asset and the borrowed asset have oracle price feeds available\n        priceOracle.getPriceFeedsPair(_newAsset, address(borrowedAsset));\n        assets.push(_newAsset);\n        allowedAssets[_newAsset] = Asset(assets.length - 1, true);\n        emit AddAsset(_newAsset);\n    }\n\n    /**\n     * @dev Calculates the accumulated interest per blocks delta\n     * @param _rate The interest rate (in ray)\n     * @param _lastUpdatedBlockTimestamp The block timestamp of the last update of interest rate\n     * @return The interest rate accumulated during the secondsDelta (in ray)\n     */\n    function _calculateLinearInterest(\n        uint256 _rate,\n        uint256 _lastUpdatedBlockTimestamp\n    ) internal view returns (uint256) {\n        uint256 secondsDelta = block.timestamp - _lastUpdatedBlockTimestamp;\n        return (_rate * secondsDelta) / SECONDS_PER_YEAR + WadRayMath.RAY;\n    }\n\n    /**\n     * @dev Calculates borrow interest using compounded interest formula\n     * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\n     * (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n     * @param _bar Borrowing annual rate (originally APR) (in ray)\n     * @param _blockTimestamp The block timestamp of the last update of borrow rate\n     * @return The borrow interest rate compounded during the secondsDelta (in ray)\n     */\n    function _calculateCompoundedInterest(uint256 _bar, uint256 _blockTimestamp) internal view returns (uint256) {\n        uint256 exp = block.timestamp - _blockTimestamp;\n\n        if (exp == 0) {\n            return WadRayMath.RAY;\n        }\n\n        uint256 expMinusOne = exp - 1;\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n        // multiply first to mitigate rounding related issues\n        uint256 basePowerTwo = _bar.rmul(_bar) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n        uint256 basePowerThree = _bar.rmul(_bar).rmul(_bar) / (SECONDS_PER_YEAR * SECONDS_PER_YEAR * SECONDS_PER_YEAR);\n\n        uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\n        uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\n\n        return WadRayMath.RAY + (_bar * exp) / SECONDS_PER_YEAR + secondTerm + thirdTerm;\n    }\n\n    /**\n     * @dev Function that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    function _onlyRole(bytes32 _role) internal view {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n    }\n\n    /**\n     * @dev Function that checks if the sender is not blacklisted.\n     */\n    function _notBlackListed() internal view {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n    }\n}\n/* solhint-enable max-states-count */\n"
    },
    "contracts/Bucket/BucketsFactory.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"./../libraries/Errors.sol\";\n\nimport {Bucket} from \"./Bucket.sol\";\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN} from \"../Constants.sol\";\nimport {IBucketsFactory} from \"./IBucketsFactory.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPToken} from \"../PToken/IPToken.sol\";\nimport {IReserve} from \"../Reserve/IReserve.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IDebtToken} from \"../DebtToken/IDebtToken.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IPTokensFactory} from \"../PToken/IPTokensFactory.sol\";\nimport {IDebtTokensFactory} from \"../DebtToken/IDebtTokensFactory.sol\";\nimport {IBucketStorage} from \"./IBucketStorage.sol\";\n\ncontract BucketsFactory is UpgradeableBeacon, IBucketsFactory, IERC165 {\n    IPTokensFactory public pTokensFactory;\n    IDebtTokensFactory public debtTokensFactory;\n    address[] public override buckets;\n    address public immutable override registry;\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(\n        address _registry,\n        IPTokensFactory _pTokensFactory,\n        IDebtTokensFactory _debtTokensFactory,\n        address _bucketImplementation\n    ) UpgradeableBeacon(_bucketImplementation) {\n        _require(\n            IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165(address(_pTokensFactory)).supportsInterface(type(IPTokensFactory).interfaceId) &&\n                IERC165(address(_debtTokensFactory)).supportsInterface(type(IDebtTokensFactory).interfaceId) &&\n                IERC165(address(_bucketImplementation)).supportsInterface(type(IBucket).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        pTokensFactory = _pTokensFactory;\n        debtTokensFactory = _debtTokensFactory;\n        registry = _registry;\n    }\n\n    /**\n     * @inheritdoc IBucketsFactory\n     */\n    function createBucket(CreateBucketParams memory _params) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        IPToken newPToken = pTokensFactory.createPToken(\n            string(abi.encodePacked(\"Primex pToken \", _params.underlyingAsset.name())),\n            string(abi.encodePacked(\"P-\", _params.underlyingAsset.symbol())),\n            _params.underlyingAsset.decimals()\n        );\n\n        IDebtToken newDebtToken = debtTokensFactory.createDebtToken(\n            string(abi.encodePacked(\"Primex DebtToken \", _params.underlyingAsset.name())),\n            string(abi.encodePacked(\"debt-\", _params.underlyingAsset.symbol())),\n            _params.underlyingAsset.decimals()\n        );\n\n        bytes memory initData = abi.encodeWithSelector(\n            IBucket.initialize.selector,\n            IBucket.ConstructorParams({\n                name: _params.nameBucket,\n                pToken: newPToken,\n                debtToken: newDebtToken,\n                positionManager: IPositionManager(_params.positionManager),\n                priceOracle: IPriceOracle(_params.priceOracle),\n                dns: IPrimexDNS(_params.dns),\n                reserve: IReserve(_params.reserve),\n                whiteBlackList: IWhiteBlackList(_params.whiteBlackList),\n                assets: _params.assets,\n                borrowedAsset: _params.underlyingAsset,\n                feeBuffer: _params.feeBuffer,\n                withdrawalFeeRate: _params.withdrawalFeeRate,\n                reserveRate: _params.reserveRate,\n                liquidityMiningRewardDistributor: _params.liquidityMiningRewardDistributor,\n                liquidityMiningAmount: _params.liquidityMiningAmount,\n                liquidityMiningDeadline: _params.liquidityMiningDeadline,\n                stabilizationDuration: _params.stabilizationDuration,\n                interestRateStrategy: _params.interestRateStrategy,\n                maxAmountPerUser: _params.maxAmountPerUser,\n                isReinvestToAaveEnabled: _params.isReinvestToAaveEnabled,\n                estimatedBar: _params.estimatedBar,\n                estimatedLar: _params.estimatedLar,\n                barCalcParams: _params.barCalcParams,\n                maxTotalDeposit: _params.maxTotalDeposit\n            }),\n            registry\n        );\n        address instance = address(new BeaconProxy(address(this), initData));\n\n        newPToken.setBucket(IBucket(instance));\n        newDebtToken.setBucket(IBucket(instance));\n\n        buckets.push(instance);\n        emit BucketCreated(instance);\n    }\n\n    /**\n     * @inheritdoc IBucketsFactory\n     */\n    function setPTokensFactory(IPTokensFactory _pTokensFactory) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165(address(_pTokensFactory)).supportsInterface(type(IPTokensFactory).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        pTokensFactory = _pTokensFactory;\n        emit PTokensFactoryChanged(address(pTokensFactory));\n    }\n\n    /**\n     * @inheritdoc IBucketsFactory\n     */\n    function setDebtTokensFactory(\n        IDebtTokensFactory _debtTokensFactory\n    ) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165(address(_debtTokensFactory)).supportsInterface(type(IDebtTokensFactory).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        debtTokensFactory = _debtTokensFactory;\n        emit DebtTokensFactoryChanged(address(debtTokensFactory));\n    }\n\n    /**\n     * @inheritdoc IBucketsFactory\n     */\n    function allBuckets() external view override returns (address[] memory) {\n        return buckets;\n    }\n\n    /**\n     * @inheritdoc UpgradeableBeacon\n     */\n\n    function upgradeTo(address _bucketImplementation) public override {\n        _require(\n            IERC165(address(_bucketImplementation)).supportsInterface(type(IBucket).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        super.upgradeTo(_bucketImplementation);\n    }\n\n    /// @notice Interface checker\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IBucketsFactory).interfaceId || _interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/Bucket/BucketStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IPool} from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\nimport {IAToken} from \"@aave/core-v3/contracts/interfaces/IAToken.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport \"../libraries/Errors.sol\";\n\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IBucketStorage} from \"./IBucketStorage.sol\";\nimport {IPToken} from \"../PToken/IPToken.sol\";\nimport {IDebtToken} from \"../DebtToken/IDebtToken.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPrimexDNSStorage} from \"../PrimexDNS/IPrimexDNSStorage.sol\";\nimport {IReserve} from \"../Reserve/IReserve.sol\";\nimport {IInterestRateStrategy} from \"../interfaces/IInterestRateStrategy.sol\";\nimport {ISwapManager} from \"../interfaces/ISwapManager.sol\";\nimport {ILiquidityMiningRewardDistributor} from \"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\";\n\nabstract contract BucketStorage is IBucketStorage, ReentrancyGuardUpgradeable, ERC165Upgradeable {\n    string public override name;\n    address public override registry;\n    IPositionManager public override positionManager;\n    IReserve public override reserve;\n    IPToken public override pToken;\n    IDebtToken public override debtToken;\n    IERC20Metadata public override borrowedAsset;\n    uint256 public override feeBuffer;\n    // The current borrow rate, expressed in ray. bar = borrowing annual rate (originally APR)\n    uint128 public override bar;\n    // The current interest rate, expressed in ray. lar = lending annual rate (originally APY)\n    uint128 public override lar;\n    // The estimated borrowing annual rate, expressed in ray\n    uint128 public override estimatedBar;\n    // The estimated lending annual rate, expressed in ray\n    uint128 public override estimatedLar;\n    uint128 public override liquidityIndex;\n    uint128 public override variableBorrowIndex;\n    // block where indexes were updated\n    uint256 public lastUpdatedBlockTimestamp;\n    uint256 public override permanentLossScaled;\n    uint256 public reserveRate;\n    uint256 public override withdrawalFeeRate;\n    IWhiteBlackList public override whiteBlackList;\n    mapping(address => Asset) public override allowedAssets;\n    IInterestRateStrategy public interestRateStrategy;\n    uint256 public aaveDeposit;\n    bool public isReinvestToAaveEnabled;\n    uint256 public override maxTotalDeposit;\n    address[] internal assets;\n    // solhint-disable-next-line var-name-mixedcase\n    LiquidityMiningParams internal LMparams;\n    IPrimexDNS internal dns;\n    IPriceOracle internal priceOracle;\n}\n"
    },
    "contracts/Bucket/IBucket.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\nimport {IPToken} from \"../PToken/IPToken.sol\";\nimport {IDebtToken} from \"../DebtToken/IDebtToken.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IReserve} from \"../Reserve/IReserve.sol\";\nimport {ILiquidityMiningRewardDistributor} from \"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\";\nimport {IInterestRateStrategy} from \"../interfaces/IInterestRateStrategy.sol\";\nimport {ISwapManager} from \"../interfaces/ISwapManager.sol\";\nimport {IBucketStorage} from \"./IBucketStorage.sol\";\n\ninterface IBucket is IBucketStorage {\n    struct ConstructorParams {\n        string name;\n        IPToken pToken;\n        IDebtToken debtToken;\n        IPositionManager positionManager;\n        IPriceOracle priceOracle;\n        IPrimexDNS dns;\n        IReserve reserve;\n        IWhiteBlackList whiteBlackList;\n        address[] assets;\n        IERC20Metadata borrowedAsset;\n        uint256 feeBuffer;\n        uint256 withdrawalFeeRate;\n        uint256 reserveRate;\n        // liquidityMining params\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor;\n        uint256 liquidityMiningAmount;\n        uint256 liquidityMiningDeadline;\n        uint256 stabilizationDuration;\n        IInterestRateStrategy interestRateStrategy;\n        uint128 estimatedBar;\n        uint128 estimatedLar;\n        uint256 maxAmountPerUser;\n        bool isReinvestToAaveEnabled;\n        bytes barCalcParams;\n        uint256 maxTotalDeposit;\n    }\n\n    event Deposit(address indexed depositer, address indexed pTokenReceiver, uint256 amount);\n\n    event Withdraw(address indexed withdrawer, address indexed borrowAssetReceiver, uint256 amount);\n\n    event DepositToAave(address indexed pool, uint256 amount);\n\n    event WithdrawFromAave(address indexed pool, uint256 amount);\n\n    event TopUpTreasury(address indexed sender, uint256 amount);\n\n    event FeeBufferChanged(uint256 feeBuffer);\n\n    event ReserveRateChanged(uint256 reserveRate);\n\n    event RatesIndexesUpdated(\n        uint128 bar,\n        uint128 lar,\n        uint128 variableBorrowIndex,\n        uint128 liquidityIndex,\n        uint256 timestamp\n    );\n\n    event WithdrawalFeeChanged(uint256 withdrawalFeeRate);\n\n    event InterestRateStrategyChanged(address interestRateStrategy);\n\n    event AddAsset(address addedAsset);\n\n    event RemoveAsset(address deletedAsset);\n\n    event MaxTotalDepositChanged(uint256 maxTotalDeposit);\n\n    event BarCalculationParamsChanged(bytes params);\n\n    event BucketLaunched();\n\n    /**\n     * @dev Initializes the contract with the given parameters.\n     * @param _params The ConstructorParams struct containing initialization parameters.\n     * @param _registry The address of the registry contract.\n     */\n    function initialize(ConstructorParams memory _params, address _registry) external;\n\n    /**\n     * @dev Function to add new trading asset for this bucket\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _newAsset The address of trading asset\n     */\n    function addAsset(address _newAsset) external;\n\n    /**\n     * @notice Removes a trading asset from this bucket.\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\n     * @param _assetToDelete The address of the asset to be removed.\n     */\n    function removeAsset(address _assetToDelete) external;\n\n    function setBarCalculationParams(bytes memory _params) external;\n\n    /**\n     * @dev Sets the reserve rate.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _reserveRate The new reserve rate value.\n     */\n    function setReserveRate(uint256 _reserveRate) external;\n\n    /**\n     * @dev Sets the new fee buffer.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _feeBuffer The new fee buffer value.\n     */\n    function setFeeBuffer(uint256 _feeBuffer) external;\n\n    /**\n     * @dev Sets the withdrawal fee.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _withdrawalFee The new withdrawal fee value.\n     */\n    function setWithdrawalFee(uint256 _withdrawalFee) external;\n\n    /**\n     * @dev Sets the interest rate strategy contract address.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _interestRateStrategy The address of the interest rate strategy contract.\n     */\n    function setInterestRateStrategy(address _interestRateStrategy) external;\n\n    /**\n     * @notice The function sets the max total deposit for the particular bucket\n     * @param _maxTotalDeposit The amount of max total deposit for the bucket\n     */\n    function setMaxTotalDeposit(uint256 _maxTotalDeposit) external;\n\n    /**\n     * @dev Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.\n     * @param _pTokenReceiver The address to receive the deposited pTokens.\n     * @param _amount The amount of underlying tokens to be deposited\n     */\n    function deposit(address _pTokenReceiver, uint256 _amount) external;\n\n    /**\n     * @dev Withdraws the 'amount' of underlying asset from the bucket. The 'amount' of overlying pTokens will be burned.\n     * @param _borrowAssetReceiver The address of receiver of the borrowed asset.\n     * @param amount The amount of underlying tokens to be withdrawn.\n     */\n    function withdraw(address _borrowAssetReceiver, uint256 amount) external;\n\n    /**\n     * @notice Allows the BIG_TIMELOCK_ADMIN role to withdraw a specified amount of tokens after delisting.\n     * @param _amount The amount of tokens to withdraw.\n     */\n    function withdrawAfterDelisting(uint256 _amount) external;\n\n    /**\n     * @dev Receives a deposit and distributes it to the specified pToken receiver.\n     * @dev Can be called only by another bucket.\n     * @param _pTokenReceiver The address of the recipient of the pToken.\n     * @param _amount The amount of tokens being deposited.\n     * @param _duration The blocking time for a fixed-term deposit (if it's 0, then it will be a usual deposit)\n     * @param _bucketFrom The name of the bucket from which the deposit is being made.\n     */\n    function receiveDeposit(\n        address _pTokenReceiver,\n        uint256 _amount,\n        uint256 _duration,\n        string memory _bucketFrom\n    ) external;\n\n    /**\n     * @notice Deposits (reinvests) funds from a bucket to another bucket.\n     * Used only in the case of failed liquidity mining in the bucket from where the transfer happens.\n     * @param _bucketTo The name of the destination bucket.\n     * @param _swapManager The address of the swap manager.\n     * @param routes The array of routes for swapping tokens.\n     * @param _amountOutMin The minimum amount of tokens to receive from the swap.\n     */\n    function depositFromBucket(\n        string calldata _bucketTo,\n        ISwapManager _swapManager,\n        PrimexPricingLibrary.Route[] calldata routes,\n        uint256 _amountOutMin\n    ) external;\n\n    /**\n     * @dev Allows the SMALL_TIMELOCK_ADMIN to withdraw all liquidity from Aave to Bucket.\n     */\n    function returnLiquidityFromAaveToBucket() external;\n\n    /**\n     * @dev Function to update rates and indexes when a trader opens a trading position.\n     * Mints debt tokens to trader. Calls only by positionManager contract.\n     * @param _trader The address of the trader, who opens position.\n     * @param _amount The 'amount' for which the deal is open, and 'amount' of debtTokens will be minted to the trader.\n     * @param _to The address to transfer the borrowed asset to.\n     */\n\n    function increaseDebt(address _trader, uint256 _amount, address _to) external;\n\n    /**\n     * @dev Function to update rates and indexes.\n     * Burns debt tokens of trader. Called only by positionManager contract.\n     * @param _trader The address of the trader, who opened position.\n     * @param _debtToBurn The 'amount' of trader's debtTokens will be burned by the trader.\n     * @param _receiverOfAmountToReturn Treasury in case of liquidation. TraderBalanceVault in other cases\n     * @param _amountToReturn Amount to transfer from bucket\n     * @param _permanentLossAmount The amount of the protocol's debt to creditors accrued for this position\n     */\n    function decreaseTraderDebt(\n        address _trader,\n        uint256 _debtToBurn,\n        address _receiverOfAmountToReturn,\n        uint256 _amountToReturn,\n        uint256 _permanentLossAmount\n    ) external;\n\n    /**\n     * @notice Batch decreases the debt of multiple traders.\n     * @dev This function can only be called by the BATCH_MANAGER_ROLE.\n     * @param _traders An array of addresses representing the traders.\n     * @param _debtsToBurn An array of uint256 values representing the debts to burn for each trader.\n     * @param _receiverOfAmountToReturn The address that will receive the amount to be returned.\n     * @param _amountToReturn The amount to be returned.\n     * @param _permanentLossAmount The amount of permanent loss.\n     * @param _length The length of the traders array.\n     */\n    function batchDecreaseTradersDebt(\n        address[] memory _traders,\n        uint256[] memory _debtsToBurn,\n        address _receiverOfAmountToReturn,\n        uint256 _amountToReturn,\n        uint256 _permanentLossAmount,\n        uint256 _length\n    ) external;\n\n    /**\n     * @notice This function allows a user to pay back a permanent loss by burning his pTokens.\n     * @param amount The amount of pTokens to be burned to pay back the permanent loss.\n     */\n    function paybackPermanentLoss(uint256 amount) external;\n\n    /**\n     * @dev Calculates the permanent loss based on the scaled permanent loss and the normalized income.\n     * @return The amount of permanent loss.\n     */\n    function permanentLoss() external view returns (uint256);\n\n    /**\n     * @dev Checks if the bucket is deprecated in the protocol.\n     * @return Whether the bucket is deprecated or not.\n     */\n    function isDeprecated() external view returns (bool);\n\n    /**\n     * @dev Returns a boolean value indicating whether the bucket is delisted.\n     * @return True if the bucket is delisted, otherwise false.\n     */\n    function isDelisted() external view returns (bool);\n\n    /**\n     * @dev Checks if an admin can withdraw from the bucket after delisting.\n     * @return A boolean indicating whether withdrawal is available.\n     */\n    function isWithdrawAfterDelistingAvailable() external view returns (bool);\n\n    /**\n     * @dev Checks if this bucket is active in the protocol.\n     * @return bool True if the bucket is active, false otherwise.\n     */\n    function isActive() external view returns (bool);\n\n    /**\n     * @dev Returns the parameters for liquidity mining.\n     * @return LMparams The liquidity mining parameters.\n     */\n    function getLiquidityMiningParams() external view returns (LiquidityMiningParams memory);\n\n    /**\n     * @dev Returns a boolean value indicating whether the bucket is stable in the liquidity mining event.\n     * @return A boolean value representing the stability of the bucket.\n     */\n    function isBucketStable() external view returns (bool);\n\n    /**\n     * @dev Calculates the max leverage according to the following formula:\n     * ((1 + maintenanceBuffer) * feeBuffer) / ((1 + maintenanceBuffer) * feeBuffer - (1 - securityBuffer) *\n     * (1 - pairPriceDropBA) * (1 - oracleTolerableLimitAB) * (1 - oracleTolerableLimitBA))\n     * @param _asset The address of trading asset\n     * @return The maximum leverage as a uint256 value.\n     */\n    function maxAssetLeverage(address _asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized income per unit of underlying asset, expressed in ray\n     * @return The normalized income per unit of underlying asset, expressed in ray\n     */\n    function getNormalizedIncome() external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of underlying asset, expressed in ray\n     */\n    function getNormalizedVariableDebt() external view returns (uint256);\n\n    /**\n     * @dev Returns allowed trading assets for current bucket\n     * @return List of addresses of allowed assets\n     */\n    function getAllowedAssets() external view returns (address[] memory);\n\n    /**\n     * @dev Returns current avalable liquidity of borrowedAsset for trading.\n     * @return The amount of available borrowedAsset\n     */\n    function availableLiquidity() external view returns (uint256);\n}\n\ninterface IBucketV2 is IBucket {\n    /**\n     * @dev Deposits the 'amount' of underlying asset into the bucket. The 'PTokenReceiver' receives overlying pTokens.\n     * @param _pTokenReceiver The address to receive the deposited pTokens.\n     * @param _amount The amount of underlying tokens to be deposited\n     * @param _takeDepositFromWallet A flag indicating whether to make the deposit from user wallet\n     */\n    function deposit(address _pTokenReceiver, uint256 _amount, bool _takeDepositFromWallet) external;\n}\n"
    },
    "contracts/Bucket/IBucketsFactory.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {ILiquidityMiningRewardDistributor} from \"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\";\nimport {IInterestRateStrategy} from \"../interfaces/IInterestRateStrategy.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPTokensFactory} from \"../PToken/IPTokensFactory.sol\";\nimport {IDebtTokensFactory} from \"../DebtToken/IDebtTokensFactory.sol\";\n\ninterface IBucketsFactory {\n    /**\n     * @param nameBucket The name of the new Bucket\n     * @param positionManager The address of PositionManager\n     * @param assets The list of active assets in bucket\n     * @param pairPriceDrops The list of pairPriceDrops for active assets\n     * @param underlyingAsset The underlying asset for bucket operations\n     * @param feeBuffer The fee buffer of the bucket\n     * @param reserveRate The reserve portion of the interest that goes to the Primex reserve\n     */\n    struct CreateBucketParams {\n        string nameBucket;\n        address positionManager;\n        address priceOracle;\n        address dns;\n        address reserve;\n        address whiteBlackList;\n        address[] assets;\n        IERC20Metadata underlyingAsset;\n        uint256 feeBuffer;\n        uint256 withdrawalFeeRate;\n        uint256 reserveRate;\n        // liquidityMining params\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor;\n        uint256 liquidityMiningAmount; // if 0 liquidityMining is off\n        uint256 liquidityMiningDeadline;\n        uint256 stabilizationDuration;\n        IInterestRateStrategy interestRateStrategy;\n        uint256 maxAmountPerUser;\n        bool isReinvestToAaveEnabled;\n        uint128 estimatedBar;\n        uint128 estimatedLar;\n        bytes barCalcParams;\n        uint256 maxTotalDeposit;\n    }\n\n    event BucketCreated(address bucketAddress);\n    event PTokensFactoryChanged(address pTokensFactory);\n    event DebtTokensFactoryChanged(address debtTokensFactory);\n\n    function registry() external returns (address);\n\n    /**\n     * @notice Creates a new Bucket. Deploys bucket, pToken, debtToken contracts.\n     * @dev Only the MEDIUM_TIMELOCK_ADMIN role can call this function.\n     * @param _params The parameters for creating the bucket.\n     */\n    function createBucket(CreateBucketParams memory _params) external;\n\n    /**\n     * @notice Set a new pTokens factory contract address.\n     * @dev This function can only be called by the DEFAULT_ADMIN_ROLE.\n     * @param _pTokensFactory The address of a new pTokens factory contract to set.\n     */\n    function setPTokensFactory(IPTokensFactory _pTokensFactory) external;\n\n    /**\n     * @notice Set a new debtTokens factory contract address.\n     * @dev This function can only be called by the DEFAULT_ADMIN_ROLE.\n     * @param _debtTokensFactory The address of a new debtTokens factory contract to set.\n     */\n    function setDebtTokensFactory(IDebtTokensFactory _debtTokensFactory) external;\n\n    /**\n     * @dev Returns an array of all deployed bucket addresses.\n     * @return list of all deployed buckets\n     */\n    function allBuckets() external view returns (address[] memory);\n\n    function buckets(uint256) external view returns (address);\n}\n"
    },
    "contracts/Bucket/IBucketStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IPToken} from \"../PToken/IPToken.sol\";\nimport {IDebtToken} from \"../DebtToken/IDebtToken.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IReserve} from \"../Reserve/IReserve.sol\";\nimport {ILiquidityMiningRewardDistributor} from \"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IInterestRateStrategy} from \"../interfaces/IInterestRateStrategy.sol\";\n\ninterface IBucketStorage {\n    /**\n     * @dev Parameters of liquidity mining\n     */\n    struct LiquidityMiningParams {\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor;\n        bool isBucketLaunched;\n        uint256 accumulatingAmount;\n        uint256 deadlineTimestamp;\n        uint256 stabilizationDuration;\n        uint256 stabilizationEndTimestamp;\n        uint256 maxAmountPerUser; // if maxAmountPerUser is >= accumulatingAmount then check on maxAmountPerUser is off\n        // Constant max variables are used for calculating users' points.\n        // These intervals are used for fair distribution of points among Lenders.\n        // Lenders who brought liquidity earlier receive more than the ones who deposited later.\n        // To get maximum points per token, a Lender should deposit immediately after the Bucket deployment.\n        uint256 maxDuration;\n        uint256 maxStabilizationEndTimestamp;\n    }\n    //                                        1. Corner case of bucket launch\n    //\n    //                                              maxDuration\n    //       ------------------------------------------------------------------------------------------------\n    //      |                                                                                               |\n    //      |                                                                        stabilizationDuration  |\n    //      |                                                                      -------------------------|\n    //      |                                                                     | bucket launch           |\n    //   +--+---------------------------------------------------------------------+-------------------------+------> time\n    //      bucket deploy                                                         deadlineTimestamp         maxStabilizationEndTimestamp\n    //                                                                                                       (=stabilizationEndTimestamp here)\n    //                                  (corner case of bucket launch)\n\n    //                                        2. One of cases of bucket launch\n    //\n    //      |                     stabilizationDuration\n    //      |                   -------------------------\n    //      |                  |                         |\n    //   +--+------------------+-------------------------+------------------------+-------------------------+------> time\n    //      bucket deploy      bucket launch            stabilizationEndTimestamp  deadlineTimestamp        maxStabilizationEndTimestamp\n    //                                                                            (after deadline bucket can't be launched)\n\n    struct Asset {\n        uint256 index;\n        bool isSupported;\n    }\n\n    function liquidityIndex() external returns (uint128);\n\n    function variableBorrowIndex() external returns (uint128);\n\n    function name() external view returns (string memory);\n\n    function registry() external view returns (address);\n\n    function positionManager() external view returns (IPositionManager);\n\n    function reserve() external view returns (IReserve);\n\n    function permanentLossScaled() external view returns (uint256);\n\n    function pToken() external view returns (IPToken);\n\n    function debtToken() external view returns (IDebtToken);\n\n    function borrowedAsset() external view returns (IERC20Metadata);\n\n    function feeBuffer() external view returns (uint256);\n\n    function withdrawalFeeRate() external view returns (uint256);\n\n    /**\n     * @notice bar = borrowing annual rate (originally APR)\n     */\n    function bar() external view returns (uint128);\n\n    /**\n     * @notice lar = lending annual rate (originally APY)\n     */\n    function lar() external view returns (uint128);\n\n    function interestRateStrategy() external view returns (IInterestRateStrategy);\n\n    function estimatedBar() external view returns (uint128);\n\n    function estimatedLar() external view returns (uint128);\n\n    function allowedAssets(address _asset) external view returns (uint256, bool);\n\n    function whiteBlackList() external view returns (IWhiteBlackList);\n\n    function maxTotalDeposit() external view returns (uint256);\n}\n"
    },
    "contracts/conditionalManagers/LimitPriceCOM.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport \"./../libraries/Errors.sol\";\n\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {ILimitPriceCOM} from \"../interfaces/ILimitPriceCOM.sol\";\nimport {IConditionalOpeningManager} from \"../interfaces/IConditionalOpeningManager.sol\";\nimport {ITakeProfitStopLossCCM} from \"../interfaces/ITakeProfitStopLossCCM.sol\";\n\ncontract LimitPriceCOM is IConditionalOpeningManager, ILimitPriceCOM, IERC165 {\n    using WadRayMath for uint256;\n\n    uint256 private constant CM_TYPE = 1;\n\n    address public immutable primexDNS;\n    address public immutable priceOracle;\n    address public immutable pm;\n\n    constructor(address _primexDNS, address _priceOracle, address _pm) {\n        _require(\n            IERC165(address(_primexDNS)).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId) &&\n                IERC165(_pm).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        primexDNS = _primexDNS;\n        priceOracle = _priceOracle;\n        pm = _pm;\n    }\n\n    /**\n     * @inheritdoc IConditionalOpeningManager\n     */\n    function canBeFilledBeforeSwap(\n        LimitOrderLibrary.LimitOrder calldata _order,\n        bytes calldata _params,\n        bytes calldata _additionalParams\n    ) external override returns (bool) {\n        if (_params.length == 0) return false;\n\n        CanBeFilledVars memory vars;\n        vars.params = abi.decode(_params, (CanBeFilledParams));\n        vars.additionalParams = abi.decode(_additionalParams, (AdditionalParams));\n\n        vars.borrowedAsset = _order.leverage == WadRayMath.WAD\n            ? _order.depositAsset\n            : address(_order.bucket.borrowedAsset());\n\n        vars.dexAdapter = address(IPrimexDNS(primexDNS).dexAdapter());\n        vars.isThirdAsset = _order.depositAsset != vars.borrowedAsset && _order.depositAsset != _order.positionAsset;\n        if (!vars.isThirdAsset) {\n            _require(\n                vars.additionalParams.depositInThirdAssetRoutes.length == 0,\n                Errors.DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0.selector\n            );\n        } else {\n            vars.depositInPositionAsset = PrimexPricingLibrary.getAmountOut(\n                PrimexPricingLibrary.AmountParams({\n                    tokenA: _order.depositAsset,\n                    tokenB: _order.positionAsset,\n                    amount: _order.depositAmount,\n                    routes: vars.additionalParams.depositInThirdAssetRoutes,\n                    dexAdapter: vars.dexAdapter,\n                    primexDNS: primexDNS\n                })\n            );\n        }\n\n        if (_order.depositAsset == vars.borrowedAsset) {\n            vars.amountIn = _order.depositAmount.wmul(_order.leverage);\n            vars.amountToTransfer = vars.amountIn;\n        } else {\n            if (_order.depositAsset == _order.positionAsset) vars.depositInPositionAsset = _order.depositAmount;\n            uint256 depositAmountInBorrowed = PrimexPricingLibrary.getOracleAmountsOut(\n                _order.depositAsset,\n                vars.borrowedAsset,\n                _order.depositAmount,\n                priceOracle\n            );\n            vars.amountIn = depositAmountInBorrowed.wmul(_order.leverage);\n            vars.amountToTransfer = vars.amountIn - depositAmountInBorrowed;\n        }\n        vars.borrowedAmountInPositionAsset = PrimexPricingLibrary.getAmountOut(\n            PrimexPricingLibrary.AmountParams({\n                tokenA: vars.borrowedAsset,\n                tokenB: _order.positionAsset,\n                amount: vars.amountToTransfer,\n                routes: vars.additionalParams.firstAssetRoutes,\n                dexAdapter: vars.dexAdapter,\n                primexDNS: primexDNS\n            })\n        );\n\n        vars.amountOut = vars.depositInPositionAsset + vars.borrowedAmountInPositionAsset;\n\n        vars.borrowedAssetMultiplier = (10 ** (18 - IERC20Metadata(vars.borrowedAsset).decimals()));\n\n        vars.exchangeRate =\n            (vars.amountIn * vars.borrowedAssetMultiplier).wdiv(\n                vars.amountOut * (10 ** (18 - IERC20Metadata(_order.positionAsset).decimals()))\n            ) /\n            vars.borrowedAssetMultiplier;\n\n        if (vars.exchangeRate > vars.params.limitPrice) return false;\n\n        if (_order.leverage > WadRayMath.WAD) {\n            uint256 leverage;\n            if (_order.depositAsset == vars.borrowedAsset) {\n                leverage = _order.leverage;\n            } else {\n                leverage = (vars.borrowedAmountInPositionAsset + vars.depositInPositionAsset).wdiv(\n                    vars.depositInPositionAsset\n                );\n            }\n            if (leverage > _order.bucket.maxAssetLeverage(_order.positionAsset)) return false;\n\n            if (vars.amountOut > IPositionManager(pm).maxPositionSize(vars.borrowedAsset, _order.positionAsset)) {\n                return false;\n            }\n        }\n\n        return\n            PrimexPricingLibrary.isCorrespondsMinPositionSize(\n                IPositionManager(pm).minPositionSize(),\n                IPositionManager(pm).minPositionAsset(),\n                vars.borrowedAsset,\n                vars.amountIn,\n                priceOracle\n            );\n    }\n\n    /**\n     * @inheritdoc IConditionalOpeningManager\n     */\n    function canBeFilledAfterSwap(\n        LimitOrderLibrary.LimitOrder calldata,\n        bytes calldata _params,\n        bytes calldata,\n        uint256 _exchangeRate\n    ) external pure override returns (bool) {\n        if (_params.length == 0) {\n            return false;\n        }\n        CanBeFilledVars memory vars;\n        vars.params = abi.decode(_params, (CanBeFilledParams));\n        return _exchangeRate <= vars.params.limitPrice;\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IConditionalOpeningManager).interfaceId ||\n            _interfaceId == type(ILimitPriceCOM).interfaceId ||\n            _interfaceId == type(IERC165).interfaceId;\n    }\n\n    /**\n     * @inheritdoc ILimitPriceCOM\n     */\n    function getLimitPrice(bytes calldata _params) public pure override returns (uint256) {\n        CanBeFilledParams memory params;\n        if (_params.length > 0) {\n            params = abi.decode(_params, (CanBeFilledParams));\n        }\n        return (params.limitPrice);\n    }\n}\n"
    },
    "contracts/conditionalManagers/TakeProfitStopLossCCM.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport \"./../libraries/Errors.sol\";\n\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IConditionalClosingManager} from \"../interfaces/IConditionalClosingManager.sol\";\nimport {ITakeProfitStopLossCCM} from \"../interfaces/ITakeProfitStopLossCCM.sol\";\n\ncontract TakeProfitStopLossCCM is IConditionalClosingManager, ITakeProfitStopLossCCM, IERC165 {\n    using WadRayMath for uint256;\n\n    uint256 private constant CM_TYPE = 2;\n\n    address public immutable primexDNS;\n    address public immutable priceOracle;\n\n    constructor(address _primexDNS, address _priceOracle) {\n        _require(\n            IERC165(address(_primexDNS)).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        primexDNS = _primexDNS;\n        priceOracle = _priceOracle;\n    }\n\n    /**\n     * @inheritdoc IConditionalClosingManager\n     */\n    function canBeClosedBeforeSwap(\n        PositionLibrary.Position calldata _position,\n        bytes calldata _params,\n        bytes calldata _additionalParams\n    ) external override returns (bool) {\n        if (_params.length == 0) return false;\n        CanBeClosedParams memory params = abi.decode(_params, (CanBeClosedParams));\n        if (_additionalParams.length > 0) {\n            AdditionalParams memory additionalParams = abi.decode(_additionalParams, (AdditionalParams));\n            return isTakeProfitReached(_position, params.takeProfitPrice, additionalParams.routes);\n        }\n        return isStopLossReached(_position, params.stopLossPrice);\n    }\n\n    /**\n     * @inheritdoc IConditionalClosingManager\n     */\n    function canBeClosedAfterSwap(\n        PositionLibrary.Position calldata _position,\n        bytes calldata _params,\n        bytes calldata,\n        uint256 _closeAmount,\n        uint256 _borowedAssetAmount\n    ) external view override returns (bool) {\n        if (_params.length == 0) return false;\n        uint256 multiplierAssetOut = 10 ** (18 - IERC20Metadata(_position.soldAsset).decimals());\n        uint256 multiplierAssetIn = 10 ** (18 - IERC20Metadata(_position.positionAsset).decimals());\n        uint256 exchangeRate = (_borowedAssetAmount * multiplierAssetOut).wdiv(_closeAmount * multiplierAssetIn) /\n            multiplierAssetOut;\n        CanBeClosedParams memory params = abi.decode(_params, (CanBeClosedParams));\n        return ((params.takeProfitPrice > 0 && exchangeRate >= params.takeProfitPrice) ||\n            isStopLossReached(_position, params.stopLossPrice));\n    }\n\n    /**\n     * @inheritdoc ITakeProfitStopLossCCM\n     */\n    function isTakeProfitReached(\n        PositionLibrary.Position calldata _position,\n        uint256 takeProfitPrice,\n        PrimexPricingLibrary.Route[] memory routes\n    ) public override returns (bool) {\n        (, uint256 takeProfitAmount) = _calcTakeProfitStopLossAmounts(\n            _position.positionAsset,\n            _position.soldAsset,\n            _position.positionAmount,\n            0,\n            takeProfitPrice\n        );\n\n        if (takeProfitAmount > 0) {\n            return\n                takeProfitAmount <=\n                PrimexPricingLibrary.getAmountOut(\n                    PrimexPricingLibrary.AmountParams({\n                        tokenA: _position.positionAsset,\n                        tokenB: _position.soldAsset,\n                        amount: _position.positionAmount,\n                        routes: routes,\n                        dexAdapter: IPrimexDNS(primexDNS).dexAdapter(),\n                        primexDNS: primexDNS\n                    })\n                );\n        }\n        return false;\n    }\n\n    /**\n     * @inheritdoc ITakeProfitStopLossCCM\n     */\n    function isStopLossReached(\n        PositionLibrary.Position calldata _position,\n        uint256 stopLossPrice\n    ) public view override returns (bool) {\n        if (stopLossPrice == 0) return false;\n        (uint256 exchangeRate, bool isForward) = IPriceOracle(priceOracle).getExchangeRate(\n            _position.positionAsset,\n            _position.soldAsset\n        );\n        return isForward ? stopLossPrice >= exchangeRate : stopLossPrice >= WadRayMath.WAD.wdiv(exchangeRate);\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IERC165).interfaceId ||\n            _interfaceId == type(IConditionalClosingManager).interfaceId ||\n            _interfaceId == type(ITakeProfitStopLossCCM).interfaceId;\n    }\n\n    /**\n     * @inheritdoc ITakeProfitStopLossCCM\n     */\n    function isTakeProfitReached(bytes calldata _params, uint256 exchangeRate) public pure override returns (bool) {\n        CanBeClosedParams memory params = abi.decode(_params, (CanBeClosedParams));\n        return params.takeProfitPrice > 0 && params.takeProfitPrice <= exchangeRate;\n    }\n\n    /**\n     * @inheritdoc ITakeProfitStopLossCCM\n     */\n    function isStopLossReached(bytes calldata _params, uint256 oracleExchangeRate) public pure override returns (bool) {\n        CanBeClosedParams memory params = abi.decode(_params, (CanBeClosedParams));\n        return params.stopLossPrice >= oracleExchangeRate;\n    }\n\n    /**\n     * @inheritdoc ITakeProfitStopLossCCM\n     */\n    function getTakeProfitStopLossPrices(bytes calldata _params) public pure override returns (uint256, uint256) {\n        CanBeClosedParams memory params;\n        if (_params.length > 0) {\n            params = abi.decode(_params, (CanBeClosedParams));\n        }\n        return (params.takeProfitPrice, params.stopLossPrice);\n    }\n\n    /**\n     * @notice Calculates the stop loss and take profit amounts based on the provided parameters.\n     * @param positionAsset The address of the position asset.\n     * @param borrowedAsset The address of the borrowed asset.\n     * @param positionAmount The amount of the position.\n     * @param stopLossPrice The stop loss price.\n     * @param takeProfitPrice The take profit price.\n     * @return stopLossAmount The calculated stop loss amount, measured in the same decimal format as the borrowed asset.\n     * @return takeProfitAmount The calculated take profit amount, measured in the same decimal format as the borrowed asset.\n     */\n    function _calcTakeProfitStopLossAmounts(\n        address positionAsset,\n        address borrowedAsset,\n        uint256 positionAmount,\n        uint256 stopLossPrice,\n        uint256 takeProfitPrice\n    ) internal view returns (uint256 stopLossAmount, uint256 takeProfitAmount) {\n        uint256 multiplier1 = 10 ** (18 - IERC20Metadata(positionAsset).decimals());\n        uint256 multiplier2 = 10 ** (18 - IERC20Metadata(borrowedAsset).decimals());\n        if (stopLossPrice != 0) {\n            /**@notice  converts the positionAmount to the WAD format\n                and then converts to the decimal format of the borrowed asset if necessary*/\n            stopLossAmount = (positionAmount * multiplier1).wmul(stopLossPrice) / multiplier2;\n        }\n        if (takeProfitPrice != 0) {\n            takeProfitAmount = (positionAmount * multiplier1).wmul(takeProfitPrice) / multiplier2;\n        }\n    }\n}\n"
    },
    "contracts/conditionalManagers/TrailingStopCCM.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport \"./../libraries/Errors.sol\";\n\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IConditionalClosingManager} from \"../interfaces/IConditionalClosingManager.sol\";\nimport {ITrailingStopCCM} from \"../interfaces/ITrailingStopCCM.sol\";\n\ncontract TrailingStopCCM is IConditionalClosingManager, ITrailingStopCCM, IERC165 {\n    using WadRayMath for uint256;\n\n    uint256 private constant CM_TYPE = 3;\n\n    IPriceOracle public immutable priceOracle;\n\n    constructor(address _priceOracle) {\n        _require(\n            IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        priceOracle = IPriceOracle(_priceOracle);\n    }\n\n    /**\n     * @inheritdoc IConditionalClosingManager\n     */\n    function canBeClosedBeforeSwap(\n        PositionLibrary.Position calldata _position,\n        bytes calldata _params,\n        bytes calldata _additionalParams\n    ) public view override returns (bool result) {\n        if (_params.length == 0 || _additionalParams.length == 0) return false;\n        CanBeClosedParams memory params = abi.decode(_params, (CanBeClosedParams));\n        AdditionalParams memory additionalParams = abi.decode(_additionalParams, (AdditionalParams));\n        (result, ) = _canBeClosed(\n            _position,\n            additionalParams.lowPriceRoundNumber,\n            additionalParams.highPriceRoundNumber,\n            params\n        );\n    }\n\n    /**\n     * @inheritdoc IConditionalClosingManager\n     */\n    function canBeClosedAfterSwap(\n        PositionLibrary.Position calldata _position,\n        bytes calldata _params,\n        bytes calldata _additionalParams,\n        uint256,\n        uint256\n    ) public view override returns (bool) {\n        return canBeClosedBeforeSwap(_position, _params, _additionalParams);\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IERC165).interfaceId ||\n            _interfaceId == type(IConditionalClosingManager).interfaceId ||\n            _interfaceId == type(ITrailingStopCCM).interfaceId;\n    }\n\n    /**\n     * @notice Checks if a position can be closed.\n     * @dev The round numbers represent the specific round of price data to\n     fetch from the price feeds for the base asset and quote asset.\n     * @param _position The position details.\n     * @param _lowPriceRoundNumbers The low price round numbers.\n     * @param _highPriceRoundNumbers The high price round numbers.\n     * @param _params The parameters for closing the position.\n     * @return A tuple indicating whether the position can be closed and\n     the minPossibleTime, that indicates the earliest point in time at which the low price might have occurred.\n     */\n    function _canBeClosed(\n        PositionLibrary.Position calldata _position,\n        uint80[2] memory _lowPriceRoundNumbers,\n        uint80[2] memory _highPriceRoundNumbers,\n        CanBeClosedParams memory _params\n    ) internal view returns (bool, uint256) {\n        _require(\n            _lowPriceRoundNumbers[0] >= _highPriceRoundNumbers[0] &&\n                _lowPriceRoundNumbers[1] >= _highPriceRoundNumbers[1],\n            Errors.LOW_PRICE_ROUND_IS_LESS_HIGH_PRICE_ROUND.selector\n        );\n\n        (address basePriceFeed, address quotePriceFeed) = priceOracle.getPriceFeedsPair(\n            _position.positionAsset,\n            _position.soldAsset\n        );\n\n        (uint256 highPrice, ) = _getPriceFromFeeds(\n            _position,\n            basePriceFeed,\n            quotePriceFeed,\n            _highPriceRoundNumbers[0],\n            _highPriceRoundNumbers[1],\n            true\n        );\n        if (highPrice < _params.activationPrice) return (false, 0);\n\n        (uint256 lowPrice, uint256 minPossibleTime) = _getPriceFromFeeds(\n            _position,\n            basePriceFeed,\n            quotePriceFeed,\n            _lowPriceRoundNumbers[0],\n            _lowPriceRoundNumbers[1],\n            false // lowPrice timestamp is higher than highPrice timestamp, so no need to check it\n        );\n        return (lowPrice < highPrice.wmul(WadRayMath.WAD - _params.trailingDelta), minPossibleTime);\n    }\n\n    /**\n     * @notice Calculates the price from price feeds for a given position.\n     * @param position The position for which the price needs to be calculated.\n     * @param basePriceFeed The address of the base price feed.\n     * @param quotePriceFeed The address of the quote price feed.\n     * @param roundBaseFeed The round ID of the base price feed.\n     * @param roundQuoteFeed The round ID of the quote price feed.\n     * @param needCheckTimestamp A boolean flag indicating whether to check the timestamp.\n     * @return The calculated price in WAD format as ratio between the base price and the quote price,\n     and the timestamp of the latest price.\n     */\n    function _getPriceFromFeeds(\n        PositionLibrary.Position calldata position,\n        address basePriceFeed,\n        address quotePriceFeed,\n        uint80 roundBaseFeed,\n        uint80 roundQuoteFeed,\n        bool needCheckTimestamp\n    ) internal view returns (uint256, uint256) {\n        return\n            PrimexPricingLibrary.getPriceFromFeeds(\n                AggregatorV3Interface(basePriceFeed),\n                AggregatorV3Interface(quotePriceFeed),\n                roundBaseFeed,\n                roundQuoteFeed,\n                needCheckTimestamp ? position.createdAt : 0\n            );\n    }\n}\n"
    },
    "contracts/Constants.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\n// admin roles\nbytes32 constant BIG_TIMELOCK_ADMIN = 0x00; // It's primary admin.\nbytes32 constant MEDIUM_TIMELOCK_ADMIN = keccak256(\"MEDIUM_TIMELOCK_ADMIN\");\nbytes32 constant SMALL_TIMELOCK_ADMIN = keccak256(\"SMALL_TIMELOCK_ADMIN\");\nbytes32 constant EMERGENCY_ADMIN = keccak256(\"EMERGENCY_ADMIN\");\nbytes32 constant GUARDIAN_ADMIN = keccak256(\"GUARDIAN_ADMIN\");\nbytes32 constant NFT_MINTER = keccak256(\"NFT_MINTER\");\nbytes32 constant TRUSTED_TOLERABLE_LIMIT_ROLE = keccak256(\"TRUSTED_TOLERABLE_LIMIT_ROLE\");\n\n// inter-contract interactions roles\nbytes32 constant NO_FEE_ROLE = keccak256(\"NO_FEE_ROLE\");\nbytes32 constant VAULT_ACCESS_ROLE = keccak256(\"VAULT_ACCESS_ROLE\");\nbytes32 constant PM_ROLE = keccak256(\"PM_ROLE\");\nbytes32 constant LOM_ROLE = keccak256(\"LOM_ROLE\");\nbytes32 constant BATCH_MANAGER_ROLE = keccak256(\"BATCH_MANAGER_ROLE\");\n\n// token constants\naddress constant NATIVE_CURRENCY = address(uint160(bytes20(keccak256(\"NATIVE_CURRENCY\"))));\naddress constant USD = 0x0000000000000000000000000000000000000348;\nuint256 constant USD_MULTIPLIER = 10 ** (18 - 8); // usd decimals in chainlink is 8\nuint8 constant MAX_ASSET_DECIMALS = 18;\n\n// time constants\nuint256 constant SECONDS_PER_YEAR = 365 days;\nuint256 constant SECONDS_PER_DAY = 1 days;\nuint256 constant HOUR = 1 hours;\nuint256 constant TEN_WAD = 10 ether;\n"
    },
    "contracts/DebtToken/DebtToken.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport \"./DebtTokenStorage.sol\";\nimport {BIG_TIMELOCK_ADMIN} from \"../Constants.sol\";\nimport {IDebtToken, IERC20Upgradeable, IERC165Upgradeable, IAccessControl, IActivityRewardDistributor} from \"./IDebtToken.sol\";\n\ncontract DebtToken is IDebtToken, DebtTokenStorage {\n    using WadRayMath for uint256;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Throws if called by any account other than the bucket.\n     */\n    modifier onlyBucket() {\n        _require(address(bucket) == msg.sender, Errors.CALLER_IS_NOT_BUCKET.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(bucket.registry()).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc IDebtToken\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _bucketsFactory\n    ) public override initializer {\n        __ERC20_init(_name, _symbol);\n        __ERC165_init();\n        _tokenDecimals = _decimals;\n        bucketsFactory = _bucketsFactory;\n    }\n\n    /**\n     * @inheritdoc IDebtToken\n     */\n    function setBucket(IBucket _bucket) external override {\n        _require(msg.sender == bucketsFactory, Errors.FORBIDDEN.selector);\n        _require(address(bucket) == address(0), Errors.BUCKET_IS_IMMUTABLE.selector);\n        _require(\n            IERC165Upgradeable(address(_bucket)).supportsInterface(type(IBucket).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        bucket = _bucket;\n    }\n\n    /**\n     * @inheritdoc IDebtToken\n     */\n    function setFeeDecreaser(IFeeExecutor _feeDecreaser) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            address(_feeDecreaser) == address(0) ||\n                IERC165Upgradeable(address(_feeDecreaser)).supportsInterface(type(IFeeExecutor).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        feeDecreaser = _feeDecreaser;\n    }\n\n    /**\n     * @inheritdoc IDebtToken\n     */\n    function setTraderRewardDistributor(\n        IActivityRewardDistributor _traderRewardDistributor\n    ) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            address(_traderRewardDistributor) == address(0) ||\n                IERC165Upgradeable(address(_traderRewardDistributor)).supportsInterface(\n                    type(IActivityRewardDistributor).interfaceId\n                ),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        traderRewardDistributor = _traderRewardDistributor;\n    }\n\n    /**\n     * @inheritdoc IDebtToken\n     */\n    function mint(address _user, uint256 _amount, uint256 _index) external override onlyBucket {\n        _require(_user != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        _require(_amount != 0, Errors.AMOUNT_IS_0.selector);\n        uint256 amountScaled = _amount.rdiv(_index);\n        _require(amountScaled != 0, Errors.INVALID_MINT_AMOUNT.selector);\n        if (address(feeDecreaser) != address(0)) {\n            //in this case the _index will be equal to the getNormalizedVariableDebt()\n            try feeDecreaser.updateBonus(_user, scaledBalanceOf(_user), address(bucket), _index) {} catch {\n                emit Errors.Log(Errors.FEE_DECREASER_CALL_FAILED.selector);\n            }\n        }\n\n        _mint(_user, amountScaled);\n\n        if (address(traderRewardDistributor) != address(0)) {\n            try\n                traderRewardDistributor.updateUserActivity(\n                    bucket,\n                    _user,\n                    scaledBalanceOf(_user),\n                    IActivityRewardDistributor.Role.TRADER\n                )\n            {} catch {\n                emit Errors.Log(Errors.TRADER_REWARD_DISTRIBUTOR_CALL_FAILED.selector);\n            }\n        }\n\n        emit Mint(_user, _amount);\n    }\n\n    /**\n     * @inheritdoc IDebtToken\n     */\n    function burn(address _user, uint256 _amount, uint256 _index) external override onlyBucket {\n        _require(_user != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        _require(_amount != 0, Errors.AMOUNT_IS_0.selector); //do we need this?\n        uint256 amountScaled = _amount.rdiv(_index);\n        _require(amountScaled != 0, Errors.INVALID_BURN_AMOUNT.selector);\n        if (address(feeDecreaser) != address(0)) {\n            //in this case the _index will be equal to the getNormalizedVariableDebt()\n            try feeDecreaser.updateBonus(_user, scaledBalanceOf(_user), address(bucket), _index) {} catch {\n                emit Errors.Log(Errors.FEE_DECREASER_CALL_FAILED.selector);\n            }\n        }\n\n        _burn(_user, amountScaled);\n\n        if (address(traderRewardDistributor) != address(0)) {\n            try\n                traderRewardDistributor.updateUserActivity(\n                    bucket,\n                    _user,\n                    scaledBalanceOf(_user),\n                    IActivityRewardDistributor.Role.TRADER\n                )\n            {} catch {\n                emit Errors.Log(Errors.TRADER_REWARD_DISTRIBUTOR_CALL_FAILED.selector);\n            }\n        }\n\n        emit Burn(_user, _amount);\n    }\n\n    /**\n     * @inheritdoc IDebtToken\n     */\n    function batchBurn(\n        address[] memory _users,\n        uint256[] memory _amounts,\n        uint256 _index,\n        uint256 _length\n    ) external override onlyBucket {\n        uint256[] memory amountsScaled = new uint256[](_length);\n        uint256[] memory scaledBalances = new uint256[](_length);\n        bool hasFeeDecreaser = address(feeDecreaser) != address(0);\n        bool hasRewardDistributor = address(traderRewardDistributor) != address(0);\n\n        for (uint256 i; i < _length; i++) {\n            amountsScaled[i] = _amounts[i].rdiv(_index);\n            if (hasFeeDecreaser) scaledBalances[i] = scaledBalanceOf(_users[i]);\n        }\n\n        if (hasFeeDecreaser) {\n            //in this case the _index will be equal to the getNormalizedVariableDebt()\n            try feeDecreaser.updateBonuses(_users, scaledBalances, address(bucket), _index) {} catch {\n                emit Errors.Log(Errors.FEE_DECREASER_CALL_FAILED.selector);\n            }\n        }\n\n        for (uint256 i; i < _length; i++) {\n            if (amountsScaled[i] > 0) {\n                _burn(_users[i], amountsScaled[i]);\n                if (hasRewardDistributor) scaledBalances[i] = scaledBalanceOf(_users[i]);\n            }\n            emit Burn(_users[i], _amounts[i]);\n        }\n\n        if (hasRewardDistributor) {\n            try\n                traderRewardDistributor.updateUsersActivities(\n                    bucket,\n                    _users,\n                    scaledBalances,\n                    _length,\n                    IActivityRewardDistributor.Role.TRADER\n                )\n            {} catch {\n                emit Errors.Log(Errors.TRADER_REWARD_DISTRIBUTOR_CALL_FAILED.selector);\n            }\n        }\n    }\n\n    /**\n     * @dev Locked transfer function to disable DebtToken transfers\n     */\n    function transfer(\n        address,\n        uint256\n    ) public view virtual override(ERC20Upgradeable, IERC20Upgradeable) returns (bool) {\n        _revert(Errors.TRANSFER_NOT_SUPPORTED.selector);\n    }\n\n    /**\n     * @dev Locked approve function to disable DebtToken transfers\n     */\n    function approve(\n        address,\n        uint256\n    ) public view virtual override(ERC20Upgradeable, IERC20Upgradeable) returns (bool) {\n        _revert(Errors.APPROVE_NOT_SUPPORTED.selector);\n    }\n\n    /**\n     * @dev Locked transferFrom function to disable DebtToken transfers\n     */\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public view virtual override(ERC20Upgradeable, IERC20Upgradeable) returns (bool) {\n        _revert(Errors.TRANSFER_NOT_SUPPORTED.selector);\n    }\n\n    /**\n     * @return decimals of the DebtToken according to bucket borrowedAsset.\n     */\n    function decimals() public view override returns (uint8) {\n        return _tokenDecimals;\n    }\n\n    /**\n     * @dev Locked increaseAllowance function to disable DebtToken transfers\n     */\n    function increaseAllowance(address, uint256) public view virtual override returns (bool) {\n        _revert(Errors.APPROVE_NOT_SUPPORTED.selector);\n    }\n\n    /**\n     * @dev Locked decreaseAllowance function to disable DebtToken transfers\n     */\n    function decreaseAllowance(address, uint256) public view virtual override returns (bool) {\n        _revert(Errors.APPROVE_NOT_SUPPORTED.selector);\n    }\n\n    /**\n     * @dev Returns current borrower's debt (principal + %)\n     * @param _user Address of borrower\n     **/\n    function balanceOf(address _user) public view override(ERC20Upgradeable, IERC20Upgradeable) returns (uint256) {\n        return super.balanceOf(_user).rmul(bucket.getNormalizedVariableDebt());\n    }\n\n    /**\n     * @inheritdoc IDebtToken\n     */\n    function scaledBalanceOf(address _user) public view override returns (uint256) {\n        return super.balanceOf(_user);\n    }\n\n    /**\n     * @inheritdoc IDebtToken\n     */\n    function scaledTotalSupply() public view virtual override returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /**\n     * @dev Calculets the total supply of the debtToken.\n     * It increments over blocks mining.\n     * @return The current total supply of the debtToken.\n     */\n    function totalSupply() public view override(ERC20Upgradeable, IERC20Upgradeable) returns (uint256) {\n        return super.totalSupply().rmul(bucket.getNormalizedVariableDebt());\n    }\n\n    /// @notice Interface checker\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IDebtToken).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "contracts/DebtToken/DebtTokenFactory.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport {DebtToken} from \"./DebtToken.sol\";\nimport {BIG_TIMELOCK_ADMIN} from \"../Constants.sol\";\nimport {IDebtTokensFactory} from \"./IDebtTokensFactory.sol\";\nimport {IDebtToken} from \"./IDebtToken.sol\";\nimport {IBucketsFactory} from \"../Bucket/IBucketsFactory.sol\";\n\ncontract DebtTokensFactory is UpgradeableBeacon, IDebtTokensFactory, IERC165 {\n    address public override bucketsFactory;\n    address public override registry;\n\n    event DebtTokenCreated(address debtAddress);\n\n    /**\n     * @dev Throws if called by any account other than the bucket.\n     */\n    modifier onlyBucketsFactory() {\n        _require(bucketsFactory == msg.sender, Errors.CALLER_IS_NOT_A_BUCKET_FACTORY.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(address _debtTokenImplementation, address _registry) UpgradeableBeacon(_debtTokenImplementation) {\n        _require(\n            IERC165(_debtTokenImplementation).supportsInterface(type(IDebtToken).interfaceId) &&\n                IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n    }\n\n    /**\n     * @inheritdoc IDebtTokensFactory\n     */\n    function createDebtToken(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) external override onlyBucketsFactory returns (IDebtToken) {\n        bytes memory initData = abi.encodeWithSelector(\n            IDebtToken.initialize.selector,\n            _name,\n            _symbol,\n            _decimals,\n            bucketsFactory\n        );\n        address instance = address(new BeaconProxy(address(this), initData));\n        emit DebtTokenCreated(instance);\n        return IDebtToken(instance);\n    }\n\n    /**\n     * @inheritdoc IDebtTokensFactory\n     */\n    function setBucketsFactory(address _bucketsFactory) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165(_bucketsFactory).supportsInterface(type(IBucketsFactory).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        bucketsFactory = _bucketsFactory;\n    }\n\n    /**\n     * @inheritdoc UpgradeableBeacon\n     */\n\n    function upgradeTo(address _debtTokenImplementation) public override {\n        _require(\n            IERC165(_debtTokenImplementation).supportsInterface(type(IDebtToken).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        super.upgradeTo(_debtTokenImplementation);\n    }\n\n    /// @notice Interface checker\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IDebtTokensFactory).interfaceId || _interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/DebtToken/DebtTokenStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport {IDebtTokenStorage, IBucket, IFeeExecutor, IActivityRewardDistributor} from \"./IDebtTokenStorage.sol\";\n\nabstract contract DebtTokenStorage is IDebtTokenStorage, ERC20Upgradeable, ERC165Upgradeable {\n    IBucket public override bucket;\n    IFeeExecutor public override feeDecreaser;\n    IActivityRewardDistributor public override traderRewardDistributor;\n    address internal bucketsFactory;\n    uint8 internal _tokenDecimals;\n}\n"
    },
    "contracts/DebtToken/IDebtToken.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\n\nimport {IDebtTokenStorage, IBucket, IFeeExecutor, IERC20Upgradeable, IActivityRewardDistributor} from \"./IDebtTokenStorage.sol\";\n\ninterface IDebtToken is IDebtTokenStorage {\n    /**\n     * @dev Emitted after the mint action\n     * @param from The address performing the mint\n     * @param value The amount being\n     **/\n    event Mint(address indexed from, uint256 value);\n\n    /**\n     * @dev Emitted after DebtTokens are burned\n     * @param from The owner of the aTokens, getting them burned\n     * @param value The amount being burned\n     **/\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * @dev contract initializer\n     * @param _name The name of the ERC20 token.\n     * @param _symbol The symbol of the ERC20 token.\n     * @param _decimals The number of decimals for the ERC20 token.\n     * @param _bucketsFactory Address of the buckets factory that will call the setBucket fucntion\n     */\n    function initialize(string memory _name, string memory _symbol, uint8 _decimals, address _bucketsFactory) external;\n\n    /**\n     * @dev Sets the bucket for the contract.\n     * @param _bucket The address of the bucket to set.\n     */\n    function setBucket(IBucket _bucket) external;\n\n    /**\n     * @dev Sets the FeeDecreaser for current DebtToken.\n     * @param _feeDecreaser The interest increaser address.\n     */\n    function setFeeDecreaser(IFeeExecutor _feeDecreaser) external;\n\n    /**\n     * @dev Sets the trader reward distributor contract address.\n     * @param _traderRewardDistributor The address of the trader reward distributor contract.\n     * Only the BIG_TIMELOCK_ADMIN role can call this function.\n     */\n    function setTraderRewardDistributor(IActivityRewardDistributor _traderRewardDistributor) external;\n\n    /**\n     * @dev Mints `amount` DebtTokens to `user`\n     * @param _user The address receiving the minted tokens\n     * @param _amount The amount of tokens getting minted\n     * @param _index The current variableBorrowIndex\n     */\n    function mint(address _user, uint256 _amount, uint256 _index) external;\n\n    /**\n     * @dev Burns DebtTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n     * @param _user The owner of the DebtTokens, getting them burned\n     * @param _amount The amount being burned\n     * @param _index The current variableBorrowIndex\n     **/\n    function burn(address _user, uint256 _amount, uint256 _index) external;\n\n    /**\n     * @dev Burns a batch of tokens from multiple users.\n     * @param _users An array of user addresses whose tokens will be burned.\n     * @param _amounts An array of token amounts to be burned for each user.\n     * @param _index The index used to calculate the scaled amounts.\n     * @param _length The length of the user and amounts arrays.\n     */\n    function batchBurn(address[] memory _users, uint256[] memory _amounts, uint256 _index, uint256 _length) external;\n\n    /**\n     * @dev Returns the principal debt balance of the user\n     * @param _user The address of the user.\n     * @return The scaled balance of the user.\n     */\n    function scaledBalanceOf(address _user) external view returns (uint256);\n\n    /**\n     * @dev Returns the scaled total supply of debtToken.\n     * @return The scaled total supply of the debtToken.\n     */\n    function scaledTotalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/DebtToken/IDebtTokensFactory.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IDebtToken} from \"./IDebtToken.sol\";\n\ninterface IDebtTokensFactory {\n    /**\n     * @dev Deploying a new DebtToken contract. Can be called by BucketsFactory only.\n     * @param _name The name of the new DebtToken.\n     * @param _symbol The symbol of the new DebtToken.\n     */\n    function createDebtToken(string memory _name, string memory _symbol, uint8 _decimals) external returns (IDebtToken);\n\n    /**\n     * @dev Sets the BucketsFactory address. Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param bucketsFactory The BucketsFactory address.\n     */\n    function setBucketsFactory(address bucketsFactory) external;\n\n    /**\n     * @dev Gets a BucketsFactory contract address.\n     */\n    function bucketsFactory() external view returns (address);\n\n    /**\n     * @dev Gets a Registry contract address.\n     */\n    function registry() external view returns (address);\n}\n"
    },
    "contracts/DebtToken/IDebtTokenStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IFeeExecutor} from \"../BonusExecutor/IFeeExecutor.sol\";\nimport {IActivityRewardDistributor} from \"../ActivityRewardDistributor/IActivityRewardDistributor.sol\";\n\ninterface IDebtTokenStorage is IERC20Upgradeable {\n    function bucket() external view returns (IBucket);\n\n    function feeDecreaser() external view returns (IFeeExecutor);\n\n    function traderRewardDistributor() external view returns (IActivityRewardDistributor);\n}\n"
    },
    "contracts/DexAdapter.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ISwapRouter} from \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport {ISwapRouter as ISwapRouterAlgebraV3} from \"@cryptoalgebra/solidity-interfaces/contracts/periphery/ISwapRouter.sol\";\nimport {IUniswapV2Router02} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport {IQuoter} from \"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\";\nimport {IQuoter as IQuoterAlgebraV3} from \"@cryptoalgebra/solidity-interfaces/contracts/periphery/IQuoter.sol\";\nimport {WadRayMath} from \"./libraries/utils/WadRayMath.sol\";\nimport {V3Path} from \"./libraries/utils/V3Path.sol\";\n\nimport \"./libraries/Errors.sol\";\n\nimport {MEDIUM_TIMELOCK_ADMIN, VAULT_ACCESS_ROLE} from \"./Constants.sol\";\nimport {IBalancer} from \"./interfaces/IBalancer.sol\";\nimport {IAsset} from \"./interfaces/IAsset.sol\";\nimport {IDexAdapter} from \"./interfaces/IDexAdapter.sol\";\nimport {ICurveRouter} from \"./interfaces/routers/ICurveRouter.sol\";\n\ncontract DexAdapter is IDexAdapter, IERC165 {\n    using WadRayMath for uint256;\n    using V3Path for bytes;\n\n    /**\n     * @inheritdoc IDexAdapter\n     */\n    mapping(address => DexType) public override dexType;\n\n    /**\n     * @inheritdoc IDexAdapter\n     */\n    mapping(address => address) public override quoters;\n\n    /**\n     * @inheritdoc IDexAdapter\n     */\n    address public immutable override registry;\n\n    /**\n     * @dev Throws if caller is not granted with _role\n     * @param _role The role that is being checked for a function caller\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(address _registry) {\n        _require(\n            IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        registry = _registry;\n    }\n\n    /**\n     * @inheritdoc IDexAdapter\n     */\n    function setQuoter(address _dexRouter, address _quoter) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(uint256(dexType[_dexRouter]) > 0, Errors.DEX_ROUTER_NOT_SUPPORTED.selector);\n        _require(_quoter != address(0), Errors.QUOTER_NOT_SUPPORTED.selector);\n        quoters[_dexRouter] = _quoter;\n        emit QuoterChanged(_dexRouter, _quoter);\n    }\n\n    /**\n     * @inheritdoc IDexAdapter\n     */\n    function setDexType(address _dexRouter, uint256 _dexType) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(_dexRouter != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        dexType[_dexRouter] = DexType(_dexType);\n        emit DexTypeChanged(_dexRouter, _dexType);\n    }\n\n    /**\n     * @inheritdoc IDexAdapter\n     */\n    function swapExactTokensForTokens(\n        SwapParams memory _params\n    ) external override onlyRole(VAULT_ACCESS_ROLE) returns (uint256[3] memory) {\n        _require(_params.to != address(0) && _params.dexRouter != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        _require(_params.amountIn != 0, Errors.ZERO_AMOUNT_IN.selector);\n        DexType type_ = dexType[_params.dexRouter];\n\n        if (type_ == DexType.UniswapV2 || type_ == DexType.Meshswap) {\n            return _swapWithUniswapV2(_params);\n        } else if (type_ == DexType.UniswapV3) {\n            return _swapWithUniswapV3(_params);\n        } else if (type_ == DexType.Curve) {\n            return _swapWithCurve(_params);\n        } else if (type_ == DexType.Balancer) {\n            return _swapWithBalancer(_params);\n        } else if (type_ == DexType.AlgebraV3) {\n            return _swapWithAlgebraV3(_params);\n        } else {\n            _revert(Errors.UNKNOWN_DEX_TYPE.selector);\n        }\n    }\n\n    /**\n     * @inheritdoc IDexAdapter\n     */\n    function getAmountsOut(GetAmountsParams memory _params) external override returns (uint256[3] memory) {\n        _checkAmountsParams(_params);\n        DexType type_ = dexType[_params.dexRouter];\n\n        if (type_ == DexType.UniswapV2 || type_ == DexType.Meshswap) {\n            return _getAmountsWithUniswapV2(_params);\n        } else if (type_ == DexType.UniswapV3) {\n            return _getAmountsWithUniswapV3(_params);\n        } else if (type_ == DexType.Curve) {\n            return _getAmountsWithCurve(_params);\n        } else if (type_ == DexType.Balancer) {\n            return _getAmountsWithBalancer(_params);\n        } else if (type_ == DexType.AlgebraV3) {\n            return _getAmountsWithAlgebraV3(_params);\n        } else {\n            _revert(Errors.UNKNOWN_DEX_TYPE.selector);\n        }\n    }\n\n    /**\n     * @inheritdoc IDexAdapter\n     */\n    function getAmountsIn(GetAmountsParams memory _params) external override returns (uint256[3] memory) {\n        _checkAmountsParams(_params);\n        DexType type_ = dexType[_params.dexRouter];\n\n        if (type_ == DexType.UniswapV2 || type_ == DexType.Meshswap) {\n            return _getAmountsInWithUniswapV2(_params);\n        } else if (type_ == DexType.UniswapV3) {\n            return _getAmountsInWithUniswapV3(_params);\n        } else if (type_ == DexType.Curve) {\n            return _getAmountsInWithCurve(_params);\n        } else if (type_ == DexType.Balancer) {\n            return _getAmountsInWithBalancer(_params);\n        } else if (type_ == DexType.AlgebraV3) {\n            return _getAmountsInWithAlgebraV3(_params);\n        } else {\n            _revert(Errors.UNKNOWN_DEX_TYPE.selector);\n        }\n    }\n\n    /**\n     * @inheritdoc IDexAdapter\n     */\n    function getGas(address dexRouter) external view override returns (uint256) {\n        _require(dexRouter != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        DexType type_ = dexType[dexRouter];\n        // These values are average taken from the gas tracker in etherscan\n        // The actual values depend on many variables especially the more complex dex such as uniswap v3\n        if (type_ == DexType.UniswapV2) {\n            return 152809;\n        } else if (type_ == DexType.UniswapV3 || type_ == DexType.AlgebraV3) {\n            return 184523;\n        } else if (type_ == DexType.Curve) {\n            return 183758;\n        } else if (type_ == DexType.Balancer) {\n            return 196625;\n        } else if (type_ == DexType.Meshswap) {\n            return 271000;\n        } else {\n            _revert(Errors.UNKNOWN_DEX_TYPE.selector);\n        }\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IERC165).interfaceId || _interfaceId == type(IDexAdapter).interfaceId;\n    }\n\n    function _getAmountsWithBalancer(GetAmountsParams memory _params) internal returns (uint256[3] memory) {\n        (address[] memory path, bytes32[] memory pools, ) = abi.decode(\n            _params.encodedPath,\n            (address[], bytes32[], int256[])\n        );\n        (IAsset[] memory assets, IBalancer.BatchSwapStep[] memory steps) = _getBalancerSwapSteps(\n            path,\n            pools,\n            _params.amount\n        );\n\n        IBalancer.FundManagement memory fundManagement = IBalancer.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: payable(address(this)),\n            toInternalBalance: false\n        });\n\n        int256[] memory deltas;\n        deltas = IBalancer(_params.dexRouter).queryBatchSwap(\n            IBalancer.SwapKind.GIVEN_IN,\n            steps,\n            assets,\n            fundManagement\n        );\n        /// @notice - queryBatchSwap will return a delta for each token in the assets array and last asset should be tokenOut\n        _require(deltas[deltas.length - 1] <= 0, Errors.DELTA_OF_TOKEN_OUT_HAS_POSITIVE_VALUE.selector);\n        uint256 amountOut = uint256(deltas[deltas.length - 1] * -1);\n        return [_params.amount, amountOut, 0];\n    }\n\n    function _getAmountsInWithBalancer(GetAmountsParams memory _params) internal returns (uint256[3] memory) {\n        (address[] memory path, bytes32[] memory pools, ) = abi.decode(\n            _params.encodedPath,\n            (address[], bytes32[], int256[])\n        );\n        IAsset[] memory assets = new IAsset[](path.length);\n        IBalancer.BatchSwapStep[] memory steps = new IBalancer.BatchSwapStep[](pools.length);\n\n        IBalancer.FundManagement memory fundManagement = IBalancer.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: payable(address(this)),\n            toInternalBalance: false\n        });\n        for (uint256 i; i < path.length - 1; i++) {\n            assets[i] = IAsset(path[i]);\n            steps[path.length - 2 - i] = IBalancer.BatchSwapStep({\n                poolId: pools[i],\n                assetInIndex: i,\n                assetOutIndex: i + 1,\n                amount: 0,\n                userData: \"0x\"\n            });\n        }\n        steps[0].amount = _params.amount;\n        assets[path.length - 1] = IAsset(path[path.length - 1]);\n\n        int256[] memory deltas;\n        deltas = IBalancer(_params.dexRouter).queryBatchSwap(\n            IBalancer.SwapKind.GIVEN_OUT,\n            steps,\n            assets,\n            fundManagement\n        );\n        _require(deltas[0] >= 0, Errors.DELTA_OF_TOKEN_IN_HAS_NEGATIVE_VALUE.selector);\n        return [uint256(deltas[0]), _params.amount, 0];\n    }\n\n    function _getAmountsWithUniswapV3(GetAmountsParams memory _params) internal returns (uint256[3] memory) {\n        address quoter = quoters[_params.dexRouter];\n        _require(address(quoter) != address(0), Errors.QUOTER_IS_NOT_PROVIDED.selector);\n        uint256 amountOut = IQuoter(quoter).quoteExactInput(_params.encodedPath, _params.amount);\n        return [_params.amount, amountOut, 0];\n    }\n\n    function _getAmountsInWithUniswapV3(GetAmountsParams memory _params) internal returns (uint256[3] memory) {\n        address quoter = quoters[_params.dexRouter];\n        _require(address(quoter) != address(0), Errors.QUOTER_IS_NOT_PROVIDED.selector);\n        uint256 amountIn = IQuoter(quoter).quoteExactOutput(_params.encodedPath, _params.amount);\n        return [amountIn, _params.amount, 0];\n    }\n\n    function _getAmountsWithAlgebraV3(GetAmountsParams memory _params) internal returns (uint256[3] memory) {\n        address quoter = quoters[_params.dexRouter];\n        _require(address(quoter) != address(0), Errors.QUOTER_IS_NOT_PROVIDED.selector);\n        (uint256 amountOut, ) = IQuoterAlgebraV3(quoter).quoteExactInput(_params.encodedPath, _params.amount);\n        return [_params.amount, amountOut, 0];\n    }\n\n    function _getAmountsInWithAlgebraV3(GetAmountsParams memory _params) internal returns (uint256[3] memory) {\n        address quoter = quoters[_params.dexRouter];\n        _require(address(quoter) != address(0), Errors.QUOTER_IS_NOT_PROVIDED.selector);\n        (uint256 amountIn, ) = IQuoterAlgebraV3(quoter).quoteExactOutput(_params.encodedPath, _params.amount);\n        return [amountIn, _params.amount, 0];\n    }\n\n    function _getAmountsWithCurve(GetAmountsParams memory _params) internal view returns (uint256[3] memory) {\n        (address[] memory path, address[] memory pools) = abi.decode(_params.encodedPath, (address[], address[]));\n        uint256 amountOut = _getExchangeAmountCurve(_params.amount, _params.dexRouter, path, pools);\n\n        return [_params.amount, amountOut, 0];\n    }\n\n    function _getExchangeAmountCurve(\n        uint256 amount,\n        address dexRouter,\n        address[] memory path,\n        address[] memory pools\n    ) internal view returns (uint256) {\n        uint256 amountOut = amount;\n\n        for (uint256 i; i < path.length - 1; i++) {\n            amountOut = ICurveRouter(dexRouter).get_exchange_amount(pools[i], path[i], path[i + 1], amountOut);\n        }\n        return amountOut;\n    }\n\n    function _getAmountsInWithCurve(GetAmountsParams memory _params) internal view returns (uint256[3] memory) {\n        (address[] memory path, address[] memory pools) = abi.decode(_params.encodedPath, (address[], address[]));\n        uint256 inverseAmount = _getExchangeAmountCurve(\n            _params.amount,\n            _params.dexRouter,\n            _reverseArray(path),\n            _reverseArray(pools)\n        );\n        //expanding the search to +50% and -50% from the inverseAmount\n        // mul by 0.5 WAD\n        uint256 minValue = inverseAmount.wmul(5e17);\n        // mul by 1.5 WAD\n        uint256 maxValue = inverseAmount.wmul(15e17);\n        uint256 amountIn;\n        for (uint256 i; i <= 100; i++) {\n            // first iteration checks the inverseAmount: (0.5 + 1.5) / 2\n            uint256 middle = (minValue + maxValue) / 2;\n            if (middle == amountIn) break;\n            amountIn = middle;\n            uint256 amountOut = _getExchangeAmountCurve(amountIn, _params.dexRouter, path, pools);\n            if (amountOut == _params.amount) break;\n            else if (amountOut < _params.amount) minValue = amountIn;\n            else maxValue = amountIn;\n        }\n        return [amountIn, _params.amount, 0];\n    }\n\n    function _getAmountsWithUniswapV2(GetAmountsParams memory _params) internal view returns (uint256[3] memory) {\n        address[] memory path = abi.decode(_params.encodedPath, (address[]));\n\n        uint256[] memory amounts = IUniswapV2Router02(_params.dexRouter).getAmountsOut(_params.amount, path);\n\n        return [_params.amount, amounts[amounts.length - 1], 0];\n    }\n\n    function _getAmountsInWithUniswapV2(GetAmountsParams memory _params) internal view returns (uint256[3] memory) {\n        address[] memory path = abi.decode(_params.encodedPath, (address[]));\n\n        uint256[] memory amounts = IUniswapV2Router02(_params.dexRouter).getAmountsIn(_params.amount, path);\n\n        return [amounts[0], _params.amount, 0];\n    }\n\n    function _reverseArray(address[] memory source) internal pure returns (address[] memory) {\n        uint256 length = source.length;\n        address[] memory result = new address[](length);\n        for (uint256 i; i < length; i++) {\n            result[length - 1 - i] = source[i];\n        }\n        return result;\n    }\n\n    function _checkAmountsParams(GetAmountsParams memory _params) internal pure {\n        _require(_params.dexRouter != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        _require(_params.amount != 0, Errors.ZERO_AMOUNT.selector);\n    }\n\n    function _getBalancerSwapSteps(\n        address[] memory path,\n        bytes32[] memory pools,\n        uint256 amount\n    ) internal pure returns (IAsset[] memory assets, IBalancer.BatchSwapStep[] memory steps) {\n        assets = new IAsset[](path.length);\n        steps = new IBalancer.BatchSwapStep[](pools.length);\n\n        for (uint256 i; i < path.length - 1; i++) {\n            assets[i] = IAsset(path[i]);\n            steps[i] = IBalancer.BatchSwapStep({\n                poolId: pools[i],\n                assetInIndex: i,\n                assetOutIndex: i + 1,\n                amount: 0,\n                userData: \"0x\"\n            });\n        }\n        steps[0].amount = amount;\n        assets[path.length - 1] = IAsset(path[path.length - 1]);\n    }\n\n    function _swapWithUniswapV2(SwapParams memory _params) private returns (uint256[3] memory) {\n        address[] memory path = abi.decode(_params.encodedPath, (address[]));\n        IERC20(path[0]).approve(_params.dexRouter, _params.amountIn);\n        uint256[] memory amounts;\n\n        amounts = IUniswapV2Router02(_params.dexRouter).swapExactTokensForTokens(\n            _params.amountIn,\n            _params.amountOutMin,\n            path,\n            _params.to,\n            _params.deadline\n        );\n\n        return [_params.amountIn, amounts[amounts.length - 1], 0];\n    }\n\n    function _swapWithUniswapV3(SwapParams memory _params) private returns (uint256[3] memory) {\n        address tokenIn = _params.encodedPath.decodeFirstToken();\n        IERC20(tokenIn).approve(_params.dexRouter, _params.amountIn);\n\n        ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\n            path: _params.encodedPath,\n            recipient: _params.to,\n            deadline: _params.deadline,\n            amountIn: _params.amountIn,\n            amountOutMinimum: _params.amountOutMin\n        });\n        uint256 amountOut;\n        // slither-disable-next-line unused-return\n        try ISwapRouter(_params.dexRouter).exactInput(params) returns (uint256 _amountOut) {\n            // slither-disable-next-line variable-scope\n            amountOut = _amountOut;\n        } catch Error(string memory err) {\n            // slither-disable-next-line variable-scope\n            revert(err);\n        } catch (bytes memory) {\n            _revert(Errors.REVERTED_WITHOUT_A_STRING_TRY_TO_CHECK_THE_ANCILLARY_DATA.selector);\n        }\n\n        return [_params.amountIn, amountOut, 0];\n    }\n\n    function _swapWithAlgebraV3(SwapParams memory _params) private returns (uint256[3] memory) {\n        address tokenIn = _params.encodedPath.decodeFirstToken();\n        IERC20(tokenIn).approve(_params.dexRouter, _params.amountIn);\n\n        ISwapRouterAlgebraV3.ExactInputParams memory params = ISwapRouterAlgebraV3.ExactInputParams({\n            path: _params.encodedPath,\n            recipient: _params.to,\n            deadline: _params.deadline,\n            amountIn: _params.amountIn,\n            amountOutMinimum: _params.amountOutMin\n        });\n        uint256 amountOut = ISwapRouterAlgebraV3(_params.dexRouter).exactInput(params);\n        return [_params.amountIn, amountOut, 0];\n    }\n\n    function _swapWithCurve(SwapParams memory _params) private returns (uint256[3] memory) {\n        // Curve does not check the deadline hence this check is necessary before the swap.\n        _require(_params.deadline >= block.timestamp, Errors.SWAP_DEADLINE_PASSED.selector);\n        (address[] memory path, address[] memory pools) = abi.decode(_params.encodedPath, (address[], address[]));\n        uint256 amountOut = _params.amountIn;\n\n        for (uint256 i; i < path.length - 1; i++) {\n            IERC20(path[i]).approve(_params.dexRouter, amountOut);\n            amountOut = ICurveRouter(_params.dexRouter).exchange(\n                pools[i],\n                path[i],\n                path[i + 1],\n                amountOut,\n                i == path.length - 2 ? _params.amountOutMin : 0,\n                i == path.length - 2 ? _params.to : address(this)\n            );\n        }\n\n        return [_params.amountIn, amountOut, 0];\n    }\n\n    function _swapWithBalancer(SwapParams memory _params) private returns (uint256[3] memory) {\n        (address[] memory path, bytes32[] memory pools, int256[] memory limits) = abi.decode(\n            _params.encodedPath,\n            (address[], bytes32[], int256[])\n        );\n        _require(path.length >= 2, Errors.INCORRECT_PATH.selector);\n        IERC20(path[0]).approve(_params.dexRouter, _params.amountIn);\n\n        IBalancer.FundManagement memory fundManagement = IBalancer.FundManagement({\n            sender: address(this),\n            fromInternalBalance: false,\n            recipient: payable(_params.to),\n            toInternalBalance: false\n        });\n\n        if (path.length > 2) {\n            (IAsset[] memory assets, IBalancer.BatchSwapStep[] memory steps) = _getBalancerSwapSteps(\n                path,\n                pools,\n                _params.amountIn\n            );\n\n            int256[] memory deltas;\n            deltas = IBalancer(_params.dexRouter).batchSwap(\n                IBalancer.SwapKind.GIVEN_IN,\n                steps,\n                assets,\n                fundManagement,\n                limits,\n                _params.deadline\n            );\n\n            return [_params.amountIn, uint256(deltas[deltas.length - 1] * -1), 0];\n        }\n\n        IBalancer.SingleSwap memory singleSwap = IBalancer.SingleSwap({\n            poolId: pools[0],\n            kind: IBalancer.SwapKind.GIVEN_IN,\n            assetIn: IAsset(path[0]),\n            assetOut: IAsset(path[1]),\n            amount: _params.amountIn,\n            userData: \"0x\"\n        });\n        uint256 amountOut = IBalancer(_params.dexRouter).swap(\n            singleSwap,\n            fundManagement,\n            _params.amountOutMin,\n            _params.deadline\n        );\n        return [_params.amountIn, amountOut, 0];\n    }\n}\n"
    },
    "contracts/EPMXPriceFeed.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {AggregatorV2V3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\nimport \"./libraries/Errors.sol\";\n\nimport {BIG_TIMELOCK_ADMIN} from \"./Constants.sol\";\nimport {IEPMXPriceFeed} from \"./interfaces/IEPMXPriceFeed.sol\";\n\ncontract EPMXPriceFeed is IEPMXPriceFeed, AggregatorV2V3Interface {\n    uint80 internal constant MAX_UINT80_HEX = type(uint80).max;\n\n    struct RoundData {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n\n    address public immutable registry;\n    uint8 public override decimals = 8; // USD decimals\n    uint80 private _currentRound;\n    RoundData private _latestRoundData;\n    mapping(uint80 => RoundData) private _answers;\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(address _registry) {\n        _require(\n            IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n    }\n\n    /**\n     * @notice Retrieves the latest answer from the oracle.\n     * @return The latest answer, with a precision of 8 decimal (USD decimals).\n     */\n    function latestAnswer() external view override returns (int256) {\n        return _latestRoundData.answer;\n    }\n\n    /**\n     * @notice Returns the latest round data.\n     * @return roundId The ID of the latest round.\n     * @return answer The answer provided in the latest round.\n     * @return startedAt The timestamp when the latest round started.\n     * @return updatedAt The timestamp when the latest round was updated.\n     * @return answeredInRound The round in which the latest answer was provided.\n     */\n    function latestRoundData() external view override returns (uint80, int256, uint256, uint256, uint80) {\n        return (\n            _latestRoundData.roundId,\n            _latestRoundData.answer,\n            _latestRoundData.startedAt,\n            _latestRoundData.updatedAt,\n            _latestRoundData.answeredInRound\n        );\n    }\n\n    /**\n     * @notice Retrieves the latest timestamp of the round data.\n     * @return The latest timestamp of when the round was updated, in seconds (UTC).\n     */\n    function latestTimestamp() external view override returns (uint256) {\n        return _latestRoundData.updatedAt;\n    }\n\n    /**\n     * @notice Retrieves the answer for a given round ID.\n     * @param roundId The round ID for which to get the answer.\n     * @return The answer previously set with setAnswer().\n     */\n    function getAnswer(uint256 roundId) external view override returns (int256) {\n        if (roundId > MAX_UINT80_HEX) {\n            return 0;\n        }\n        return _answers[uint80(roundId)].answer;\n    }\n\n    /**\n     * @notice Retrieves the timestamp of a given round ID.\n     * @param roundId The round ID for which to retrieve the timestamp.\n     * @return The timestamp when the round was last updated.\n     */\n    function getTimestamp(uint256 roundId) external view override returns (uint256) {\n        if (roundId > MAX_UINT80_HEX) {\n            return 0;\n        }\n        return _answers[uint80(roundId)].updatedAt;\n    }\n\n    /**\n     * @notice Retrieves the latest round ID.\n     * @return The latest round ID.\n     */\n    function latestRound() external view override returns (uint256) {\n        return _latestRoundData.roundId;\n    }\n\n    /**\n     * @inheritdoc IEPMXPriceFeed\n     */\n    function setAnswer(int256 answer) public override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _latestRoundData.answer = answer;\n        _latestRoundData.roundId = _currentRound;\n        _latestRoundData.startedAt = block.timestamp;\n        _latestRoundData.updatedAt = block.timestamp;\n        _latestRoundData.answeredInRound = _currentRound;\n        _answers[_currentRound] = _latestRoundData;\n        _currentRound++;\n        emit AnswerUpdated(answer, _latestRoundData.roundId, block.timestamp);\n    }\n\n    /**\n     * @notice Retrieves the data for a specific round.\n     * @param _roundId The ID of the round to retrieve data for.\n     * @return roundId The ID of the round.\n     * @return answer The answer for the round.\n     * @return startedAt The timestamp when the round started.\n     * @return updatedAt The timestamp when the round was last updated.\n     * @return answeredInRound The ID of the round in which the answer was computed.\n     */\n    function getRoundData(uint80 _roundId) public view override returns (uint80, int256, uint256, uint256, uint80) {\n        RoundData memory roundData = _answers[_roundId];\n        return (\n            roundData.roundId,\n            roundData.answer,\n            roundData.startedAt,\n            roundData.updatedAt,\n            roundData.answeredInRound\n        );\n    }\n\n    /**\n     * @notice Returns the description of the contract.\n     * @return The description string \"EPMX / USD\".\n     */\n    function description() public pure override returns (string memory) {\n        return \"EPMX / USD\";\n    }\n\n    /**\n     * @notice This function provides the version number of the contract.\n     */\n    function version() public pure override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/EPMXToken.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"./libraries/Errors.sol\";\n\nimport {BIG_TIMELOCK_ADMIN} from \"./Constants.sol\";\nimport {IEPMXToken} from \"./interfaces/IEPMXToken.sol\";\n\ncontract EPMXToken is IEPMXToken, ERC20, ERC165 {\n    address public immutable registry;\n    mapping(address => bool) public whitelist;\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(address _recipient, address _registry) ERC20(\"Early Primex Token\", \"ePMX\") {\n        _require(\n            ERC165(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n\n        if (_recipient == address(0)) {\n            _recipient = msg.sender;\n        }\n        _mint(_recipient, 1000000000 * 10 ** decimals());\n    }\n\n    /**\n     * @inheritdoc IEPMXToken\n     */\n    function burn(uint256 _amount) external override {\n        _burn(msg.sender, _amount);\n        emit Burn(msg.sender, _amount);\n    }\n\n    /**\n     * @inheritdoc IEPMXToken\n     */\n    function addAddressToWhitelist(address _address) public override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(!whitelist[_address], Errors.ADDRESS_ALREADY_WHITELISTED.selector);\n        whitelist[_address] = true;\n        emit WhitelistedAddressAdded(_address);\n    }\n\n    /**\n     * @inheritdoc IEPMXToken\n     */\n    function addAddressesToWhitelist(address[] memory _addresses) public override onlyRole(BIG_TIMELOCK_ADMIN) {\n        for (uint256 i; i < _addresses.length; i++) {\n            addAddressToWhitelist(_addresses[i]);\n        }\n    }\n\n    /**\n     * @inheritdoc IEPMXToken\n     */\n    function removeAddressFromWhitelist(address _address) public override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(whitelist[_address], Errors.ADDRESS_NOT_WHITELISTED.selector);\n        whitelist[_address] = false;\n        emit WhitelistedAddressRemoved(_address);\n    }\n\n    /**\n     * @inheritdoc IEPMXToken\n     */\n    function removeAddressesFromWhitelist(address[] calldata _addresses) public override onlyRole(BIG_TIMELOCK_ADMIN) {\n        for (uint256 i; i < _addresses.length; i++) {\n            removeAddressFromWhitelist(_addresses[i]);\n        }\n    }\n\n    /**\n     * @inheritdoc IEPMXToken\n     */\n    function isWhitelisted(address _address) public view override returns (bool) {\n        return whitelist[_address];\n    }\n\n    /**\n     * @notice Interface checker\n     * @param interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IEPMXToken).interfaceId ||\n            interfaceId == type(IERC20).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer.\n     * It enforces the restriction that the `from` or `to` address must be on the whitelist,\n     * or the `from` address must be the zero address for minting.\n     * @param from The address transferring the tokens. Use the zero address for minting.\n     * @param to The address receiving the tokens.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 /* amount */) internal virtual override(ERC20) {\n        _require(\n            whitelist[from] || whitelist[to] || from == address(0),\n            Errors.RECIPIENT_OR_SENDER_MUST_BE_ON_WHITE_LIST.selector\n        );\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n"
    },
    "contracts/InterestRateStrategy.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {WadRayMath} from \"./libraries/utils/WadRayMath.sol\";\n\nimport \"./libraries/Errors.sol\";\n\nimport {IInterestRateStrategy} from \"./interfaces/IInterestRateStrategy.sol\";\n\ncontract InterestRateStrategy is IInterestRateStrategy, ERC165 {\n    using WadRayMath for uint256;\n    // a bucket address to its params\n    mapping(address => BarCalculationParams) internal calculationParams;\n\n    /**\n     * @inheritdoc IInterestRateStrategy\n     */\n    function setBarCalculationParams(bytes calldata _params) external override {\n        BarCalculationParams memory barCalculationParams = abi.decode(_params, (BarCalculationParams));\n        calculationParams[msg.sender] = barCalculationParams;\n        emit BarCalculationParamsChanged(\n            msg.sender,\n            barCalculationParams.urOptimal,\n            barCalculationParams.k0,\n            barCalculationParams.k1,\n            barCalculationParams.b0,\n            barCalculationParams.b1\n        );\n    }\n\n    /**\n     * @inheritdoc IInterestRateStrategy\n     */\n    function getBarCalculationParams(address _address) external view override returns (BarCalculationParams memory) {\n        return calculationParams[_address];\n    }\n\n    /**\n     * @inheritdoc IInterestRateStrategy\n     */\n    function calculateInterestRates(uint256 ur, uint256 reserveRate) public view override returns (uint128, uint128) {\n        _require(ur <= WadRayMath.RAY, Errors.UR_IS_MORE_THAN_1.selector);\n        if (ur == 0) return (0, 0);\n        BarCalculationParams memory barCalcParams = calculationParams[msg.sender];\n        uint256 newBAR;\n        if (ur <= barCalcParams.urOptimal) {\n            newBAR = barCalcParams.k0.rmul(ur) + (barCalcParams.b0);\n        } else {\n            uint256 k1modified = barCalcParams.k1.rmul(ur);\n            if (barCalcParams.b1 < 0) {\n                uint256 b1modified = uint256(barCalcParams.b1 * (-1));\n                _require(k1modified >= b1modified, Errors.BAR_OVERFLOW.selector);\n                newBAR = k1modified - b1modified;\n            } else {\n                newBAR = k1modified + uint256(barCalcParams.b1);\n            }\n        }\n\n        // Errors.BAR_OVERFLOW is not possible to test\n        _require(newBAR <= type(uint128).max, Errors.BAR_OVERFLOW.selector);\n        uint256 newLAR = newBAR.rmul(ur);\n        if (reserveRate != 0) {\n            newLAR = newLAR.wmul(WadRayMath.WAD - reserveRate);\n        }\n        _require(newLAR <= type(uint128).max, Errors.LAR_OVERFLOW.selector);\n\n        return (uint128(newBAR), uint128(newLAR));\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IInterestRateStrategy).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "contracts/interfaces/EIP20NonStandardInterface.sol": {
      "content": "// Copyright 2020 Compound Labs, Inc.\n// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity ^0.8.10;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     */\n    function transfer(address dst, uint256 amount) external;\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     */\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved\n     * @return success Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return remaining The number of tokens allowed to be spent\n     */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/interfaces/IArbGasInfo.sol": {
      "content": "pragma solidity ^0.8.18;\n\n/// Precompiled contract that exists in every Arbitrum Nitro chain at 0x000000000000000000000000000000000000006c.\ninterface IArbGasInfo {\n    // get ArbOS's estimate of the L1 gas price in wei\n    function getL1BaseFeeEstimate() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IAsset.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/** @notice This contract was taken from (https://github.com/balancer-labs/balancer-v2-monorepo) and used for IBalancer*/\n\npragma solidity ^0.8.18;\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n\n}\n"
    },
    "contracts/interfaces/IBalancer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n/** @notice This contract (originally IVault) was taken from (https://github.com/balancer-labs/balancer-v2-monorepo).\n * Unused methods were removed.\n */\n\npragma solidity ^0.8.18;\n\nimport {IAsset} from \"./IAsset.sol\";\n\ninterface IBalancer {\n    enum PoolSpecialization {\n        GENERAL,\n        MINIMAL_SWAP_INFO,\n        TWO_TOKEN\n    }\n\n    /**\n     * @dev Returns a Pool's contract address and specialization setting.\n     */\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *f\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(\n        bytes32 poolId\n    ) external view returns (IAsset[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n}\n"
    },
    "contracts/interfaces/IBatchManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\n\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IKeeperRewardDistributorStorage} from \"../KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\";\nimport {IPausable} from \"./IPausable.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\n\ninterface IBatchManager is IPausable {\n    struct CloseBatchPositionsVars {\n        uint256[] ids;\n        address[] traders;\n        uint256[] positionAmounts;\n        uint256[] debts;\n        uint256[] depositsDecrease;\n        uint256[] decreasingCounter;\n        IKeeperRewardDistributorStorage.KeeperActionType actionType;\n        uint256 numberOfPositions;\n        uint256 oracleTolerableLimit;\n        uint256 securityBuffer;\n        IPositionManager positionManager;\n        IPrimexDNS primexDNS;\n        IPriceOracle priceOracle;\n        ITraderBalanceVault traderBalanceVault;\n        uint256 pairPriceDrop;\n        LimitOrderLibrary.Condition[] closeConditions;\n        bool borrowedAmountIsNotZero;\n        address bucket;\n        uint256 totalCloseAmount;\n        uint256 uncoveredAmount;\n        uint256 totalDebt;\n        address adapter;\n        uint256[] returnedToTraders;\n        uint256 amountToReturn;\n        uint256 borrowedAssetAmountOut;\n        uint256 normalizedVariableDebt;\n        uint256 permanentLoss;\n        uint256[] shareOfBorrowedAssetAmount;\n        bool isLiquidation;\n    }\n\n    /**\n     * @notice Closes positions in batch\n     * @param  _ids  An array of IDs of the positions to be closed.\n     * @param  _routes  An array of routes for swap.\n     * @param  _positionAsset  The address of the position asset.\n     * @param  _depositedAsset  The address of the borrowed asset.\n     * @param  _bucket  The instance of the bucket.\n     * @param  _conditionIndexes  The array of the indexes of close conditions for each position.\n     * @param  _closeReason  The reason for closing positions.\n     */\n    function closeBatchPositions(\n        uint256[] calldata _ids,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        address _positionAsset,\n        address _depositedAsset,\n        IBucket _bucket,\n        uint256[] calldata _conditionIndexes,\n        PositionLibrary.CloseReason _closeReason\n    ) external;\n\n    /**\n     * @notice Retrieves the address of PositionManager contract.\n     */\n    function positionManager() external view returns (IPositionManager);\n\n    /**\n     * @notice Retrieves the address of PriceOracle contract.\n     */\n    function priceOracle() external view returns (IPriceOracle);\n\n    /**\n     * @notice Retrieves the address of WhiteBlackList contract.\n     */\n    function whiteBlackList() external view returns (IWhiteBlackList);\n\n    /**\n     * @notice Retrieves the address of Registry contract.\n     */\n    function registry() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IBestDexLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {ILimitOrderManager} from \"../LimitOrderManager/ILimitOrderManager.sol\";\n\ninterface IBestDexLens {\n    /**\n     * @dev Structure for the getBestDexForOpenablePosition function\n     * @param positionManager Instance of the PositionManager\n     * @param borrowedAsset The address of the borrowed asset of this `bucket`\n     * @param borrowedAmount The amount of borrowed token in this position\n     * @param depositAsset The address of the deposited asset\n     * @param depositAmount The amount of deposited trader funds of open position\n     * @param positionAsset The address of the bought asset of open position\n     * @param shares The number of parts into which the swap will be divided\n     * @param dexes An array with dexes by which the algorithm will iterate\n     */\n    struct BestDexForOpenablePositionParams {\n        IPositionManager positionManager;\n        address borrowedAsset;\n        uint256 borrowedAmount;\n        address depositAsset;\n        uint256 depositAmount;\n        address positionAsset;\n        Shares shares;\n        DexWithAncillaryData[] dexes;\n    }\n\n    /**\n     * @dev Structure for different shares for swap\n     * @param firstAssetShares Shares for swap first asset to position asset\n     * @param depositInThirdAssetShares Shares for swap deposit asset to third asset\n     * @param depositToBorrowedShares Shares for swap deposit asset to borrowed asset\n     */\n    struct Shares {\n        uint256 firstAssetShares;\n        uint256 depositInThirdAssetShares;\n        uint256 depositToBorrowedShares;\n    }\n\n    /**\n     * @param dex The name of dex\n     * @param ancillaryData Additional data required for certain dex type.\n     */\n    struct DexWithAncillaryData {\n        string dex;\n        bytes32 ancillaryData;\n    }\n\n    /**\n     * @dev Structure for the getBestDexByOrderParams function\n     * @param positionManager instance of the PositionManager\n     * @param limitOrderManager instance of the LimitOrderManager\n     * @param orderId order id\n     * @param dexes dexes with ancillary data\n     */\n    struct BestDexByOrderParams {\n        IPositionManager positionManager;\n        ILimitOrderManager limitOrderManager;\n        uint256 orderId;\n        Shares shares;\n        DexWithAncillaryData[] dexes;\n    }\n\n    /**\n     * @dev Structure for the input params for getBestMultipleDexes\n     * @param positionManager instance of the PositionManager\n     * @param assetToBuy address\n     * @param assetToSell address\n     * @param amount amount to sell or amount to buy depending on the isAmountToBuy\n     * @param isAmountToBuy if true, then the best value, found via getAmountsIn\n     * @param shares The number of parts into which the swap will be divided\n     * @param gasPriceInCheckedAsset gas Price in asset to sell or asset to buy depending on the isAmountToBuy\n     * @param dexes An array with dexes by which the algorithm will iterate\n     */\n    struct GetBestMultipleDexesParams {\n        IPositionManager positionManager;\n        address assetToBuy;\n        address assetToSell;\n        uint256 amount;\n        bool isAmountToBuy;\n        uint256 shares;\n        uint256 gasPriceInCheckedAsset;\n        DexWithAncillaryData[] dexes;\n    }\n\n    /**\n     * @dev Structure for the getBestMultipleDexes function\n     * @param shareCount Number of shares\n     * @param filledRoutes Number of filled routes\n     * @param path Path of assets\n     * @param activeDexesLength Count of active dexes\n     * @param gasInCheckedAsset The paid price for gas in the purchase token\n     * @param gases Estimated gas to perform swap on each dex\n     */\n    struct GetBestMultipleDexesVars {\n        uint256 shareCount;\n        uint256 filledRoutes;\n        address[] path;\n        uint256 activeDexesLength;\n        int256 gasInCheckedAsset;\n        uint256[] gases;\n    }\n\n    /**\n     * @dev Structure for the return params for getBestMultipleDexes\n     * @param returnAmount expected return amount\n     * @param estimateGasAmount expected fee amount\n     * @param routes swap routes on dexes\n     */\n    struct GetBestMultipleDexesReturnParams {\n        uint256 returnAmount;\n        uint256 estimateGasAmount;\n        PrimexPricingLibrary.Route[] routes;\n    }\n\n    /**\n     * @dev Structure for the function getBestDex through the buy parameters\n     * @param assetToBuy Asset to buy on the dex(=_positionAsset in function openPosition)\n     * @param assetToSell Asset for sell on the dex(= an asset borrowed from a bucket)\n     * @param amountToSell Amount `assetToSell`(=borrowedAmount in function openPosition)\n     */\n    struct BuyData {\n        address assetToBuy;\n        address assetToSell;\n        uint256 amountToSell;\n    }\n\n    /**\n     * @dev Structure for the getBestDexByOrder function\n     * @param firstAssetReturnParams GetBestMultipleDexesReturnParams for the first asset to position asset\n     * @param depositInThirdAssetReturnParams GetBestMultipleDexesReturnParams for deposit asset to third asset\n     * @param depositToBorrowedReturnParams GetBestMultipleDexesReturnParams for deposit asset to borrowed asset\n     */\n    struct GetBestDexByOrderReturnParams {\n        GetBestMultipleDexesReturnParams firstAssetReturnParams;\n        GetBestMultipleDexesReturnParams depositInThirdAssetReturnParams;\n        GetBestMultipleDexesReturnParams depositToBorrowedReturnParams;\n    }\n\n    /**\n     * @notice Returns swap paths on best dexes, expected amount and estimateGasAmount.\n     * @dev This function calculates the best DEX to use for a given position based on various parameters.\n     * @param _positionManager The instance of the PositionManager contract.\n     * @param _positionId The ID of the position.\n     * @param _shares The number of shares for dexes.\n     * @param _dexesWithAncillaryData An array of DEXes along with their ancillary data.\n     * @return A GetBestMultipleDexesReturnParams struct.\n     */\n    function getBestDexByPosition(\n        IPositionManager _positionManager,\n        uint256 _positionId,\n        uint256 _shares,\n        DexWithAncillaryData[] memory _dexesWithAncillaryData\n    ) external returns (GetBestMultipleDexesReturnParams memory);\n\n    /**\n     * @notice Selects the best dex to open position by order.\n     * @param _params The BestDexByOrderParams struct specifying the order parameters.\n     * @return _returnParams The GetBestDexByOrderReturnParams struct\n     */\n    function getBestDexByOrder(\n        BestDexByOrderParams memory _params\n    ) external returns (GetBestDexByOrderReturnParams memory _returnParams);\n\n    /**\n     * @notice Selects the best multiple dexes to open a position\n     * @param _params GetBestMultipleDexesParams params\n     * @return _returnParams - the array of best dexes at the moment to open a position with the specified parameters\n     */\n    function getBestMultipleDexes(\n        GetBestMultipleDexesParams memory _params\n    ) external returns (GetBestMultipleDexesReturnParams memory _returnParams);\n\n    /**\n     * @notice Returns the best DEXes for opening a position.\n     * @param _params The parameters for the function.\n     * @return _firstAssetReturnParams The return parameters for the first asset.\n     * @return _depositInThirdAssetReturnParams The return parameters includes routes for converting a third asset\n     * (i.e. an asset which is not either underlying asset or position asset) to a position asset.\n     * @return _depositToBorrowedReturnParams The return parameters for converting deposit asset (which is a position\n     * asset or third asset) to borrowed asset (i.e. underlying asset).\n     */\n    function getBestDexForOpenablePosition(\n        BestDexForOpenablePositionParams memory _params\n    )\n        external\n        returns (\n            GetBestMultipleDexesReturnParams memory _firstAssetReturnParams,\n            GetBestMultipleDexesReturnParams memory _depositInThirdAssetReturnParams,\n            GetBestMultipleDexesReturnParams memory _depositToBorrowedReturnParams\n        );\n\n    /**\n     * @notice the function shows the profit/loss of a position with `_id`\n     * (in case of loss position, a negative number is issued) on dex `_dexName`\n     * @param _positionManager The address of the PositionManager where the position is stored\n     * @param _id Position id to calculate profit.\n     * @param _routes swap routes on dexes\n     */\n    function getPositionProfit(\n        address _positionManager,\n        uint256 _id,\n        PrimexPricingLibrary.Route[] calldata _routes\n    ) external returns (int256);\n\n    /**\n     * @notice The function returns the current price and profit for open position with `_id` on the best dex\n     * @param _positionManager The instance of the PositionManager where the position is stored\n     * @param _id Position id to show the parameters position\n     * @param _shares shares for expected close\n     * @param _dexes dexes with ancillary data\n     */\n    function getCurrentPriceAndProfitByPosition(\n        IPositionManager _positionManager,\n        uint256 _id,\n        uint256 _shares,\n        DexWithAncillaryData[] memory _dexes\n    ) external returns (uint256, int256);\n\n    /**\n     * @notice The function returns an array of the current price and the profit for open position with `_id` on the best dex\n     * @param _positionManager The instance of the PositionManager where the position is stored\n     * @param _ids Array of position ids to show the parameters position\n     * @param _shares shares for expected close\n     * @param _dexes Array of dexes with ancillary data\n     */\n    function getArrayCurrentPriceAndProfitByPosition(\n        IPositionManager _positionManager,\n        uint256[] memory _ids,\n        uint256[] memory _shares,\n        DexWithAncillaryData[][] memory _dexes\n    ) external returns (uint256[] memory, int256[] memory);\n\n    /**\n     * @notice Calculates the amount of output token that can be obtained for a given input token amount\n     * and pricing parameters.\n     * @param _params The input parameters for the calculation.\n     * @return The calculated output amount.\n     */\n    function getAmountOut(PrimexPricingLibrary.AmountParams memory _params) external returns (uint256);\n\n    /**\n     * @notice Calculates the amount of tokens to be received in exchange for a given amount of input tokens,\n     * based on the provided pricing parameters.\n     * @param _params The pricing parameters for calculating the token amount.\n     * @return The amount of tokens to be received.\n     */\n    function getAmountIn(PrimexPricingLibrary.AmountParams memory _params) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IConditionalClosingManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\ninterface IConditionalClosingManager {\n    /**\n     * @notice Checks if a position can be closed.\n     * @param _position The position details.\n     * @param _params The encoded parameters for closing the position.\n     * @param _additionalParams Additional encoded parameters.\n     * @return A boolean indicating whether the position can be closed.\n     */\n    function canBeClosedBeforeSwap(\n        PositionLibrary.Position calldata _position,\n        bytes calldata _params,\n        bytes calldata _additionalParams\n    ) external returns (bool);\n\n    /**\n     * @notice Checks if a position can be closed.\n     * @param _position The position details.\n     * @param _params The encoded parameters for closing the position.\n     * @param _additionalParams Additional encoded parameters (not used).\n     * @param _closeAmount The amount of the position to be closed, measured in the same decimal format as the position's asset.\n     * @param _borowedAssetAmount The amount of borrowed asset.\n     * @return A boolean indicating whether the position can be closed.\n     */\n    function canBeClosedAfterSwap(\n        PositionLibrary.Position calldata _position,\n        bytes calldata _params,\n        bytes calldata _additionalParams,\n        uint256 _closeAmount,\n        uint256 _borowedAssetAmount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IConditionalOpeningManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\ninterface IConditionalOpeningManager {\n    /**\n     * @notice Checks if a limit order can be filled.\n     * Is used as a view function outside transactions and allows to check whether a specific order can be executed imitating the swap.\n     * @param _order The limit order details.\n     * @param _params Open condition parameters for the order.\n     * @param _additionalParams Additional parameters for the order.\n     * @return A boolean value indicating if the limit order can be filled.\n     */\n    function canBeFilledBeforeSwap(\n        LimitOrderLibrary.LimitOrder calldata _order,\n        bytes calldata _params,\n        bytes calldata _additionalParams\n    ) external returns (bool);\n\n    /**\n     * @notice Checks if a limit order can be filled based on the exchange rate.\n     * @dev This function compares the exchange rate with the limit price.\n     * @param _order The limit order details.\n     * @param _params Open condition parameters for the order.\n     * @param _additionalParams Additional parameters for the order.\n     * @param _exchangeRate The exchange rate in WAD format to compare with the limit price.\n     * @return A boolean value indicating if the limit order can be filled based on the exchange rate.\n     */\n    function canBeFilledAfterSwap(\n        LimitOrderLibrary.LimitOrder calldata _order,\n        bytes calldata _params,\n        bytes calldata _additionalParams,\n        uint256 _exchangeRate\n    ) external pure returns (bool);\n}\n"
    },
    "contracts/interfaces/IDexAdapter.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IQuoter} from \"@uniswap/v3-periphery/contracts/interfaces/IQuoter.sol\";\n\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {ICurveCalc} from \"./routers/ICurveCalc.sol\";\nimport {ICurveRegistry} from \"./routers/ICurveRegistry.sol\";\n\ninterface IDexAdapter {\n    /**\n     * @notice Possible dex types\n     */\n    enum DexType {\n        none, // 0\n        UniswapV2, // 1  \"uniswap\", \"sushiswap\", \"quickswap\" (v2)\n        UniswapV3, // 2\n        Curve, // 3\n        Balancer, // 4\n        AlgebraV3, // 5\n        Meshswap // 6\n    }\n\n    /*\n     * @param encodedPath Swap path encoded in bytes\n     * Encoded differently for different dexes:\n     * Uniswap v2 - just encoded array of asset addresses\n     * Uniswap v3 - swap path is a sequence of bytes. In Solidity, a path can be built like that:\n     *      bytes.concat(bytes20(address(weth)), bytes3(uint24(pool1Fee)), bytes20(address(usdc)), bytes3(uint24(pool2Fee)) ...)\n     * Quickswap - swap path is a sequence of bytes. In Solidity, a path can be built like that:\n     *      bytes.concat(bytes20(address(weth)), bytes20(address(usdc)), bytes20(address(usdt) ...)\n     * Curve - encoded array of asset addresses and pool addresses\n     * Balancer - encoded array of asset addresses, pool ids and asset limits\n     * @param _amountIn TokenA amount in\n     * @param _amountOutMin Min tokenB amount out\n     * @param _to Destination address for swap\n     * @param _deadline Timestamp deadline for swap\n     * @param _dexRouter Dex router address\n     */\n    struct SwapParams {\n        bytes encodedPath;\n        uint256 amountIn;\n        uint256 amountOutMin;\n        address to;\n        uint256 deadline;\n        address dexRouter;\n    }\n\n    /*\n     * @param encodedPath Swap path encoded in bytes\n     * @param _amountIn TokenA amount in\n     * @param _dexRouter Dex router address\n     */\n    struct GetAmountsParams {\n        bytes encodedPath;\n        uint256 amount; // amountIn or amountOut\n        address dexRouter;\n    }\n\n    event QuoterChanged(address indexed dexRouter, address indexed quoter);\n    event DexTypeChanged(address indexed dexRouter, uint256 indexed dexType);\n\n    /**\n     * @param _dexRouter The router address for which the quoter is set\n     * @param _quoter The quoter address to set\n     */\n    function setQuoter(address _dexRouter, address _quoter) external;\n\n    /**\n     * @notice Set a dex type for a dex router\n     * @param _dexRouter The dex router address\n     * @param _dexType The dex type from enum DexType\n     */\n    function setDexType(address _dexRouter, uint256 _dexType) external;\n\n    /**\n     * @notice Swap ERC20 tokens\n     * @param _params SwapParams struct\n     */\n    function swapExactTokensForTokens(SwapParams memory _params) external returns (uint256[3] memory);\n\n    /**\n     * @notice Performs chained getAmountOut calculations\n     * @notice given an input amount of an asset, returns the maximum output amount of the other asset\n     * @param _params GetAmountsParams struct\n     */\n    function getAmountsOut(GetAmountsParams memory _params) external returns (uint256[3] memory);\n\n    /**\n     * @notice Performs chained getAmountIn calculations\n     * @notice given an output amount of an asset, returns the maximum input amount of the other asset\n     * @param _params GetAmountsParams struct\n     */\n    function getAmountsIn(GetAmountsParams memory _params) external returns (uint256[3] memory);\n\n    /**\n     * @notice Dex type mapping dexRouter => dex type\n     */\n    function dexType(address) external view returns (DexType);\n\n    /**\n     * @notice Mapping from the dexRouter to its quoter\n     */\n    function quoters(address) external view returns (address);\n\n    /**\n     * @return The address of the Registry contract\n     */\n    function registry() external view returns (address);\n\n    /**\n     * @notice Gets the average amount of gas that is required for the swap on some dex\n     * @param dexRouter The address of a router\n     */\n    function getGas(address dexRouter) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IEPMXPriceFeed.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IEPMXPriceFeed {\n    /**\n     * @notice Sets the answer for the current round.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param answer The answer to be set with a precision of 8 decimal (USD decimals).\n     */\n    function setAnswer(int256 answer) external;\n}\n"
    },
    "contracts/interfaces/IEPMXToken.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IEPMXToken {\n    event WhitelistedAddressAdded(address indexed addr);\n    event WhitelistedAddressRemoved(address indexed addr);\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * @notice Adds the specified address to the whitelist.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _address The address to be added to the whitelist.\n     */\n    function addAddressToWhitelist(address _address) external;\n\n    /**\n     * @notice Adds multiple addresses to the whitelist.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _addresses The array of addresses to be added.\n     */\n    function addAddressesToWhitelist(address[] calldata _addresses) external;\n\n    /**\n     * @notice Removes an address from the whitelist.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _address The address to be removed.\n     */\n    function removeAddressFromWhitelist(address _address) external;\n\n    /**\n     * @notice Removes an address from the whitelist.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _addresses The array of addresses to be removed.\n     */\n    function removeAddressesFromWhitelist(address[] calldata _addresses) external;\n\n    /**\n     * @notice Burns a specific amount of tokens from the caller's balance.\n     * @param _amount The amount of tokens to be burned.\n     *\n     * Requirements:\n     * The caller must be on the white list.\n     */\n    function burn(uint256 _amount) external;\n\n    /**\n     * @notice Checks if an address is whitelisted.\n     * @param _address The address to check.\n     * @return A boolean value indicating whether the address is whitelisted or not.\n     */\n    function isWhitelisted(address _address) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC20Mock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Mock is IERC20 {\n    function setMintTimeLimit(bool _isLimited) external;\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IInterestRateStrategy.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IInterestRateStrategy {\n    /**\n     * @dev parameters for BAR calculation - they differ depending on bucket's underlying asset\n     */\n    struct BarCalculationParams {\n        uint256 urOptimal;\n        uint256 k0;\n        uint256 k1;\n        uint256 b0;\n        int256 b1;\n    }\n\n    event BarCalculationParamsChanged(\n        address indexed bucket,\n        uint256 urOptimal,\n        uint256 k0,\n        uint256 k1,\n        uint256 b0,\n        int256 b1\n    );\n\n    /**\n     * @dev Updates bucket's BAR and LAR.\n     * Calculates using utilization ratio (UR):\n     * BAR = UR <= URoptimal ? (k0 * UR + b0) : (k1 * UR + b1), where 'b1' may be < 0,\n     * LAR = BAR * UR,\n     * if reserveRate != 0, then LAR = LAR * (1 - reserveRate)\n     * @param ur Utilization ratio\n     * @param reserveRate The reserve portion of the interest that goes to the Primex reserve\n     * @return tuple containing BAR and LAR\n     */\n\n    function calculateInterestRates(uint256 ur, uint256 reserveRate) external returns (uint128, uint128);\n\n    /**\n     * @dev Set parameters for BAR calculation.\n     * @param _params parameters are represented in byte string\n     */\n\n    function setBarCalculationParams(bytes memory _params) external;\n\n    /**\n     * @dev Retrieves the calculation parameters for the Bar calculation.\n     * @param _address an address of the bucket\n     * @return BarCalculationParams struct containing the parameters.\n     */\n    function getBarCalculationParams(address _address) external view returns (BarCalculationParams memory);\n}\n"
    },
    "contracts/interfaces/ILimitPriceCOM.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\ninterface ILimitPriceCOM {\n    struct CanBeFilledParams {\n        uint256 limitPrice;\n    }\n\n    struct AdditionalParams {\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\n    }\n\n    struct CanBeFilledVars {\n        CanBeFilledParams params;\n        AdditionalParams additionalParams;\n        address borrowedAsset;\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 amountToTransfer;\n        address dexAdapter;\n        bool isThirdAsset;\n        uint256 borrowedAssetMultiplier;\n        uint256 exchangeRate;\n        uint256 depositInPositionAsset;\n        uint256 borrowedAmountInPositionAsset;\n    }\n\n    /**\n     * @notice Retrieves the limit price from the provided `_params` input.\n     * @dev To use this function correctly, you need to encode a CanBeFilledParams struct into the _params parameter.\n     * The CanBeFilledParams struct has field limitPrice.\n     * @param _params The encoded parameters containing the limit price information.\n     * @return The limit price extracted from the `_params`.\n     */\n    //TODO Consider removing this function from the protocol as it is currently unused.\n    function getLimitPrice(bytes calldata _params) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPausable.sol": {
      "content": "// Copyright (c) 2016-2023 zOS Global Limited and contributors\n// SPDX-License-Identifier: MIT\n\n// Interface for OpenZeppelin's Pausable contract from https://github.com/OpenZeppelin/openzeppelin-contracts/\npragma solidity ^0.8.18;\n\ninterface IPausable {\n    /**\n     * @dev Triggers stopped state.\n     * This function can only be called by an address with the EMERGENCY_ADMIN role.\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function pause() external;\n\n    /**\n     * @dev Returns to normal state.\n     * This function can only be called by an address with the SMALL_TIMELOCK_ADMIN or MEDIUM_TIMELOCK_ADMIN role depending on the contract.\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function unpause() external;\n}\n"
    },
    "contracts/interfaces/IPriceFeedUpdaterTestService.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {PrimexAggregatorV3TestService} from \"../TestnetServices/PrimexAggregatorV3TestService.sol\";\n\ninterface IPriceFeedUpdaterTestService {\n    struct PriceFeedStatus {\n        bool isNeedUpdate;\n        PrimexAggregatorV3TestService priceFeed;\n        uint256 lastAverageDexPrice;\n    }\n\n    struct PriceFeed {\n        address token0;\n        address token1;\n        PrimexAggregatorV3TestService priceFeed;\n    }\n\n    function addRouter(address _newRouter) external;\n\n    function deleteRouter(uint256 _index) external;\n\n    function setDivider(uint256 _multiplier) external;\n\n    function checkArrayPriceFeed(PriceFeed[] memory _priceFeeds) external returns (PriceFeedStatus[] memory);\n\n    function updateArrayPriceFeed(\n        PrimexAggregatorV3TestService[] memory _priceFeeds,\n        int256[] memory _newAnswers\n    ) external;\n\n    function checkPriceFeed(PriceFeed memory _priceFeed) external returns (PriceFeedStatus memory);\n\n    function updatePriceFeed(PrimexAggregatorV3TestService _priceFeed, int256 _newAnswer) external;\n\n    function getRouters() external view returns (address[] memory _routers);\n}\n"
    },
    "contracts/interfaces/IPrimexLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\n\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IInterestRateStrategy} from \"./IInterestRateStrategy.sol\";\nimport {ILiquidityMiningRewardDistributor} from \"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\";\n\ninterface IPrimexLens {\n    /**\n     * @dev A struct to store metadata information of a token.\n     * @param tokenAddress The address of the token contract.\n     * @param symbol The symbol of the token.\n     * @param name The name of the token.\n     * @param decimals  The decimal places of the token.\n     * @param balance The balance of the token.\n     */\n    struct TokenMetadata {\n        address tokenAddress;\n        string symbol;\n        string name;\n        uint256 decimals;\n        uint256 balance;\n    }\n\n    /**\n     * @param id Id of the asset.\n     * @param isSupported Flag indicating if the asset supported in the bucket.\n     * @param pairPriceDrop PriceDrop of the trading asset relative to borrowed asset, in WAD format.\n     * @param maxLeverage maxAssetLeverage allowed for the trading asset in the bucket, in WAD format.\n     */\n    struct BucketTokenMetadata {\n        uint256 id;\n        bool isSupported;\n        uint256 pairPriceDrop;\n        uint256 maxLeverage;\n    }\n\n    /**\n     * @param asset Metadata of the asset token as a struct TokenMetadata\n     * @param properties Metadata of the bucket token properties as a struct BucketTokenMetadata\n     */\n    struct SupportedAsset {\n        TokenMetadata asset;\n        BucketTokenMetadata properties;\n    }\n\n    /**\n     * @param amountInMining The amount of tokens provided by the lender for mining.\n     * @param currentPercent The current percentage of rewards allocated to the lender, in WAD format (1 WAD = 100%)\n     * @param rewardsInPMX The expected rewards for the lender in PMX tokens.\n     */\n    struct LenderInfo {\n        uint256 amountInMining;\n        uint256 currentPercent;\n        ILiquidityMiningRewardDistributor.RewardsInPMX rewardsInPMX;\n    }\n\n    /**\n     * @dev Struct representing info about a liquidity mining in the bucket.\n     * @param pmxAmount Total reward of PMX for liquidity mining in the bucket.\n     * @param withdrawnRewards Total reward of PMX amount already withdrawn from the bucket.\n     * @param totalPoints Total points accumulated by users in the bucket.\n     */\n    struct LiquidityMiningBucketInfo {\n        uint256 pmxAmount;\n        uint256 withdrawnRewards;\n        uint256 totalPoints;\n    }\n\n    /**\n     * @dev Struct representing info about bucket.\n     * @param bucketAddress The bucket address.\n     * @param name The bucket name.\n     * @param asset TokenMetadata of borrowed asset of the bucket.\n     * @param bar Borrowing annual rate of the bucket, expressed in RAY.\n     * @param lar Lending annual rate of the bucket, expressed in RAY.\n     * @param supply Sum of availableLiquidity and demand, in borrowed asset.\n     * @param demand Total supply of the debtToken, in borrowed asset.\n     * @param availableLiquidity Balance of borrowed asset on the bucket, in borrowed asset.\n     * @param utilizationRatio Percentage of the bucket funds used in the loan, in in RAY format (1 RAY = 100%).\n     * @param supportedAssets Assets with which you can open a position in the bucket.\n     * @param pToken TokenMetadata of pToken of the bucket.\n     * @param debtToken TokenMetadata of debtToken of the bucket.\n     * @param feeBuffer The fee buffer of the bucket, in WAD format.\n     * @param withdrawalFeeRate Percentage of withdrawal that is redirected to the treasury, in WAD format (1 WAD = 100%)\n     * @param miningParams Parameters of the bucket liquidity mining.\n     * @param lenderInfo Liquidity mining lender information.\n     * @param lmBucketInfo Liquidity mining the bucket information.\n     * @param estimatedBar Expected value of bar, expressed in RAY\n     * @param estimatedLar Expected value of lar., expressed in RAY\n     * @param isDeprecated Indicates whether the bucket is outdated and deprecated.\n     * @param isDelisted Indicates whether the bucket is delisted.\n     * @param barCalcParams The BarCalculationParams struct containing the parameters for calculating bar and lar.\n     * @param maxTotalDeposit Max amount of borrowed asset that can be deposited in bucket, in borrowed asset.\n     */\n    struct BucketMetaData {\n        address bucketAddress;\n        string name;\n        TokenMetadata asset;\n        uint128 bar;\n        uint128 lar;\n        uint256 supply;\n        uint256 demand;\n        uint256 availableLiquidity;\n        uint256 utilizationRatio;\n        SupportedAsset[] supportedAssets;\n        TokenMetadata pToken;\n        TokenMetadata debtToken;\n        uint256 feeBuffer;\n        uint256 withdrawalFeeRate;\n        IBucket.LiquidityMiningParams miningParams;\n        LenderInfo lenderInfo;\n        LiquidityMiningBucketInfo lmBucketInfo;\n        uint128 estimatedBar;\n        uint128 estimatedLar;\n        bool isDeprecated;\n        bool isDelisted;\n        IInterestRateStrategy.BarCalculationParams barCalcParams;\n        uint256 maxTotalDeposit;\n    }\n\n    /**\n     * @dev Struct representing the data of a round in an chainlink oracle contract.\n     * @param roundId Id of the round.\n     * @param answer The answer provided for the round.\n     * @param startedAt The timestamp when the round started.\n     * @param updatedAt The timestamp when the round was last updated.\n     * @param answeredInRound The round in which the answer was provided.\n     */\n    struct RoundData {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n\n    /**\n     * @dev Structure of open position parameters\n     * @param bucket The domain name of the bucket where the position was opened\n     * @param borrowedAsset The address of the borrowed asset of this `bucket`\n     * @param positionAsset the address of the bought asset of open position\n     * @param borrowedAmount the amount of borrowed token in this position\n     * @param debt the debt on an open position consists of the loan body and accumulated interest\n     * @param depositAmount The amount of deposit trader funds of open position\n     * @param healthPosition The parameter determining the riskiness of the position (is averaged to 1).\n     * If it is greater than 1, then the position is not risky, if it is less than 1 risky.\n     * The decimals of this parameter is determined by the decimals `borrowedAsset`.\n     * @param profit An integer showing the profit/loss for open position.\n     */\n    struct OpenPositionData {\n        uint256 id;\n        BucketMetaData bucket;\n        TokenMetadata[2] pair;\n        uint256 positionSize;\n        uint256 liquidationPrice;\n        uint256 stopLossPrice;\n        uint256 takeProfitPrice;\n        uint256 debt;\n        uint256 depositAmount;\n        uint256 createdAt;\n    }\n\n    /**\n     * @dev Structure for the getPositionStatus function with parameters that show the current status of the position\n     * @param liquidationThreshold True if the position is risky\n     * @param takeProfitReached True if the position has reached takeProfitAmount\n     * @param stopLossReached True if the position has reached stopLossAmount\n     */\n    struct PositionStatus {\n        bool liquidationThreshold;\n        bool takeProfitReached;\n        bool stopLossReached;\n    }\n\n    /**\n     * @dev Structure for the getOpenPositionsWithConditions function\n     * @param positionData Open position data\n     * @param conditionsData Conditions data for corresponding position\n     */\n    struct OpenPositionWithConditions {\n        PositionLibrary.Position positionData;\n        LimitOrderLibrary.Condition[] conditionsData;\n    }\n\n    /**\n     * @dev Structure for the getLimitOrdersWithConditions function\n     * @param limitOrderData Limit order data\n     * @param openConditionsData Open conditions data for corresponding order\n     */\n    struct LimitOrderWithConditions {\n        LimitOrderLibrary.LimitOrder limitOrderData;\n        LimitOrderLibrary.Condition[] openConditionsData;\n    }\n\n    /**\n     * @notice Retrieves open position data based on the provided position manager and id.\n     * @param _positionManager The address of the PositionManager where the position is stored\n     * @param _id Position id to show the parameters position\n     * @return openPositionData The open position data including various details.\n     */\n    function getOpenPositionData(address _positionManager, uint256 _id) external returns (OpenPositionData memory);\n\n    /**\n     * @notice The function shows the parameters for all open positions of the `_trader` with the best dex for each position\n     * @param _positionManager The address of the PositionManager where the positions is stored\n     * @param _trader The address, information about all positions of which will be displayed\n     * @param _cursor The cursor value for pagination.\n     * @param _count The number of positions to retrieve.\n     */\n    function getArrayOpenPositionDataByTrader(\n        address _positionManager,\n        address _trader,\n        uint256 _cursor,\n        uint256 _count\n    ) external returns (OpenPositionData[] memory, uint256);\n\n    /**\n     * @notice The function shows the parameters for all open positions of the `_trader` with the best dex for each position\n     * @param _positionManager The address of the PositionManager where the positions is stored\n     * @param _bucket The address of the bucket positions are related to\n     * @param _cursor The cursor value for pagination.\n     * @param _count The number of positions to retrieve.\n     */\n    function getArrayOpenPositionDataByBucket(\n        address _positionManager,\n        address _bucket,\n        uint256 _cursor,\n        uint256 _count\n    ) external returns (OpenPositionData[] memory, uint256);\n\n    /**\n     * @notice Retrieves the status of a position.\n     * @param _positionManager The address of the PositionManager where the position is stored\n     * @param _id Position id to show the parameters position\n     * @param _routes An array of route objects representing the pricing routes.\n     * @return positionStatus The status of the position.\n     */\n    function getPositionStatus(\n        address _positionManager,\n        uint256 _id,\n        PrimexPricingLibrary.Route[] calldata _routes\n    ) external returns (PositionStatus memory);\n\n    /**\n     * @notice Checks if the take profit condition is reached for a given position.\n     * @param _positionManager The address of the PositionManager contract.\n     * @param _id The ID of the position to check.\n     * @param _routes The routes for pricing the position.\n     * @return A boolean indicating whether the take profit condition is reached.\n     */\n    function isTakeProfitReached(\n        address _positionManager,\n        uint256 _id,\n        PrimexPricingLibrary.Route[] calldata _routes\n    ) external returns (bool);\n\n    /**\n     * @notice The function returns the limit orders with corresponding conditions\n     * @param _limitOrderManager The address of the LimitOrderManager where the order is stored.\n     * @param _cursor The cursor value for pagination.\n     * @param _count The number of positions to retrieve.\n     * @return limitOrderWithConditions An array of LimitOrderWithConditions structs representing open positions with conditions.\n     * @return newCursor The new cursor value for pagination.\n     */\n    function getLimitOrdersWithConditions(\n        address _limitOrderManager,\n        uint256 _cursor,\n        uint256 _count\n    ) external view returns (LimitOrderWithConditions[] memory, uint256 newCursor);\n\n    /**\n     * @notice The function returns the positions with corresponding conditions.\n     * @param _positionManager The address of the PositionManager where the position is stored.\n     * @param _cursor The cursor value for pagination.\n     * @param _count The number of positions to retrieve.\n     * @return openPositionsWithConditionsArray An array of OpenPositionWithConditions structs representing open positions with conditions.\n     * @return newCursor The new cursor value for pagination.\n     */\n    function getOpenPositionsWithConditions(\n        address _positionManager,\n        uint256 _cursor,\n        uint256 _count\n    ) external view returns (OpenPositionWithConditions[] memory, uint256 newCursor);\n\n    /**\n     * @notice Retrieves the metadata of a token for a given trader.\n     * @param _token The address of the token.\n     * @param _trader The address of the trader.\n     * @return metadata The metadata of the token.\n     */\n    function getTokenMetadata(address _token, address _trader) external view returns (TokenMetadata memory);\n\n    /**\n     * @notice Retrieves the metadata of an array of tokens for a given trader.\n     * @param _tokens The array of token addresses.\n     * @param _trader The address of the trader.\n     * @return res The array of token metadata.\n     */\n    function getTokenArrayMetadata(\n        address[] calldata _tokens,\n        address _trader\n    ) external view returns (TokenMetadata[] memory);\n\n    /**\n     * @notice Retrieves the metadata of an asset within a bucket.\n     * @param _bucket The address of the Bucket contract.\n     * @param _asset The address of the asset to retrieve metadata for.\n     * @return metadata The metadata of the asset within the bucket.\n     */\n    function getAssetMetadata(address _bucket, address _asset) external view returns (BucketTokenMetadata memory);\n\n    /**\n     * @notice Retrieves information about a supported asset.\n     * @param _bucket The address of the Bucket where the asset is supported.\n     * @param _asset The address of the asset for which information is requested.\n     * @param _trader The address of the Trader requesting the information.\n     * @return supportedAsset The SupportedAsset struct containing the asset and its properties.\n     */\n    function getSupportedAsset(\n        address _bucket,\n        address _asset,\n        address _trader\n    ) external view returns (SupportedAsset memory);\n\n    /**\n     * @notice Retrieves an array of SupportedAsset structs for the given bucket, assets, and trader.\n     * @param _bucket The address of the Bucket.\n     * @param _assets An array of asset addresses.\n     * @param _trader The address of the trader.\n     * @return res An array of SupportedAsset structs representing the supported assets.\n     */\n    function getSupportedAssetArray(\n        address _bucket,\n        address[] memory _assets,\n        address _trader\n    ) external view returns (SupportedAsset[] memory);\n\n    /**\n     * @notice Retrieves the metadata of a bucket.\n     * @param _bucket The address of the Bucket contract.\n     * @param _trader The address of the trader.\n     * @return The metadata of the bucket.\n     */\n    function getBucket(address _bucket, address _trader) external view returns (BucketMetaData memory);\n\n    /**\n     * @notice Retrieves an array of `BucketMetaData` for the given `_user`.\n     * @param _buckets The array of bucket addresses.\n     * @param _trader The address of the trader.\n     * @param _positionManager The address of the PositionManager contract.\n     * @param _showDeprecated Flag to determine whether deprecated buckets should be included.\n     * @return An array of `BucketMetaData` objects.\n     */\n    function getBucketsArray(\n        address[] memory _buckets,\n        address _trader,\n        address _positionManager,\n        bool _showDeprecated\n    ) external view returns (BucketMetaData[] memory);\n\n    /**\n     * @notice Retrieves all bucket metadata from a bucket factory contract.\n     * @param _bucketFactory The address of the BucketFactory contract.\n     * @param _trader The address of the trader for whom the buckets are retrieved.\n     * @param _positionManager The address of the PositionManager contract.\n     * @param _showDeprecated A boolean flag indicating whether to include deprecated buckets in the result.\n     * @return An array of BucketMetaData structs representing the bucket metadata.\n     */\n    function getAllBucketsFactory(\n        address _bucketFactory,\n        address _trader,\n        address _positionManager,\n        bool _showDeprecated\n    ) external view returns (BucketMetaData[] memory);\n\n    /**\n     * @notice Retrieves the latest round data for multiple Chainlink feeds.\n     * @param _feeds An array of feed addresses.\n     * @return res An array of RoundData structs containing the latest round data for each feed.\n     */\n    function getChainlinkLatestRoundData(address[] calldata _feeds) external view returns (RoundData[] memory);\n\n    /**\n     * @notice Calculates the liquidation price for a given position.\n     * @dev The liquidation price is the price at which a position can be liquidated (i.e., its collateral can cover the borrowed amount).\n     * @param _positionManager The address of the PositionManager contract.\n     * @param _bucket The name of the bucket associated with the position.\n     * @param _borrowedAmount The amount borrowed in the position.\n     * @param _positionAsset The address of the asset held in the position.\n     * @param _positionAmount The amount of the asset held in the position.\n     * @return The liquidation price in borrowed asset for the position.\n     */\n    function getLiquidationPrice(\n        address _positionManager,\n        string memory _bucket,\n        uint256 _borrowedAmount,\n        address _positionAsset,\n        uint256 _positionAmount\n    ) external view returns (uint256);\n\n    /**\n     * @notice Retrieves the liquidation price of a position.\n     * @param _positionManager The address of the PositionManager contract.\n     * @param _id The ID of the position.\n     * @return The liquidation price in borrowed asset of the position.\n     */\n    function getLiquidationPrice(address _positionManager, uint256 _id) external view returns (uint256);\n\n    /**\n     * @notice Checks if the stop loss condition of a position is reached.\n     * @param _positionManager The address of the PositionManager contract.\n     * @param _id The ID of the position to check.\n     * @return A boolean indicating whether the stop loss condition is reached.\n     */\n    function isStopLossReached(address _positionManager, uint256 _id) external view returns (bool);\n\n    /**\n     * @notice Retrieves the maximum decrease in position value for a given position ID.\n     * @dev maxDecrease = (1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - pricedrop) * borrowedAssetAmountOut /\n     * (feeBuffer * (1 + maintenanceBuffer)) - position.bucket.getNormalizedVariableDebt() * position.scaledDebtAmount\n     * @param _pm The instance of the PositionManager contract.\n     * @param _id The ID of the position.\n     * @return The maximum decrease in position value.\n     */\n    function getPositionMaxDecrease(IPositionManager _pm, uint256 _id) external view returns (uint256);\n\n    /**\n     * @notice Retrieves information about a lender from the LiquidityMiningRewardDistributor contract.\n     * @param liquidityMiningRewardDistributor The instance of the LiquidityMiningRewardDistributor contract.\n     * @param bucketName The name of the lending bucket.\n     * @param user The address of the lender.\n     * @return info The lender information.\n     */\n    function getLenderInfo(\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor,\n        string memory bucketName,\n        address user\n    ) external view returns (LenderInfo memory);\n\n    /**\n     * @notice Retrieves information about a liquidity mining bucket.\n     * @param liquidityMiningRewardDistributor The instance of the LiquidityMiningRewardDistributor contract.\n     * @param _bucketName The name of the liquidity mining bucket.\n     * @return info The liquidity mining bucket information.\n     */\n    function getLMBucketInfo(\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor,\n        string memory _bucketName\n    ) external view returns (LiquidityMiningBucketInfo memory);\n}\n"
    },
    "contracts/interfaces/IPrimexPricingLibraryMock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\ninterface IPrimexPricingLibraryMock {\n    function getAmountOut(PrimexPricingLibrary.AmountParams memory _params) external returns (uint256);\n\n    function getAmountIn(PrimexPricingLibrary.AmountParams memory _params) external returns (uint256);\n\n    function getOracleAmountsOut(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountAssetA,\n        address _priceOracle\n    ) external returns (uint256);\n\n    function getDepositAmountInBorrowed(\n        PrimexPricingLibrary.AmountParams memory _params,\n        bool _isThirdAsset,\n        address _priceOracle\n    ) external returns (uint256);\n\n    function multiSwap(\n        PrimexPricingLibrary.MultiSwapParams memory _params,\n        uint256 _oracleTolerableLimit,\n        address _primexDNS,\n        address _priceOracle,\n        bool _needCheck\n    ) external returns (uint256);\n\n    function getLiquidationPrice(\n        address _bucket,\n        address _positionAsset,\n        uint256 _positionAmount,\n        uint256 _positionDebt\n    ) external view returns (uint256);\n\n    function getLiquidationPriceByOrder(\n        address _bucket,\n        address _positionAsset,\n        uint256 _limitPrice,\n        uint256 _leverage\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPrimexProxyAdmin.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\n\ninterface IPrimexProxyAdmin {\n    function upgradeBeacon(UpgradeableBeacon beacon, address implementation) external;\n\n    function changeBeaconProxyAdmin(UpgradeableBeacon beacon, address newAdmin) external;\n}\n"
    },
    "contracts/interfaces/IPrimexRegistry.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IPrimexRegistry {\n    /**\n     * @notice A mapping that stores whether a role is designated for contracts only.\n     * @param role The bytes32 identifier of the role.\n     * @return True if the role is designated for contracts only\n     */\n    function isRoleForContractsOnly(bytes32 role) external view returns (bool);\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\n\n    /**\n     * @notice Sets roles to be restricted for contracts only.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param roles An array of bytes32 role identifiers to be restricted for contracts only.\n     */\n    function setRolesForContractsOnly(bytes32[] calldata roles) external;\n\n    /**\n     * @notice Removes roles to be restricted for contracts only.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param roles An array of bytes32 role identifiers to be removed.\n     */\n    function removeRolesForContractsOnly(bytes32[] calldata roles) external;\n\n    function grantRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/interfaces/IPrimexUpkeep.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\n\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {ILimitOrderManager} from \"../LimitOrderManager/ILimitOrderManager.sol\";\nimport {IPrimexLens} from \"./IPrimexLens.sol\";\nimport {IBestDexLens} from \"./IBestDexLens.sol\";\n\ninterface IPrimexUpkeep {\n    enum LiquidationSource {\n        NONE,\n        POSITION,\n        ORDER\n    }\n\n    struct OpenByOrderInfo {\n        uint256 id;\n        uint256 conditionIndex;\n        bytes comAdditionalParams;\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\n    }\n\n    struct LiquidatePositionInfo {\n        uint256 id;\n        uint256 conditionIndex;\n        bytes ccmAdditionalParams;\n        PrimexPricingLibrary.Route[] positionAssetRoutes;\n        PositionLibrary.CloseReason closeReason;\n    }\n\n    struct Routes {\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\n    }\n\n    struct Closable {\n        bool isRiskyOrDelisted;\n        bool canBeClosed;\n        PositionLibrary.CloseReason closeReason;\n    }\n\n    struct CheckUpkeepParams {\n        IBestDexLens.DexWithAncillaryData[] dexes;\n        uint256 cursor;\n        uint256 count;\n        uint256 outputSize;\n    }\n\n    event ErrorHandled(uint256 indexed positionId, address indexed keeper, string reason);\n\n    event PanicErrorHandled(uint256 indexed panicErrorId);\n\n    event LowLevelErrorHandled(bytes revertReason);\n\n    function pm() external returns (IPositionManager);\n\n    function lom() external returns (ILimitOrderManager);\n\n    function primexLens() external returns (IPrimexLens);\n\n    function registry() external returns (address);\n\n    function bestDexLens() external returns (IBestDexLens);\n\n    /**\n     * @dev This function is intended to be called off-chain. Do not call this from other contracts to avoid an out-of-gas error\n     * @notice Checks the upkeep status and performs the necessary actions.\n     * Should be called using callStatic to avoid gas fees\n     * @param checkData The data needed to perform the upkeep check.\n     * @param _dexesWithAncillaryData An array of DexWithAncillaryData structs.\n     * @param _cursor The cursor for pagination.\n     * @param _count The number of elements to retrieve.\n     * @param _outputSize The desired output size.\n     * @return newCursor The new cursor value. Cursor = 0 if no more elements are available.\n     * @return upkeepNeeded A boolean indicating whether upkeep is needed.\n     * @return performData Additional data needed to perform the upkeep.\n     */\n    function checkUpkeep(\n        bytes calldata checkData,\n        IBestDexLens.DexWithAncillaryData[] memory _dexesWithAncillaryData,\n        uint256 _cursor,\n        uint256 _count,\n        uint256 _outputSize\n    ) external returns (uint256 newCursor, bool upkeepNeeded, bytes memory performData);\n\n    /**\n     * @notice Liquidates positions or closes them by condition.\n     * @param toLiquidate Array of LiquidatePositionInfo containing information about positions to be liquidated.\n     * @param keeper The address of the keeper performing the upkeep.\n     */\n    function performUpkeepPositions(LiquidatePositionInfo[] calldata toLiquidate, address keeper) external;\n\n    /**\n     * @notice Equivalent to performUpkeepPositions() but lacking the try/catch block internally.\n     * @param toLiquidate Array of LiquidatePositionInfo containing information about positions to be liquidated.\n     * @param keeper The address of the keeper performing the upkeep.\n     */\n    function performUpkeepPositionsUnsafe(LiquidatePositionInfo[] calldata toLiquidate, address keeper) external;\n\n    /**\n     * @notice Executes limit orders based on the provided OpenByOrderInfo array.\n     * @param toOpenByOrder The array of OpenByOrderInfo structs containing the necessary information to open positions.\n     * @param keeper The address of the keeper performing the upkeep.\n     */\n    function performUpkeepOrders(OpenByOrderInfo[] calldata toOpenByOrder, address keeper) external;\n\n    /**\n     * @notice Equivalent to performUpkeepOrders() but lacking the try/catch block internally.\n     * @param toOpenByOrder The array of OpenByOrderInfo structs containing the necessary information to open positions.\n     * @param keeper The address of the keeper performing the upkeep.\n     */\n    function performUpkeepOrdersUnsafe(OpenByOrderInfo[] calldata toOpenByOrder, address keeper) external;\n\n    /**\n     * @notice Performs upkeep based on the given performData and keeper address.\n     * @param performData The encoded performData containing information about the upkeep.\n     * @param keeper The address of the keeper performing the upkeep.\n     */\n    function performUpkeep(bytes calldata performData, address keeper) external;\n\n    /**\n     * @notice Retrieves the closing parameters based on a condition.\n     * @param ccm The address of the CloseConditionalManager contract.\n     * @param secondAssetRoutes The array of second asset routes.\n     * @return params The encoded closing parameters.\n     */\n    function getClosingParamsByCondition(\n        address ccm,\n        PrimexPricingLibrary.Route[] memory secondAssetRoutes\n    ) external returns (bytes memory params);\n}\n"
    },
    "contracts/interfaces/IRedeemer.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IRedeemer {\n    event RateChanged(uint256 indexed rate);\n    event AdminClaimedEarlyTokens(address indexed token, address indexed to, uint256 indexed amount);\n    event AdminClaimedRegularTokens(address indexed token, address indexed to, uint256 indexed amount);\n\n    /**\n     * @notice Sets the new exchange rate between ePMX and PMX tokens.\n     * Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _rate The new exchange rate in WAD format to be set.\n     */\n    function changeRate(uint256 _rate) external;\n\n    /**\n     * @notice This function allows the sender to redeem a specified amount of tokens.\n     * @dev The sender must have a balance of ePMX tokens.\n     * The redeemed tokens are transferred to the sender's address.\n     */\n    function redeem() external;\n}\n"
    },
    "contracts/interfaces/ISwapManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface ISwapManager is IPausable {\n    event SpotSwap(\n        address indexed trader,\n        address indexed receiver,\n        address tokenA,\n        address tokenB,\n        uint256 amountSold,\n        uint256 amountBought\n    );\n\n    /**\n     * @param tokenA The address of the asset to be swapped from.\n     * @param tokenB The address of the asset to be received in the swap.\n     * @param amountTokenA The amount of tokenA to be swapped.\n     * @param amountOutMin The minimum amount of tokenB expected to receive.\n     * @param routes An array of PrimexPricingLibrary.Route structs representing the routes for the swap.\n     * @param receiver The address where the swapped tokens will be received.\n     * @param deadline The deadline for the swap transaction.\n     * @param isSwapFromWallet A flag indicating whether the swap is perfomed from a wallet or a protocol balance.\n     * @param isSwapToWallet A flag indicating whether the swapped tokens will be sent to a wallet or a protocol balance.\n     * @param isSwapFeeInPmx A flag indicating whether the swap fee is paid in PMX or in native token.\n     * @param payFeeFromWallet A flag indicating whether the swap fee is perfomed from a wallet or a protocol balance.\n     */\n    struct SwapParams {\n        address tokenA;\n        address tokenB;\n        uint256 amountTokenA;\n        uint256 amountOutMin;\n        PrimexPricingLibrary.Route[] routes;\n        address receiver;\n        uint256 deadline;\n        bool isSwapFromWallet;\n        bool isSwapToWallet;\n        bool isSwapFeeInPmx;\n        bool payFeeFromWallet;\n    }\n\n    /**\n     * @notice Executes a swap on dexes defined in routes\n     * @param params The SwapParams struct containing the details of the swap transaction.\n     * @param maximumOracleTolerableLimit The maximum tolerable limit in WAD format (1 WAD = 100%)\n     * @param needOracleTolerableLimitCheck Flag indicating whether to perform an oracle tolerable limit check.\n     * @return The resulting amount after the swap.\n     */\n    function swap(\n        SwapParams calldata params,\n        uint256 maximumOracleTolerableLimit,\n        bool needOracleTolerableLimitCheck\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Retrieves the instance of PrimexRegistry contract.\n     */\n    function registry() external view returns (IAccessControl);\n\n    /**\n     * @notice Retrieves the instance of TraderBalanceVault contract.\n     */\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\n\n    /**\n     * @notice Retrieves the instance of PrimexDNS contract.\n     */\n    function primexDNS() external view returns (IPrimexDNS);\n\n    /**\n     * @notice Retrieves the instance of PriceOracle contract.\n     */\n    function priceOracle() external view returns (IPriceOracle);\n}\n"
    },
    "contracts/interfaces/ITakeProfitStopLossCCM.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\ninterface ITakeProfitStopLossCCM {\n    struct CanBeClosedParams {\n        uint256 takeProfitPrice;\n        uint256 stopLossPrice;\n    }\n\n    struct AdditionalParams {\n        PrimexPricingLibrary.Route[] routes;\n    }\n\n    /**\n     * @notice Checks if the take profit has been reached for a given position.\n     * @param _position The position details.\n     * @param takeProfitPrice The take profit price in WAD format.\n     * @param routes The array of routes for asset swapping.\n     * @return A boolean indicating whether the take profit has been reached.\n     */\n    function isTakeProfitReached(\n        PositionLibrary.Position calldata _position,\n        uint256 takeProfitPrice,\n        PrimexPricingLibrary.Route[] memory routes\n    ) external returns (bool);\n\n    /**\n     * @notice Checks if the take profit has been reached based on the given parameters.\n     * @dev Used in closeBatchPositions() function.\n     * @param _params The encoded parameters.\n     * @param exchangeRate The exchange rate in WAD format.\n     * @return A boolean indicating whether the take profit has been reached.\n     */\n    function isTakeProfitReached(bytes calldata _params, uint256 exchangeRate) external view returns (bool);\n\n    /**\n     * @notice Checks if the stop loss price has been reached for a given position.\n     * @param _position The position details.\n     * @param stopLossPrice The stop loss price in WAD format to compare against.\n     * @return True if the stop loss price is reached, false otherwise.\n     */\n    function isStopLossReached(\n        PositionLibrary.Position calldata _position,\n        uint256 stopLossPrice\n    ) external view returns (bool);\n\n    /**\n     * @notice Checks if the stop loss price has been reached on the given parameters.\n     * @dev The takeProfitPrice and stopLossPrice values can be obtained from the encoded data via CanBeClosedParams struct.\n     * @param _params The encoded closing condition parameters containing stop loss price.\n     * @param oracleExchangeRate The current exchange rate from the oracle in WAD format.\n     * @return True if the stop loss price is reached, false otherwise.\n     */\n    function isStopLossReached(bytes calldata _params, uint256 oracleExchangeRate) external view returns (bool);\n\n    /**\n     * @notice Retrieves the take profit and stop loss prices from the given parameters.\n     * @param _params The encoded parameters for closing a position.\n     * @return takeProfitPrice The take profit price.\n     * @return stopLossPrice The stop loss price.\n     */\n    function getTakeProfitStopLossPrices(bytes calldata _params) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/ITrailingStopCCM.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ITrailingStopCCM {\n    /**\n     * @dev Structure for canBeClosed function of TrailingStop. Params are defined by user at the moment of creation\n     * @param activationPrice The price after which trailing stop will be activated\n     * @param trailingDelta Percentage of the highest price during the position lifecycle.\n     * If price drops below it position should be closed\n     */\n    struct CanBeClosedParams {\n        uint256 activationPrice;\n        uint256 trailingDelta;\n    }\n    /**\n     * @dev Structure for canBeClosed function of TrailingStop. Params are defined by keeper at the moment of closing\n     * @param highPriceRoundNumber Round numbers of price feeds (baseFeed and quoteFeed) for high price\n     * @param lowPriceRoundNumber Round numbers of price feeds (baseFeed and quoteFeed) for low price\n     */\n    struct AdditionalParams {\n        uint80[2] highPriceRoundNumber;\n        uint80[2] lowPriceRoundNumber;\n    }\n}\n"
    },
    "contracts/interfaces/IWhitelist.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IWhitelist {\n    event WhitelistedAddressAdded(address indexed addr);\n    event WhitelistedAddressRemoved(address indexed addr);\n\n    function initialize(address _registry) external;\n\n    function addAddressToWhitelist(address _address) external;\n\n    function addAddressesToWhitelist(address[] calldata _addresses) external;\n\n    function removeAddressFromWhitelist(address _address) external;\n\n    function removeAddressesFromWhitelist(address[] calldata _addresses) external;\n\n    function isWhitelisted(address _address) external view returns (bool);\n\n    function registry() external view returns (address);\n}\n"
    },
    "contracts/interfaces/routers/ICurveCalc.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ICurveCalc {\n    // solhint-disable func-name-mixedcase\n    function get_dx(\n        // solhint-disable-next-line var-name-mixedcase\n        int128 n_coins,\n        uint256[8] memory balances,\n        uint256 amp,\n        uint256 fee,\n        uint256[8] memory rates,\n        uint256[8] memory precisions,\n        bool underlying,\n        int128 i,\n        int128 j,\n        uint256 dy\n    ) external pure returns (uint256);\n}\n"
    },
    "contracts/interfaces/routers/ICurvePool.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ICurvePool {\n    // solhint-disable func-name-mixedcase\n    // solhint-disable var-name-mixedcase\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] memory min_amounts) external;\n\n    function A() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function fee() external view returns (uint256);\n\n    function balances(uint256 _i) external view returns (uint256);\n\n    function coins(uint256 _i) external view returns (address);\n\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/routers/ICurveRegistry.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ICurveRegistry {\n    // solhint-disable func-name-mixedcase\n    function get_n_coins(address _pool) external view returns (uint256[2] memory);\n\n    function get_rates(address _pool) external view returns (uint256[8] memory);\n\n    function get_coin_indices(address _pool, address _from, address _to) external view returns (int128, int128, bool);\n}\n"
    },
    "contracts/interfaces/routers/ICurveRouter.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\n/* solhint-disable func-name-mixedcase */\ninterface ICurveRouter {\n    function exchange(\n        address _pool,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint256 _expected,\n        address _receiver\n    ) external returns (uint256);\n\n    function exchange_with_best_rate(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint256 _expected,\n        address _receiver\n    ) external returns (uint256);\n\n    function get_best_rate(address _from, address _to, uint256 _amount) external view returns (address, uint256);\n\n    function get_input_amount(\n        address _pool,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external view returns (uint256);\n\n    function get_exchange_amount(\n        address _pool,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/KeeperRewardDistributor/IKeeperRewardDistributor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IKeeperRewardDistributorStorage, IKeeperRewardDistributorStorageV2} from \"./IKeeperRewardDistributorStorage.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface IKeeperRewardDistributor is IKeeperRewardDistributorStorage, IPausable {\n    struct DecreasingGasByReasonParams {\n        DecreasingReason reason;\n        uint256 amount;\n    }\n    struct MaxGasPerPositionParams {\n        KeeperActionType actionType;\n        KeeperActionRewardConfig config;\n    }\n\n    /**\n     * @dev     Params for initialize() function\n     * @param   priceOracle  Address of the PriceOracle contract\n     * @param   registry  Address of the Registry contract\n     * @param   pmx  Address of PMXToken\n     * @param   treasury  Address of the Treasury contract\n     * @param   pmxPartInReward  Percentage of PMX in reward (in WAD)\n     * @param   nativePartInReward  Percentage of native token in reward (in WAD)\n     * @param   positionSizeCoefficientA  CoefficientA in the formula positionSize * CoefficientA + CoefficientB\n     * @param   positionSizeCoefficientB  CoefficientB in the formula positionSize * CoefficientA + CoefficientB\n     * @param   additionalGas  Additional gas added to actual gas spent\n     * @param   defaultMaxGasPrice  Max gas price allowed during reward calculation (used when no oracle price found)\n     * @param   oracleGasPriceTolerance  Percentage by which oracle gas price can be exceeded (in WAD)\n     * @param   paymentModel  The model of payment for gas in the network\n     * @param   maxGasPerPositionParams  Parameters for the setMaxGasPerPosition function\n     * @param   decreasingGasByReasonParams  Parameters for the setDecreasingGasByReason function\n     */\n    struct InitParams {\n        address priceOracle;\n        address registry;\n        address pmx;\n        address treasury;\n        address whiteBlackList;\n        uint256 pmxPartInReward;\n        uint256 nativePartInReward;\n        uint256 positionSizeCoefficientA;\n        int256 positionSizeCoefficientB;\n        uint256 additionalGas;\n        uint256 defaultMaxGasPrice;\n        uint256 oracleGasPriceTolerance;\n        PaymentModel paymentModel;\n        MaxGasPerPositionParams[] maxGasPerPositionParams;\n        DecreasingGasByReasonParams[] decreasingGasByReasonParams;\n    }\n\n    event ClaimFees(address indexed keeper, address indexed asset, uint256 amount);\n    event DefaultMaxGasPriceChanged(uint256 indexed defaultMaxGasPrice);\n    event OracleGasPriceToleranceChanged(uint256 indexed oracleGasPriceTolerance);\n    event MaxGasPerPositionChanged(KeeperActionType indexed actionType, KeeperActionRewardConfig config);\n    event DataLengthRestrictionsChanged(KeeperCallingMethod callingMethod, uint256 maxRoutesLength, uint256 baseLength);\n    event DecreasingGasByReasonChanged(DecreasingReason indexed reason, uint256 amount);\n    event PmxPartInRewardChanged(uint256 indexed pmxPartInReward);\n    event NativePartInRewardChanged(uint256 indexed nativePartInReward);\n    event PositionSizeCoefficientsChanged(\n        uint256 indexed positionSizeCoefficientA,\n        int256 indexed positionSizeCoefficientB\n    );\n    event AdditionalGasChanged(uint256 indexed additionalGas);\n    event KeeperRewardUpdated(address indexed keeper, uint256 rewardInPmx, uint256 rewardInNativeCurrency);\n\n    /**\n     * @notice Initializes the KeeperRewardDistributor contract.\n     * @param _params  Parameters for initialization\n     */\n    function initialize(InitParams calldata _params) external;\n\n    /**\n     * @dev Params for the updateReward function\n     * @param keeper  Address of the keeper\n     * @param positionAsset  Address of the position asset\n     * @param positionSize  Size of the position\n     * @param action  The action that was performed by the keeper\n     * @param numberOfActions  Number of actions performed by the keeper\n     * @param gasSpent Gas spent on executing transaction\n     * @param decreasingCounter An array where each index contains the number of decreasing reasons according to the DecreasingReason enum\n     * @param routesLength  The length of routes provided as input to the protocol function,\n     * subject to an additional commission in the ARBITRUM payment model.\n     */\n\n    struct UpdateRewardParams {\n        address keeper;\n        address positionAsset;\n        uint256 positionSize;\n        KeeperActionType action;\n        uint256 numberOfActions;\n        uint256 gasSpent;\n        uint256[] decreasingCounter;\n        uint256 routesLength;\n    }\n\n    /**\n     * @notice Updates reward for keeper for closing position or executing order\n     * @dev Only callable by the PM_ROLE, LOM_ROLE, BATCH_MANAGER_ROLE roles.\n     * @param _params The UpdateRewardParams params\n     */\n    function updateReward(UpdateRewardParams calldata _params) external;\n\n    /**\n     * @notice Claims earned reward of the keeper\n     * @param _pmxAmount  Amount of PMX token to claim\n     * @param _nativeAmount  Amount of native token to claim\n     */\n    function claim(uint256 _pmxAmount, uint256 _nativeAmount) external;\n\n    /**\n     * @notice Sets the default maximum gas price allowed.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _defaultMaxGasPrice The new default maximum gas price value.\n     */\n    function setDefaultMaxGasPrice(uint256 _defaultMaxGasPrice) external;\n\n    /**\n     * @notice Sets the amount of gas to be removed for the specified reason\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _reason The reason for which an amount is set\n     * @param _amount Gas amount.\n     */\n    function setDecreasingGasByReason(DecreasingReason _reason, uint256 _amount) external;\n\n    /**\n     * @notice Sets the KeeperActionRewardConfig for the specified action type\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _actionType The action type for which the config is set\n     * @param _config The KeeperActionRewardConfig struct\n     */\n\n    function setMaxGasPerPosition(KeeperActionType _actionType, KeeperActionRewardConfig calldata _config) external;\n\n    /**\n     * @notice Sets the dataLengthRestrictions for the specified KeeperCallingMethod.\n     * @param _callingMethod The calling method for which dataLengthRestrictions is set\n     * @param _maxRoutesLength The maximum routes length for which an additional fee will be paid in the ARBITRUM payment model, in bytes\n     * @param _baseLength The length of the data entering the protocol function including method signature\n     * and excluding dynamic types(e.g, routesLength), in bytes\n     */\n    function setDataLengthRestrictions(\n        KeeperCallingMethod _callingMethod,\n        uint256 _maxRoutesLength,\n        uint256 _baseLength\n    ) external;\n\n    /**\n     * @notice Sets the tolerance for gas price fluctuations from the oracle price.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _oracleGasPriceTolerance The new oracle gas price tolerance value (percent expressed as WAD).\n     */\n    function setOracleGasPriceTolerance(uint256 _oracleGasPriceTolerance) external;\n\n    /**\n     * @notice Sets the PMX token's portion in the reward calculation.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _pmxPartInReward The new PMX token's portion in the reward calculation (percent expressed as WAD).\n     */\n    function setPmxPartInReward(uint256 _pmxPartInReward) external;\n\n    /**\n     * @notice Sets the native token's portion in the reward calculation.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _nativePartInReward The new native token's portion in the reward calculation (percent expressed as WAD).\n     */\n    function setNativePartInReward(uint256 _nativePartInReward) external;\n\n    /**\n     * @notice Sets the position size coefficients for reward calculations.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _positionSizeCoefficientA The new positionSizeCoefficientA value (in WAD).\n     * @param _positionSizeCoefficientB The new positionSizeCoefficientB value (in WAD).\n     */\n    function setPositionSizeCoefficients(uint256 _positionSizeCoefficientA, int256 _positionSizeCoefficientB) external;\n\n    /**\n     * @notice Sets the additional gas value for reward calculations.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _additionalGas The new additionalGas value.\n     */\n    function setAdditionalGas(uint256 _additionalGas) external;\n}\n\ninterface IKeeperRewardDistributorV2 is IKeeperRewardDistributor, IKeeperRewardDistributorStorageV2 {\n    event MinPositionSizeMultiplierChanged(int256 newMinPositionSizeMultiplier);\n\n    /**\n     * @notice Sets the minPositionSizeMultiplier for reward calculations.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _minPositionSizeMultiplier The new minPositionSizeMultiplier value (in WAD).\n     */\n\n    function setMinPositionSizeMultiplier(int256 _minPositionSizeMultiplier) external;\n}\n"
    },
    "contracts/KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IKeeperRewardDistributorStorage {\n    enum DecreasingReason {\n        NonExistentIdForLiquidation,\n        NonExistentIdForSLOrTP,\n        IncorrectConditionForLiquidation,\n        IncorrectConditionForSL,\n        ClosePostionInTheSameBlock\n    }\n\n    enum KeeperActionType {\n        OpenByOrder,\n        StopLoss,\n        TakeProfit,\n        Liquidation,\n        BucketDelisted\n    }\n\n    enum KeeperCallingMethod {\n        ClosePositionByCondition,\n        OpenPositionByOrder,\n        CloseBatchPositions\n    }\n\n    /**\n     * @dev Structure used in the calculation of keeper rewards in the ARBITRUM payment model\n     * @param maxRoutesLength The maximum length of routes for which will be paid keeper rewards, depending on KeeperCallingMethod\n     * @param baseLength The static length of the data entering the protocol function, depending on KeeperCallingMethod\n     */\n    struct DataLengthRestrictions {\n        uint256 maxRoutesLength;\n        uint256 baseLength;\n    }\n\n    /**\n     * @dev Structure used in the calculation of maximum gas per position\n     * @param baseMaxGas1 Base gas amount that used to calculate max gas amount\n     * @param baseMaxGas2 Base gas amount that used to calculate max gas amount when number of keeper actions > inflectionPoint\n     * @param multiplier2 The multiplier which is multiplied by the number of keeper actions when number of keeper actions > inflectionPoint\n     * @param inflectionPoint Number of actions after which the multiplier2 takes effect\n     */\n    struct KeeperActionRewardConfig {\n        uint256 baseMaxGas1;\n        uint256 baseMaxGas2;\n        uint256 multiplier1;\n        uint256 multiplier2;\n        uint256 inflectionPoint;\n    }\n\n    struct KeeperBalance {\n        uint256 pmxBalance;\n        uint256 nativeBalance;\n    }\n    enum PaymentModel {\n        DEFAULT,\n        ARBITRUM\n    }\n\n    function priceOracle() external view returns (address);\n\n    function registry() external view returns (address);\n\n    function pmx() external view returns (address);\n\n    function treasury() external view returns (address payable);\n\n    function pmxPartInReward() external view returns (uint256);\n\n    function nativePartInReward() external view returns (uint256);\n\n    function positionSizeCoefficientA() external view returns (uint256);\n\n    function positionSizeCoefficientB() external view returns (int256);\n\n    function additionalGas() external view returns (uint256);\n\n    function defaultMaxGasPrice() external view returns (uint256);\n\n    function oracleGasPriceTolerance() external view returns (uint256);\n\n    function paymentModel() external view returns (PaymentModel);\n\n    function keeperBalance(address) external view returns (uint256, uint256);\n\n    function maxGasPerPosition(KeeperActionType) external view returns (uint256, uint256, uint256, uint256, uint256);\n\n    function dataLengthRestrictions(KeeperCallingMethod) external view returns (uint256, uint256);\n\n    function decreasingGasByReason(DecreasingReason) external view returns (uint256);\n\n    function totalBalance() external view returns (uint256, uint256);\n}\n\ninterface IKeeperRewardDistributorStorageV2 is IKeeperRewardDistributorStorage {\n    function minPositionSizeMultiplier() external view returns (int256);\n}\n"
    },
    "contracts/KeeperRewardDistributor/KeeperRewardDistributor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {TokenTransfersLibrary} from \"../libraries/TokenTransfersLibrary.sol\";\n\nimport \"./KeeperRewardDistributorStorage.sol\";\nimport \"../Constants.sol\";\nimport {IKeeperRewardDistributor, IKeeperRewardDistributorV2} from \"./IKeeperRewardDistributor.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {ITreasury} from \"../Treasury/ITreasury.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\nimport {IArbGasInfo} from \"../interfaces/IArbGasInfo.sol\";\n\ncontract KeeperRewardDistributor is IKeeperRewardDistributorV2, KeeperRewardDistributorStorageV2 {\n    using WadRayMath for uint256;\n    IArbGasInfo internal constant ARB_NITRO_ORACLE = IArbGasInfo(0x000000000000000000000000000000000000006C);\n    uint256 internal constant GAS_FOR_BYTE = 16;\n    uint256 internal constant TRASNSACTION_METADATA_BYTES = 140;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    modifier notBlackListed() {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n        _;\n    }\n    /**\n     * @dev Modifier that checks if the caller has a manager role.\n     */\n\n    modifier onlyManagerRole() {\n        _require(\n            IAccessControl(registry).hasRole(PM_ROLE, msg.sender) ||\n                IAccessControl(registry).hasRole(LOM_ROLE, msg.sender) ||\n                IAccessControl(registry).hasRole(BATCH_MANAGER_ROLE, msg.sender),\n            Errors.FORBIDDEN.selector\n        );\n        _;\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n    function initialize(InitParams calldata _params) external override initializer {\n        _require(\n            IERC165Upgradeable(_params.registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(_params.priceOracle).supportsInterface(type(IPriceOracle).interfaceId) &&\n                IERC165Upgradeable(_params.treasury).supportsInterface(type(ITreasury).interfaceId) &&\n                IERC165Upgradeable(_params.pmx).supportsInterface(type(IERC20).interfaceId) &&\n                IERC165Upgradeable(_params.whiteBlackList).supportsInterface(type(IWhiteBlackList).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        pmx = _params.pmx;\n        priceOracle = _params.priceOracle;\n        registry = _params.registry;\n        treasury = payable(_params.treasury);\n        whiteBlackList = IWhiteBlackList(_params.whiteBlackList);\n        pmxPartInReward = _params.pmxPartInReward;\n        nativePartInReward = _params.nativePartInReward;\n        positionSizeCoefficientA = _params.positionSizeCoefficientA;\n        positionSizeCoefficientB = _params.positionSizeCoefficientB;\n        additionalGas = _params.additionalGas;\n        defaultMaxGasPrice = _params.defaultMaxGasPrice;\n        oracleGasPriceTolerance = _params.oracleGasPriceTolerance;\n        paymentModel = _params.paymentModel;\n        for (uint i; i < _params.maxGasPerPositionParams.length; ++i) {\n            _setMaxGasPerPosition(\n                _params.maxGasPerPositionParams[i].actionType,\n                _params.maxGasPerPositionParams[i].config\n            );\n        }\n        for (uint i; i < _params.decreasingGasByReasonParams.length; ++i) {\n            _setDecreasingGasByReason(\n                _params.decreasingGasByReasonParams[i].reason,\n                _params.decreasingGasByReasonParams[i].amount\n            );\n        }\n        __ReentrancyGuard_init();\n        __Pausable_init();\n        __ERC165_init();\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n    function updateReward(UpdateRewardParams calldata _params) external override onlyManagerRole {\n        int256 positionSizeMultiplier = int256(\n            (\n                PrimexPricingLibrary.getOracleAmountsOut(\n                    _params.positionAsset,\n                    NATIVE_CURRENCY,\n                    _params.positionSize,\n                    priceOracle\n                )\n            ).wmul(positionSizeCoefficientA)\n        ) + positionSizeCoefficientB;\n        if (positionSizeMultiplier <= 0) return;\n        if (positionSizeMultiplier < minPositionSizeMultiplier) positionSizeMultiplier = minPositionSizeMultiplier;\n\n        uint256 gasAmount = additionalGas + _pureGasSpent(_params.gasSpent, _params.decreasingCounter);\n        uint256 maxGasAmount = _getMaxGasAmount(_params.action, _params.numberOfActions);\n        if (gasAmount > maxGasAmount) {\n            gasAmount = maxGasAmount;\n        }\n        uint256 gasPrice = tx.gasprice;\n        int256 oracleGasPrice = IPriceOracle(priceOracle).getGasPrice();\n        uint256 maxGasPriceForReward = oracleGasPrice > 0\n            ? uint256(oracleGasPrice).wmul(WadRayMath.WAD + oracleGasPriceTolerance)\n            : defaultMaxGasPrice;\n        if (gasPrice > maxGasPriceForReward) {\n            gasPrice = maxGasPriceForReward;\n        }\n\n        uint256 rewardInNativeCurrency;\n        uint256 rewardInPmx;\n\n        // to avoid stack too deep\n        {\n            uint256 l1CostWei;\n            if (paymentModel == PaymentModel.ARBITRUM) {\n                KeeperCallingMethod callingMethod;\n                uint256 variableLength;\n                if (_params.numberOfActions > 1) {\n                    callingMethod = KeeperCallingMethod.CloseBatchPositions;\n                    // 64 represents 1 slot (32bytes) of _ids and 1 slot (32 bytes) of _conditionIndexes\n                    variableLength = _params.numberOfActions * 64;\n                } else if (_params.action == KeeperActionType.OpenByOrder) {\n                    callingMethod = KeeperCallingMethod.OpenPositionByOrder;\n                } else {\n                    callingMethod = KeeperCallingMethod.ClosePositionByCondition;\n                }\n                DataLengthRestrictions memory restrictions = dataLengthRestrictions[callingMethod];\n                variableLength += _params.routesLength < restrictions.maxRoutesLength\n                    ? _params.routesLength\n                    : restrictions.maxRoutesLength;\n                l1CostWei =\n                    ARB_NITRO_ORACLE.getL1BaseFeeEstimate() *\n                    GAS_FOR_BYTE *\n                    (variableLength + restrictions.baseLength + TRASNSACTION_METADATA_BYTES);\n            }\n\n            uint256 reward = (gasAmount * gasPrice + l1CostWei).wmul(uint256(positionSizeMultiplier));\n            rewardInNativeCurrency = reward.wmul(nativePartInReward);\n            rewardInPmx = PrimexPricingLibrary.getOracleAmountsOut(NATIVE_CURRENCY, pmx, reward, priceOracle).wmul(\n                pmxPartInReward\n            );\n        }\n        keeperBalance[_params.keeper].pmxBalance += rewardInPmx;\n        keeperBalance[_params.keeper].nativeBalance += rewardInNativeCurrency;\n\n        totalBalance.pmxBalance += rewardInPmx;\n        totalBalance.nativeBalance += rewardInNativeCurrency;\n        emit KeeperRewardUpdated(_params.keeper, rewardInPmx, rewardInNativeCurrency);\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n    function claim(\n        uint256 _pmxAmount,\n        uint256 _nativeAmount\n    ) external override nonReentrant whenNotPaused notBlackListed {\n        KeeperBalance memory balance = keeperBalance[msg.sender];\n        if (_pmxAmount > balance.pmxBalance) _pmxAmount = balance.pmxBalance;\n        if (_nativeAmount > balance.nativeBalance) _nativeAmount = balance.nativeBalance;\n\n        if (_pmxAmount > 0) {\n            keeperBalance[msg.sender].pmxBalance -= _pmxAmount;\n            totalBalance.pmxBalance -= _pmxAmount;\n            ITreasury(treasury).transferFromTreasury(_pmxAmount, pmx, msg.sender);\n            emit ClaimFees(msg.sender, pmx, _pmxAmount);\n        }\n        if (_nativeAmount > 0) {\n            keeperBalance[msg.sender].nativeBalance -= _nativeAmount;\n            totalBalance.nativeBalance -= _nativeAmount;\n            ITreasury(treasury).transferFromTreasury(_nativeAmount, NATIVE_CURRENCY, msg.sender);\n            emit ClaimFees(msg.sender, NATIVE_CURRENCY, _nativeAmount);\n        }\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n\n    function setDecreasingGasByReason(\n        DecreasingReason _reason,\n        uint256 _amount\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _setDecreasingGasByReason(_reason, _amount);\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributorV2\n     */\n\n    function setMinPositionSizeMultiplier(\n        int256 _minPositionSizeMultiplier\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(\n            _minPositionSizeMultiplier > 0 && uint256(_minPositionSizeMultiplier) <= WadRayMath.WAD * 2,\n            Errors.INCORRECT_MULTIPLIER.selector\n        );\n        minPositionSizeMultiplier = _minPositionSizeMultiplier;\n        emit MinPositionSizeMultiplierChanged(_minPositionSizeMultiplier);\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n\n    function setMaxGasPerPosition(\n        KeeperActionType _actionType,\n        KeeperActionRewardConfig calldata _config\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _setMaxGasPerPosition(_actionType, _config);\n    }\n\n    function setDataLengthRestrictions(\n        KeeperCallingMethod _callingMethod,\n        uint256 _maxRoutesLength,\n        uint256 _baseLength\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        DataLengthRestrictions storage restrictions = dataLengthRestrictions[_callingMethod];\n        restrictions.maxRoutesLength = _maxRoutesLength;\n        restrictions.baseLength = _baseLength;\n        emit DataLengthRestrictionsChanged(_callingMethod, _maxRoutesLength, _baseLength);\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n    function setDefaultMaxGasPrice(uint256 _defaultMaxGasPrice) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        defaultMaxGasPrice = _defaultMaxGasPrice;\n        emit DefaultMaxGasPriceChanged(_defaultMaxGasPrice);\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n    function setOracleGasPriceTolerance(\n        uint256 _oracleGasPriceTolerance\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        oracleGasPriceTolerance = _oracleGasPriceTolerance;\n        emit OracleGasPriceToleranceChanged(_oracleGasPriceTolerance);\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n    function setPmxPartInReward(uint256 _pmxPartInReward) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(_pmxPartInReward <= TEN_WAD, Errors.INCORRECT_PART_IN_REWARD.selector);\n        pmxPartInReward = _pmxPartInReward;\n        emit PmxPartInRewardChanged(_pmxPartInReward);\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n    function setNativePartInReward(uint256 _nativePartInReward) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(_nativePartInReward <= TEN_WAD, Errors.INCORRECT_PART_IN_REWARD.selector);\n        nativePartInReward = _nativePartInReward;\n        emit NativePartInRewardChanged(_nativePartInReward);\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n    function setPositionSizeCoefficients(\n        uint256 _positionSizeCoefficientA,\n        int256 _positionSizeCoefficientB\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        positionSizeCoefficientA = _positionSizeCoefficientA;\n        positionSizeCoefficientB = _positionSizeCoefficientB;\n        emit PositionSizeCoefficientsChanged(_positionSizeCoefficientA, _positionSizeCoefficientB);\n    }\n\n    /**\n     * @inheritdoc IKeeperRewardDistributor\n     */\n    function setAdditionalGas(uint256 _additionalGas) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        additionalGas = _additionalGas;\n        emit AdditionalGasChanged(_additionalGas);\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IKeeperRewardDistributorV2).interfaceId ||\n            _interfaceId == type(IKeeperRewardDistributor).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    function _setMaxGasPerPosition(KeeperActionType _actionType, KeeperActionRewardConfig calldata _config) internal {\n        maxGasPerPosition[_actionType] = _config;\n        emit MaxGasPerPositionChanged(_actionType, _config);\n    }\n\n    function _setDecreasingGasByReason(DecreasingReason _reason, uint256 _amount) internal {\n        decreasingGasByReason[_reason] = _amount;\n        emit DecreasingGasByReasonChanged(_reason, _amount);\n    }\n\n    function _pureGasSpent(\n        uint256 _totalGasSpent,\n        uint256[] calldata _decreasingCounter\n    ) internal view returns (uint256) {\n        if (_decreasingCounter.length == 0) return _totalGasSpent;\n        uint256 decreaseAmount;\n        for (uint256 i; i < _decreasingCounter.length; ++i) {\n            if (_decreasingCounter[i] > 0)\n                decreaseAmount += _decreasingCounter[i] * decreasingGasByReason[DecreasingReason(i)];\n        }\n        return _totalGasSpent > decreaseAmount ? _totalGasSpent - decreaseAmount : 0;\n    }\n\n    function _getMaxGasAmount(KeeperActionType _actionType, uint256 _numberOfActions) internal view returns (uint256) {\n        // at the moment the number of actions to open by order is always 1\n        if (_actionType == KeeperActionType.OpenByOrder) return maxGasPerPosition[_actionType].multiplier1;\n        KeeperActionRewardConfig storage config = maxGasPerPosition[_actionType];\n        if (config.inflectionPoint == 0 || config.inflectionPoint > _numberOfActions)\n            return config.baseMaxGas1 + config.multiplier1 * _numberOfActions;\n        // We apply the multiplier2  only if numberOfActions >= inflectionPoint\n        return config.baseMaxGas2 + config.multiplier2 * _numberOfActions;\n    }\n}\n"
    },
    "contracts/KeeperRewardDistributor/KeeperRewardDistributorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IKeeperRewardDistributorStorage, IKeeperRewardDistributorStorageV2} from \"./IKeeperRewardDistributorStorage.sol\";\n\nabstract contract KeeperRewardDistributorStorage is\n    IKeeperRewardDistributorStorage,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    ERC165Upgradeable\n{\n    address public override priceOracle;\n    address public override registry;\n    address public override pmx;\n    address payable public override treasury;\n    uint256 public override pmxPartInReward;\n    uint256 public override nativePartInReward;\n    uint256 public override positionSizeCoefficientA;\n    int256 public override positionSizeCoefficientB;\n    uint256 public override additionalGas;\n    uint256 public override defaultMaxGasPrice;\n    uint256 public override oracleGasPriceTolerance;\n    PaymentModel public override paymentModel;\n    mapping(address => KeeperBalance) public override keeperBalance;\n    KeeperBalance public override totalBalance;\n    mapping(KeeperActionType => KeeperActionRewardConfig) public override maxGasPerPosition;\n    mapping(KeeperCallingMethod => DataLengthRestrictions) public override dataLengthRestrictions;\n    mapping(DecreasingReason => uint256) public override decreasingGasByReason;\n    IWhiteBlackList internal whiteBlackList;\n}\n\nabstract contract KeeperRewardDistributorStorageV2 is\n    IKeeperRewardDistributorStorageV2,\n    KeeperRewardDistributorStorage\n{\n    int256 public override minPositionSizeMultiplier;\n}\n"
    },
    "contracts/lens/BestDexLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport \"./../libraries/Errors.sol\";\n\nimport {IBestDexLens} from \"../interfaces/IBestDexLens.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {ILimitOrderManager} from \"../LimitOrderManager/ILimitOrderManager.sol\";\nimport {IDexAdapter} from \"../interfaces/IDexAdapter.sol\";\n\n/**\n * @dev  All functions in this contract are intended to be called off-chain. Do not call functions from other contracts to avoid an out-of-gas error.\n */\ncontract BestDexLens is IBestDexLens, IERC165 {\n    using WadRayMath for uint256;\n    using SafeCast for uint256;\n\n    int256 internal constant VERY_NEGATIVE_VALUE = -1e72;\n    int256 internal constant VERY_POSITIVE_VALUE = 1e72;\n\n    /**\n     * @inheritdoc IBestDexLens\n     */\n    function getBestDexByOrder(\n        BestDexByOrderParams memory _params\n    ) external override returns (GetBestDexByOrderReturnParams memory _returnParams) {\n        _require(\n            IERC165(address(_params.positionManager)).supportsInterface(type(IPositionManager).interfaceId) &&\n                IERC165(address(_params.limitOrderManager)).supportsInterface(type(ILimitOrderManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        LimitOrderLibrary.LimitOrder memory order = _params.limitOrderManager.getOrder(_params.orderId);\n        address borrowedAsset = order.leverage == WadRayMath.WAD\n            ? order.depositAsset\n            : address(order.bucket.borrowedAsset());\n        IPrimexDNS primexDns = _params.positionManager.primexDNS();\n\n        bool isBorrowedAsset = borrowedAsset == order.depositAsset;\n        bool isThirdAsset = !isBorrowedAsset && order.depositAsset != order.positionAsset;\n\n        if (!isBorrowedAsset) {\n            _returnParams.depositToBorrowedReturnParams = getBestMultipleDexes(\n                GetBestMultipleDexesParams({\n                    positionManager: _params.positionManager,\n                    assetToBuy: borrowedAsset,\n                    assetToSell: order.depositAsset,\n                    amount: order.depositAmount,\n                    isAmountToBuy: false,\n                    shares: _params.shares.depositToBorrowedShares,\n                    gasPriceInCheckedAsset: 0,\n                    dexes: _params.dexes\n                })\n            );\n        }\n\n        uint256 depositAmountInBorrowed = PrimexPricingLibrary.getDepositAmountInBorrowed(\n            PrimexPricingLibrary.AmountParams({\n                tokenA: order.depositAsset,\n                tokenB: borrowedAsset,\n                amount: order.depositAmount,\n                routes: _returnParams.depositToBorrowedReturnParams.routes,\n                dexAdapter: primexDns.dexAdapter(),\n                primexDNS: address(primexDns)\n            }),\n            isThirdAsset,\n            address(_params.positionManager.priceOracle())\n        );\n\n        uint256 amountToTransfer = depositAmountInBorrowed.wmul(order.leverage - WadRayMath.WAD);\n\n        if (isBorrowedAsset) {\n            amountToTransfer += depositAmountInBorrowed;\n        } else if (isThirdAsset) {\n            _returnParams.depositInThirdAssetReturnParams = getBestMultipleDexes(\n                GetBestMultipleDexesParams({\n                    positionManager: _params.positionManager,\n                    assetToBuy: order.positionAsset,\n                    assetToSell: order.depositAsset,\n                    amount: order.depositAmount,\n                    isAmountToBuy: false,\n                    shares: _params.shares.depositInThirdAssetShares,\n                    gasPriceInCheckedAsset: 0,\n                    dexes: _params.dexes\n                })\n            );\n        }\n\n        _returnParams.firstAssetReturnParams = getBestMultipleDexes(\n            GetBestMultipleDexesParams({\n                positionManager: _params.positionManager,\n                assetToBuy: order.positionAsset,\n                assetToSell: borrowedAsset,\n                amount: amountToTransfer,\n                isAmountToBuy: false,\n                shares: _params.shares.firstAssetShares,\n                gasPriceInCheckedAsset: 0,\n                dexes: _params.dexes\n            })\n        );\n    }\n\n    /**\n     * @inheritdoc IBestDexLens\n     */\n    function getArrayCurrentPriceAndProfitByPosition(\n        IPositionManager _positionManager,\n        uint256[] memory _ids,\n        uint256[] memory _shares,\n        DexWithAncillaryData[][] memory _dexes\n    ) external override returns (uint256[] memory, int256[] memory) {\n        _require(\n            (_dexes.length == _ids.length) && (_shares.length == _dexes.length),\n            Errors.DIFFERENT_DATA_LENGTH.selector\n        );\n        uint256 count = _ids.length;\n        uint256[] memory currentPrices = new uint256[](count);\n        int256[] memory currentProfits = new int256[](count);\n        for (uint256 i; i < count; i++) {\n            (currentPrices[i], currentProfits[i]) = getCurrentPriceAndProfitByPosition(\n                _positionManager,\n                _ids[i],\n                _shares[i],\n                _dexes[i]\n            );\n        }\n        return (currentPrices, currentProfits);\n    }\n\n    /**\n     * @inheritdoc IBestDexLens\n     */\n    function getPositionProfit(\n        address _positionManager,\n        uint256 _id,\n        PrimexPricingLibrary.Route[] memory _routes\n    ) public override returns (int256) {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        PositionLibrary.Position memory position = IPositionManager(_positionManager).getPosition(_id);\n\n        uint256 expectedBorowedAssetAmount = PrimexPricingLibrary.getAmountOut(\n            PrimexPricingLibrary.AmountParams({\n                tokenA: position.positionAsset,\n                tokenB: position.soldAsset,\n                amount: position.positionAmount,\n                routes: _routes,\n                dexAdapter: IPositionManager(_positionManager).primexDNS().dexAdapter(),\n                primexDNS: address(IPositionManager(_positionManager).primexDNS())\n            })\n        );\n        uint256 positionDebt = IPositionManager(_positionManager).getPositionDebt(_id);\n        uint256 returnedToTrader = expectedBorowedAssetAmount > positionDebt\n            ? expectedBorowedAssetAmount - positionDebt\n            : 0;\n\n        return returnedToTrader.toInt256() - position.depositAmountInSoldAsset.toInt256();\n    }\n\n    /**\n     * @inheritdoc IBestDexLens\n     */\n    function getBestDexByPosition(\n        IPositionManager _positionManager,\n        uint256 _positionId,\n        uint256 _shares,\n        DexWithAncillaryData[] memory _dexesWithAncillaryData\n    ) public override returns (GetBestMultipleDexesReturnParams memory) {\n        _require(\n            IERC165(address(_positionManager)).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        PositionLibrary.Position memory position = _positionManager.getPosition(_positionId);\n\n        return\n            getBestMultipleDexes(\n                GetBestMultipleDexesParams({\n                    positionManager: _positionManager,\n                    assetToBuy: position.soldAsset,\n                    assetToSell: position.positionAsset,\n                    amount: position.positionAmount,\n                    isAmountToBuy: false,\n                    shares: _shares,\n                    gasPriceInCheckedAsset: 0,\n                    dexes: _dexesWithAncillaryData\n                })\n            );\n    }\n\n    /**\n     * @inheritdoc IBestDexLens\n     */\n    function getBestDexForOpenablePosition(\n        BestDexForOpenablePositionParams memory _params\n    )\n        public\n        override\n        returns (\n            GetBestMultipleDexesReturnParams memory _firstAssetReturnParams,\n            GetBestMultipleDexesReturnParams memory _depositInThirdAssetReturnParams,\n            GetBestMultipleDexesReturnParams memory _depositToBorrowedReturnParams\n        )\n    {\n        _require(\n            IERC165(address(_params.positionManager)).supportsInterface(type(IPositionManager).interfaceId) &&\n                _params.borrowedAsset != address(0) &&\n                _params.depositAsset != address(0) &&\n                _params.positionAsset != address(0),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        _require(_params.depositAmount != 0, Errors.DEPOSITED_AMOUNT_IS_0.selector);\n\n        _require(\n            _params.borrowedAmount != 0 || _params.borrowedAsset == _params.depositAsset,\n            Errors.SPOT_DEPOSITED_ASSET_SHOULD_BE_EQUAL_BORROWED_ASSET.selector\n        );\n\n        bool isBorrowedAsset = _params.borrowedAsset == _params.depositAsset;\n        bool isThirdAsset = !isBorrowedAsset && _params.depositAsset != _params.positionAsset;\n        if (!isBorrowedAsset) {\n            _depositToBorrowedReturnParams = getBestMultipleDexes(\n                GetBestMultipleDexesParams({\n                    positionManager: _params.positionManager,\n                    assetToBuy: _params.borrowedAsset,\n                    assetToSell: _params.depositAsset,\n                    amount: _params.depositAmount,\n                    isAmountToBuy: false,\n                    shares: _params.shares.depositToBorrowedShares,\n                    gasPriceInCheckedAsset: 0,\n                    dexes: _params.dexes\n                })\n            );\n        }\n        if (isThirdAsset) {\n            _depositInThirdAssetReturnParams = getBestMultipleDexes(\n                GetBestMultipleDexesParams({\n                    positionManager: _params.positionManager,\n                    assetToBuy: _params.positionAsset,\n                    assetToSell: _params.depositAsset,\n                    amount: _params.depositAmount,\n                    isAmountToBuy: false,\n                    shares: _params.shares.depositInThirdAssetShares,\n                    gasPriceInCheckedAsset: 0,\n                    dexes: _params.dexes\n                })\n            );\n        }\n        _firstAssetReturnParams = getBestMultipleDexes(\n            GetBestMultipleDexesParams({\n                positionManager: _params.positionManager,\n                assetToBuy: _params.positionAsset,\n                assetToSell: _params.borrowedAsset,\n                amount: _params.borrowedAmount + (isBorrowedAsset ? _params.depositAmount : 0),\n                isAmountToBuy: false,\n                shares: _params.shares.firstAssetShares,\n                gasPriceInCheckedAsset: 0,\n                dexes: _params.dexes\n            })\n        );\n    }\n\n    /**\n     * @inheritdoc IBestDexLens\n     */\n    function getBestMultipleDexes(\n        GetBestMultipleDexesParams memory _params\n    ) public override returns (GetBestMultipleDexesReturnParams memory _returnParams) {\n        _require(\n            _params.assetToBuy != address(0) && _params.assetToSell != address(0),\n            Errors.ZERO_ASSET_ADDRESS.selector\n        );\n        _require(_params.assetToBuy != _params.assetToSell, Errors.ASSETS_SHOULD_BE_DIFFERENT.selector);\n        _require(_params.shares > 0, Errors.ZERO_SHARES.selector);\n        _require(_params.amount >= _params.shares, Errors.SHARES_AMOUNT_IS_GREATER_THAN_AMOUNT_TO_SELL.selector);\n\n        GetBestMultipleDexesVars memory vars;\n        DexWithAncillaryData[] memory activeDexes = new DexWithAncillaryData[](_params.dexes.length);\n        vars.shareCount = _params.shares;\n\n        // stores estimated gas to perform swap on each DEX\n        vars.gases = new uint256[](_params.dexes.length);\n\n        // matrix [allDexes.length][shareCount] containing the swapped amount\n        // on each DEX (rows) for each share (columns) minus estimated gas to perform the swap\n        int256[][] memory amountByDexByShare = new int256[][](_params.dexes.length);\n\n        vars.path = new address[](2);\n        vars.path[0] = _params.assetToSell;\n        vars.path[1] = _params.assetToBuy;\n\n        // filter out inactive DEXes and collect their outputs for all possible share splits\n        {\n            IDexAdapter.GetAmountsParams memory amountParams;\n\n            for (uint256 i; i < _params.dexes.length; i++) {\n                // if DEX is not supported or deactivated - set expected gas to a very large number\n                // slither-disable-next-line unused-return\n                try _params.positionManager.primexDNS().getDexAddress(_params.dexes[i].dex) returns (\n                    // slither-disable-next-line unused-return,variable-scope\n                    address currentRouter\n                ) {\n                    uint256 returnGas = IDexAdapter(_params.positionManager.primexDNS().dexAdapter()).getGas(\n                        currentRouter\n                    );\n                    amountParams.amount = _params.amount / vars.shareCount;\n                    amountParams.dexRouter = currentRouter;\n\n                    amountParams.encodedPath = PrimexPricingLibrary.encodePath(\n                        vars.path,\n                        currentRouter,\n                        _params.dexes[i].ancillaryData,\n                        _params.positionManager.primexDNS().dexAdapter(),\n                        _params.isAmountToBuy\n                    );\n\n                    uint256 amount = _getAmountsFromAdapter(\n                        amountParams,\n                        IDexAdapter(_params.positionManager.primexDNS().dexAdapter()),\n                        _params.isAmountToBuy\n                    );\n                    if (amount == type(uint256).max) continue;\n                    // add DEX to active list\n                    activeDexes[vars.activeDexesLength] = _params.dexes[i];\n                    amountByDexByShare[vars.activeDexesLength] = new int256[](vars.shareCount);\n                    // store estimated gas\n                    vars.gases[vars.activeDexesLength] = returnGas;\n                    vars.gasInCheckedAsset = ((returnGas * _params.gasPriceInCheckedAsset) / 1e18).toInt256();\n                    amountByDexByShare[vars.activeDexesLength][0] = _params.isAmountToBuy\n                        ? amount.toInt256() + vars.gasInCheckedAsset\n                        : amount.toInt256() - vars.gasInCheckedAsset;\n                } catch {\n                    continue;\n                }\n                for (uint256 j = 1; j < vars.shareCount; j++) {\n                    amountParams.amount = (_params.amount * (j + 1)) / vars.shareCount;\n                    uint256 amount = _getAmountsFromAdapter(\n                        amountParams,\n                        IDexAdapter(_params.positionManager.primexDNS().dexAdapter()),\n                        _params.isAmountToBuy\n                    );\n\n                    amountByDexByShare[vars.activeDexesLength][j] = _params.isAmountToBuy\n                        ? (\n                            amount == type(uint256).max\n                                ? VERY_POSITIVE_VALUE\n                                : amount.toInt256() + vars.gasInCheckedAsset\n                        )\n                        : (\n                            amount == type(uint256).max\n                                ? VERY_NEGATIVE_VALUE\n                                : amount.toInt256() - vars.gasInCheckedAsset\n                        );\n                }\n\n                // we should get here if first _getAmountsFromAdapter is successful and DEX is active\n                vars.activeDexesLength++;\n            }\n        }\n\n        _require(vars.activeDexesLength > 0, Errors.NO_ACTIVE_DEXES.selector);\n\n        // array with best splitting route\n        uint256[] memory distribution = new uint256[](vars.activeDexesLength);\n        uint256 involvedDexesLength;\n\n        {\n            // matrix [activeDexesLength][shareCount] containing the maximum amount you receive for swapping\n            // j parts of asset for each DEX\n            int256[][] memory answer = new int256[][](vars.activeDexesLength);\n            // matrix [activeDexesLength][shareCount] containing the amount of parts you should swap on previous DEXes\n            // if you swap j parts on current DEX\n            uint256[][] memory parentParts = new uint256[][](vars.activeDexesLength);\n\n            for (uint256 i; i < vars.activeDexesLength; i++) {\n                answer[i] = new int256[](vars.shareCount);\n                parentParts[i] = new uint256[](vars.shareCount);\n            }\n\n            // copy first DEX from `amountByDexByShare` to the `answer` first row\n            for (uint256 j; j < vars.shareCount; j++) {\n                answer[0][j] = amountByDexByShare[0][j];\n            }\n\n            for (uint256 i = 1; i < vars.activeDexesLength; i++) {\n                for (uint256 j; j < vars.shareCount; j++) {\n                    // choose the value from the previous DEX as a max value\n                    int256 bestValue = answer[i - 1][j];\n                    // save current shares count\n                    parentParts[i][j] = j + 1;\n                    // current value is a sum of previous max shares so that total shares count is j + 1\n                    int256 currentValue = amountByDexByShare[i][j];\n                    if (\n                        _params.isAmountToBuy ? (currentValue < bestValue || bestValue == 0) : currentValue > bestValue\n                    ) {\n                        bestValue = currentValue;\n                        parentParts[i][j] = 0;\n                    }\n\n                    for (uint256 k; k < j; k++) {\n                        currentValue = answer[i - 1][j - k - 1] + amountByDexByShare[i][k];\n\n                        // if current value of DEX + previous value of previous DEX is higher than max value\n                        // update max value and save previous shares count\n                        if (\n                            _params.isAmountToBuy\n                                ? (currentValue < bestValue || bestValue == 0)\n                                : currentValue > bestValue\n                        ) {\n                            bestValue = currentValue;\n                            parentParts[i][j] = j - k;\n                        }\n                    }\n                    answer[i][j] = bestValue;\n                }\n            }\n\n            // iterate over `parentParts` backwards and collect the parts of the shares to get the resulting maximum amount\n            {\n                uint256 partsLeft = vars.shareCount;\n                for (uint256 i; i < vars.activeDexesLength; i++) {\n                    if (partsLeft == 0) break;\n                    uint256 curExchange = vars.activeDexesLength - i - 1;\n                    distribution[curExchange] = partsLeft - parentParts[curExchange][partsLeft - 1];\n                    partsLeft = parentParts[curExchange][partsLeft - 1];\n                    if (distribution[curExchange] > 0) {\n                        involvedDexesLength++;\n                    }\n                }\n            }\n        }\n\n        _returnParams.routes = new PrimexPricingLibrary.Route[](involvedDexesLength);\n\n        for (uint256 i; i < vars.activeDexesLength; i++) {\n            if (distribution[i] == 0) continue;\n\n            _returnParams.routes[vars.filledRoutes] = PrimexPricingLibrary.Route({\n                paths: new PrimexPricingLibrary.SwapPath[](1),\n                shares: distribution[i]\n            });\n            _returnParams.routes[vars.filledRoutes].paths[0] = PrimexPricingLibrary.SwapPath({\n                dexName: activeDexes[i].dex,\n                encodedPath: PrimexPricingLibrary.encodePath(\n                    vars.path,\n                    _params.positionManager.primexDNS().getDexAddress(activeDexes[i].dex),\n                    activeDexes[i].ancillaryData,\n                    _params.positionManager.primexDNS().dexAdapter(),\n                    _params.isAmountToBuy\n                )\n            });\n            vars.filledRoutes++;\n            // collect some additional statistics: total return amount, estimate gas spending\n            _returnParams.estimateGasAmount = _returnParams.estimateGasAmount.add(vars.gases[i]);\n            int256 value = amountByDexByShare[i][distribution[i] - 1];\n            _returnParams.returnAmount =\n                _returnParams.returnAmount +\n                uint256(\n                    (\n                        value == 0 ? int256(0) : _params.isAmountToBuy\n                            ? (value - ((vars.gases[i] * _params.gasPriceInCheckedAsset) / 1e18).toInt256())\n                            : (value + ((vars.gases[i] * _params.gasPriceInCheckedAsset) / 1e18).toInt256())\n                    )\n                );\n        }\n    }\n\n    /**\n     * @inheritdoc IBestDexLens\n     */\n    function getCurrentPriceAndProfitByPosition(\n        IPositionManager _positionManager,\n        uint256 _id,\n        uint256 _shares,\n        DexWithAncillaryData[] memory _dexes\n    ) public override returns (uint256, int256) {\n        _require(\n            IERC165(address(_positionManager)).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        PositionLibrary.Position memory position = _positionManager.getPosition(_id);\n\n        PrimexPricingLibrary.Route[] memory routes = getBestMultipleDexes(\n            GetBestMultipleDexesParams({\n                positionManager: _positionManager,\n                assetToBuy: position.soldAsset,\n                assetToSell: position.positionAsset,\n                amount: position.positionAmount,\n                isAmountToBuy: false,\n                shares: _shares,\n                gasPriceInCheckedAsset: 0,\n                dexes: _dexes\n            })\n        ).routes;\n\n        uint256 multiplier1 = 10 ** (18 - IERC20Metadata(position.soldAsset).decimals());\n\n        uint256 currentPriceNumerator = PrimexPricingLibrary.getAmountOut(\n            PrimexPricingLibrary.AmountParams({\n                tokenA: position.positionAsset,\n                tokenB: position.soldAsset,\n                amount: position.positionAmount,\n                routes: routes,\n                dexAdapter: _positionManager.primexDNS().dexAdapter(),\n                primexDNS: address(_positionManager.primexDNS())\n            })\n        ) * multiplier1;\n        uint256 currentPriceDenominator = position.positionAmount *\n            (10 ** (18 - IERC20Metadata(position.positionAsset).decimals()));\n\n        return (\n            currentPriceNumerator.wdiv(currentPriceDenominator) / multiplier1,\n            getPositionProfit(address(_positionManager), _id, routes)\n        );\n    }\n\n    /**\n     * @inheritdoc IBestDexLens\n     */\n    function getAmountOut(PrimexPricingLibrary.AmountParams memory _params) public override returns (uint256) {\n        return PrimexPricingLibrary.getAmountOut(_params);\n    }\n\n    /**\n     * @inheritdoc IBestDexLens\n     */\n    function getAmountIn(PrimexPricingLibrary.AmountParams memory _params) public override returns (uint256) {\n        return PrimexPricingLibrary.getAmountIn(_params);\n    }\n\n    /**\n     * @notice Interface checker\n     * @param interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IBestDexLens).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    /**\n     * @notice Retrieves the amounts from a DEX adapter contract.\n     * @param _params The parameters for getting amounts from the adapter.\n     * @param _adapter The DEX adapter contract.\n     * @param _isAmountToBuy A flag indicating whether the amount to retrieve is for buying or selling.\n     * @return The retrieved amount.\n     */\n    function _getAmountsFromAdapter(\n        IDexAdapter.GetAmountsParams memory _params,\n        IDexAdapter _adapter,\n        bool _isAmountToBuy\n    ) internal returns (uint256) {\n        if (_isAmountToBuy) {\n            try _adapter.getAmountsIn(_params) returns (uint256[3] memory answersList) {\n                return answersList[0];\n            } catch {\n                return type(uint256).max;\n            }\n        }\n        try _adapter.getAmountsOut(_params) returns (uint256[3] memory answersList) {\n            return answersList[1];\n        } catch {\n            return type(uint256).max;\n        }\n    }\n}\n"
    },
    "contracts/lens/PrimexLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport \"./../libraries/Errors.sol\";\n\nimport {IPrimexLens} from \"../interfaces/IPrimexLens.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IBucketsFactory} from \"../Bucket/IBucketsFactory.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {ILimitOrderManager} from \"../LimitOrderManager/ILimitOrderManager.sol\";\nimport {ITakeProfitStopLossCCM} from \"../interfaces/ITakeProfitStopLossCCM.sol\";\nimport {ILiquidityMiningRewardDistributor} from \"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\";\nimport {IInterestRateStrategy} from \"../interfaces/IInterestRateStrategy.sol\";\nimport {IPrimexDNSStorage} from \"../PrimexDNS/IPrimexDNSStorage.sol\";\n\n/**\n * @dev  All functions in this contract are intended to be called off-chain. Do not call functions from other contracts to avoid an out-of-gas error.\n */\n\ncontract PrimexLens is IPrimexLens, ERC165 {\n    using WadRayMath for uint256;\n    using PositionLibrary for PositionLibrary.Position;\n\n    address public immutable takeProfitStopLossCCM;\n\n    constructor(address _takeProfitStopLossCCM) {\n        _require(\n            IERC165(_takeProfitStopLossCCM).supportsInterface(type(ITakeProfitStopLossCCM).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        takeProfitStopLossCCM = _takeProfitStopLossCCM;\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getPositionStatus(\n        address _positionManager,\n        uint256 _id,\n        PrimexPricingLibrary.Route[] calldata _routes\n    ) external override returns (PositionStatus memory) {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        PositionLibrary.Position memory position = IPositionManager(_positionManager).getPosition(_id);\n        LimitOrderLibrary.Condition[] memory closeConditions = IPositionManager(_positionManager).getCloseConditions(\n            _id\n        );\n        bool _isTakeProfitReached;\n        bool _isStopLossReached;\n        for (uint256 i; i < closeConditions.length; i++) {\n            if (\n                IERC165(IPositionManager(_positionManager).primexDNS().cmTypeToAddress(closeConditions[i].managerType))\n                    .supportsInterface(type(ITakeProfitStopLossCCM).interfaceId)\n            ) {\n                ITakeProfitStopLossCCM.CanBeClosedParams memory params = abi.decode(\n                    closeConditions[i].params,\n                    (ITakeProfitStopLossCCM.CanBeClosedParams)\n                );\n                _isTakeProfitReached = ITakeProfitStopLossCCM(takeProfitStopLossCCM).isTakeProfitReached(\n                    position,\n                    params.takeProfitPrice,\n                    _routes\n                );\n                _isStopLossReached = ITakeProfitStopLossCCM(takeProfitStopLossCCM).isStopLossReached(\n                    position,\n                    params.stopLossPrice\n                );\n                break;\n            }\n        }\n        return\n            PositionStatus({\n                liquidationThreshold: IPositionManager(_positionManager).isPositionRisky(_id),\n                takeProfitReached: _isTakeProfitReached,\n                stopLossReached: _isStopLossReached\n            });\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getOpenPositionsWithConditions(\n        address _positionManager,\n        uint256 _cursor,\n        uint256 _count\n    )\n        external\n        view\n        override\n        returns (OpenPositionWithConditions[] memory openPositionsWithConditions, uint256 newCursor)\n    {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        uint256 positionsLength = IPositionManager(_positionManager).getAllPositionsLength();\n        if (_cursor >= positionsLength) {\n            return (openPositionsWithConditions, 0);\n        }\n        if (_cursor + _count >= positionsLength) {\n            _count = positionsLength - _cursor;\n        } else {\n            newCursor = _cursor + _count;\n        }\n\n        openPositionsWithConditions = new OpenPositionWithConditions[](_count);\n        for (uint256 i; i < _count; i++) {\n            openPositionsWithConditions[i].positionData = IPositionManager(_positionManager).getPositionByIndex(\n                _cursor + i\n            );\n            openPositionsWithConditions[i].conditionsData = IPositionManager(_positionManager).getCloseConditions(\n                openPositionsWithConditions[i].positionData.id\n            );\n        }\n        return (openPositionsWithConditions, newCursor);\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getArrayOpenPositionDataByTrader(\n        address _positionManager,\n        address _trader,\n        uint256 _cursor,\n        uint256 _count\n    ) external view override returns (OpenPositionData[] memory positionsData, uint256 newCursor) {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId) && _trader != address(0),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        uint256 positionsLength = IPositionManager(_positionManager).getTraderPositionsLength(_trader);\n        if (_cursor >= positionsLength) {\n            return (positionsData, 0);\n        }\n        if (_cursor + _count >= positionsLength) {\n            _count = positionsLength - _cursor;\n        } else {\n            newCursor = _cursor + _count;\n        }\n\n        positionsData = new OpenPositionData[](_count);\n        for (uint256 i; i < _count; i++) {\n            uint256 positionId = IPositionManager(_positionManager).traderPositionIds(_trader, _cursor + i);\n            positionsData[i] = getOpenPositionData(_positionManager, positionId);\n        }\n        return (positionsData, newCursor);\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getArrayOpenPositionDataByBucket(\n        address _positionManager,\n        address _bucket,\n        uint256 _cursor,\n        uint256 _count\n    ) external view override returns (OpenPositionData[] memory positionsData, uint256 newCursor) {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId) && _bucket != address(0),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        uint256 positionsLength = IPositionManager(_positionManager).getBucketPositionsLength(_bucket);\n        if (_cursor >= positionsLength) {\n            return (positionsData, 0);\n        }\n        if (_cursor + _count >= positionsLength) {\n            _count = positionsLength - _cursor;\n        } else {\n            newCursor = _cursor + _count;\n        }\n\n        positionsData = new OpenPositionData[](_count);\n        for (uint256 i; i < _count; i++) {\n            uint256 positionId = IPositionManager(_positionManager).bucketPositionIds(_bucket, _cursor + i);\n            positionsData[i] = getOpenPositionData(_positionManager, positionId);\n        }\n        return (positionsData, newCursor);\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getAllBucketsFactory(\n        address _bucketFactory,\n        address _user,\n        address _positionManager,\n        bool _showDeprecated\n    ) external view override returns (BucketMetaData[] memory) {\n        _require(\n            IERC165(_bucketFactory).supportsInterface(type(IBucketsFactory).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        address[] memory buckets = IBucketsFactory(_bucketFactory).allBuckets();\n        return getBucketsArray(buckets, _user, _positionManager, _showDeprecated);\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getChainlinkLatestRoundData(\n        address[] calldata _feeds\n    ) external view override returns (RoundData[] memory) {\n        uint256 feedCount = _feeds.length;\n        RoundData[] memory res = new RoundData[](feedCount);\n\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n\n        for (uint256 i; i < feedCount; i++) {\n            _require(_feeds[i] != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n            (roundId, answer, startedAt, updatedAt, answeredInRound) = AggregatorV3Interface(_feeds[i])\n                .latestRoundData();\n            res[i].roundId = roundId;\n            res[i].answer = answer;\n            res[i].startedAt = startedAt;\n            res[i].updatedAt = updatedAt;\n            res[i].answeredInRound = answeredInRound;\n        }\n\n        return res;\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    // getLiquidationPrice for openable positions\n    // in an ideal situation this liquidationPrice is equal getLiquidationPrice for opened positions\n    function getLiquidationPrice(\n        address _positionManager,\n        string memory _bucket,\n        uint256 _borrowedAmount,\n        address _positionAsset,\n        uint256 _positionAmount\n    ) external view override returns (uint256) {\n        _require(\n            IERC165(address(_positionManager)).supportsInterface(type(IPositionManager).interfaceId) &&\n                _positionAsset != address(0),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        address bucket = IPositionManager(_positionManager).primexDNS().getBucketAddress(_bucket);\n\n        return PrimexPricingLibrary.getLiquidationPrice(bucket, _positionAsset, _positionAmount, _borrowedAmount);\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getLimitOrdersWithConditions(\n        address _limitOrderManager,\n        uint256 _cursor,\n        uint256 _count\n    ) external view override returns (LimitOrderWithConditions[] memory limitOrdersWithConditions, uint256 newCursor) {\n        _require(\n            IERC165(_limitOrderManager).supportsInterface(type(ILimitOrderManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        uint256 ordersLength = ILimitOrderManager(_limitOrderManager).getOrdersLength();\n        if (_cursor >= ordersLength) {\n            return (limitOrdersWithConditions, 0);\n        }\n        if (_cursor + _count >= ordersLength) {\n            _count = ordersLength - _cursor;\n        } else {\n            newCursor = _cursor + _count;\n        }\n\n        limitOrdersWithConditions = new LimitOrderWithConditions[](_count);\n        for (uint256 i; i < _count; i++) {\n            limitOrdersWithConditions[i].limitOrderData = ILimitOrderManager(_limitOrderManager).getOrderByIndex(\n                _cursor + i\n            );\n            limitOrdersWithConditions[i].openConditionsData = ILimitOrderManager(_limitOrderManager).getOpenConditions(\n                limitOrdersWithConditions[i].limitOrderData.id\n            );\n        }\n        return (limitOrdersWithConditions, newCursor);\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getTokenArrayMetadata(\n        address[] calldata _tokens,\n        address _trader\n    ) external view override returns (TokenMetadata[] memory) {\n        uint256 tokenCount = _tokens.length;\n        TokenMetadata[] memory res = new TokenMetadata[](tokenCount);\n\n        for (uint256 i; i < tokenCount; i++) {\n            res[i] = getTokenMetadata(_tokens[i], _trader);\n        }\n\n        return res;\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function isTakeProfitReached(\n        address _positionManager,\n        uint256 _id,\n        PrimexPricingLibrary.Route[] calldata _routes\n    ) public override returns (bool) {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        PositionLibrary.Position memory position = IPositionManager(_positionManager).getPosition(_id);\n        LimitOrderLibrary.Condition[] memory closeConditions = IPositionManager(_positionManager).getCloseConditions(\n            _id\n        );\n        if (closeConditions.length == 0) return false;\n        ITakeProfitStopLossCCM.CanBeClosedParams memory params;\n        for (uint256 i; i < closeConditions.length; i++) {\n            if (\n                IERC165(IPositionManager(_positionManager).primexDNS().cmTypeToAddress(closeConditions[i].managerType))\n                    .supportsInterface(type(ITakeProfitStopLossCCM).interfaceId)\n            ) {\n                params = abi.decode(closeConditions[i].params, (ITakeProfitStopLossCCM.CanBeClosedParams));\n                break;\n            }\n        }\n        return\n            ITakeProfitStopLossCCM(takeProfitStopLossCCM).isTakeProfitReached(\n                position,\n                params.takeProfitPrice,\n                _routes\n            );\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getOpenPositionData(\n        address _positionManager,\n        uint256 _id\n    ) public view override returns (OpenPositionData memory) {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        PositionLibrary.Position memory position = IPositionManager(_positionManager).getPosition(_id);\n\n        bool isSpot = address(position.bucket) == address(0);\n        uint256 debt = IPositionManager(_positionManager).getPositionDebt(_id);\n        BucketMetaData memory bucket;\n        if (!isSpot) bucket = getBucket(address(position.bucket), position.trader);\n\n        LimitOrderLibrary.Condition[] memory closeConditions = IPositionManager(_positionManager).getCloseConditions(\n            _id\n        );\n        ITakeProfitStopLossCCM.CanBeClosedParams memory params;\n        for (uint256 i; i < closeConditions.length; i++) {\n            if (\n                IERC165(IPositionManager(_positionManager).primexDNS().cmTypeToAddress(closeConditions[i].managerType))\n                    .supportsInterface(type(ITakeProfitStopLossCCM).interfaceId) &&\n                closeConditions[i].params.length != 0\n            ) {\n                params = abi.decode(closeConditions[i].params, (ITakeProfitStopLossCCM.CanBeClosedParams));\n                break;\n            }\n        }\n        return\n            OpenPositionData({\n                id: position.id,\n                bucket: bucket,\n                pair: [\n                    isSpot ? getTokenMetadata(position.soldAsset, position.trader) : bucket.asset,\n                    getTokenMetadata(position.positionAsset, position.trader)\n                ],\n                positionSize: position.positionAmount,\n                liquidationPrice: getLiquidationPrice(_positionManager, _id),\n                stopLossPrice: params.stopLossPrice,\n                takeProfitPrice: params.takeProfitPrice,\n                debt: debt,\n                depositAmount: position.depositAmountInSoldAsset,\n                createdAt: position.createdAt\n            });\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function isStopLossReached(address _positionManager, uint256 _id) public view override returns (bool) {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        PositionLibrary.Position memory position = IPositionManager(_positionManager).getPosition(_id);\n        LimitOrderLibrary.Condition[] memory closeConditions = IPositionManager(_positionManager).getCloseConditions(\n            _id\n        );\n        if (closeConditions.length == 0) return false;\n        ITakeProfitStopLossCCM.CanBeClosedParams memory params;\n        for (uint256 i; i < closeConditions.length; i++) {\n            if (\n                IERC165(IPositionManager(_positionManager).primexDNS().cmTypeToAddress(closeConditions[i].managerType))\n                    .supportsInterface(type(ITakeProfitStopLossCCM).interfaceId)\n            ) {\n                params = abi.decode(closeConditions[i].params, (ITakeProfitStopLossCCM.CanBeClosedParams));\n                break;\n            }\n        }\n        return ITakeProfitStopLossCCM(takeProfitStopLossCCM).isStopLossReached(position, params.stopLossPrice);\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getTokenMetadata(address _token, address _trader) public view override returns (TokenMetadata memory) {\n        _require(_token != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        return\n            TokenMetadata({\n                tokenAddress: _token,\n                symbol: IERC20Metadata(_token).symbol(),\n                name: IERC20Metadata(_token).name(),\n                decimals: IERC20Metadata(_token).decimals(),\n                balance: _trader != address(0) ? IERC20Metadata(_token).balanceOf(_trader) : 0\n            });\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getAssetMetadata(\n        address _bucket,\n        address _asset\n    ) public view override returns (BucketTokenMetadata memory) {\n        _require(\n            IERC165(_bucket).supportsInterface(type(IBucket).interfaceId) && _asset != address(0),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        uint256 pairPriceDrop = IBucket(_bucket).positionManager().priceOracle().pairPriceDrops(\n            _asset,\n            address(IBucket(_bucket).borrowedAsset())\n        );\n\n        (uint256 id, bool isSupported) = IBucket(_bucket).allowedAssets(_asset);\n        return\n            BucketTokenMetadata({\n                id: id,\n                isSupported: isSupported,\n                pairPriceDrop: pairPriceDrop,\n                maxLeverage: IBucket(_bucket).maxAssetLeverage(_asset)\n            });\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getSupportedAsset(\n        address _bucket,\n        address _asset,\n        address _trader\n    ) public view override returns (SupportedAsset memory) {\n        return\n            SupportedAsset({asset: getTokenMetadata(_asset, _trader), properties: getAssetMetadata(_bucket, _asset)});\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getSupportedAssetArray(\n        address _bucket,\n        address[] memory _assets,\n        address _trader\n    ) public view override returns (SupportedAsset[] memory) {\n        uint256 assetCount = _assets.length;\n        SupportedAsset[] memory res = new SupportedAsset[](assetCount);\n\n        for (uint256 i; i < assetCount; i++) {\n            res[i] = getSupportedAsset(_bucket, _assets[i], _trader);\n        }\n\n        return res;\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getBucket(address _bucket, address _user) public view override returns (BucketMetaData memory) {\n        _require(IERC165(_bucket).supportsInterface(type(IBucket).interfaceId), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        uint256 availableLiquidity = IBucket(_bucket).availableLiquidity();\n        uint256 demand = IBucket(_bucket).debtToken().totalSupply();\n        uint256 supply = demand + availableLiquidity;\n        uint256 ur = supply > 0 ? demand.rdiv(supply) : 0;\n\n        address[] memory allowedAssets = IBucket(_bucket).getAllowedAssets();\n        SupportedAsset[] memory supportedAssets = getSupportedAssetArray(_bucket, allowedAssets, _user);\n        // solhint-disable-next-line var-name-mixedcase\n        IBucket.LiquidityMiningParams memory LMparams = IBucket(_bucket).getLiquidityMiningParams();\n        IInterestRateStrategy.BarCalculationParams memory barCalcParams = IBucket(_bucket)\n            .interestRateStrategy()\n            .getBarCalculationParams(_bucket);\n        return\n            BucketMetaData({\n                bucketAddress: _bucket,\n                name: IBucket(_bucket).name(),\n                asset: getTokenMetadata(address(IBucket(_bucket).borrowedAsset()), _user),\n                bar: IBucket(_bucket).bar(),\n                lar: IBucket(_bucket).lar(),\n                supply: supply,\n                demand: demand,\n                availableLiquidity: availableLiquidity,\n                utilizationRatio: ur,\n                supportedAssets: supportedAssets,\n                pToken: getTokenMetadata(address(IBucket(_bucket).pToken()), _user),\n                debtToken: getTokenMetadata(address(IBucket(_bucket).debtToken()), _user),\n                feeBuffer: IBucket(_bucket).feeBuffer(),\n                withdrawalFeeRate: IBucket(_bucket).withdrawalFeeRate(),\n                miningParams: LMparams,\n                lenderInfo: getLenderInfo(LMparams.liquidityMiningRewardDistributor, IBucket(_bucket).name(), _user),\n                lmBucketInfo: getLMBucketInfo(LMparams.liquidityMiningRewardDistributor, IBucket(_bucket).name()),\n                estimatedBar: IBucket(_bucket).estimatedBar(),\n                estimatedLar: IBucket(_bucket).estimatedLar(),\n                isDeprecated: IBucket(_bucket).isDeprecated(),\n                isDelisted: IBucket(_bucket).isDelisted(),\n                barCalcParams: barCalcParams,\n                maxTotalDeposit: IBucket(_bucket).maxTotalDeposit()\n            });\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getLenderInfo(\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor,\n        string memory bucketName,\n        address user\n    ) public view override returns (LenderInfo memory) {\n        LenderInfo memory info;\n        if (address(liquidityMiningRewardDistributor) == address(0)) return info;\n        (info.amountInMining, info.currentPercent, info.rewardsInPMX) = liquidityMiningRewardDistributor.getLenderInfo(\n            bucketName,\n            user,\n            block.timestamp\n        );\n        return info;\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getLMBucketInfo(\n        ILiquidityMiningRewardDistributor liquidityMiningRewardDistributor,\n        string memory bucketName\n    ) public view override returns (LiquidityMiningBucketInfo memory) {\n        LiquidityMiningBucketInfo memory info;\n        if (address(liquidityMiningRewardDistributor) == address(0)) return info;\n        (info.pmxAmount, info.withdrawnRewards, info.totalPoints) = liquidityMiningRewardDistributor.getBucketInfo(\n            bucketName\n        );\n        return info;\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getBucketsArray(\n        address[] memory _buckets,\n        address _user,\n        address _positionManager,\n        bool _showDeprecated\n    ) public view override returns (BucketMetaData[] memory) {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        uint256 bucketCount;\n        for (uint256 i; i < _buckets.length; i++) {\n            IBucket bucket = IBucket(_buckets[i]);\n            (address bucketAddress, IPrimexDNSStorage.Status currentStatus, , ) = IPositionManager(_positionManager)\n                .primexDNS()\n                .buckets(bucket.name());\n            if (\n                (_showDeprecated ||\n                    !(currentStatus == IPrimexDNSStorage.Status.Deprecated && bucket.pToken().balanceOf(_user) == 0)) &&\n                bucketAddress == _buckets[i]\n            ) {\n                _buckets[bucketCount] = _buckets[i];\n                bucketCount++;\n            }\n        }\n        BucketMetaData[] memory res = new BucketMetaData[](bucketCount);\n        for (uint256 i; i < bucketCount; i++) {\n            res[i] = getBucket(_buckets[i], _user);\n        }\n        return res;\n    }\n\n    /**\n     * @notice Interface checker\n     * @param interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IPrimexLens).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getLiquidationPrice(address _positionManager, uint256 _id) public view override returns (uint256) {\n        _require(\n            IERC165(_positionManager).supportsInterface(type(IPositionManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        PositionLibrary.Position memory position = IPositionManager(_positionManager).getPosition(_id);\n        if (position.scaledDebtAmount == 0) return 0;\n\n        uint256 positionDebt = IPositionManager(_positionManager).getPositionDebt(_id);\n        return\n            PrimexPricingLibrary.getLiquidationPrice(\n                address(position.bucket),\n                position.positionAsset,\n                position.positionAmount,\n                positionDebt\n            );\n    }\n\n    /**\n     * @inheritdoc IPrimexLens\n     */\n    function getPositionMaxDecrease(IPositionManager _pm, uint256 _id) public view override returns (uint256) {\n        PositionLibrary.Position memory position = _pm.getPosition(_id);\n        uint256 pairPriceDrop = _pm.priceOracle().getPairPriceDrop(position.positionAsset, address(position.soldAsset));\n        uint256 securityBuffer = _pm.securityBuffer();\n        uint256 maintenanceBuffer = _pm.maintenanceBuffer();\n\n        uint256 oracleTolerableLimit = _pm.getOracleTolerableLimit(position.positionAsset, address(position.soldAsset));\n\n        uint256 feeBuffer = position.bucket.feeBuffer();\n        uint256 borrowedAssetAmountOut = PrimexPricingLibrary.getOracleAmountsOut(\n            position.positionAsset,\n            position.soldAsset,\n            position.positionAmount,\n            address(_pm.priceOracle())\n        );\n        uint256 maxDecrease = (WadRayMath.WAD - securityBuffer)\n            .wmul(WadRayMath.WAD - oracleTolerableLimit)\n            .wmul(WadRayMath.WAD - pairPriceDrop)\n            .wmul(borrowedAssetAmountOut)\n            .wdiv(feeBuffer.wmul(WadRayMath.WAD + maintenanceBuffer)) -\n            position.bucket.getNormalizedVariableDebt().rmul(position.scaledDebtAmount);\n\n        return maxDecrease <= position.depositAmountInSoldAsset ? maxDecrease : position.depositAmountInSoldAsset;\n    }\n}\n"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\n// solhint-disable-next-line func-visibility\nfunction _require(bool condition, bytes4 selector) pure {\n    if (!condition) _revert(selector);\n}\n\n// solhint-disable-next-line func-visibility\nfunction _revert(bytes4 selector) pure {\n    // solhint-disable-next-line no-inline-assembly\n    assembly (\"memory-safe\") {\n        let free_mem_ptr := mload(64)\n        mstore(free_mem_ptr, selector)\n        revert(free_mem_ptr, 4)\n    }\n}\n\nlibrary Errors {\n    event Log(bytes4 error);\n\n    //common\n    error ADDRESS_NOT_SUPPORTED();\n    error FORBIDDEN();\n    error AMOUNT_IS_0();\n    error CALLER_IS_NOT_TRADER();\n    error CONDITION_INDEX_IS_OUT_OF_BOUNDS();\n    error INVALID_PERCENT_NUMBER();\n    error INVALID_SECURITY_BUFFER();\n    error INVALID_MAINTENANCE_BUFFER();\n    error TOKEN_ADDRESS_IS_ZERO();\n    error IDENTICAL_TOKEN_ADDRESSES();\n    error ASSET_DECIMALS_EXCEEDS_MAX_VALUE();\n    error CAN_NOT_ADD_WITH_ZERO_ADDRESS();\n    error SHOULD_BE_DIFFERENT_ASSETS_IN_SPOT();\n    error TOKEN_NOT_SUPPORTED();\n    error INSUFFICIENT_DEPOSIT();\n    error SHOULD_NOT_HAVE_DUPLICATES();\n    // error LIMIT_PRICE_IS_ZERO();\n    error BUCKET_IS_NOT_ACTIVE();\n    error DIFFERENT_DATA_LENGTH();\n    error RECIPIENT_OR_SENDER_MUST_BE_ON_WHITE_LIST();\n    error SLIPPAGE_TOLERANCE_EXCEEDED();\n    error OPERATION_NOT_SUPPORTED();\n    error SENDER_IS_BLACKLISTED();\n    error NATIVE_CURRENCY_CANNOT_BE_ASSET();\n    error DISABLED_TRANSFER_NATIVE_CURRENCY();\n    error INVALID_AMOUNT();\n\n    // bonus executor\n    error CALLER_IS_NOT_NFT();\n    error BONUS_FOR_BUCKET_ALREADY_ACTIVATED();\n    error WRONG_LENGTH();\n    error BONUS_DOES_NOT_EXIST();\n    error CALLER_IS_NOT_DEBT_TOKEN();\n    error CALLER_IS_NOT_P_TOKEN();\n    error MAX_BONUS_COUNT_EXCEEDED();\n    error TIER_IS_NOT_ACTIVE();\n    error BONUS_PERCENT_IS_ZERO();\n\n    // bucket\n    error INCORRECT_LIQUIDITY_MINING_PARAMS();\n    error PAIR_PRICE_DROP_IS_NOT_CORRECT();\n    error ASSET_IS_NOT_SUPPORTED();\n    error BUCKET_OUTSIDE_PRIMEX_PROTOCOL();\n    error DEADLINE_IS_PASSED();\n    error DEADLINE_IS_NOT_PASSED();\n    error BUCKET_IS_NOT_LAUNCHED();\n    error BURN_AMOUNT_EXCEEDS_PROTOCOL_DEBT();\n    error LIQUIDITY_INDEX_OVERFLOW();\n    error BORROW_INDEX_OVERFLOW();\n    error BAR_OVERFLOW();\n    error LAR_OVERFLOW();\n    error UR_IS_MORE_THAN_1();\n    error ASSET_ALREADY_SUPPORTED();\n    error DEPOSIT_IS_MORE_AMOUNT_PER_USER();\n    error DEPOSIT_EXCEEDS_MAX_TOTAL_DEPOSIT();\n    error MINING_AMOUNT_WITHDRAW_IS_LOCKED_ON_STABILIZATION_PERIOD();\n    error WITHDRAW_RATE_IS_MORE_10_PERCENT();\n    error INVALID_FEE_BUFFER();\n    error RESERVE_RATE_SHOULD_BE_LESS_THAN_1();\n    error MAX_TOTAL_DEPOSIT_IS_ZERO();\n    error AMOUNT_SCALED_SHOULD_BE_GREATER_THAN_ZERO();\n    error NOT_ENOUGH_LIQUIDITY_IN_THE_BUCKET();\n\n    // p/debt token, PMXToken\n    error BUCKET_IS_IMMUTABLE();\n    error INVALID_MINT_AMOUNT();\n    error INVALID_BURN_AMOUNT();\n    error TRANSFER_NOT_SUPPORTED();\n    error APPROVE_NOT_SUPPORTED();\n    error CALLER_IS_NOT_BUCKET();\n    error CALLER_IS_NOT_A_BUCKET_FACTORY();\n    error CALLER_IS_NOT_P_TOKEN_RECEIVER();\n    error DURATION_MUST_BE_MORE_THAN_0();\n    error INCORRECT_ID();\n    error THERE_ARE_NO_LOCK_DEPOSITS();\n    error LOCK_TIME_IS_NOT_EXPIRED();\n    error TRANSFER_AMOUNT_EXCEED_ALLOWANCE();\n    error CALLER_IS_NOT_A_MINTER();\n    error ACTION_ONLY_WITH_AVAILABLE_BALANCE();\n    error FEE_DECREASER_CALL_FAILED();\n    error TRADER_REWARD_DISTRIBUTOR_CALL_FAILED();\n    error INTEREST_INCREASER_CALL_FAILED();\n    error LENDER_REWARD_DISTRIBUTOR_CALL_FAILED();\n    error DEPOSIT_DOES_NOT_EXIST();\n    error RECIPIENT_IS_BLACKLISTED();\n\n    //LOM\n    error ORDER_CAN_NOT_BE_FILLED();\n    error ORDER_DOES_NOT_EXIST();\n    error ORDER_IS_NOT_SPOT();\n    error LEVERAGE_MUST_BE_MORE_THAN_1();\n    error CANNOT_CHANGE_SPOT_ORDER_TO_MARGIN();\n    error SHOULD_HAVE_OPEN_CONDITIONS();\n    error INCORRECT_LEVERAGE();\n    error INCORRECT_DEADLINE();\n    error LEVERAGE_SHOULD_BE_1();\n    error LEVERAGE_EXCEEDS_MAX_LEVERAGE();\n    error SHOULD_OPEN_POSITION();\n    error IS_SPOT_ORDER();\n    error SHOULD_NOT_HAVE_CLOSE_CONDITIONS();\n    error ORDER_HAS_EXPIRED();\n\n    // LiquidityMiningRewardDistributor\n    error BUCKET_IS_NOT_STABLE();\n    error ATTEMPT_TO_WITHDRAW_MORE_THAN_DEPOSITED();\n    error WITHDRAW_PMX_BY_ADMIN_FORBIDDEN();\n\n    // nft\n    error TOKEN_IS_BLOCKED();\n    error ONLY_MINTERS();\n    error PROGRAM_IS_NOT_ACTIVE();\n    error CALLER_IS_NOT_OWNER();\n    error TOKEN_IS_ALREADY_ACTIVATED();\n    error WRONG_NETWORK();\n    error ID_DOES_NOT_EXIST();\n    error WRONG_URIS_LENGTH();\n\n    // PM\n    error ASSET_ADDRESS_NOT_SUPPORTED();\n    error IDENTICAL_ASSET_ADDRESSES();\n    error POSITION_DOES_NOT_EXIST();\n    error AMOUNT_IS_MORE_THAN_POSITION_AMOUNT();\n    error BORROWED_AMOUNT_IS_ZERO();\n    error IS_SPOT_POSITION();\n    error AMOUNT_IS_MORE_THAN_DEPOSIT();\n    error DECREASE_AMOUNT_IS_ZERO();\n    error INSUFFICIENT_DEPOSIT_SIZE();\n    error IS_NOT_RISKY_OR_CANNOT_BE_CLOSED();\n    error BUCKET_SHOULD_BE_UNDEFINED();\n    error DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0();\n    error POSITION_CANNOT_BE_CLOSED_FOR_THIS_REASON();\n    error ADDRESS_IS_ZERO();\n    error WRONG_TRUSTED_MULTIPLIER();\n    error POSITION_SIZE_EXCEEDED();\n    error POSITION_BUCKET_IS_INCORRECT();\n    error THERE_MUST_BE_AT_LEAST_ONE_POSITION();\n    error NOTHING_TO_CLOSE();\n\n    // BatchManager\n    error PARAMS_LENGTH_MISMATCH();\n    error BATCH_CANNOT_BE_CLOSED_FOR_THIS_REASON();\n    error CLOSE_CONDITION_IS_NOT_CORRECT();\n    error SOLD_ASSET_IS_INCORRECT();\n\n    // Price Oracle\n    error ZERO_EXCHANGE_RATE();\n    error NO_PRICEFEED_FOUND();\n    error NO_PRICE_DROP_FEED_FOUND();\n\n    //DNS\n    error INCORRECT_FEE_RATE();\n    error INCORRECT_RESTRICTIONS();\n    error BUCKET_ALREADY_FROZEN();\n    error BUCKET_IS_ALREADY_ADDED();\n    error DEX_IS_ALREADY_ACTIVATED();\n    error DEX_IS_ALREADY_FROZEN();\n    error DEX_IS_ALREADY_ADDED();\n    error BUCKET_NOT_ADDED();\n    error DEX_NOT_ACTIVE();\n    error BUCKET_ALREADY_ACTIVATED();\n    error DEX_NOT_ADDED();\n    error BUCKET_IS_INACTIVE();\n    error WITHDRAWAL_NOT_ALLOWED();\n    error BUCKET_IS_ALREADY_DEPRECATED();\n\n    // Primex upkeep\n    error NUMBER_IS_0();\n\n    //referral program, WhiteBlackList\n    error CALLER_ALREADY_REGISTERED();\n    error MISMATCH();\n    error PARENT_NOT_WHITELISTED();\n    error ADDRESS_ALREADY_WHITELISTED();\n    error ADDRESS_ALREADY_BLACKLISTED();\n    error ADDRESS_NOT_BLACKLISTED();\n    error ADDRESS_NOT_WHITELISTED();\n    error ADDRESS_NOT_UNLISTED();\n    error ADDRESS_IS_WHITELISTED();\n    error ADDRESS_IS_NOT_CONTRACT();\n\n    //Reserve\n    error BURN_AMOUNT_IS_ZERO();\n    error CALLER_IS_NOT_EXECUTOR();\n    error ADDRESS_NOT_PRIMEX_BUCKET();\n    error NOT_SUFFICIENT_RESERVE_BALANCE();\n    error INCORRECT_TRANSFER_RESTRICTIONS();\n\n    //Vault\n    error AMOUNT_EXCEEDS_AVAILABLE_BALANCE();\n    error INSUFFICIENT_FREE_ASSETS();\n    error CALLER_IS_NOT_SPENDER();\n\n    //Pricing Library\n    error IDENTICAL_ASSETS();\n    error SUM_OF_SHARES_SHOULD_BE_GREATER_THAN_ZERO();\n    error DIFFERENT_PRICE_DEX_AND_ORACLE();\n    error TAKE_PROFIT_IS_LTE_LIMIT_PRICE();\n    error STOP_LOSS_IS_GTE_LIMIT_PRICE();\n    error STOP_LOSS_IS_LTE_LIQUIDATION_PRICE();\n    error INSUFFICIENT_POSITION_SIZE();\n    error INCORRECT_PATH();\n    error DEPOSITED_TO_BORROWED_ROUTES_LENGTH_SHOULD_BE_0();\n    error INCORRECT_CM_TYPE();\n    error FEE_RATE_IN_NATIVE_IS_ZERO();\n\n    // Token transfers\n    error TOKEN_TRANSFER_IN_FAILED();\n    error TOKEN_TRANSFER_IN_OVERFLOW();\n    error TOKEN_TRANSFER_OUT_FAILED();\n    error NATIVE_TOKEN_TRANSFER_FAILED();\n\n    // Conditional Managers\n    error LOW_PRICE_ROUND_IS_LESS_HIGH_PRICE_ROUND();\n    error TRAILING_DELTA_IS_INCORRECT();\n    error DATA_FOR_ROUND_DOES_NOT_EXIST();\n    error HIGH_PRICE_TIMESTAMP_IS_INCORRECT();\n    error NO_PRICE_FEED_INTERSECTION();\n    error SHOULD_BE_CCM();\n    error SHOULD_BE_COM();\n\n    //Lens\n    error DEPOSITED_AMOUNT_IS_0();\n    error SPOT_DEPOSITED_ASSET_SHOULD_BE_EQUAL_BORROWED_ASSET();\n    error ZERO_ASSET_ADDRESS();\n    error ASSETS_SHOULD_BE_DIFFERENT();\n    error ZERO_SHARES();\n    error SHARES_AMOUNT_IS_GREATER_THAN_AMOUNT_TO_SELL();\n    error NO_ACTIVE_DEXES();\n\n    //Bots\n    error WRONG_BALANCES();\n    error INVALID_INDEX();\n    error INVALID_DIVIDER();\n    error ARRAYS_LENGTHS_IS_NOT_EQUAL();\n    error DENOMINATOR_IS_0();\n\n    //DexAdapter\n    error ZERO_AMOUNT_IN();\n    error ZERO_AMOUNT();\n    error UNKNOWN_DEX_TYPE();\n    error REVERTED_WITHOUT_A_STRING_TRY_TO_CHECK_THE_ANCILLARY_DATA();\n    error DELTA_OF_TOKEN_OUT_HAS_POSITIVE_VALUE();\n    error DELTA_OF_TOKEN_IN_HAS_NEGATIVE_VALUE();\n    error QUOTER_IS_NOT_PROVIDED();\n    error DEX_ROUTER_NOT_SUPPORTED();\n    error QUOTER_NOT_SUPPORTED();\n    error SWAP_DEADLINE_PASSED();\n\n    //SpotTradingRewardDistributor\n    error PERIOD_DURATION_IS_ZERO();\n    error REWARD_AMOUNT_IS_ZERO();\n    error REWARD_PER_PERIOD_IS_NOT_CORRECT();\n\n    //ActivityRewardDistributor\n    error TOTAL_REWARD_AMOUNT_IS_ZERO();\n    error REWARD_PER_DAY_IS_NOT_CORRECT();\n    error ZERO_BUCKET_ADDRESS();\n    //KeeperRewardDistributor\n    error INCORRECT_PART_IN_REWARD();\n    error INCORRECT_MULTIPLIER();\n\n    //Treasury\n    error TRANSFER_RESTRICTIONS_NOT_MET();\n    error INSUFFICIENT_NATIVE_TOKEN_BALANCE();\n    error INSUFFICIENT_TOKEN_BALANCE();\n    error EXCEEDED_MAX_AMOUNT_DURING_TIMEFRAME();\n    error EXCEEDED_MAX_SPENDING_LIMITS();\n    error SPENDING_LIMITS_ARE_INCORRECT();\n    error SPENDER_IS_NOT_EXIST();\n}\n"
    },
    "contracts/libraries/LimitOrderLibrary.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {WadRayMath} from \"./utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"./PrimexPricingLibrary.sol\";\nimport {TokenTransfersLibrary} from \"./TokenTransfersLibrary.sol\";\n\nimport {NATIVE_CURRENCY} from \"../Constants.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPrimexDNSStorage} from \"../PrimexDNS/IPrimexDNSStorage.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IConditionalOpeningManager} from \"../interfaces/IConditionalOpeningManager.sol\";\nimport {IConditionalClosingManager} from \"../interfaces/IConditionalClosingManager.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {ISwapManager} from \"../interfaces/ISwapManager.sol\";\n\nimport \"./Errors.sol\";\n\nlibrary LimitOrderLibrary {\n    using WadRayMath for uint256;\n\n    enum CloseReason {\n        FilledMargin,\n        FilledSpot,\n        FilledSwap,\n        Cancelled\n    }\n\n    struct Condition {\n        uint256 managerType;\n        bytes params;\n    }\n\n    /**\n     * @dev Creates a limit order and locks the deposit asset in the traderBalanceVault\n     * @param bucket The bucket, from which the loan will be taken\n     * @param positionAsset The address of output token for exchange\n     * @param depositAsset The address of the deposit token\n     * @param depositAmount The amount of deposit trader funds for deal\n     * @param feeToken An asset in which the fee will be paid. At this point it could be the pmx, the epmx or a native currency\n     * @param trader The trader, who has created the order\n     * @param deadline Unix timestamp after which the order will not be filled\n     * @param id The unique id of the order\n     * @param leverage leverage for trading\n     * @param shouldOpenPosition The flag to indicate whether position should be opened\n     * @param createdAt The timeStamp when the order was created\n     * @param updatedConditionsAt The timestamp when the open condition was updated\n     */\n    struct LimitOrder {\n        IBucket bucket;\n        address positionAsset;\n        address depositAsset;\n        uint256 depositAmount;\n        address feeToken;\n        uint256 protocolFee;\n        address trader;\n        uint256 deadline;\n        uint256 id;\n        uint256 leverage;\n        bool shouldOpenPosition;\n        uint256 createdAt;\n        uint256 updatedConditionsAt;\n        // The byte-encoded params, can be used for future updates\n        bytes extraParams;\n    }\n\n    /**\n     * @dev Structure for the сreateLimitOrder with parameters necessary to create limit order\n     * @param bucket The bucket, from which the loan will be taken\n     * @param depositAsset The address of the deposit token (collateral for margin trade or\n     * locked funds for spot)\n     * @param depositAmount The amount of deposit funds for deal\n     * @param positionAsset The address output token for exchange\n     * @param deadline Unix timestamp after which the order will not be filled\n     * @param takeDepositFromWallet Bool, add a collateral deposit within the current transaction\n     * @param leverage leverage for trading\n     * @param shouldOpenPosition Bool, indicate whether position should be opened\n     * @param openingManagerAddresses Array of contract addresses that will be called in canBeFilled\n     * @param openingManagerParams Array of bytes representing params for contracts in openingManagerAddresses\n     * @param closingManagerAddresses Array of contract addresses that will be called in canBeClosed\n     * @param closingManagerParams Array of bytes representing params for contracts in closingManagerAddresses\n     */\n    struct CreateLimitOrderParams {\n        string bucket;\n        uint256 depositAmount;\n        address depositAsset;\n        address positionAsset;\n        uint256 deadline;\n        bool takeDepositFromWallet;\n        bool payFeeFromWallet;\n        uint256 leverage;\n        bool shouldOpenPosition;\n        Condition[] openConditions;\n        Condition[] closeConditions;\n        bool isProtocolFeeInPmx;\n    }\n\n    struct CreateLimitOrderVars {\n        bool isSpot;\n        IBucket bucket;\n        uint256 positionSize;\n        address priceOracle;\n        uint256 rate;\n        address feeToken;\n    }\n\n    /**\n     * @dev Opens a position on an existing order\n     * @param orderId order id\n     * @param com address of ConditionalOpeningManager\n     * @param comAdditionalParams  params needed for ConditionalOpeningManager to calc canBeFilled\n     * @param firstAssetRoutes routes to swap first asset\n     * @param depositInThirdAssetRoutes routes to swap deposit asset\n     */\n    struct OpenPositionParams {\n        uint256 orderId;\n        uint256 conditionIndex;\n        bytes comAdditionalParams;\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\n        address keeper;\n    }\n\n    struct OpenPositionByOrderVars {\n        address assetIn;\n        address assetOut;\n        uint256 amountIn;\n        uint256 amountOut;\n        CloseReason closeReason;\n        uint256 newPositionId;\n        uint256 exchangeRate;\n    }\n\n    /**\n     * @dev Params for PositionManager to open position\n     * @param order order\n     * @param firstAssetRoutes routes to swap first asset on dex\n     * (borrowedAmount + depositAmount if deposit in borrowedAsset)\n     * @param depositInThirdAssetRoutes routes to swap deposit in third asset on dex\n     */\n    struct OpenPositionByOrderParams {\n        address sender;\n        LimitOrder order;\n        Condition[] closeConditions;\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\n    }\n\n    /**\n     * @dev Structure for the updateOrder with parameters necessary to update limit order\n     * @param orderId order id to update\n     * @param depositAmount The amount of deposit funds for deal\n     * @param makeDeposit Bool, add a collateral deposit within the current transaction\n     * @param leverage leverage for trading\n     * @param takeDepositFromWallet Bool, add a collateral deposit within the current transaction\n     * @param payFeeFromWallet A flag indicating whether the Limit Order fee is perfomed from a wallet or a protocol balance.\n     */\n    struct UpdateLimitOrderParams {\n        uint256 orderId;\n        uint256 depositAmount;\n        uint256 leverage;\n        bool isProtocolFeeInPmx;\n        bool takeDepositFromWallet;\n        bool payFeeFromWallet;\n    }\n\n    /**\n     * @notice Updates the protocol fee for a LimitOrder.\n     * @param _order The LimitOrder storage object to update.\n     * @param _params The new parameters for the LimitOrder.\n     * @param _traderBalanceVault The instance of the TraderBalanceVault contract.\n     * @param _primexDNS The PrimexDNS contract for accessing PMX-related information.\n     * @param _priceOracle The address of the price oracle contract.\n     */\n    function updateProtocolFee(\n        LimitOrder storage _order,\n        UpdateLimitOrderParams calldata _params,\n        ITraderBalanceVault _traderBalanceVault,\n        IPrimexDNS _primexDNS,\n        address _priceOracle\n    ) public {\n        address feeToken;\n        if (_params.isProtocolFeeInPmx) {\n            feeToken = _primexDNS.pmx();\n            _require(msg.value == 0, Errors.DISABLED_TRANSFER_NATIVE_CURRENCY.selector);\n        } else {\n            feeToken = NATIVE_CURRENCY;\n        }\n        if (\n            _params.leverage != _order.leverage ||\n            _params.depositAmount != _order.depositAmount ||\n            feeToken != _order.feeToken\n        ) {\n            uint256 newProtocolFee = PrimexPricingLibrary.calculateProtocolFee(\n                PrimexPricingLibrary.DepositData({\n                    protocolFee: 0,\n                    depositAsset: _order.depositAsset,\n                    depositAmount: _params.depositAmount,\n                    leverage: _params.leverage\n                }),\n                _primexDNS,\n                _priceOracle,\n                _order.shouldOpenPosition\n                    ? IPrimexDNSStorage.OrderType.LIMIT_ORDER\n                    : IPrimexDNSStorage.OrderType.SWAP_LIMIT_ORDER,\n                feeToken\n            );\n            if (feeToken == _order.feeToken) {\n                uint256 amount;\n                unchecked {\n                    if (newProtocolFee > _order.protocolFee) amount = newProtocolFee - _order.protocolFee;\n                    else amount = _order.protocolFee - newProtocolFee;\n                }\n                depositLockOrUnlock(\n                    _traderBalanceVault,\n                    feeToken,\n                    amount,\n                    _params.payFeeFromWallet,\n                    newProtocolFee > _order.protocolFee\n                );\n            } else {\n                if (newProtocolFee > 0) {\n                    //lock the new fee token\n                    depositLockOrUnlock(_traderBalanceVault, feeToken, newProtocolFee, _params.payFeeFromWallet, true);\n                }\n                //unlock the old fee token\n                depositLockOrUnlock(\n                    _traderBalanceVault,\n                    _order.feeToken,\n                    _order.protocolFee,\n                    _params.payFeeFromWallet,\n                    false\n                );\n                _order.feeToken = feeToken;\n            }\n            _order.protocolFee = newProtocolFee;\n        }\n    }\n\n    /**\n     * @notice Updates the leverage of a limit order.\n     * @param _order The limit order to update.\n     * @param _leverage The new leverage value in WAD format for the order.\n     */\n    function updateLeverage(LimitOrder storage _order, uint256 _leverage) public {\n        _require(_leverage > WadRayMath.WAD, Errors.LEVERAGE_MUST_BE_MORE_THAN_1.selector);\n        _require(_order.leverage != WadRayMath.WAD, Errors.CANNOT_CHANGE_SPOT_ORDER_TO_MARGIN.selector);\n\n        _require(\n            _leverage < _order.bucket.maxAssetLeverage(_order.positionAsset),\n            Errors.LEVERAGE_EXCEEDS_MAX_LEVERAGE.selector\n        );\n        _order.leverage = _leverage;\n    }\n\n    /**\n     * @notice Updates the deposit details of a LimitOrder.\n     * @param _order The LimitOrder to update.\n     * @param _amount The amount of the asset being deposited.\n     * @param _takeDepositFromWallet Boolean indicating whether to make a deposit or unlock the deposited asset.\n     * @param traderBalanceVault The instance of ITraderBalanceVault used for deposit and unlock operations.\n     */\n    function updateDeposit(\n        LimitOrderLibrary.LimitOrder storage _order,\n        uint256 _amount,\n        bool _takeDepositFromWallet,\n        ITraderBalanceVault traderBalanceVault\n    ) public {\n        depositLockOrUnlock(\n            traderBalanceVault,\n            _order.depositAsset,\n            (_amount > _order.depositAmount) ? _amount - _order.depositAmount : _order.depositAmount - _amount,\n            _takeDepositFromWallet,\n            _amount > _order.depositAmount\n        );\n        _order.depositAmount = _amount;\n    }\n\n    /**\n     * @notice Sets the open conditions for a LimitOrder.\n     * @param _order The limit order.\n     * @param openConditionsMap The mapping of order IDs to open conditions.\n     * @param openConditions The array of open conditions.\n     * @param primexDNS The instance of the Primex DNS contract.\n     */\n    function setOpenConditions(\n        LimitOrderLibrary.LimitOrder memory _order,\n        mapping(uint256 => Condition[]) storage openConditionsMap,\n        Condition[] memory openConditions,\n        IPrimexDNS primexDNS\n    ) public {\n        _require(hasNoConditionManagerTypeDuplicates(openConditions), Errors.SHOULD_NOT_HAVE_DUPLICATES.selector);\n        _require(openConditions.length > 0, Errors.SHOULD_HAVE_OPEN_CONDITIONS.selector);\n        if (openConditionsMap[_order.id].length > 0) {\n            delete openConditionsMap[_order.id];\n        }\n        Condition memory condition;\n        for (uint256 i; i < openConditions.length; i++) {\n            condition = openConditions[i];\n            _require(\n                IERC165Upgradeable(primexDNS.cmTypeToAddress(condition.managerType)).supportsInterface(\n                    type(IConditionalOpeningManager).interfaceId\n                ),\n                Errors.SHOULD_BE_COM.selector\n            );\n            openConditionsMap[_order.id].push(condition);\n        }\n    }\n\n    /**\n     * @notice Sets the close conditions for a LimitOrder.\n     * @param _order The limit order.\n     * @param closeConditionsMap The mapping of order IDs to close conditions.\n     * @param closeConditions The array of close conditions to set.\n     * @param primexDNS The Primex DNS contract address.\n     */\n    function setCloseConditions(\n        LimitOrderLibrary.LimitOrder memory _order,\n        mapping(uint256 => Condition[]) storage closeConditionsMap,\n        Condition[] memory closeConditions,\n        IPrimexDNS primexDNS\n    ) public {\n        _require(hasNoConditionManagerTypeDuplicates(closeConditions), Errors.SHOULD_NOT_HAVE_DUPLICATES.selector);\n        _require(\n            _order.shouldOpenPosition || closeConditions.length == 0,\n            Errors.SHOULD_NOT_HAVE_CLOSE_CONDITIONS.selector\n        );\n\n        if (closeConditionsMap[_order.id].length > 0) {\n            delete closeConditionsMap[_order.id];\n        }\n        Condition memory condition;\n        for (uint256 i; i < closeConditions.length; i++) {\n            condition = closeConditions[i];\n            _require(\n                IERC165Upgradeable(primexDNS.cmTypeToAddress(condition.managerType)).supportsInterface(\n                    type(IConditionalClosingManager).interfaceId\n                ),\n                Errors.SHOULD_BE_CCM.selector\n            );\n            closeConditionsMap[_order.id].push(condition);\n        }\n    }\n\n    /**\n     * @notice Creates a limit order.\n     * @param _params The struct containing the order parameters.\n     * @param pm The instance of the PositionManager contract.\n     * @param traderBalanceVault The instance of the TraderBalanceVault contract.\n     * @param primexDNS The instance of the PrimexDNS contract.\n     * @return The created limit order.\n     */\n    function createLimitOrder(\n        CreateLimitOrderParams calldata _params,\n        IPositionManager pm,\n        ITraderBalanceVault traderBalanceVault,\n        IPrimexDNS primexDNS\n    ) public returns (LimitOrder memory) {\n        _require(_params.leverage >= WadRayMath.WAD, Errors.INCORRECT_LEVERAGE.selector);\n        _require(_params.deadline > block.timestamp, Errors.INCORRECT_DEADLINE.selector);\n\n        CreateLimitOrderVars memory vars;\n        vars.isSpot = bytes(_params.bucket).length == 0;\n        vars.positionSize = _params.depositAmount.wmul(_params.leverage);\n        vars.priceOracle = address(pm.priceOracle());\n        if (vars.isSpot) {\n            _require(_params.leverage == WadRayMath.WAD, Errors.LEVERAGE_SHOULD_BE_1.selector);\n            _require(_params.depositAsset != _params.positionAsset, Errors.SHOULD_BE_DIFFERENT_ASSETS_IN_SPOT.selector);\n            IPriceOracle(vars.priceOracle).getPriceFeedsPair(_params.positionAsset, _params.depositAsset);\n        } else {\n            _require(_params.shouldOpenPosition, Errors.SHOULD_OPEN_POSITION.selector);\n            _require(_params.leverage > WadRayMath.WAD, Errors.LEVERAGE_MUST_BE_MORE_THAN_1.selector);\n            vars.bucket = IBucket(primexDNS.getBucketAddress(_params.bucket));\n            _require(vars.bucket.getLiquidityMiningParams().isBucketLaunched, Errors.BUCKET_IS_NOT_LAUNCHED.selector);\n\n            (, bool tokenAllowed) = vars.bucket.allowedAssets(_params.positionAsset);\n            _require(tokenAllowed, Errors.TOKEN_NOT_SUPPORTED.selector);\n            _require(\n                _params.leverage < vars.bucket.maxAssetLeverage(_params.positionAsset),\n                Errors.LEVERAGE_EXCEEDS_MAX_LEVERAGE.selector\n            );\n        }\n        LimitOrder memory order = LimitOrder({\n            bucket: IBucket(address(0)),\n            positionAsset: _params.positionAsset,\n            depositAsset: _params.depositAsset,\n            depositAmount: _params.depositAmount,\n            feeToken: _params.isProtocolFeeInPmx ? primexDNS.pmx() : NATIVE_CURRENCY,\n            protocolFee: 0,\n            trader: msg.sender,\n            deadline: _params.deadline,\n            id: 0,\n            leverage: _params.leverage,\n            shouldOpenPosition: _params.shouldOpenPosition,\n            createdAt: block.timestamp,\n            updatedConditionsAt: block.timestamp,\n            extraParams: \"\"\n        });\n        order.bucket = vars.bucket;\n\n        PrimexPricingLibrary.validateMinPositionSize(\n            pm.minPositionSize(),\n            pm.minPositionAsset(),\n            vars.positionSize,\n            order.depositAsset,\n            vars.priceOracle\n        );\n        if (_params.isProtocolFeeInPmx) {\n            vars.feeToken = primexDNS.pmx();\n            _require(msg.value == 0, Errors.DISABLED_TRANSFER_NATIVE_CURRENCY.selector);\n        } else {\n            vars.feeToken = NATIVE_CURRENCY;\n        }\n\n        order.protocolFee = PrimexPricingLibrary.calculateProtocolFee(\n            PrimexPricingLibrary.DepositData({\n                protocolFee: 0,\n                depositAsset: _params.depositAsset,\n                depositAmount: _params.depositAmount,\n                leverage: _params.leverage\n            }),\n            primexDNS,\n            vars.priceOracle,\n            order.shouldOpenPosition\n                ? IPrimexDNSStorage.OrderType.LIMIT_ORDER\n                : IPrimexDNSStorage.OrderType.SWAP_LIMIT_ORDER,\n            vars.feeToken\n        );\n\n        if (order.protocolFee > 0) {\n            // fee locking\n            depositLockOrUnlock(traderBalanceVault, vars.feeToken, order.protocolFee, _params.payFeeFromWallet, true);\n        }\n        // deposit locking\n        depositLockOrUnlock(\n            traderBalanceVault,\n            order.depositAsset,\n            order.depositAmount,\n            _params.takeDepositFromWallet,\n            true\n        );\n\n        return order;\n    }\n\n    /**\n     * @notice Opens a position by order.\n     * @param order The LimitOrder storage containing order details.\n     * @param _params The OpenPositionParams calldata containing additional position parameters.\n     * @param _closeConditions The Condition array containing close conditions for the position.\n     * @param pm The instance of the PositionManager contract.\n     * @param traderBalanceVault The instance of the TraderBalanceVault contract.\n     * @param primexDNS The instance of the PrimexDNS contract.\n     * @param swapManager The instance of the SwapManager contract.\n     * @return vars The OpenPositionByOrderVars struct containing the result of the open position operation.\n     */\n    function openPositionByOrder(\n        LimitOrder storage order,\n        OpenPositionParams calldata _params,\n        Condition[] memory _closeConditions,\n        IPositionManager pm,\n        ITraderBalanceVault traderBalanceVault,\n        IPrimexDNS primexDNS,\n        ISwapManager swapManager\n    ) public returns (OpenPositionByOrderVars memory) {\n        OpenPositionByOrderVars memory vars;\n        bool isSpot = address(order.bucket) == address(0);\n\n        if (order.shouldOpenPosition) {\n            vars.closeReason = isSpot ? CloseReason.FilledSpot : CloseReason.FilledMargin;\n            (vars.amountIn, vars.amountOut, vars.newPositionId, vars.exchangeRate) = pm.openPositionByOrder(\n                OpenPositionByOrderParams({\n                    sender: msg.sender,\n                    order: order,\n                    closeConditions: _closeConditions,\n                    firstAssetRoutes: _params.firstAssetRoutes,\n                    depositInThirdAssetRoutes: _params.depositInThirdAssetRoutes\n                })\n            );\n        } else {\n            _require(\n                _params.depositInThirdAssetRoutes.length == 0,\n                Errors.DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0.selector\n            );\n            vars.closeReason = CloseReason.FilledSwap;\n            vars.amountIn = order.depositAmount;\n\n            // calculateFee is false so 'depositData' and 'priceOracle' are default values except 'protocolFee'\n            PrimexPricingLibrary.payProtocolFee(\n                PrimexPricingLibrary.ProtocolFeeParams({\n                    depositData: PrimexPricingLibrary.DepositData({\n                        protocolFee: order.protocolFee,\n                        depositAsset: address(0),\n                        depositAmount: 0,\n                        leverage: 0\n                    }),\n                    feeToken: order.feeToken,\n                    isSwapFromWallet: false,\n                    calculateFee: false,\n                    orderType: IPrimexDNSStorage.OrderType.SWAP_LIMIT_ORDER,\n                    trader: order.trader,\n                    priceOracle: address(0),\n                    traderBalanceVault: traderBalanceVault,\n                    primexDNS: primexDNS\n                })\n            );\n\n            traderBalanceVault.unlockAsset(\n                ITraderBalanceVault.UnlockAssetParams({\n                    trader: order.trader,\n                    receiver: address(this),\n                    asset: order.depositAsset,\n                    amount: order.depositAmount\n                })\n            );\n\n            vars.amountOut = swapManager.swap(\n                ISwapManager.SwapParams({\n                    tokenA: order.depositAsset,\n                    tokenB: order.positionAsset,\n                    amountTokenA: order.depositAmount,\n                    amountOutMin: 0,\n                    routes: _params.firstAssetRoutes,\n                    receiver: order.trader,\n                    deadline: order.deadline,\n                    isSwapFromWallet: false,\n                    isSwapToWallet: false,\n                    isSwapFeeInPmx: false,\n                    payFeeFromWallet: false\n                }),\n                pm.getOracleTolerableLimit(order.depositAsset, order.positionAsset),\n                true\n            );\n            uint256 multiplierDepositAsset = 10 ** (18 - IERC20Metadata(order.depositAsset).decimals());\n            uint256 multiplierPositionAsset = 10 ** (18 - IERC20Metadata(order.positionAsset).decimals());\n            vars.exchangeRate =\n                (vars.amountIn * multiplierDepositAsset).wdiv(vars.amountOut * multiplierPositionAsset) /\n                multiplierDepositAsset;\n        }\n\n        vars.assetIn = isSpot ? order.depositAsset : address(order.bucket.borrowedAsset());\n        vars.assetOut = order.positionAsset;\n        return vars;\n    }\n\n    /**\n     * @notice Checks if an array of Condition structs has no duplicate manager types.\n     * @param conditions The array of Condition structs to be checked.\n     * @return bool Boolean value indicating whether the array has no duplicate manager types.\n     */\n    function hasNoConditionManagerTypeDuplicates(Condition[] memory conditions) public pure returns (bool) {\n        if (conditions.length == 0) {\n            return true;\n        }\n        for (uint256 i; i < conditions.length - 1; i++) {\n            for (uint256 j = i + 1; j < conditions.length; j++) {\n                if (conditions[i].managerType == conditions[j].managerType) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice This function is used to either deposit or unlock assets in the trader balance vault.\n     * @param traderBalanceVault The instance of the trader balance vault.\n     * @param _depositAsset The address of the asset to be deposited or unlocked.\n     * @param _amount The amount of the asset to be deposited or unlocked.\n     * @param _takeDepositFromWallet Boolean indicating whether to make a deposit or not.\n     * @param _isAdd Boolean indicating whether to lock or unlock asset. Should lock asset, if true.\n     */\n    function depositLockOrUnlock(\n        ITraderBalanceVault traderBalanceVault,\n        address _depositAsset,\n        uint256 _amount,\n        bool _takeDepositFromWallet,\n        bool _isAdd\n    ) internal {\n        if (!_isAdd) {\n            traderBalanceVault.unlockAsset(\n                ITraderBalanceVault.UnlockAssetParams(msg.sender, msg.sender, _depositAsset, _amount)\n            );\n            return;\n        }\n        if (_takeDepositFromWallet) {\n            if (_depositAsset == NATIVE_CURRENCY) {\n                _require(msg.value >= _amount, Errors.INSUFFICIENT_DEPOSIT.selector);\n                traderBalanceVault.increaseLockedBalance{value: _amount}(msg.sender, _depositAsset, _amount);\n                if (msg.value > _amount) {\n                    uint256 rest = msg.value - _amount;\n                    traderBalanceVault.topUpAvailableBalance{value: rest}(msg.sender, NATIVE_CURRENCY, rest);\n                }\n                return;\n            }\n            TokenTransfersLibrary.doTransferFromTo(_depositAsset, msg.sender, address(traderBalanceVault), _amount);\n            traderBalanceVault.increaseLockedBalance(msg.sender, _depositAsset, _amount);\n            return;\n        }\n        traderBalanceVault.useTraderAssets(\n            ITraderBalanceVault.LockAssetParams(\n                msg.sender,\n                address(0),\n                _depositAsset,\n                _amount,\n                ITraderBalanceVault.OpenType.CREATE_LIMIT_ORDER\n            )\n        );\n    }\n}\n"
    },
    "contracts/libraries/PositionLibrary.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {WadRayMath} from \"./utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"./PrimexPricingLibrary.sol\";\nimport {TokenTransfersLibrary} from \"./TokenTransfersLibrary.sol\";\nimport {LimitOrderLibrary} from \"./LimitOrderLibrary.sol\";\nimport \"./Errors.sol\";\n\nimport {NATIVE_CURRENCY} from \"../Constants.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPrimexDNSStorage} from \"../PrimexDNS/IPrimexDNSStorage.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IConditionalClosingManager} from \"../interfaces/IConditionalClosingManager.sol\";\nimport {ITakeProfitStopLossCCM} from \"../interfaces/ITakeProfitStopLossCCM.sol\";\nimport {IKeeperRewardDistributorStorage} from \"../KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\";\n\nlibrary PositionLibrary {\n    using WadRayMath for uint256;\n\n    event ClosePosition(\n        uint256 indexed positionId,\n        address indexed trader,\n        address indexed closedBy,\n        address bucketAddress,\n        address soldAsset,\n        address positionAsset,\n        uint256 decreasePositionAmount,\n        int256 profit,\n        uint256 positionDebt,\n        uint256 amountOut,\n        PositionLibrary.CloseReason reason\n    );\n\n    /**\n     * @notice This struct represents a trading position\n     * @param id unique identifier for the position\n     * @param scaledDebtAmount scaled debt amount associated with the position\n     * @param bucket instance of the Bucket associated for trading\n     * @param soldAsset bucket asset in the case of margin trading or deposit asset in the case of spot trading\n     * @param depositAmountInSoldAsset equivalent of trader deposit size (this deposit can be in any asset) in the sold asset\n     * or just deposit amount for spot trading\n     * @param positionAsset asset of the trading position\n     * @param positionAmount amount of the trading position\n     * @param trader address of the trader holding the position\n     * @param openBorrowIndex variable borrow index when position was opened\n     * @param createdAt timestamp when the position was created\n     * @param updatedConditionsAt timestamp when the close condition was updated\n     * @param extraParams byte-encoded params, can be used for future updates\n     */\n    struct Position {\n        uint256 id;\n        uint256 scaledDebtAmount;\n        IBucket bucket;\n        address soldAsset;\n        uint256 depositAmountInSoldAsset;\n        address positionAsset;\n        uint256 positionAmount;\n        address trader;\n        uint256 openBorrowIndex;\n        uint256 createdAt;\n        uint256 updatedConditionsAt;\n        bytes extraParams;\n    }\n\n    struct IncreaseDepositParams {\n        uint256 amount;\n        address asset;\n        bool takeDepositFromWallet;\n        PrimexPricingLibrary.Route[] routes;\n        IPrimexDNS primexDNS;\n        IPriceOracle priceOracle;\n        ITraderBalanceVault traderBalanceVault;\n        uint256 amountOutMin;\n    }\n\n    struct DecreaseDepositParams {\n        uint256 amount;\n        IPrimexDNS primexDNS;\n        IPriceOracle priceOracle;\n        ITraderBalanceVault traderBalanceVault;\n        uint256 pairPriceDrop;\n        uint256 securityBuffer;\n        uint256 oracleTolerableLimit;\n        uint256 maintenanceBuffer;\n    }\n\n    struct MultiSwapParams {\n        address tokenA;\n        address tokenB;\n        uint256 amountTokenA;\n        PrimexPricingLibrary.Route[] routes;\n        address receiver;\n        uint256 deadline;\n        bool takeDepositFromWallet;\n        IPrimexDNS primexDNS;\n        IPriceOracle priceOracle;\n        ITraderBalanceVault traderBalanceVault;\n    }\n\n    struct ClosePositionParams {\n        uint256 closeAmount;\n        uint256 depositDecrease;\n        uint256 scaledDebtAmount;\n        address depositReceiver;\n        PrimexPricingLibrary.Route[] routes;\n        uint256 amountOutMin;\n        uint256 oracleTolerableLimit;\n        IPrimexDNS primexDNS;\n        IPriceOracle priceOracle;\n        ITraderBalanceVault traderBalanceVault;\n        LimitOrderLibrary.Condition closeCondition;\n        bytes ccmAdditionalParams;\n        bool borrowedAmountIsNotZero;\n        uint256 pairPriceDrop;\n        uint256 securityBuffer;\n        bool needOracleTolerableLimitCheck;\n    }\n\n    struct ClosePositionVars {\n        address dexAdapter;\n        uint256 borowedAssetAmount;\n        uint256 amountToReturn;\n        uint256 permanentLoss;\n        uint256 fee;\n    }\n\n    struct ClosePositionEventData {\n        int256 profit;\n        uint256 debtAmount;\n        uint256 amountOut;\n        IKeeperRewardDistributorStorage.KeeperActionType actionType;\n    }\n\n    struct OpenPositionVars {\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\n        PrimexPricingLibrary.DepositData depositData;\n        address feeToken;\n        uint256 borrowedAmount;\n        uint256 amountOutMin;\n        uint256 deadline;\n        bool isSpot;\n        bool isThirdAsset;\n        bool takeDepositFromWallet;\n        bool payFeeFromWallet;\n        bool byOrder;\n        address sender;\n        LimitOrderLibrary.Condition[] closeConditions;\n        bool needOracleTolerableLimitCheck;\n    }\n\n    struct OpenPositionEventData {\n        uint256 protocolFee;\n        uint256 entryPrice;\n        uint256 leverage;\n    }\n\n    /**\n     * The struct for openPosition function local vars\n     */\n    struct OpenPositionLocalData {\n        uint256 amountToTransfer;\n        address dexAdapter;\n        address depositReceiver;\n        uint256 depositInPositionAsset;\n        bool isSpot;\n    }\n\n    /**\n     * @dev Structure for the OpenPositionParams when margin trading is activated\n     * @param bucket The bucket, from which the loan will be taken\n     * @param borrowedAmount The amount of tokens borrowed to be exchanged\n     * @param depositInThirdAssetRoutes routes to swap deposit in third asset on dex\n     */\n    struct OpenPositionMarginParams {\n        string bucket;\n        uint256 borrowedAmount;\n        PrimexPricingLibrary.Route[] depositInThirdAssetRoutes;\n    }\n\n    /**\n     * @dev Structure for the openPosition with parameters necessary to open a position\n     * @param marginParams margin trading related params\n     * @param firstAssetRoutes routes to swap first asset on dex\n     * (borrowedAmount + depositAmount if deposit in borrowedAsset)\n     * @param depositAsset The address of the deposit token (collateral for margin trade or\n     * locked funds for spot)\n     * @param depositAmount The amount of deposit funds for deal\n     * @param positionAsset The address output token for exchange\n     * @param amountOutMin The minimum amount of output tokens\n     * that must be received for the transaction not to revert.\n     * @param deadline Unix timestamp after which the transaction will revert.\n     * @param takeDepositFromWallet Bool, add a deposit within the current transaction\n     * @param payFeeFromWallet Bool, add a fee  within the current transaction\n     * @param closeConditions Array of conditions that position can be closed by\n     */\n    struct OpenPositionParams {\n        OpenPositionMarginParams marginParams;\n        PrimexPricingLibrary.Route[] firstAssetRoutes;\n        address depositAsset;\n        uint256 depositAmount;\n        address positionAsset;\n        uint256 amountOutMin;\n        uint256 deadline;\n        bool takeDepositFromWallet;\n        bool payFeeFromWallet;\n        bool isProtocolFeeInPmx;\n        LimitOrderLibrary.Condition[] closeConditions;\n    }\n    struct PositionManagerParams {\n        IPrimexDNS primexDNS;\n        IPriceOracle priceOracle;\n        ITraderBalanceVault traderBalanceVault;\n        uint256 oracleTolerableLimit;\n        uint256 oracleTolerableLimitForThirdAsset;\n        uint256 minPositionSize;\n        address minPositionAsset;\n        uint256 maxPositionSize;\n    }\n\n    struct ScaledParams {\n        uint256 decreasePercent;\n        uint256 scaledDebtAmount;\n        uint256 depositDecrease;\n        bool borrowedAmountIsNotZero;\n    }\n\n    enum CloseReason {\n        CLOSE_BY_TRADER,\n        RISKY_POSITION,\n        BUCKET_DELISTED,\n        LIMIT_CONDITION,\n        BATCH_LIQUIDATION,\n        BATCH_STOP_LOSS,\n        BATCH_TAKE_PROFIT\n    }\n\n    /**\n     * @dev Increases the deposit amount for a position.\n     * @param position The storage reference to the position.\n     * @param params The parameters for increasing the deposit.\n     * @return The amount of trader debtTokens burned.\n     */\n    function increaseDeposit(Position storage position, IncreaseDepositParams memory params) public returns (uint256) {\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\n        _require(position.scaledDebtAmount != 0, Errors.BORROWED_AMOUNT_IS_ZERO.selector);\n        address borrowedAsset = position.soldAsset;\n\n        uint256 depositAmountInBorrowed;\n        address depositReceiver = params.primexDNS.dexAdapter();\n        if (params.asset == borrowedAsset) {\n            depositReceiver = address(position.bucket);\n            depositAmountInBorrowed = params.amount;\n        }\n\n        if (params.takeDepositFromWallet) {\n            TokenTransfersLibrary.doTransferFromTo(params.asset, msg.sender, depositReceiver, params.amount);\n        } else {\n            params.traderBalanceVault.useTraderAssets(\n                ITraderBalanceVault.LockAssetParams(\n                    msg.sender,\n                    depositReceiver,\n                    params.asset,\n                    params.amount,\n                    ITraderBalanceVault.OpenType.OPEN\n                )\n            );\n        }\n\n        if (params.asset != borrowedAsset) {\n            depositAmountInBorrowed = PrimexPricingLibrary.multiSwap(\n                PrimexPricingLibrary.MultiSwapParams({\n                    tokenA: params.asset,\n                    tokenB: borrowedAsset,\n                    amountTokenA: params.amount,\n                    routes: params.routes,\n                    dexAdapter: params.primexDNS.dexAdapter(),\n                    receiver: address(position.bucket),\n                    deadline: block.timestamp\n                }),\n                0,\n                address(params.primexDNS),\n                address(params.priceOracle),\n                false // don't need oracle check. add amountOutMin?\n            );\n            _require(depositAmountInBorrowed >= params.amountOutMin, Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector);\n        }\n\n        uint256 debt = getDebt(position);\n        uint256 amountToTrader;\n        uint256 debtToBurn = depositAmountInBorrowed;\n\n        if (depositAmountInBorrowed >= debt) {\n            amountToTrader = depositAmountInBorrowed - debt;\n            debtToBurn = debt;\n            position.scaledDebtAmount = 0;\n            if (amountToTrader > 0)\n                params.traderBalanceVault.topUpAvailableBalance(position.trader, borrowedAsset, amountToTrader);\n        } else {\n            position.scaledDebtAmount =\n                position.scaledDebtAmount -\n                debtToBurn.rdiv(position.bucket.getNormalizedVariableDebt());\n        }\n\n        position.depositAmountInSoldAsset += debtToBurn;\n\n        position.bucket.decreaseTraderDebt(\n            position.trader,\n            debtToBurn,\n            address(params.traderBalanceVault),\n            amountToTrader,\n            0\n        );\n        return debtToBurn;\n    }\n\n    /**\n     * @dev Decreases the deposit amount for a position.\n     * @param position The storage reference to the position.\n     * @param params The parameters for the decrease deposit operation.\n     */\n    function decreaseDeposit(Position storage position, DecreaseDepositParams memory params) public {\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\n        _require(position.bucket != IBucket(address(0)), Errors.IS_SPOT_POSITION.selector);\n        _require(position.bucket.isActive(), Errors.BUCKET_IS_NOT_ACTIVE.selector);\n        _require(params.amount > 0, Errors.DECREASE_AMOUNT_IS_ZERO.selector);\n        _require(params.amount <= position.depositAmountInSoldAsset, Errors.AMOUNT_IS_MORE_THAN_DEPOSIT.selector);\n        position.depositAmountInSoldAsset -= params.amount;\n        position.scaledDebtAmount =\n            position.scaledDebtAmount +\n            params.amount.rdiv(position.bucket.getNormalizedVariableDebt());\n\n        params.traderBalanceVault.topUpAvailableBalance(position.trader, position.soldAsset, params.amount);\n\n        _require(\n            health(\n                position,\n                params.priceOracle,\n                params.pairPriceDrop,\n                params.securityBuffer,\n                params.oracleTolerableLimit\n            ) >= WadRayMath.WAD + params.maintenanceBuffer,\n            Errors.INSUFFICIENT_DEPOSIT_SIZE.selector\n        );\n        position.bucket.increaseDebt(position.trader, params.amount, address(params.traderBalanceVault));\n    }\n\n    /**\n     * @notice Closes a position.\n     * @param position The position to be closed.\n     * @param params The parameters for closing the position.\n     * @param reason The reason for closing the position.\n     * @return posEventData The event data for the closed position.\n     */\n    function closePosition(\n        Position memory position,\n        ClosePositionParams memory params,\n        CloseReason reason\n    ) public returns (ClosePositionEventData memory) {\n        ClosePositionEventData memory posEventData;\n        ClosePositionVars memory vars;\n\n        if (params.borrowedAmountIsNotZero) {\n            posEventData.debtAmount = params.scaledDebtAmount.rmul(position.bucket.getNormalizedVariableDebt());\n        }\n\n        vars.dexAdapter = params.primexDNS.dexAdapter();\n        TokenTransfersLibrary.doTransferOut(position.positionAsset, vars.dexAdapter, params.closeAmount);\n        posEventData.amountOut = PrimexPricingLibrary.multiSwap(\n            PrimexPricingLibrary.MultiSwapParams({\n                tokenA: position.positionAsset,\n                tokenB: position.soldAsset,\n                amountTokenA: params.closeAmount,\n                routes: params.routes,\n                dexAdapter: vars.dexAdapter,\n                receiver: params.borrowedAmountIsNotZero\n                    ? address(position.bucket)\n                    : address(params.traderBalanceVault),\n                deadline: block.timestamp\n            }),\n            params.oracleTolerableLimit,\n            address(params.primexDNS),\n            address(params.priceOracle),\n            params.needOracleTolerableLimitCheck\n        );\n\n        _require(\n            posEventData.amountOut >= params.amountOutMin && posEventData.amountOut > 0,\n            Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector\n        );\n\n        bool canBeClosed;\n        if (reason == CloseReason.CLOSE_BY_TRADER) {\n            canBeClosed = position.trader == msg.sender;\n        } else if (reason == CloseReason.RISKY_POSITION) {\n            canBeClosed =\n                health(\n                    position,\n                    params.priceOracle,\n                    params.pairPriceDrop,\n                    params.securityBuffer,\n                    params.oracleTolerableLimit\n                ) <\n                WadRayMath.WAD;\n            posEventData.actionType = IKeeperRewardDistributorStorage.KeeperActionType.Liquidation;\n        } else if (reason == CloseReason.LIMIT_CONDITION) {\n            address cm = params.primexDNS.cmTypeToAddress(params.closeCondition.managerType);\n            _require(cm != address(0), Errors.INCORRECT_CM_TYPE.selector);\n\n            canBeClosed = IConditionalClosingManager(cm).canBeClosedAfterSwap(\n                position,\n                params.closeCondition.params,\n                params.ccmAdditionalParams,\n                params.closeAmount,\n                posEventData.amountOut\n            );\n            posEventData.actionType = IKeeperRewardDistributorStorage.KeeperActionType.StopLoss;\n        } else if (reason == CloseReason.BUCKET_DELISTED) {\n            canBeClosed = position.bucket != IBucket(address(0)) && position.bucket.isDelisted();\n            posEventData.actionType = IKeeperRewardDistributorStorage.KeeperActionType.BucketDelisted;\n        }\n        _require(canBeClosed, Errors.POSITION_CANNOT_BE_CLOSED_FOR_THIS_REASON.selector);\n\n        uint256 permanentLoss;\n        if (posEventData.amountOut > posEventData.debtAmount) {\n            unchecked {\n                vars.amountToReturn = posEventData.amountOut - posEventData.debtAmount;\n            }\n        } else {\n            unchecked {\n                permanentLoss = posEventData.debtAmount - posEventData.amountOut;\n            }\n        }\n\n        posEventData.profit = -int256(params.depositDecrease);\n\n        if (reason != CloseReason.RISKY_POSITION) {\n            if (vars.amountToReturn > 0) {\n                posEventData.profit += int256(vars.amountToReturn);\n                params.traderBalanceVault.topUpAvailableBalance(\n                    reason == CloseReason.CLOSE_BY_TRADER ? params.depositReceiver : position.trader,\n                    position.soldAsset,\n                    vars.amountToReturn\n                );\n            }\n        }\n\n        if (params.borrowedAmountIsNotZero) {\n            position.bucket.decreaseTraderDebt(\n                position.trader,\n                posEventData.debtAmount,\n                reason == CloseReason.RISKY_POSITION ? params.primexDNS.treasury() : address(params.traderBalanceVault),\n                vars.amountToReturn,\n                permanentLoss\n            );\n        }\n\n        // to avoid stack to deep\n        CloseReason _reason = reason;\n        if (params.closeAmount == position.positionAmount) {\n            emit ClosePosition({\n                positionId: position.id,\n                trader: position.trader,\n                closedBy: msg.sender,\n                bucketAddress: address(position.bucket),\n                soldAsset: position.soldAsset,\n                positionAsset: position.positionAsset,\n                decreasePositionAmount: position.positionAmount,\n                profit: posEventData.profit,\n                positionDebt: posEventData.debtAmount,\n                amountOut: posEventData.amountOut,\n                reason: _reason\n            });\n        }\n        return posEventData;\n    }\n\n    /**\n     * @dev Sets the maximum position size between two tokens.\n     * @param maxPositionSize The storage mapping for maximum position sizes.\n     * @param token0 The address of token0.\n     * @param token1 The address of token1.\n     * @param amountInToken0 The maximum position size in token0.\n     * @param amountInToken1 The maximum position size in token1.\n     */\n    function setMaxPositionSize(\n        mapping(address => mapping(address => uint256)) storage maxPositionSize,\n        address token0,\n        address token1,\n        uint256 amountInToken0,\n        uint256 amountInToken1\n    ) public {\n        _require(token0 != address(0) && token1 != address(0), Errors.TOKEN_ADDRESS_IS_ZERO.selector);\n        _require(token0 != token1, Errors.IDENTICAL_ASSET_ADDRESSES.selector);\n\n        maxPositionSize[token1][token0] = amountInToken0;\n        maxPositionSize[token0][token1] = amountInToken1;\n    }\n\n    /**\n     * @dev Sets the tolerable limit for an oracle between two assets.\n     * @param oracleTolerableLimits The mapping to store oracle tolerable limits.\n     * @param assetA The address of the first asset.\n     * @param assetB The address of the second asset.\n     * @param percent The percentage tolerable limit for the oracle in WAD format (1 WAD = 100%).\n     */\n    function setOracleTolerableLimit(\n        mapping(address => mapping(address => uint256)) storage oracleTolerableLimits,\n        address assetA,\n        address assetB,\n        uint256 percent\n    ) public {\n        _require(assetA != address(0) && assetB != address(0), Errors.ASSET_ADDRESS_NOT_SUPPORTED.selector);\n        _require(assetA != assetB, Errors.IDENTICAL_ASSET_ADDRESSES.selector);\n        _require(percent <= WadRayMath.WAD && percent > 0, Errors.INVALID_PERCENT_NUMBER.selector);\n        oracleTolerableLimits[assetA][assetB] = percent;\n        oracleTolerableLimits[assetB][assetA] = percent;\n    }\n\n    /**\n     * @dev Sets the close conditions for a given position.\n     * @param position The position for which to set the close conditions.\n     * @param closeConditionsMap The storage mapping of close conditions for each position ID.\n     * @param closeConditions The array of close conditions to be set.\n     * @param primexDNS The address of the IPrimexDNS contract.\n     */\n    function setCloseConditions(\n        Position memory position,\n        mapping(uint256 => LimitOrderLibrary.Condition[]) storage closeConditionsMap,\n        LimitOrderLibrary.Condition[] memory closeConditions,\n        IPrimexDNS primexDNS\n    ) public {\n        _require(\n            LimitOrderLibrary.hasNoConditionManagerTypeDuplicates(closeConditions),\n            Errors.SHOULD_NOT_HAVE_DUPLICATES.selector\n        );\n        if (closeConditionsMap[position.id].length > 0) {\n            delete closeConditionsMap[position.id];\n        }\n        LimitOrderLibrary.Condition memory condition;\n        for (uint256 i; i < closeConditions.length; i++) {\n            condition = closeConditions[i];\n            _require(\n                IERC165Upgradeable(primexDNS.cmTypeToAddress(condition.managerType)).supportsInterface(\n                    type(IConditionalClosingManager).interfaceId\n                ),\n                Errors.SHOULD_BE_CCM.selector\n            );\n\n            closeConditionsMap[position.id].push(condition);\n        }\n    }\n\n    /**\n     * @notice Opens a position by depositing assets and borrowing funds (except when the position is spot)\n     * @param _position The position to be opened\n     * @param _vars Variables related to the position opening\n     * @param _pmParams Parameters for the PositionManager contract\n     * @return The updated position and event data\n     */\n    function openPosition(\n        Position memory _position,\n        OpenPositionVars memory _vars,\n        PositionManagerParams memory _pmParams\n    ) public returns (Position memory, OpenPositionEventData memory) {\n        PrimexPricingLibrary.validateMinPositionSize(\n            _pmParams.minPositionSize,\n            _pmParams.minPositionAsset,\n            _vars.borrowedAmount + _position.depositAmountInSoldAsset,\n            _position.soldAsset,\n            address(_pmParams.priceOracle)\n        );\n        OpenPositionLocalData memory data;\n        data.amountToTransfer = _vars.borrowedAmount;\n        data.dexAdapter = _pmParams.primexDNS.dexAdapter();\n        data.depositReceiver = data.dexAdapter;\n        if (_vars.depositData.depositAsset == _position.positionAsset) {\n            _position.positionAmount = _vars.depositData.depositAmount;\n            data.depositInPositionAsset = _vars.depositData.depositAmount;\n            data.depositReceiver = address(this);\n        } else if (_vars.depositData.depositAsset == _position.soldAsset) {\n            data.amountToTransfer += _vars.depositData.depositAmount;\n        }\n\n        data.isSpot = _vars.borrowedAmount == 0;\n        if (data.isSpot) _vars.depositData.depositAsset = _position.soldAsset;\n\n        if (_vars.takeDepositFromWallet) {\n            TokenTransfersLibrary.doTransferFromTo(\n                _vars.depositData.depositAsset,\n                msg.sender,\n                data.depositReceiver,\n                _vars.depositData.depositAmount\n            );\n        } else {\n            _pmParams.traderBalanceVault.useTraderAssets(\n                ITraderBalanceVault.LockAssetParams({\n                    trader: _position.trader,\n                    depositReceiver: data.depositReceiver,\n                    depositAsset: _vars.depositData.depositAsset,\n                    depositAmount: _vars.depositData.depositAmount,\n                    openType: _vars.byOrder\n                        ? ITraderBalanceVault.OpenType.OPEN_BY_ORDER\n                        : ITraderBalanceVault.OpenType.OPEN\n                })\n            );\n        }\n\n        if (!data.isSpot) {\n            _position.bucket.increaseDebt(_position.trader, _vars.borrowedAmount, data.dexAdapter);\n            // @note You need to write index only after opening a position in bucket.\n            // Since when opening position in the bucket, index becomes relevant (containing accumulated profit)\n            _position.openBorrowIndex = _position.bucket.variableBorrowIndex();\n            _position.scaledDebtAmount = _vars.borrowedAmount.rdiv(_position.openBorrowIndex);\n        }\n        if (_vars.isThirdAsset) {\n            data.depositInPositionAsset = PrimexPricingLibrary.multiSwap(\n                PrimexPricingLibrary.MultiSwapParams({\n                    tokenA: _vars.depositData.depositAsset,\n                    tokenB: _position.positionAsset,\n                    amountTokenA: _vars.depositData.depositAmount,\n                    routes: _vars.depositInThirdAssetRoutes,\n                    dexAdapter: data.dexAdapter,\n                    receiver: address(this),\n                    deadline: _vars.deadline\n                }),\n                _pmParams.oracleTolerableLimitForThirdAsset,\n                address(_pmParams.primexDNS),\n                address(_pmParams.priceOracle),\n                true\n            );\n            _position.positionAmount += data.depositInPositionAsset;\n        } else {\n            _require(\n                _vars.depositInThirdAssetRoutes.length == 0,\n                Errors.DEPOSIT_IN_THIRD_ASSET_ROUTES_LENGTH_SHOULD_BE_0.selector\n            );\n        }\n\n        uint256 borrowedAmountInPositionAsset = PrimexPricingLibrary.multiSwap(\n            PrimexPricingLibrary.MultiSwapParams({\n                tokenA: _position.soldAsset,\n                tokenB: _position.positionAsset,\n                amountTokenA: data.isSpot ? _vars.depositData.depositAmount : data.amountToTransfer,\n                routes: _vars.firstAssetRoutes,\n                dexAdapter: data.dexAdapter,\n                receiver: address(this),\n                deadline: _vars.deadline\n            }),\n            _pmParams.oracleTolerableLimit,\n            address(_pmParams.primexDNS),\n            address(_pmParams.priceOracle),\n            _vars.needOracleTolerableLimitCheck\n        );\n        _position.positionAmount += borrowedAmountInPositionAsset;\n        _require(_pmParams.maxPositionSize >= _position.positionAmount, Errors.POSITION_SIZE_EXCEEDED.selector);\n        uint256 leverage = WadRayMath.WAD;\n        if (!data.isSpot) {\n            if (_vars.depositData.depositAsset == _position.soldAsset) {\n                leverage = (_vars.borrowedAmount + _position.depositAmountInSoldAsset).wdiv(\n                    _position.depositAmountInSoldAsset\n                );\n            } else {\n                leverage = (borrowedAmountInPositionAsset + data.depositInPositionAsset).wdiv(\n                    data.depositInPositionAsset\n                );\n            }\n            _require(\n                leverage <= _position.bucket.maxAssetLeverage(_position.positionAsset),\n                Errors.INSUFFICIENT_DEPOSIT.selector\n            );\n        }\n\n        if (!_vars.byOrder) {\n            _vars.depositData.leverage = leverage;\n        }\n\n        _require(_position.positionAmount >= _vars.amountOutMin, Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector);\n\n        OpenPositionEventData memory posEventData;\n\n        posEventData.protocolFee = PrimexPricingLibrary.payProtocolFee(\n            PrimexPricingLibrary.ProtocolFeeParams({\n                depositData: _vars.depositData,\n                feeToken: _vars.feeToken,\n                isSwapFromWallet: _vars.payFeeFromWallet,\n                calculateFee: !_vars.byOrder,\n                orderType: _vars.byOrder\n                    ? IPrimexDNSStorage.OrderType.LIMIT_ORDER\n                    : IPrimexDNSStorage.OrderType.MARKET_ORDER,\n                trader: _position.trader,\n                priceOracle: address(_pmParams.priceOracle),\n                traderBalanceVault: _pmParams.traderBalanceVault,\n                primexDNS: _pmParams.primexDNS\n            })\n        );\n\n        uint256 multiplierBorrowedAsset = 10 ** (18 - IERC20Metadata(_position.soldAsset).decimals());\n        uint256 multiplierPositionAsset = 10 ** (18 - IERC20Metadata(_position.positionAsset).decimals());\n        posEventData.entryPrice =\n            ((_vars.borrowedAmount + _position.depositAmountInSoldAsset) * multiplierBorrowedAsset).wdiv(\n                _position.positionAmount * multiplierPositionAsset\n            ) /\n            multiplierBorrowedAsset;\n        posEventData.leverage = _vars.depositData.leverage;\n        return (_position, posEventData);\n    }\n\n    /**\n     * @dev Retrieves the debt amount for a given position.\n     * @param position The Position struct representing the position to get the debt amount for.\n     * @return The debt amount in debtTokens.\n     */\n    function getDebt(Position memory position) public view returns (uint256) {\n        if (position.scaledDebtAmount == 0) return 0;\n        return position.scaledDebtAmount.rmul(position.bucket.getNormalizedVariableDebt());\n    }\n\n    /**\n     * @dev Calculates the health of a position.\n     * @dev health = ((1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - priceDrop) * borrowedAssetAmountOut) /\n     (feeBuffer * debt)\n     * @param position The position object containing relevant information.\n     * @param priceOracle The price oracle contract used for obtaining asset prices.\n     * @param pairPriceDrop The priceDrop in WAD format of the asset pair.\n     * @param securityBuffer The security buffer in WAD format for the position.\n     * @param oracleTolerableLimit The tolerable limit in WAD format for the price oracle.\n     * @return The health value in WAD format of the position.\n     */\n    function health(\n        Position memory position,\n        IPriceOracle priceOracle,\n        uint256 pairPriceDrop,\n        uint256 securityBuffer,\n        uint256 oracleTolerableLimit\n    ) public view returns (uint256) {\n        if (position.scaledDebtAmount == 0) return WadRayMath.WAD;\n        return\n            health(\n                PrimexPricingLibrary.getOracleAmountsOut(\n                    position.positionAsset,\n                    position.soldAsset,\n                    position.positionAmount,\n                    address(priceOracle)\n                ),\n                pairPriceDrop,\n                securityBuffer,\n                oracleTolerableLimit,\n                getDebt(position),\n                position.bucket.feeBuffer()\n            );\n    }\n\n    /**\n     * @dev Creates a new position based on the given parameters.\n     * @param _params The input parameters for creating the position.\n     * @param primexDNS The address of the PrimexDNS contract.\n     * @param priceOracle The address of the PriceOracle contract.\n     * @return position The created Position struct.\n     * @return vars The OpenPositionVars struct.\n     */\n    function createPosition(\n        OpenPositionParams calldata _params,\n        IPrimexDNS primexDNS,\n        IPriceOracle priceOracle\n    ) public view returns (Position memory, OpenPositionVars memory) {\n        OpenPositionVars memory vars = OpenPositionVars({\n            firstAssetRoutes: _params.firstAssetRoutes,\n            depositInThirdAssetRoutes: _params.marginParams.depositInThirdAssetRoutes,\n            depositData: PrimexPricingLibrary.DepositData({\n                protocolFee: 0,\n                depositAsset: address(0),\n                depositAmount: _params.depositAmount,\n                leverage: 0\n            }),\n            feeToken: _params.isProtocolFeeInPmx ? primexDNS.pmx() : NATIVE_CURRENCY,\n            borrowedAmount: _params.marginParams.borrowedAmount,\n            amountOutMin: _params.amountOutMin,\n            deadline: _params.deadline,\n            isSpot: _params.marginParams.borrowedAmount == 0,\n            isThirdAsset: false,\n            takeDepositFromWallet: _params.takeDepositFromWallet,\n            payFeeFromWallet: _params.payFeeFromWallet,\n            byOrder: false,\n            sender: address(0),\n            closeConditions: _params.closeConditions,\n            needOracleTolerableLimitCheck: _params.marginParams.borrowedAmount > 0\n        });\n        PositionLibrary.Position memory position = PositionLibrary.Position({\n            id: 0,\n            scaledDebtAmount: 0,\n            bucket: IBucket(address(0)),\n            soldAsset: address(0),\n            depositAmountInSoldAsset: 0,\n            positionAsset: _params.positionAsset,\n            positionAmount: 0,\n            trader: msg.sender,\n            openBorrowIndex: 0,\n            createdAt: block.timestamp,\n            updatedConditionsAt: block.timestamp,\n            extraParams: \"\"\n        });\n\n        if (vars.isSpot) {\n            _require(_params.depositAsset != _params.positionAsset, Errors.SHOULD_BE_DIFFERENT_ASSETS_IN_SPOT.selector);\n            _require(bytes(_params.marginParams.bucket).length == 0, Errors.BUCKET_SHOULD_BE_UNDEFINED.selector);\n            priceOracle.getPriceFeedsPair(_params.positionAsset, _params.depositAsset);\n            position.soldAsset = _params.depositAsset;\n            position.depositAmountInSoldAsset = vars.depositData.depositAmount;\n            vars.depositData.leverage = WadRayMath.WAD;\n        } else {\n            position.bucket = IBucket(primexDNS.getBucketAddress(_params.marginParams.bucket));\n            position.soldAsset = address(position.bucket.borrowedAsset());\n            vars.depositData.depositAsset = _params.depositAsset;\n            (, bool tokenAllowed) = position.bucket.allowedAssets(_params.positionAsset);\n            _require(tokenAllowed, Errors.TOKEN_NOT_SUPPORTED.selector);\n\n            vars.isThirdAsset =\n                _params.depositAsset != position.soldAsset &&\n                _params.depositAsset != _params.positionAsset;\n\n            position.depositAmountInSoldAsset = PrimexPricingLibrary.getOracleAmountsOut(\n                _params.depositAsset,\n                position.soldAsset,\n                _params.depositAmount,\n                address(priceOracle)\n            );\n        }\n\n        return (position, vars);\n    }\n\n    /**\n     * @notice Creates a position based on the provided order parameters.\n     * @dev This function calculates and returns a Position and OpenPositionVars struct.\n     * @param _params The OpenPositionByOrderParams struct containing the order parameters.\n     * @param priceOracle The price oracle contract used for retrieving asset prices.\n     * @return position The Position struct representing the created position.\n     * @return vars The OpenPositionVars struct containing additional variables related to the position.\n     */\n    function createPositionByOrder(\n        LimitOrderLibrary.OpenPositionByOrderParams calldata _params,\n        IPriceOracle priceOracle\n    ) public view returns (Position memory, OpenPositionVars memory) {\n        OpenPositionVars memory vars = OpenPositionVars({\n            firstAssetRoutes: _params.firstAssetRoutes,\n            depositInThirdAssetRoutes: _params.depositInThirdAssetRoutes,\n            depositData: PrimexPricingLibrary.DepositData({\n                protocolFee: _params.order.protocolFee,\n                depositAsset: address(0),\n                depositAmount: _params.order.depositAmount,\n                leverage: _params.order.leverage\n            }),\n            feeToken: _params.order.feeToken,\n            borrowedAmount: 0,\n            amountOutMin: 0,\n            deadline: _params.order.deadline,\n            isSpot: _params.order.leverage == WadRayMath.WAD,\n            isThirdAsset: false,\n            takeDepositFromWallet: false,\n            payFeeFromWallet: false,\n            byOrder: true,\n            sender: _params.sender,\n            closeConditions: _params.closeConditions,\n            needOracleTolerableLimitCheck: true\n        });\n\n        Position memory position = Position({\n            id: 0,\n            scaledDebtAmount: 0,\n            bucket: IBucket(address(0)),\n            soldAsset: address(0),\n            depositAmountInSoldAsset: 0,\n            positionAsset: _params.order.positionAsset,\n            positionAmount: 0,\n            trader: _params.order.trader,\n            openBorrowIndex: 0,\n            createdAt: block.timestamp,\n            updatedConditionsAt: block.timestamp,\n            extraParams: \"\"\n        });\n\n        if (vars.isSpot) {\n            position.soldAsset = _params.order.depositAsset;\n            position.depositAmountInSoldAsset = vars.depositData.depositAmount;\n        } else {\n            position.bucket = _params.order.bucket;\n            position.soldAsset = address(position.bucket.borrowedAsset());\n            vars.depositData.depositAsset = _params.order.depositAsset;\n            vars.isThirdAsset =\n                _params.order.depositAsset != position.soldAsset &&\n                _params.order.depositAsset != _params.order.positionAsset;\n\n            position.depositAmountInSoldAsset = PrimexPricingLibrary.getOracleAmountsOut(\n                _params.order.depositAsset,\n                position.soldAsset,\n                _params.order.depositAmount,\n                address(priceOracle)\n            );\n            vars.borrowedAmount = position.depositAmountInSoldAsset.wmul(_params.order.leverage - WadRayMath.WAD);\n        }\n        return (position, vars);\n    }\n\n    /**\n     * @notice Calculates the health score for a position.\n     * @param borrowedAssetAmountOut The amount of borrowed assets.\n     * @param pairPriceDrop The priceDrop in WAD format of the pair.\n     * @param securityBuffer The security buffer in WAD format.\n     * @param oracleTolerableLimit The tolerable limit in WAD format for the oracle.\n     * @param positionDebt The debt of the position.\n     * @param feeBuffer The buffer for fees.\n     * @return The health score of the position.\n     */\n    function health(\n        uint256 borrowedAssetAmountOut,\n        uint256 pairPriceDrop,\n        uint256 securityBuffer,\n        uint256 oracleTolerableLimit,\n        uint256 positionDebt,\n        uint256 feeBuffer\n    ) public pure returns (uint256) {\n        return\n            (\n                (WadRayMath.WAD - securityBuffer)\n                    .wmul(WadRayMath.WAD - oracleTolerableLimit)\n                    .wmul(WadRayMath.WAD - pairPriceDrop)\n                    .wmul(borrowedAssetAmountOut)\n            ).wdiv(feeBuffer.wmul(positionDebt));\n    }\n}\n"
    },
    "contracts/libraries/PrimexPricingLibrary.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {BytesLib} from \"./utils/BytesLib.sol\";\nimport {WadRayMath} from \"./utils/WadRayMath.sol\";\n\nimport {NATIVE_CURRENCY, USD, USD_MULTIPLIER} from \"../Constants.sol\";\nimport {IDexAdapter} from \"../interfaces/IDexAdapter.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IPrimexDNS, IPrimexDNSV2, IPrimexDNSStorage} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {TokenTransfersLibrary} from \"./TokenTransfersLibrary.sol\";\n\nimport \"./Errors.sol\";\n\nlibrary PrimexPricingLibrary {\n    using WadRayMath for uint256;\n    using BytesLib for bytes;\n\n    struct Route {\n        uint256 shares;\n        SwapPath[] paths;\n    }\n\n    struct SwapPath {\n        string dexName;\n        bytes encodedPath;\n    }\n\n    struct MultiSwapParams {\n        address tokenA;\n        address tokenB;\n        uint256 amountTokenA;\n        Route[] routes;\n        address dexAdapter;\n        address receiver;\n        uint256 deadline;\n    }\n\n    struct MultiSwapVars {\n        uint256 sumOfShares;\n        uint256 balance;\n        uint256 amountOnDex;\n        uint256 remainder;\n        Route route;\n    }\n\n    struct AmountParams {\n        address tokenA;\n        address tokenB;\n        uint256 amount;\n        Route[] routes;\n        address dexAdapter;\n        address primexDNS;\n    }\n\n    struct LiquidationPriceCalculationParams {\n        address bucket;\n        address positionAsset;\n        uint256 limitPrice;\n        uint256 leverage;\n    }\n\n    struct DepositData {\n        uint256 protocolFee;\n        address depositAsset;\n        uint256 depositAmount;\n        uint256 leverage;\n    }\n\n    /**\n     * @param depositData the deposit data through which the protocol fee can be calculated\n     * if the position is opened through an order using deposit asset\n     * @param feeToken An asset in which the fee will be paid. At this point it could be the pmx, the epmx or a native currency\n     * @param isSwapFromWallet bool, the protocol fee is taken from the user wallet or from the Vault\n     * @param trader trader address\n     * @param priceOracle PriceOracle contract address\n     * @param orderType Type of possible order in Primex protocol\n     * @param traderBalanceVault TraderBalanceVault contract address\n     * @param primexDNS PrimexDNS contract address\n     */\n    struct ProtocolFeeParams {\n        DepositData depositData;\n        address feeToken;\n        bool isSwapFromWallet;\n        address trader;\n        address priceOracle;\n        IPrimexDNSStorage.OrderType orderType;\n        bool calculateFee;\n        ITraderBalanceVault traderBalanceVault;\n        IPrimexDNS primexDNS;\n    }\n\n    /**\n     * The struct for payProtocolFee function\n     */\n    struct ProtocolFeeVars {\n        bool fromLocked;\n        address treasury;\n    }\n\n    /**\n     * The struct for getLiquidationPrice and getLiquidationPriceByOrder functions\n     */\n    struct LiquidationPriceData {\n        IBucket bucket;\n        IPositionManager positionManager;\n        IPriceOracle priceOracle;\n        IERC20Metadata borrowedAsset;\n    }\n\n    event Withdraw(\n        address indexed withdrawer,\n        address borrowAssetReceiver,\n        address borrowedAsset,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Encodes the given parameters into a bytes array based on the specified DEX type.\n     * @param path The token path for the swap.\n     * @param dexRouter The address of the DEX router.\n     * @param ancillaryData Additional data required for certain DEX types.\n     * @param dexAdapter The address of the DEX adapter.\n     * @param isAmountToBuy A flag indicating whether it is the path for the swap with fixed amountIn or amountOut.\n     * Swap with fixed amountIn, if true.\n     * @return The encoded bytes array.\n     */\n    function encodePath(\n        address[] memory path,\n        address dexRouter,\n        bytes32 ancillaryData,\n        address dexAdapter,\n        bool isAmountToBuy\n    ) external view returns (bytes memory) {\n        IDexAdapter.DexType type_ = IDexAdapter(dexAdapter).dexType(dexRouter);\n\n        if (type_ == IDexAdapter.DexType.UniswapV2 || type_ == IDexAdapter.DexType.Meshswap) {\n            return abi.encode(path);\n        }\n        if (type_ == IDexAdapter.DexType.UniswapV3) {\n            if (isAmountToBuy)\n                return bytes.concat(bytes20(path[1]), bytes3(uint24(uint256(ancillaryData))), bytes20(path[0]));\n            return bytes.concat(bytes20(path[0]), bytes3(uint24(uint256(ancillaryData))), bytes20(path[1]));\n        }\n        if (type_ == IDexAdapter.DexType.AlgebraV3) {\n            if (isAmountToBuy) return bytes.concat(bytes20(path[1]), bytes20(path[0]));\n            return bytes.concat(bytes20(path[0]), bytes20(path[1]));\n        }\n        if (type_ == IDexAdapter.DexType.Curve) {\n            address[] memory pools = new address[](1);\n            pools[0] = address(uint160(uint256(ancillaryData)));\n            return abi.encode(path, pools);\n        }\n        if (type_ == IDexAdapter.DexType.Balancer) {\n            int256[] memory limits = new int256[](2);\n            limits[0] = type(int256).max;\n            bytes32[] memory pools = new bytes32[](1);\n            pools[0] = ancillaryData;\n            return abi.encode(path, pools, limits);\n        }\n        _revert(Errors.UNKNOWN_DEX_TYPE.selector);\n    }\n\n    /**\n     * @notice Wrapped getAmountsOut to the dex\n     * @param _params parameters necessary to get amount out\n     * @return the amount of `tokenB` by the amount of 'tokenA' on dexes\n     */\n    function getAmountOut(AmountParams memory _params) public returns (uint256) {\n        _require(_params.tokenA != _params.tokenB, Errors.IDENTICAL_ASSETS.selector);\n        _require(\n            IERC165(address(_params.primexDNS)).supportsInterface(type(IPrimexDNS).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        uint256 sumOfShares;\n        for (uint256 i; i < _params.routes.length; i++) {\n            sumOfShares += _params.routes[i].shares;\n        }\n        _require(sumOfShares > 0, Errors.SUM_OF_SHARES_SHOULD_BE_GREATER_THAN_ZERO.selector);\n\n        uint256 remainder = _params.amount;\n        uint256 sum;\n        uint256 amountOnDex;\n        Route memory route;\n        IDexAdapter.GetAmountsParams memory getAmountsParams;\n        address[] memory path;\n\n        for (uint256 i; i < _params.routes.length; i++) {\n            route = _params.routes[i];\n            amountOnDex = i == _params.routes.length - 1 ? remainder : (_params.amount * route.shares) / sumOfShares;\n            remainder -= amountOnDex;\n\n            for (uint256 j; j < route.paths.length; j++) {\n                getAmountsParams.encodedPath = route.paths[j].encodedPath;\n                getAmountsParams.amount = amountOnDex;\n                getAmountsParams.dexRouter = IPrimexDNS(_params.primexDNS).getDexAddress(route.paths[j].dexName);\n                path = decodePath(getAmountsParams.encodedPath, getAmountsParams.dexRouter, _params.dexAdapter);\n                _require(path.length >= 2, Errors.INCORRECT_PATH.selector);\n                amountOnDex = IDexAdapter(_params.dexAdapter).getAmountsOut(getAmountsParams)[1];\n            }\n            sum += amountOnDex;\n        }\n\n        return sum;\n    }\n\n    /**\n     * @notice Wrapped getAmountIn to the dex\n     * @param _params parameters necessary to get amount in\n     * @return the amount of `tokenA` by the amount of 'tokenB' on dexes\n     */\n    function getAmountIn(AmountParams memory _params) public returns (uint256) {\n        _require(_params.tokenA != _params.tokenB, Errors.IDENTICAL_ASSETS.selector);\n        _require(\n            IERC165(address(_params.primexDNS)).supportsInterface(type(IPrimexDNS).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        uint256 sumOfShares;\n        for (uint256 i; i < _params.routes.length; i++) {\n            sumOfShares += _params.routes[i].shares;\n        }\n        _require(sumOfShares > 0, Errors.SUM_OF_SHARES_SHOULD_BE_GREATER_THAN_ZERO.selector);\n\n        uint256 remainder = _params.amount;\n        uint256 sum;\n        uint256 amountOnDex;\n        Route memory route;\n        IDexAdapter.GetAmountsParams memory getAmountsParams;\n        address[] memory path;\n\n        for (uint256 i; i < _params.routes.length; i++) {\n            route = _params.routes[i];\n            amountOnDex = i == _params.routes.length - 1 ? remainder : (_params.amount * route.shares) / sumOfShares;\n            remainder -= amountOnDex;\n            for (uint256 j; j < route.paths.length; j++) {\n                getAmountsParams.encodedPath = route.paths[route.paths.length - 1 - j].encodedPath;\n                getAmountsParams.amount = amountOnDex;\n                getAmountsParams.dexRouter = IPrimexDNS(_params.primexDNS).getDexAddress(\n                    route.paths[route.paths.length - 1 - j].dexName\n                );\n                path = decodePath(getAmountsParams.encodedPath, getAmountsParams.dexRouter, _params.dexAdapter);\n                _require(path.length >= 2, Errors.INCORRECT_PATH.selector);\n                amountOnDex = IDexAdapter(_params.dexAdapter).getAmountsIn(getAmountsParams)[0];\n            }\n            sum += amountOnDex;\n        }\n\n        return sum;\n    }\n\n    /**\n     * @notice Calculates the amount of deposit assets in borrowed assets.\n     * @param _params The parameters for the calculation.\n     * @param _isThirdAsset A flag indicating if deposit is in a third asset.\n     * @param _priceOracle The address of the price oracle.\n     * @return The amount of deposit assets is measured in borrowed assets.\n     */\n    function getDepositAmountInBorrowed(\n        AmountParams memory _params,\n        bool _isThirdAsset,\n        address _priceOracle\n    ) public returns (uint256) {\n        _require(\n            IERC165(_params.primexDNS).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        if (_params.tokenA == _params.tokenB) {\n            _require(_params.routes.length == 0, Errors.DEPOSITED_TO_BORROWED_ROUTES_LENGTH_SHOULD_BE_0.selector);\n            return _params.amount;\n        }\n\n        uint256 depositAmountInBorrowed = getAmountOut(_params);\n        if (_isThirdAsset) {\n            uint256 oracleDepositAmountOut = getOracleAmountsOut(\n                _params.tokenA,\n                _params.tokenB,\n                _params.amount,\n                _priceOracle\n            );\n            if (depositAmountInBorrowed > oracleDepositAmountOut) depositAmountInBorrowed = oracleDepositAmountOut;\n        }\n\n        return depositAmountInBorrowed;\n    }\n\n    /**\n     * @notice Performs a multi-hop swap transaction using the specified parameters.\n     * @dev This function executes a series of token swaps on different DEXs based on the provided routes.\n     * @param _params The struct containing all the necessary parameters for the multi-hop swap.\n     * @param _maximumOracleTolerableLimit The maximum tolerable limit in WAD format (1 WAD = 100%)\n     * for the price difference between DEX and the oracle.\n     * @param _primexDNS The address of the Primex DNS contract.\n     * @param _priceOracle The address of the price oracle contract.\n     * @param _needOracleTolerableLimitCheck Flag indicating whether to perform an oracle tolerable limit check.\n     * @return The final balance of the _params.tokenB in the receiver's address after the multi-hop swap.\n     */\n    function multiSwap(\n        MultiSwapParams memory _params,\n        uint256 _maximumOracleTolerableLimit,\n        address _primexDNS,\n        address _priceOracle,\n        bool _needOracleTolerableLimitCheck\n    ) public returns (uint256) {\n        _require(\n            IERC165(_primexDNS).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        MultiSwapVars memory vars;\n        vars.balance = IERC20Metadata(_params.tokenB).balanceOf(_params.receiver);\n        for (uint256 i; i < _params.routes.length; i++) {\n            vars.sumOfShares += _params.routes[i].shares;\n        }\n        _require(vars.sumOfShares > 0, Errors.SUM_OF_SHARES_SHOULD_BE_GREATER_THAN_ZERO.selector);\n\n        vars.remainder = _params.amountTokenA;\n        IDexAdapter.SwapParams memory swapParams;\n        swapParams.deadline = _params.deadline;\n\n        for (uint256 i; i < _params.routes.length; i++) {\n            vars.route = _params.routes[i];\n            vars.amountOnDex = i == _params.routes.length - 1\n                ? vars.remainder\n                : (_params.amountTokenA * vars.route.shares) / vars.sumOfShares;\n            vars.remainder -= vars.amountOnDex;\n            swapParams.to = _params.dexAdapter;\n\n            for (uint256 j; j < vars.route.paths.length; j++) {\n                swapParams.encodedPath = vars.route.paths[j].encodedPath;\n                swapParams.amountIn = vars.amountOnDex;\n                swapParams.dexRouter = IPrimexDNS(_primexDNS).getDexAddress(vars.route.paths[j].dexName);\n                if (j == vars.route.paths.length - 1) {\n                    swapParams.to = _params.receiver;\n                }\n                vars.amountOnDex = IDexAdapter(_params.dexAdapter).swapExactTokensForTokens(swapParams)[1];\n            }\n        }\n\n        vars.balance = IERC20Metadata(_params.tokenB).balanceOf(_params.receiver) - vars.balance;\n        if (_needOracleTolerableLimitCheck) {\n            _require(\n                vars.balance >=\n                    getOracleAmountsOut(_params.tokenA, _params.tokenB, _params.amountTokenA, _priceOracle).wmul(\n                        WadRayMath.WAD - _maximumOracleTolerableLimit\n                    ),\n                Errors.DIFFERENT_PRICE_DEX_AND_ORACLE.selector\n            );\n        }\n\n        return vars.balance;\n    }\n\n    /**\n     * @notice Pays the protocol fee.\n     * @dev This function transfers the protocol fee from the trader to the protocol treasury.\n     * @param params The parameters for paying the protocol fee.\n     * @return protocolFee The amount of the protocol fee in PMX or NATIVE_CURRENCY paid.\n     */\n    function payProtocolFee(ProtocolFeeParams memory params) public returns (uint256 protocolFee) {\n        if (!params.isSwapFromWallet || params.feeToken != NATIVE_CURRENCY) {\n            _require(msg.value == 0, Errors.DISABLED_TRANSFER_NATIVE_CURRENCY.selector);\n        }\n        ProtocolFeeVars memory vars;\n        vars.treasury = params.primexDNS.treasury();\n        vars.fromLocked = true;\n\n        protocolFee = params.depositData.protocolFee;\n        if (params.calculateFee) {\n            protocolFee = calculateProtocolFee(\n                params.depositData,\n                params.primexDNS,\n                params.priceOracle,\n                params.orderType,\n                params.feeToken\n            );\n            if (protocolFee == 0) return 0;\n            vars.fromLocked = false;\n            if (params.isSwapFromWallet) {\n                if (params.feeToken == NATIVE_CURRENCY) {\n                    _require(msg.value >= protocolFee, Errors.INSUFFICIENT_DEPOSIT.selector);\n                    TokenTransfersLibrary.doTransferOutETH(vars.treasury, protocolFee);\n                    if (msg.value > protocolFee) {\n                        uint256 rest = msg.value - protocolFee;\n                        params.traderBalanceVault.topUpAvailableBalance{value: rest}(msg.sender, NATIVE_CURRENCY, rest);\n                    }\n                } else {\n                    TokenTransfersLibrary.doTransferFromTo(params.feeToken, params.trader, vars.treasury, protocolFee);\n                }\n                return protocolFee;\n            }\n        }\n\n        params.traderBalanceVault.withdrawFrom(\n            params.trader,\n            vars.treasury,\n            params.feeToken,\n            protocolFee,\n            vars.fromLocked\n        );\n    }\n\n    /**\n     * @notice Calculate and return protocol fee\n     * @param _depositData The deposit data through which the protocol fee can be calculated.\n     * @param _primexDNS The address of the PrimexDNS contract.\n     * @param _priceOracle The address of the PriceOracle contract.\n     * @param _orderType Type of possible order in Primex protocol\n     * @param _feeToken An asset in which the fee will be paid. At this point it could be the pmx, the epmx or a native currency\n     * @return The amount of the protocol fee in '_feeToken' which needs to be paid according to the specified deposit parameters.\n     */\n    function calculateProtocolFee(\n        DepositData memory _depositData,\n        IPrimexDNS _primexDNS,\n        address _priceOracle,\n        IPrimexDNSStorage.OrderType _orderType,\n        address _feeToken\n    ) public view returns (uint256) {\n        uint256 feeRate = _primexDNS.feeRates(_orderType, _feeToken);\n        if (feeRate == 0) return 0;\n        uint256 nativeFeeRate = _feeToken == NATIVE_CURRENCY\n            ? feeRate\n            : _primexDNS.feeRates(_orderType, NATIVE_CURRENCY);\n\n        _depositData.protocolFee = getOracleAmountsOut(\n            _depositData.depositAsset,\n            NATIVE_CURRENCY,\n            _depositData.depositAmount.wmul(_depositData.leverage).wmul(nativeFeeRate),\n            _priceOracle\n        );\n\n        (uint256 minFee, uint256 maxFee) = IPrimexDNSV2(address(_primexDNS)).feeRestrictions(_orderType);\n        if (minFee > _depositData.protocolFee) {\n            _depositData.protocolFee = minFee;\n        } else if (maxFee < _depositData.protocolFee) {\n            _depositData.protocolFee = maxFee;\n        }\n\n        if (_feeToken != NATIVE_CURRENCY) {\n            _require(nativeFeeRate != 0, Errors.FEE_RATE_IN_NATIVE_IS_ZERO.selector);\n            uint256 discountMultiplier = feeRate.wdiv(nativeFeeRate);\n            _depositData.protocolFee = getOracleAmountsOut(\n                NATIVE_CURRENCY,\n                _feeToken,\n                _depositData.protocolFee.wmul(discountMultiplier),\n                _priceOracle\n            );\n        }\n\n        return _depositData.protocolFee;\n    }\n\n    /**\n     * @param _tokenA asset for sell\n     * @param _tokenB asset to buy\n     * @param _amountAssetA Amount tokenA to sell\n     * @param _priceOracle PriceOracle contract address\n     * @return returns the amount of `tokenB` by the `amountAssetA` by the price of the oracle\n     */\n    function getOracleAmountsOut(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountAssetA,\n        address _priceOracle\n    ) public view returns (uint256) {\n        _require(\n            IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        if (_tokenA == _tokenB) {\n            return _amountAssetA;\n        }\n        (uint256 exchangeRate, bool isForward) = IPriceOracle(_priceOracle).getExchangeRate(_tokenA, _tokenB);\n        uint256 amountAssetB;\n        uint256 multiplier1 = _getAssetMultiplier(_tokenA);\n        uint256 multiplier2 = _getAssetMultiplier(_tokenB);\n\n        if (isForward) {\n            amountAssetB = (_amountAssetA * multiplier1).wmul(exchangeRate) / multiplier2;\n        } else {\n            amountAssetB = (_amountAssetA * multiplier1).wdiv(exchangeRate) / multiplier2;\n        }\n        return amountAssetB;\n    }\n\n    /**\n     * @param _tokenA asset for sell\n     * @param _tokenB asset to buy\n     * @param _amountsAssetA An array of amounts of tokenA to sell\n     * @param _priceOracle PriceOracle contract address\n     * @return returns an array of amounts of `tokenB` by the `amountsAssetA` by the price of the oracle\n     */\n    function getBatchOracleAmountsOut(\n        address _tokenA,\n        address _tokenB,\n        uint256[] memory _amountsAssetA,\n        address _priceOracle\n    ) public view returns (uint256[] memory) {\n        _require(\n            IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        if (_tokenA == _tokenB) {\n            return _amountsAssetA;\n        }\n        uint256[] memory amountsAssetB = new uint256[](_amountsAssetA.length);\n        (uint256 exchangeRate, bool isForward) = IPriceOracle(_priceOracle).getExchangeRate(_tokenA, _tokenB);\n        uint256 multiplier1 = 10 ** (18 - IERC20Metadata(_tokenA).decimals());\n        uint256 multiplier2 = 10 ** (18 - IERC20Metadata(_tokenB).decimals());\n\n        if (isForward) {\n            for (uint256 i; i < _amountsAssetA.length; i++) {\n                amountsAssetB[i] = (_amountsAssetA[i] * multiplier1).wmul(exchangeRate) / multiplier2;\n            }\n        } else {\n            for (uint256 i; i < _amountsAssetA.length; i++) {\n                amountsAssetB[i] = (_amountsAssetA[i] * multiplier1).wdiv(exchangeRate) / multiplier2;\n            }\n        }\n        return amountsAssetB;\n    }\n\n    /**\n     * @notice Calculates the liquidation price for a position.\n     * @dev liquidationPrice = (feeBuffer * debt) /\n     * ((1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - priceDrop) * positionAmount))\n     * @param _bucket The address of the related bucket.\n     * @param _positionAsset The address of the position asset.\n     * @param _positionAmount The size of the opened position.\n     * @param _positionDebt The debt amount in debtTokens associated with the position.\n     * @return The calculated liquidation price in borrowed asset.\n     */\n    function getLiquidationPrice(\n        address _bucket,\n        address _positionAsset,\n        uint256 _positionAmount,\n        uint256 _positionDebt\n    ) public view returns (uint256) {\n        _require(_positionAsset != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        LiquidationPriceData memory data;\n        data.bucket = IBucket(_bucket);\n\n        (, bool tokenAllowed) = data.bucket.allowedAssets(_positionAsset);\n        _require(tokenAllowed, Errors.TOKEN_NOT_SUPPORTED.selector);\n\n        data.positionManager = data.bucket.positionManager();\n        data.borrowedAsset = data.bucket.borrowedAsset();\n        data.priceOracle = data.positionManager.priceOracle();\n\n        uint256 multiplier1 = 10 ** (18 - data.borrowedAsset.decimals());\n        uint256 denominator = (WadRayMath.WAD - data.positionManager.securityBuffer())\n            .wmul(\n                WadRayMath.WAD -\n                    data.positionManager.getOracleTolerableLimit(_positionAsset, address(data.borrowedAsset))\n            )\n            .wmul(WadRayMath.WAD - data.priceOracle.getPairPriceDrop(_positionAsset, address(data.borrowedAsset)))\n            .wmul(_positionAmount) * 10 ** (18 - IERC20Metadata(_positionAsset).decimals());\n        // numerator = data.bucket.feeBuffer().wmul(_positionDebt) * multiplier1;\n        return (data.bucket.feeBuffer().wmul(_positionDebt) * multiplier1).wdiv(denominator) / multiplier1;\n    }\n\n    /**\n     * @notice Validates if a position meets the minimum size requirement.\n     * @param _minPositionSize The minimum position size.\n     * @param _minPositionAsset The asset associated with the minimum position size.\n     * @param _amount The amount of the asset in the position.\n     * @param _asset The asset associated with the position.\n     * @param _priceOracle The address of the price oracle contract.\n     */\n    function validateMinPositionSize(\n        uint256 _minPositionSize,\n        address _minPositionAsset,\n        uint256 _amount,\n        address _asset,\n        address _priceOracle\n    ) public view {\n        _require(\n            isCorrespondsMinPositionSize(_minPositionSize, _minPositionAsset, _asset, _amount, _priceOracle),\n            Errors.INSUFFICIENT_POSITION_SIZE.selector\n        );\n    }\n\n    /**\n     * @notice Checks if the given amount of _asset corresponds to the minimum position size _minPositionSize,\n     * based on the _minPositionAsset and the provided _priceOracle.\n     * Returns true if the amount corresponds to or exceeds the minimum position size, otherwise returns false.\n     * @param _minPositionSize The minimum position size required.\n     * @param _minPositionAsset The address of the asset used for determining the minimum position size.\n     * @param _asset The address of the asset being checked.\n     * @param _amount The amount of _asset being checked.\n     * @param _priceOracle The address of the price oracle contract.\n     * @return A boolean value indicating whether the amount corresponds to or exceeds the minimum position size.\n     */\n    function isCorrespondsMinPositionSize(\n        uint256 _minPositionSize,\n        address _minPositionAsset,\n        address _asset,\n        uint256 _amount,\n        address _priceOracle\n    ) public view returns (bool) {\n        if (_minPositionSize == 0) return true;\n\n        uint256 amountInMinPositionAsset = getOracleAmountsOut(_asset, _minPositionAsset, _amount, _priceOracle);\n        return amountInMinPositionAsset >= _minPositionSize;\n    }\n\n    /**\n     * @notice Decodes an encoded path and returns an array of addresses.\n     * @param encodedPath The encoded path to be decoded.\n     * @param dexRouter The address of the DEX router.\n     * @param dexAdapter The address of the DEX adapter.\n     * @return path An array of addresses representing the decoded path.\n     */\n    function decodePath(\n        bytes memory encodedPath,\n        address dexRouter,\n        address dexAdapter\n    ) public view returns (address[] memory path) {\n        IDexAdapter.DexType type_ = IDexAdapter(dexAdapter).dexType(dexRouter);\n\n        if (type_ == IDexAdapter.DexType.UniswapV2 || type_ == IDexAdapter.DexType.Meshswap) {\n            path = abi.decode(encodedPath, (address[]));\n        } else if (type_ == IDexAdapter.DexType.UniswapV3) {\n            uint256 skip;\n            uint256 offsetSize = 23; // address size(20) + fee size(3)\n            uint256 pathLength = encodedPath.length / offsetSize + 1;\n            path = new address[](pathLength);\n            for (uint256 i; i < pathLength; i++) {\n                path[i] = encodedPath.toAddress(skip, encodedPath.length);\n                skip += offsetSize;\n            }\n        } else if (type_ == IDexAdapter.DexType.Curve) {\n            (path, ) = abi.decode(encodedPath, (address[], address[]));\n        } else if (type_ == IDexAdapter.DexType.Balancer) {\n            (path, , ) = abi.decode(encodedPath, (address[], bytes32[], int256[]));\n        } else if (type_ == IDexAdapter.DexType.AlgebraV3) {\n            uint256 skip;\n            uint256 offsetSize = 20; // address size(20)\n            uint256 pathLength = encodedPath.length / offsetSize;\n            path = new address[](pathLength);\n            for (uint256 i; i < pathLength; i++) {\n                path[i] = encodedPath.toAddress(skip, encodedPath.length);\n                skip += offsetSize;\n            }\n        } else {\n            _revert(Errors.UNKNOWN_DEX_TYPE.selector);\n        }\n    }\n\n    /**\n     * @notice Retrieves the price from two price feeds.\n     * @dev This function returns the price ratio between the base price and the quote price.\n     * @param basePriceFeed The address of the base price feed (AggregatorV3Interface).\n     * @param quotePriceFeed The address of the quote price feed (AggregatorV3Interface).\n     * @param roundBaseFeed The round ID of the base price feed.\n     * @param roundQuoteFeed The round ID of the quote price feed.\n     * @param checkedTimestamp The timestamp used to filter relevant prices. Set to 0 to consider all prices.\n     * @return The price ratio in WAD format between the base price and the quote price, and the timestamp of the latest price.\n     */\n    function getPriceFromFeeds(\n        AggregatorV3Interface basePriceFeed,\n        AggregatorV3Interface quotePriceFeed,\n        uint80 roundBaseFeed,\n        uint80 roundQuoteFeed,\n        uint256 checkedTimestamp\n    ) internal view returns (uint256, uint256) {\n        (, int256 basePrice, , uint256 basePriceUpdatedAt, ) = basePriceFeed.getRoundData(roundBaseFeed);\n        (, , , uint256 basePriceUpdatedAtNext, ) = basePriceFeed.getRoundData(roundBaseFeed + 1);\n        // update to current timestamp if roundBaseFeed is last round\n        if (basePriceUpdatedAtNext == 0) basePriceUpdatedAtNext = block.timestamp;\n\n        (, int256 quotePrice, , uint256 quotePriceUpdatedAt, ) = quotePriceFeed.getRoundData(roundQuoteFeed);\n        (, , , uint256 quotePriceUpdatedAtNext, ) = quotePriceFeed.getRoundData(roundQuoteFeed + 1);\n        // update to current timestamp if roundQuoteFeed is last round\n        if (quotePriceUpdatedAtNext == 0) quotePriceUpdatedAtNext = block.timestamp;\n\n        _require(basePriceUpdatedAt > 0 && quotePriceUpdatedAt > 0, Errors.DATA_FOR_ROUND_DOES_NOT_EXIST.selector);\n\n        // we work only with prices that were relevant after position creation\n        _require(\n            checkedTimestamp == 0 ||\n                (basePriceUpdatedAtNext > checkedTimestamp && quotePriceUpdatedAtNext > checkedTimestamp),\n            Errors.HIGH_PRICE_TIMESTAMP_IS_INCORRECT.selector\n        );\n        // there should be an intersection between their duration\n        _require(\n            quotePriceUpdatedAt < basePriceUpdatedAtNext && basePriceUpdatedAt < quotePriceUpdatedAtNext,\n            Errors.NO_PRICE_FEED_INTERSECTION.selector\n        );\n        //the return value will always be 18 decimals if the basePrice and quotePrice have the same decimals\n        return (\n            uint256(basePrice).wdiv(uint256(quotePrice)),\n            quotePriceUpdatedAt < basePriceUpdatedAt ? quotePriceUpdatedAt : basePriceUpdatedAt\n        );\n    }\n\n    /**\n     * @notice Returns the asset multiplier for a given asset.\n     * @dev If the asset is the native currency, the function returns 1.\n     * If the asset is USD, the function returns the value stored in the constant USD_MULTIPLIER.\n     * For any other asset, the function calculates the multiplier based on the number of decimals of the token.\n     * @param _asset The address of the asset.\n     * @return The asset multiplier. It is a number with 10 raised to a power of decimals of a given asset.\n     */\n    function _getAssetMultiplier(address _asset) internal view returns (uint256) {\n        if (_asset == NATIVE_CURRENCY) return 1;\n        if (_asset == USD) return USD_MULTIPLIER;\n\n        return 10 ** (18 - IERC20Metadata(_asset).decimals());\n    }\n}\n"
    },
    "contracts/libraries/TokenTransfersLibrary.sol": {
      "content": "// Copyright 2020 Compound Labs, Inc.\n// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BSD-3-Clause\n\n// Modified version of token transfer logic that allows working with non-standart ERC-20 tokens, added method doTransferFromTo,\n// modified doTransferIn\n\npragma solidity 0.8.18;\n\nimport \"./Errors.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {EIP20NonStandardInterface} from \"../interfaces/EIP20NonStandardInterface.sol\";\n\nlibrary TokenTransfersLibrary {\n    function doTransferIn(address token, address from, uint256 amount) public returns (uint256) {\n        return doTransferFromTo(token, from, address(this), amount);\n    }\n\n    function doTransferFromTo(address token, address from, address to, uint256 amount) public returns (uint256) {\n        uint256 balanceBefore = IERC20(token).balanceOf(to);\n        // The returned value is checked in the assembly code below.\n        // Arbitrary `from` should be checked at a higher level. The library function cannot be called by the user.\n        // slither-disable-next-line unchecked-transfer arbitrary-send-erc20\n        EIP20NonStandardInterface(token).transferFrom(from, to, amount);\n\n        bool success;\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            switch returndatasize()\n            case 0 {\n                // This is a non-standard ERC-20\n                success := not(0) // set success to true\n            }\n            case 32 {\n                // This is a compliant ERC-20\n                returndatacopy(0, 0, 32)\n                success := mload(0) // Set `success = returndata` of external call\n            }\n            default {\n                // This is an excessively non-compliant ERC-20, revert.\n                revert(0, 0)\n            }\n        }\n        _require(success, Errors.TOKEN_TRANSFER_IN_FAILED.selector);\n\n        // Calculate the amount that was *actually* transferred\n        uint256 balanceAfter = IERC20(token).balanceOf(to);\n        _require(balanceAfter >= balanceBefore, Errors.TOKEN_TRANSFER_IN_OVERFLOW.selector);\n\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n    }\n\n    function doTransferOut(address token, address to, uint256 amount) public {\n        // The returned value is checked in the assembly code below.\n        // slither-disable-next-line unchecked-transfer\n        EIP20NonStandardInterface(token).transfer(to, amount);\n\n        bool success;\n        // solhint-disable-next-line no-inline-assembly\n        assembly (\"memory-safe\") {\n            switch returndatasize()\n            case 0 {\n                // This is a non-standard ERC-20\n                success := not(0) // set success to true\n            }\n            case 32 {\n                // This is a complaint ERC-20\n                returndatacopy(0, 0, 32)\n                success := mload(0) // Set `success = returndata` of external call\n            }\n            default {\n                // This is an excessively non-compliant ERC-20, revert.\n                revert(0, 0)\n            }\n        }\n        _require(success, Errors.TOKEN_TRANSFER_OUT_FAILED.selector);\n    }\n\n    function doTransferOutETH(address to, uint256 value) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        _require(success, Errors.NATIVE_TOKEN_TRANSFER_FAILED.selector);\n    }\n}\n"
    },
    "contracts/libraries/utils/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// A modified version of BytesLib\n// Origin: https://github.com/1inch/universal-router/blob/b972662f8d3f0ba55ef99411720f613f77c3fab5/contracts/modules/uniswap/v3/BytesLib.sol\n// Unused methods and constants were removed\npragma solidity 0.8.18;\n\nlibrary BytesLib {\n    error ToAddressOverflow();\n    error ToAddressOutOfBounds();\n\n    /// @notice Returns the address starting at byte `_start`\n    /// @dev _bytesLength must equal _bytes.length for this to function correctly\n    /// @param _bytes The input bytes string to slice\n    /// @param _start The starting index of the address\n    /// @param _bytesLength The length of _bytes\n    /// @return tempAddress The address starting at _start\n    function toAddress(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _bytesLength\n    ) internal pure returns (address tempAddress) {\n        unchecked {\n            if (_start + 20 < _start) revert ToAddressOverflow();\n            if (_bytesLength < _start + 20) revert ToAddressOutOfBounds();\n        }\n\n        assembly {\n            tempAddress := mload(add(add(_bytes, 0x14), _start))\n        }\n    }\n}\n"
    },
    "contracts/libraries/utils/V3Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// A modified version of V3Path library\n// Origin: https://github.com/1inch/universal-router/blob/b972662f8d3f0ba55ef99411720f613f77c3fab5/contracts/modules/uniswap/v3/V3Path.sol\n// Unused methods and constants were removed\n\npragma solidity 0.8.18;\n\nimport {BytesLib} from \"./BytesLib.sol\";\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary V3Path {\n    using BytesLib for bytes;\n\n    function decodeFirstToken(bytes memory path) internal pure returns (address tokenA) {\n        tokenA = path.toAddress(0, path.length);\n    }\n}\n"
    },
    "contracts/libraries/utils/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n// A modified version of ds-math library\n// Origin: https://github.com/dapphub/ds-math/blob/master/src/math.sol\n// Unused methods were removed, errors changed\n\npragma solidity 0.8.18;\nerror DS_MATH_ADD_OVERFLOW();\nerror DS_MATH_MUL_OVERFLOW();\n\nlibrary WadRayMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        if ((z = x + y) < x) revert DS_MATH_ADD_OVERFLOW();\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        if (!(y == 0 || (z = x * y) / y == x)) revert DS_MATH_MUL_OVERFLOW();\n    }\n\n    uint256 internal constant WAD = 10 ** 18;\n    uint256 internal constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    //rounds to zero if x*y < RAY / 2\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n}\n"
    },
    "contracts/LimitOrderManager/ILimitOrderManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\nimport {ILimitOrderManagerStorage} from \"./ILimitOrderManagerStorage.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface ILimitOrderManager is ILimitOrderManagerStorage, IPausable {\n    enum LimitOrderType {\n        Margin,\n        Spot,\n        Swap\n    }\n\n    struct UpdateOrderConditionsParams {\n        uint256 orderId;\n        LimitOrderLibrary.Condition[] openConditions;\n        LimitOrderLibrary.Condition[] closeConditions;\n    }\n\n    event CreateLimitOrder(\n        uint256 indexed orderId,\n        address indexed trader,\n        LimitOrderLibrary.LimitOrder order,\n        LimitOrderLibrary.Condition[] openConditions,\n        LimitOrderLibrary.Condition[] closeConditions\n    );\n\n    event CloseLimitOrder(\n        uint256 indexed orderId,\n        address indexed trader,\n        address indexed closedBy,\n        LimitOrderLibrary.CloseReason reason,\n        uint256 positionId,\n        // TODO: can delete args below when front be ready for it\n        string bucket,\n        address borrowedAsset,\n        address positionAsset,\n        uint256 leverage,\n        address depositAsset,\n        uint256 depositAmount\n    );\n\n    event UpdateOrder(\n        uint256 indexed orderId,\n        address indexed trader,\n        uint256 depositAmount,\n        uint256 leverage,\n        address feeToken,\n        uint256 protocolFee\n    );\n\n    event UpdateOrderConditions(\n        uint256 indexed orderId,\n        address indexed trader,\n        LimitOrderLibrary.Condition[] openConditions,\n        LimitOrderLibrary.Condition[] closeConditions\n    );\n\n    /**\n     * @notice Initializes the LimitOrderManager contract.\n     * @param _registry The address of the Registry contract.\n     * @param _primexDNS The address of the PrimexDNS contract.\n     * @param _pm The address of the PositionManager contract.\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\n     * @param _swapManager The address of the SwapManager contract.\n     * @param _whiteBlackList The address of the WhiteBlacklist contract.\n     */\n    function initialize(\n        address _registry,\n        address _primexDNS,\n        address _pm,\n        address payable _traderBalanceVault,\n        address _swapManager,\n        address _whiteBlackList\n    ) external;\n\n    /**\n     * @notice Creates a limit order.\n     * @dev This function allows users to create a limit order and locks the deposit asset in the traderBalanceVault\n     * @param _params The parameters necessary to create limit order\n     */\n    function createLimitOrder(LimitOrderLibrary.CreateLimitOrderParams calldata _params) external payable;\n\n    /**\n     * @notice Cancels the order. Can only be called by the trader\n     * @param _orderId order id\n     */\n    function cancelLimitOrder(uint256 _orderId) external;\n\n    /**\n     * @notice Removes expired limit orders\n     * @param _orderIds The array of order IDs to remove.\n     */\n    function cancelExpiredLimitOrders(uint256[] calldata _orderIds) external;\n\n    /**\n     * @notice Opens a position by an existing order.\n     * @dev This function is called to open a position based on the given order parameters.\n     * @param _params The OpenPositionParams struct containing the necessary parameters for opening the position.\n     */\n    function openPositionByOrder(LimitOrderLibrary.OpenPositionParams calldata _params) external;\n\n    /**\n     * @notice Updates an existing limit order.\n     * @dev Edits prices on an existing order\n     * @param _params The parameters for updating the limit order.\n     */\n    function updateOrder(LimitOrderLibrary.UpdateLimitOrderParams calldata _params) external payable;\n\n    /**\n     * @notice Updates the open and close conditions of an order.\n     * @dev Only the trader of the order can update the conditions.\n     * @param _params The parameters for updating the order conditions.\n     */\n    function updateOrderConditions(UpdateOrderConditionsParams memory _params) external;\n\n    /**\n     * @notice Returns true if current price >= limit price and block.timestamp <= deadline\n     * @param _orderId order id\n     * @param _conditionIndex index of condition in openConditions\n     * @param _additionalParams parameters needed for dex\n     */\n    function canBeFilled(\n        uint256 _orderId,\n        uint256 _conditionIndex,\n        bytes calldata _additionalParams\n    ) external returns (bool);\n\n    /**\n     * @notice Function to set new swapManager.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _swapManager Address of the new swapManager.\n     */\n    function setSwapManager(address _swapManager) external;\n\n    /**\n     * @notice Retrieves the details of a limit order based on its ID.\n     * @param _id The ID of the limit order to retrieve.\n     * @return The LimitOrder struct representing the limit order.\n     */\n    function getOrder(uint256 _id) external view returns (LimitOrderLibrary.LimitOrder memory);\n\n    /**\n     * @notice Retrieves the limit order at the specified index.\n     * @param _index The index of the limit order to retrieve.\n     * @return The limit order at the specified index.\n     */\n    function getOrderByIndex(uint256 _index) external view returns (LimitOrderLibrary.LimitOrder memory);\n\n    /**\n     * @notice Retrieves the close conditions associated with the given order ID.\n     * @param _orderId The ID of the order.\n     * @return An array of Condition representing the close conditions.\n     */\n    function getCloseConditions(uint256 _orderId) external view returns (LimitOrderLibrary.Condition[] memory);\n\n    /**\n     * @notice Retrieves the open conditions associated with a given order ID.\n     * @param _orderId The ID of the order.\n     * @return An array of Condition structs representing the open conditions.\n     */\n    function getOpenConditions(uint256 _orderId) external view returns (LimitOrderLibrary.Condition[] memory);\n\n    /**\n     * @notice Returns the length of the orders array.\n     * @return The number of orders in the array.\n     */\n    function getOrdersLength() external view returns (uint256);\n\n    /**\n     * @notice Returns the length of the order array for a specific trader.\n     * @param _trader The address of the trader.\n     * @return The length of the order array.\n     */\n    function getTraderOrdersLength(address _trader) external view returns (uint256);\n\n    /**\n     * @notice Returns an array of LimitOrder structures representing the orders placed by a specific trader.\n     * @param _trader The address of the trader.\n     * @return traderOrders An array of LimitOrder structures representing the orders placed by the trader.\n     */\n    function getTraderOrders(address _trader) external view returns (LimitOrderLibrary.LimitOrder[] memory);\n\n    /**\n     * @notice Returns the length of orders in a bucket.\n     * @param _bucket The address of the bucket.\n     * @return The number of orders in the bucket.\n     */\n    function getBucketOrdersLength(address _bucket) external view returns (uint256);\n\n    /**\n     * @notice Retrieves all limit orders associated with a given bucket.\n     * @param _bucket The address of the bucket.\n     * @return An array of LimitOrder structs representing the bucket's orders.\n     */\n    function getBucketOrders(address _bucket) external view returns (LimitOrderLibrary.LimitOrder[] memory);\n}\n"
    },
    "contracts/LimitOrderManager/ILimitOrderManagerStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {ISwapManager} from \"../interfaces/ISwapManager.sol\";\n\ninterface ILimitOrderManagerStorage {\n    function ordersId() external view returns (uint256);\n\n    function orderIndexes(uint256) external view returns (uint256);\n\n    function traderOrderIndexes(uint256) external view returns (uint256);\n\n    function traderOrderIds(address _trader, uint256 _index) external view returns (uint256);\n\n    function bucketOrderIndexes(uint256) external view returns (uint256);\n\n    function bucketOrderIds(address _bucket, uint256 _index) external view returns (uint256);\n\n    function registry() external view returns (IAccessControl);\n\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\n\n    function primexDNS() external view returns (IPrimexDNS);\n\n    function pm() external view returns (IPositionManager);\n\n    function swapManager() external view returns (ISwapManager);\n}\n"
    },
    "contracts/LimitOrderManager/LimitOrderManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"./LimitOrderManagerStorage.sol\";\nimport {BIG_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN, NATIVE_CURRENCY, BIG_TIMELOCK_ADMIN} from \"../Constants.sol\";\nimport {ILimitOrderManager} from \"./ILimitOrderManager.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IKeeperRewardDistributorStorage} from \"../KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\";\nimport {IKeeperRewardDistributor} from \"../KeeperRewardDistributor/IKeeperRewardDistributor.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ncontract LimitOrderManager is ILimitOrderManager, LimitOrderManagerStorage {\n    using WadRayMath for uint256;\n    using LimitOrderLibrary for LimitOrderLibrary.LimitOrder;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Throws if order doesn't exist\n     * @param _orderId order id\n     */\n    modifier orderExists(uint256 _orderId) {\n        uint256 index = orderIndexes[_orderId]; // is 0 if not explicitly set\n        _require(orders.length > 0 && orders[index].id == _orderId, Errors.ORDER_DOES_NOT_EXIST.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(registry.hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    modifier notBlackListed() {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function initialize(\n        address _registry,\n        address _primexDNS,\n        address _pm,\n        address payable _traderBalanceVault,\n        address _swapManager,\n        address _whiteBlackList\n    ) external override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(_primexDNS).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165Upgradeable(_pm).supportsInterface(type(IPositionManager).interfaceId) &&\n                IERC165Upgradeable(_traderBalanceVault).supportsInterface(type(ITraderBalanceVault).interfaceId) &&\n                IERC165Upgradeable(_swapManager).supportsInterface(type(ISwapManager).interfaceId) &&\n                IERC165Upgradeable(_whiteBlackList).supportsInterface(type(IWhiteBlackList).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = IAccessControl(_registry);\n        whiteBlackList = IWhiteBlackList(_whiteBlackList);\n        primexDNS = IPrimexDNS(_primexDNS);\n        pm = IPositionManager(_pm);\n        traderBalanceVault = ITraderBalanceVault(_traderBalanceVault);\n        swapManager = ISwapManager(_swapManager);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __ERC165_init();\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function createLimitOrder(\n        LimitOrderLibrary.CreateLimitOrderParams calldata _params\n    ) external payable override nonReentrant notBlackListed whenNotPaused {\n        LimitOrderLibrary.LimitOrder memory order = LimitOrderLibrary.createLimitOrder(\n            _params,\n            pm,\n            traderBalanceVault,\n            primexDNS\n        );\n        ordersId++;\n        order.id = ordersId;\n\n        orders.push(order);\n        orderIndexes[order.id] = orders.length - 1;\n\n        traderOrderIds[order.trader].push(order.id);\n        traderOrderIndexes[order.id] = traderOrderIds[order.trader].length - 1;\n\n        bucketOrderIds[address(order.bucket)].push(order.id);\n        bucketOrderIndexes[order.id] = bucketOrderIds[address(order.bucket)].length - 1;\n\n        order.setCloseConditions(closeConditions, _params.closeConditions, primexDNS);\n        order.setOpenConditions(openConditions, _params.openConditions, primexDNS);\n\n        bool isSpot = bytes(_params.bucket).length == 0;\n        LimitOrderType limitOrderType;\n        if (isSpot) {\n            limitOrderType = order.shouldOpenPosition ? LimitOrderType.Spot : LimitOrderType.Swap;\n        }\n\n        emit CreateLimitOrder({\n            orderId: order.id,\n            trader: order.trader,\n            order: order,\n            openConditions: openConditions[ordersId],\n            closeConditions: closeConditions[ordersId]\n        });\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function cancelLimitOrder(uint256 _orderId) external override orderExists(_orderId) nonReentrant notBlackListed {\n        LimitOrderLibrary.LimitOrder storage order = orders[orderIndexes[_orderId]];\n        _require(msg.sender == order.trader, Errors.CALLER_IS_NOT_TRADER.selector);\n\n        bool isSpot = order.bucket == IBucket(address(0));\n        emit CloseLimitOrder({\n            orderId: _orderId,\n            trader: order.trader,\n            closedBy: msg.sender,\n            reason: LimitOrderLibrary.CloseReason.Cancelled,\n            positionId: 0,\n            bucket: isSpot ? \"\" : order.bucket.name(),\n            borrowedAsset: isSpot ? address(0) : address(order.bucket.borrowedAsset()),\n            positionAsset: order.positionAsset,\n            leverage: order.leverage,\n            depositAsset: order.depositAsset,\n            depositAmount: order.depositAmount\n        });\n        _unlockAssetsAndDeleteOrder(order);\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function cancelExpiredLimitOrders(uint256[] calldata _orderIds) external override {\n        for (uint256 i; i < _orderIds.length; i++) {\n            uint256 index = orderIndexes[_orderIds[i]];\n            if (orders.length == 0) break;\n            LimitOrderLibrary.LimitOrder storage order = orders[index];\n            bool isSpot = order.bucket == IBucket(address(0));\n            if (\n                order.id == _orderIds[i] &&\n                (order.deadline <= block.timestamp || (!isSpot && order.bucket.isWithdrawAfterDelistingAvailable()))\n            ) {\n                emit CloseLimitOrder({\n                    orderId: order.id,\n                    trader: order.trader,\n                    closedBy: msg.sender,\n                    reason: LimitOrderLibrary.CloseReason.Cancelled,\n                    positionId: 0,\n                    bucket: isSpot ? \"\" : order.bucket.name(),\n                    borrowedAsset: isSpot ? address(0) : address(order.bucket.borrowedAsset()),\n                    positionAsset: order.positionAsset,\n                    leverage: order.leverage,\n                    depositAsset: order.depositAsset,\n                    depositAmount: order.depositAmount\n                });\n                _unlockAssetsAndDeleteOrder(order);\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function openPositionByOrder(\n        LimitOrderLibrary.OpenPositionParams calldata _params\n    ) external override orderExists(_params.orderId) nonReentrant notBlackListed whenNotPaused {\n        uint256 initialGasleft = gasleft();\n        _require(\n            _params.conditionIndex < openConditions[_params.orderId].length,\n            Errors.CONDITION_INDEX_IS_OUT_OF_BOUNDS.selector\n        );\n\n        LimitOrderLibrary.LimitOrder storage order = orders[orderIndexes[_params.orderId]];\n\n        _require(order.deadline > block.timestamp, Errors.ORDER_HAS_EXPIRED.selector);\n\n        if (address(order.bucket) != address(0)) {\n            _require(order.bucket.isActive(), Errors.BUCKET_IS_NOT_ACTIVE.selector);\n            (, bool isSupported) = order.bucket.allowedAssets(order.positionAsset);\n            _require(isSupported, Errors.ASSET_IS_NOT_SUPPORTED.selector);\n        }\n        _require(_params.keeper != address(0), Errors.ADDRESS_IS_ZERO.selector);\n\n        LimitOrderLibrary.OpenPositionByOrderVars memory vars = LimitOrderLibrary.openPositionByOrder(\n            order,\n            _params,\n            closeConditions[order.id],\n            pm,\n            traderBalanceVault,\n            primexDNS,\n            swapManager\n        );\n\n        LimitOrderLibrary.Condition storage condition = openConditions[_params.orderId][_params.conditionIndex];\n        _require(\n            IConditionalOpeningManager(primexDNS.cmTypeToAddress(condition.managerType)).canBeFilledAfterSwap(\n                orders[orderIndexes[_params.orderId]],\n                condition.params,\n                _params.comAdditionalParams,\n                vars.exchangeRate\n            ),\n            Errors.ORDER_CAN_NOT_BE_FILLED.selector\n        );\n\n        bool isSpot = order.bucket == IBucket(address(0));\n        emit CloseLimitOrder({\n            orderId: _params.orderId,\n            trader: order.trader,\n            closedBy: _params.keeper,\n            reason: vars.closeReason,\n            positionId: vars.newPositionId,\n            bucket: isSpot ? \"\" : order.bucket.name(),\n            borrowedAsset: isSpot ? address(0) : vars.assetIn,\n            positionAsset: order.positionAsset,\n            leverage: order.leverage,\n            depositAsset: order.depositAsset,\n            depositAmount: order.depositAmount\n        });\n        bool shouldUpdateReward = order.updatedConditionsAt != block.timestamp;\n        _deleteOrder(order);\n        if (shouldUpdateReward) {\n            // to avoid abuse of the reward system, we will not pay the reward to\n            // the keeper if the position open in the same block as the open conditions change\n            pm.keeperRewardDistributor().updateReward(\n                IKeeperRewardDistributor.UpdateRewardParams({\n                    keeper: _params.keeper,\n                    positionAsset: vars.assetOut,\n                    positionSize: vars.amountOut,\n                    action: IKeeperRewardDistributorStorage.KeeperActionType.OpenByOrder,\n                    numberOfActions: 1,\n                    gasSpent: initialGasleft - gasleft(),\n                    decreasingCounter: new uint256[](0),\n                    routesLength: abi.encode(_params.firstAssetRoutes, _params.depositInThirdAssetRoutes).length\n                })\n            );\n        }\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function updateOrder(\n        LimitOrderLibrary.UpdateLimitOrderParams calldata _params\n    ) external payable override nonReentrant notBlackListed {\n        LimitOrderLibrary.LimitOrder storage order = orders[orderIndexes[_params.orderId]];\n        IBucket bucket = order.bucket;\n\n        _require(msg.sender == order.trader, Errors.CALLER_IS_NOT_TRADER.selector);\n\n        if (bucket != IBucket(address(0))) {\n            _require(bucket.isActive(), Errors.BUCKET_IS_NOT_ACTIVE.selector);\n        }\n\n        address priceOracle = address(pm.priceOracle());\n\n        order.updateProtocolFee(_params, traderBalanceVault, primexDNS, priceOracle);\n\n        if (_params.depositAmount != order.depositAmount) {\n            order.updateDeposit(_params.depositAmount, _params.takeDepositFromWallet, traderBalanceVault);\n        }\n        if (_params.leverage != order.leverage) {\n            order.updateLeverage(_params.leverage);\n        }\n\n        uint256 positionSize = order.depositAmount.wmul(order.leverage);\n\n        PrimexPricingLibrary.validateMinPositionSize(\n            pm.minPositionSize(),\n            pm.minPositionAsset(),\n            positionSize,\n            order.depositAsset,\n            priceOracle\n        );\n        emit UpdateOrder({\n            orderId: order.id,\n            trader: order.trader,\n            depositAmount: order.depositAmount,\n            leverage: order.leverage,\n            feeToken: order.feeToken,\n            protocolFee: order.protocolFee\n        });\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function updateOrderConditions(\n        UpdateOrderConditionsParams memory _params\n    ) external override nonReentrant notBlackListed {\n        LimitOrderLibrary.LimitOrder storage order = orders[orderIndexes[_params.orderId]];\n        _require(msg.sender == order.trader, Errors.CALLER_IS_NOT_TRADER.selector);\n        if (order.bucket != IBucket(address(0))) {\n            _require(order.bucket.isActive(), Errors.BUCKET_IS_NOT_ACTIVE.selector);\n        }\n        if (keccak256(abi.encode(_params.closeConditions)) != keccak256(abi.encode(closeConditions[order.id]))) {\n            order.setCloseConditions(closeConditions, _params.closeConditions, primexDNS);\n        }\n\n        if (keccak256(abi.encode(_params.openConditions)) != keccak256(abi.encode(openConditions[order.id]))) {\n            order.setOpenConditions(openConditions, _params.openConditions, primexDNS);\n            order.updatedConditionsAt = block.timestamp;\n        }\n        emit UpdateOrderConditions({\n            orderId: _params.orderId,\n            trader: order.trader,\n            openConditions: _params.openConditions,\n            closeConditions: _params.closeConditions\n        });\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function setSwapManager(address _swapManager) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165Upgradeable(_swapManager).supportsInterface(type(ISwapManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        swapManager = ISwapManager(_swapManager);\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function getOrder(uint256 _id) external view override returns (LimitOrderLibrary.LimitOrder memory) {\n        _require(orders[orderIndexes[_id]].id == _id, Errors.ORDER_DOES_NOT_EXIST.selector);\n        return orders[orderIndexes[_id]];\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function getOrderByIndex(uint256 _index) external view override returns (LimitOrderLibrary.LimitOrder memory) {\n        return orders[_index];\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function getTraderOrdersLength(address _trader) external view override returns (uint256) {\n        return traderOrderIds[_trader].length;\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function getTraderOrders(address _trader) external view override returns (LimitOrderLibrary.LimitOrder[] memory) {\n        uint256 ordersCount = traderOrderIds[_trader].length;\n        LimitOrderLibrary.LimitOrder[] memory traderOrders = new LimitOrderLibrary.LimitOrder[](ordersCount);\n        for (uint256 i; i < ordersCount; i++) {\n            uint256 id = traderOrderIds[_trader][i];\n            traderOrders[i] = orders[orderIndexes[id]];\n        }\n        return traderOrders;\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function getBucketOrdersLength(address _bucket) external view override returns (uint256) {\n        return bucketOrderIds[_bucket].length;\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function getBucketOrders(address _bucket) external view override returns (LimitOrderLibrary.LimitOrder[] memory) {\n        uint256 ordersCount = bucketOrderIds[_bucket].length;\n        LimitOrderLibrary.LimitOrder[] memory bucketOrders = new LimitOrderLibrary.LimitOrder[](ordersCount);\n        for (uint256 i; i < ordersCount; i++) {\n            uint256 id = bucketOrderIds[_bucket][i];\n            bucketOrders[i] = orders[orderIndexes[id]];\n        }\n        return bucketOrders;\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function canBeFilled(\n        uint256 _orderId,\n        uint256 _conditionIndex,\n        bytes calldata _additionalParams\n    ) public override returns (bool) {\n        _require(_conditionIndex < openConditions[_orderId].length, Errors.CONDITION_INDEX_IS_OUT_OF_BOUNDS.selector);\n        LimitOrderLibrary.Condition storage condition = openConditions[_orderId][_conditionIndex];\n        LimitOrderLibrary.LimitOrder storage order = orders[orderIndexes[_orderId]];\n\n        if (order.deadline < block.timestamp) return false;\n\n        if (address(order.bucket) != address(0)) {\n            (, bool isSupported) = order.bucket.allowedAssets(order.positionAsset);\n            if (!order.bucket.isActive() || !isSupported) return false;\n        }\n\n        return\n            IConditionalOpeningManager(primexDNS.cmTypeToAddress(condition.managerType)).canBeFilledBeforeSwap(\n                orders[orderIndexes[_orderId]],\n                condition.params,\n                _additionalParams\n            );\n    }\n\n    /**\n     * @notice Returns orders array length.\n     */\n    function getOrdersLength() public view override returns (uint256) {\n        return orders.length;\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function getCloseConditions(uint256 _orderId) public view override returns (LimitOrderLibrary.Condition[] memory) {\n        return closeConditions[_orderId];\n    }\n\n    /**\n     * @inheritdoc ILimitOrderManager\n     */\n    function getOpenConditions(uint256 _orderId) public view override returns (LimitOrderLibrary.Condition[] memory) {\n        return openConditions[_orderId];\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(ILimitOrderManager).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Unlocks a deposit amount and a fee amount in the TraderBalanceVault and deletes the order\n     * @param _order order to delete\n     */\n    function _unlockAssetsAndDeleteOrder(LimitOrderLibrary.LimitOrder memory _order) internal {\n        //unlock deposit\n        traderBalanceVault.unlockAsset(\n            ITraderBalanceVault.UnlockAssetParams(\n                _order.trader,\n                _order.trader,\n                _order.depositAsset,\n                _order.depositAmount\n            )\n        );\n        //unlock fee\n        traderBalanceVault.unlockAsset(\n            ITraderBalanceVault.UnlockAssetParams(_order.trader, _order.trader, _order.feeToken, _order.protocolFee)\n        );\n        _deleteOrder(_order);\n    }\n\n    /**\n     * @notice Deletes the order from the orders array\n     * @param _order order to delete\n     */\n    function _deleteOrder(LimitOrderLibrary.LimitOrder memory _order) internal {\n        delete openConditions[_order.id];\n        delete closeConditions[_order.id];\n\n        uint256 lastBucketOrderId = bucketOrderIds[address(_order.bucket)][\n            bucketOrderIds[address(_order.bucket)].length - 1\n        ];\n        bucketOrderIds[address(_order.bucket)][bucketOrderIndexes[_order.id]] = lastBucketOrderId;\n        bucketOrderIndexes[lastBucketOrderId] = bucketOrderIndexes[_order.id];\n        bucketOrderIds[address(_order.bucket)].pop();\n        delete bucketOrderIndexes[_order.id];\n\n        uint256 lastTraderOrderId = traderOrderIds[_order.trader][traderOrderIds[_order.trader].length - 1];\n        traderOrderIds[_order.trader][traderOrderIndexes[_order.id]] = lastTraderOrderId;\n        traderOrderIndexes[lastTraderOrderId] = traderOrderIndexes[_order.id];\n        traderOrderIds[_order.trader].pop();\n        delete traderOrderIndexes[_order.id];\n\n        orders[orderIndexes[_order.id]] = orders[orders.length - 1];\n        orderIndexes[orders[orders.length - 1].id] = orderIndexes[_order.id];\n        orders.pop();\n        delete orderIndexes[_order.id];\n    }\n}\n"
    },
    "contracts/LimitOrderManager/LimitOrderManagerStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {TokenTransfersLibrary} from \"../libraries/TokenTransfersLibrary.sol\";\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport \"../libraries/Errors.sol\";\n\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {ILimitOrderManagerStorage} from \"./ILimitOrderManagerStorage.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IConditionalOpeningManager} from \"../interfaces/IConditionalOpeningManager.sol\";\nimport {ISwapManager} from \"../interfaces/ISwapManager.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\n\nabstract contract LimitOrderManagerStorage is\n    ILimitOrderManagerStorage,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    ERC165Upgradeable\n{\n    LimitOrderLibrary.LimitOrder[] internal orders;\n    uint256 public override ordersId;\n    mapping(uint256 => uint256) public override orderIndexes;\n    // mapping from orderId to the index in the traderOrderIds[trader] array\n    mapping(uint256 => uint256) public override traderOrderIndexes;\n    // mapping from trader address to the order ids array\n    mapping(address => uint256[]) public override traderOrderIds;\n    // mapping from orderId to the index in the bucketOrderIds[bucket] array\n    mapping(uint256 => uint256) public override bucketOrderIndexes;\n    // mapping from bucket address to the order ids array\n    mapping(address => uint256[]) public override bucketOrderIds;\n    // mapping from order to open conditions\n    mapping(uint256 => LimitOrderLibrary.Condition[]) public openConditions;\n    // mapping from order to close conditions\n    mapping(uint256 => LimitOrderLibrary.Condition[]) public closeConditions;\n\n    IAccessControl public override registry;\n    ITraderBalanceVault public override traderBalanceVault;\n    IPrimexDNS public override primexDNS;\n    IPositionManager public override pm;\n    ISwapManager public override swapManager;\n    IWhiteBlackList internal whiteBlackList;\n}\n"
    },
    "contracts/LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {ILiquidityMiningRewardDistributorStorage} from \"./ILiquidityMiningRewardDistributorStorage.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface ILiquidityMiningRewardDistributor is ILiquidityMiningRewardDistributorStorage, IPausable {\n    struct RewardsInPMX {\n        uint256 minReward;\n        uint256 maxReward;\n        uint256 extraReward;\n    }\n\n    /**\n     * @notice Emitted when a reward is claimed by a receiver from a specific bucket.\n     * @param receiver The address of the receiver.\n     * @param bucket The address of the bucket from which the reward is claimed.\n     * @param amount The amount of the claimed reward.\n     */\n    event ClaimedReward(address indexed receiver, address indexed bucket, uint256 amount);\n    /**\n     * @notice Emitted when PMX tokens are withdrawn by an admin.\n     * @param amount The amount of PMX tokens withdrawn.\n     */\n    event WithdrawPmxByAdmin(uint256 indexed amount);\n\n    /**\n     * @notice Initializes the contract with the specified parameters.\n     * @param _primexDNS The address of the IPrimexDNS contract.\n     * @param _pmx The address of the PMX token contract.\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\n     * @param _registry The address of the registry contract.\n     * @param _treasury The address of the treasury contract.\n     * @param _reinvestmentRate The rate at which rewards are reinvested.\n     * @param _reinvestmentDuration The duration for which rewards are reinvested.\n     * @param _whiteBlackList The address of the WhiteBlackList contract.\n     */\n    function initialize(\n        IPrimexDNS _primexDNS,\n        IERC20 _pmx,\n        ITraderBalanceVault _traderBalanceVault,\n        address _registry,\n        address _treasury,\n        uint256 _reinvestmentRate,\n        uint256 _reinvestmentDuration,\n        IWhiteBlackList _whiteBlackList\n    ) external;\n\n    /**\n     * @notice Updates the reward amount for a specific bucket.\n     * @dev Only callable by the PrimexDNS contract.\n     * @param _bucketName The name of the bucket.\n     * @param _pmxRewardsAmount The amount of PMX rewards to be allocated to the bucket.\n     */\n    function updateBucketReward(string memory _bucketName, uint256 _pmxRewardsAmount) external;\n\n    /**\n     * @notice Adds points for a user for future reward distribution.\n     * @dev Only callable by the Bucket contract.\n     * @param _bucketName The name of the bucket.\n     * @param _user The address of the user.\n     * @param _miningAmount The amount of mining points to be added.\n     * @param _maxStabilizationPeriodEnd The maximum end timestamp of the stabilization period.\n     * @param _maxPeriodTime The maximum period time.\n     * @param _currentTimestamp The current timestamp.\n     */\n    function addPoints(\n        string memory _bucketName,\n        address _user,\n        uint256 _miningAmount,\n        uint256 _maxStabilizationPeriodEnd,\n        uint256 _maxPeriodTime,\n        uint256 _currentTimestamp\n    ) external;\n\n    /**\n     * @notice Removes points for a user.\n     * @dev Only callable by the Bucket contract.\n     * @param _name The name of the bucket.\n     * @param _user The address of the user.\n     * @param _amount The amount of mining points to be removed.\n     */\n    function removePoints(string memory _name, address _user, uint256 _amount) external;\n\n    /**\n     * @notice Claims the accumulated rewards for a specific bucket.\n     * @param _bucketName The name of the bucket.\n     */\n    function claimReward(string memory _bucketName) external;\n\n    /**\n     * @notice Moves rewards from one bucket to another.\n     * @dev Only callable by the Bucket contract.\n     * @param _bucketFrom The name of the source bucket.\n     * @param _bucketTo The name of the destination bucket.\n     * @param _user The address of the user.\n     * @param _isBucketLaunched A flag indicating if the destination bucket is launched.\n     * @param _liquidityMiningDeadline The deadline for liquidity mining\n     */\n    function reinvest(\n        string memory _bucketFrom,\n        string memory _bucketTo,\n        address _user,\n        bool _isBucketLaunched,\n        uint256 _liquidityMiningDeadline\n    ) external;\n\n    /**\n     * @dev The function to withdraw PMX from a delisted bucket or a bucket where liquidity mining failed (after reinvesting period).\n     * Emits WithdrawPmxByAdmin event.\n     * @param _bucketFrom Name of the bucket with failed liquidity mining event.\n     */\n    function withdrawPmxByAdmin(string memory _bucketFrom) external;\n\n    /**\n     * @notice Retrieves information about a lender in a specific bucket.\n     * @param _bucketName The name of the bucket.\n     * @param _lender The address of the lender.\n     * @param _timestamp The timestamp for which the information is queried.\n     * @return amountInMining The amount of tokens the lender has in mining for the given bucket.\n     * @return currentPercent The current percentage of rewards the lender is eligible to receive for the given bucket.\n     * Measured in WAD (1 WAD = 100%).\n     * @return rewardsInPMX An object containing information about the lender's rewards in PMX for the given bucket.\n     */\n    function getLenderInfo(\n        string calldata _bucketName,\n        address _lender,\n        uint256 _timestamp\n    ) external view returns (uint256 amountInMining, uint256 currentPercent, RewardsInPMX memory rewardsInPMX);\n\n    /**\n     * @notice Retrieves rewards information about a specific bucket.\n     * @param _bucketName The name of the bucket.\n     * @return totalPmxReward The total amount of PMX reward in the bucket.\n     * @return withdrawnRewards The total amount of withdrawn rewards from the bucket.\n     * @return totalPoints The total number of mining points in the bucket.\n     */\n    function getBucketInfo(\n        string calldata _bucketName\n    ) external view returns (uint256 totalPmxReward, uint256 withdrawnRewards, uint256 totalPoints);\n\n    /**\n     * @notice Retrieves the amount of tokens a lender has in mining for a specific bucket.\n     * @param _bucket The name of the bucket.\n     * @param _lender The address of the lender.\n     * @return The amount of tokens the lender has in mining for the given bucket.\n     */\n    function getLenderAmountInMining(string calldata _bucket, address _lender) external view returns (uint256);\n}\n"
    },
    "contracts/LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\n\ninterface ILiquidityMiningRewardDistributorStorage {\n    struct LenderInfo {\n        uint256 points;\n        uint256 depositedAmount;\n    }\n\n    struct BucketInfo {\n        uint256 totalPoints;\n        uint256 totalPmxReward;\n        uint256 withdrawnRewards;\n        mapping(address => LenderInfo) lendersInfo;\n    }\n\n    function primexDNS() external view returns (IPrimexDNS);\n\n    function pmx() external view returns (IERC20);\n\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\n\n    function registry() external view returns (address);\n\n    function reinvestmentRate() external view returns (uint256);\n\n    function reinvestmentDuration() external view returns (uint256);\n\n    function extraRewards(address, string calldata) external view returns (uint256);\n}\n"
    },
    "contracts/LiquidityMiningRewardDistributor/LiquidityMiningRewardDistributor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport \"./LiquidityMiningRewardDistributorStorage.sol\";\nimport {EMERGENCY_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN} from \"../Constants.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {ILiquidityMiningRewardDistributor, IPausable} from \"./ILiquidityMiningRewardDistributor.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {ITreasury} from \"../Treasury/ITreasury.sol\";\n\ncontract LiquidityMiningRewardDistributor is\n    ILiquidityMiningRewardDistributor,\n    LiquidityMiningRewardDistributorStorage\n{\n    using WadRayMath for uint256;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    modifier notBlackListed() {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function initialize(\n        IPrimexDNS _primexDNS,\n        IERC20 _pmx,\n        ITraderBalanceVault _traderBalanceVault,\n        address _registry,\n        address _treasury,\n        uint256 _reinvestmentRate,\n        uint256 _reinvestmentDuration,\n        IWhiteBlackList _whiteBlackList\n    ) external override initializer {\n        _require(\n            IERC165Upgradeable(address(_pmx)).supportsInterface(type(IERC20).interfaceId) &&\n                IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(_treasury).supportsInterface(type(ITreasury).interfaceId) &&\n                IERC165Upgradeable(address(_primexDNS)).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165Upgradeable(address(_traderBalanceVault)).supportsInterface(\n                    type(ITraderBalanceVault).interfaceId\n                ) &&\n                IERC165Upgradeable(address(_whiteBlackList)).supportsInterface(type(IWhiteBlackList).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        _require(_reinvestmentRate <= WadRayMath.WAD, Errors.INVALID_PERCENT_NUMBER.selector);\n        treasury = _treasury;\n        pmx = _pmx;\n        primexDNS = _primexDNS;\n        traderBalanceVault = _traderBalanceVault;\n        registry = _registry;\n        whiteBlackList = _whiteBlackList;\n        reinvestmentRate = _reinvestmentRate;\n        reinvestmentDuration = _reinvestmentDuration;\n        __Pausable_init();\n        __ERC165_init();\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function updateBucketReward(string memory _bucketName, uint256 _pmxRewardAmount) external override {\n        _require(address(primexDNS) == msg.sender, Errors.FORBIDDEN.selector);\n        buckets[_bucketName].totalPmxReward = _pmxRewardAmount;\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function addPoints(\n        string memory _bucketName,\n        address _user,\n        uint256 _miningAmount,\n        uint256 _maxStabilizationPeriodEnd,\n        uint256 _maxPeriodTime,\n        uint256 _currentTimestamp\n    ) external override {\n        _require(primexDNS.getBucketAddress(_bucketName) == msg.sender, Errors.FORBIDDEN.selector);\n        uint256 points = _calculatePoints(_miningAmount, _maxStabilizationPeriodEnd, _maxPeriodTime, _currentTimestamp);\n        buckets[_bucketName].totalPoints += points;\n        buckets[_bucketName].lendersInfo[_user].points += points;\n        buckets[_bucketName].lendersInfo[_user].depositedAmount += _miningAmount;\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function removePoints(string memory _bucketName, address _user, uint256 _amount) external override {\n        (address bucketAddress, , , ) = primexDNS.buckets(_bucketName);\n        _require(bucketAddress == msg.sender, Errors.FORBIDDEN.selector);\n        LenderInfo storage userInfo = buckets[_bucketName].lendersInfo[_user];\n        if (userInfo.depositedAmount == _amount || _amount == type(uint256).max) {\n            buckets[_bucketName].totalPoints -= userInfo.points;\n            delete buckets[_bucketName].lendersInfo[_user];\n            delete extraRewards[_user][_bucketName];\n            return;\n        }\n        _require(userInfo.depositedAmount > _amount, Errors.ATTEMPT_TO_WITHDRAW_MORE_THAN_DEPOSITED.selector);\n\n        uint256 multiplier = _amount.wdiv(userInfo.depositedAmount);\n        uint256 removedPoints = userInfo.points.wmul(multiplier);\n\n        buckets[_bucketName].totalPoints -= removedPoints;\n        userInfo.points -= removedPoints;\n        userInfo.depositedAmount -= _amount;\n        if (extraRewards[_user][_bucketName] > 0) {\n            extraRewards[_user][_bucketName] -= extraRewards[_user][_bucketName].wmul(multiplier);\n        }\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function claimReward(string memory _bucketName) external override nonReentrant notBlackListed {\n        (address bucketAddress, , , ) = primexDNS.buckets(_bucketName);\n        _require(IBucket(bucketAddress).isBucketStable(), Errors.BUCKET_IS_NOT_STABLE.selector);\n        uint256 reward = _calculateRewardAndUpdateState(_bucketName, msg.sender, WadRayMath.WAD);\n        _claimReward(reward, msg.sender, bucketAddress);\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function reinvest(\n        string memory _bucketFrom,\n        string memory _bucketTo,\n        address _user,\n        bool _isBucketToLaunched,\n        uint256 _bucketFromLiquidityMiningDeadline\n    ) external override {\n        address bucketFromAddress = primexDNS.getBucketAddress(_bucketFrom);\n        _require(bucketFromAddress == msg.sender, Errors.FORBIDDEN.selector);\n        // _bucketTo was checked in _bucketFrom\n        _require(\n            block.timestamp <= _bucketFromLiquidityMiningDeadline + reinvestmentDuration,\n            Errors.DEADLINE_IS_PASSED.selector\n        );\n        uint256 reward = _calculateRewardAndUpdateState(_bucketFrom, _user, reinvestmentRate);\n\n        if (_isBucketToLaunched) {\n            _claimReward(reward, _user, bucketFromAddress);\n        } else {\n            extraRewards[_user][_bucketTo] += reward;\n        }\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function withdrawPmxByAdmin(string calldata _bucketFrom) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        uint256 currentTimestamp = block.timestamp;\n        (address bucketAddress, , , ) = primexDNS.buckets(_bucketFrom);\n        IBucket.LiquidityMiningParams memory lmParams = IBucket(bucketAddress).getLiquidityMiningParams();\n        _require(\n            IBucket(bucketAddress).isWithdrawAfterDelistingAvailable() ||\n                (currentTimestamp > (lmParams.deadlineTimestamp + reinvestmentDuration) && !lmParams.isBucketLaunched),\n            Errors.WITHDRAW_PMX_BY_ADMIN_FORBIDDEN.selector\n        );\n        // Overflow is not possible because withdrawnRewards is a sum of rewards, where\n        // reward is the quotient of dividing (totalPmxReward*user points)/totalPoints\n        // and additionally it is reduced by reinvestmentRate which is less than 1.\n        // There is no setter for reinvestmentRate for now.\n        uint256 amountToWithdraw = buckets[_bucketFrom].totalPmxReward - buckets[_bucketFrom].withdrawnRewards;\n\n        _require(amountToWithdraw != 0, Errors.ZERO_AMOUNT.selector);\n        buckets[_bucketFrom].withdrawnRewards = buckets[_bucketFrom].totalPmxReward;\n        pmx.transfer(treasury, amountToWithdraw);\n        emit WithdrawPmxByAdmin(amountToWithdraw);\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function getLenderInfo(\n        string calldata _bucketName,\n        address _lender,\n        uint256 _timestamp\n    )\n        external\n        view\n        override\n        returns (uint256 amountInMining, uint256 currentPercent, RewardsInPMX memory rewardsInPMX)\n    {\n        LenderInfo storage lenderInfo = buckets[_bucketName].lendersInfo[_lender];\n        amountInMining = lenderInfo.depositedAmount;\n        rewardsInPMX.extraReward = extraRewards[_lender][_bucketName];\n\n        (address bucketAddress, , , ) = primexDNS.buckets(_bucketName);\n        // solhint-disable-next-line var-name-mixedcase\n        IBucket.LiquidityMiningParams memory LMparams = IBucket(bucketAddress).getLiquidityMiningParams();\n\n        if (buckets[_bucketName].totalPoints == 0) {\n            return (amountInMining, currentPercent, rewardsInPMX);\n        }\n\n        currentPercent = lenderInfo.points.wdiv(buckets[_bucketName].totalPoints);\n        uint256 maxExpectedPoints;\n        uint256 minExpectedPoints;\n        uint256 multiplier = WadRayMath.WAD;\n\n        if (_timestamp > LMparams.deadlineTimestamp && !LMparams.isBucketLaunched) {\n            maxExpectedPoints = buckets[_bucketName].totalPoints;\n            minExpectedPoints = buckets[_bucketName].totalPoints;\n            multiplier = reinvestmentRate;\n        } else if (\n            LMparams.isBucketLaunched || LMparams.accumulatingAmount <= IBucket(bucketAddress).availableLiquidity()\n        ) {\n            maxExpectedPoints = buckets[_bucketName].totalPoints;\n            minExpectedPoints = buckets[_bucketName].totalPoints;\n        } else {\n            uint256 tokensLeft = LMparams.accumulatingAmount - IBucket(bucketAddress).availableLiquidity();\n            maxExpectedPoints =\n                buckets[_bucketName].totalPoints +\n                _calculatePoints(tokensLeft, LMparams.maxStabilizationEndTimestamp, LMparams.maxDuration, _timestamp);\n\n            minExpectedPoints =\n                buckets[_bucketName].totalPoints +\n                _calculatePoints(tokensLeft, LMparams.stabilizationDuration, LMparams.maxDuration, 0);\n        }\n        uint256 pointsInPMX = lenderInfo.points * buckets[_bucketName].totalPmxReward;\n        rewardsInPMX.minReward = (pointsInPMX / maxExpectedPoints).wmul(multiplier);\n        rewardsInPMX.maxReward = (pointsInPMX / minExpectedPoints).wmul(multiplier);\n\n        return (amountInMining, currentPercent, rewardsInPMX);\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function getBucketInfo(\n        string calldata _bucketName\n    ) external view override returns (uint256 totalPmxReward, uint256 withdrawnRewards, uint256 totalPoints) {\n        return (\n            buckets[_bucketName].totalPmxReward,\n            buckets[_bucketName].withdrawnRewards,\n            buckets[_bucketName].totalPoints\n        );\n    }\n\n    /**\n     * @inheritdoc ILiquidityMiningRewardDistributor\n     */\n    function getLenderAmountInMining(\n        string calldata _bucketName,\n        address _lender\n    ) external view override returns (uint256) {\n        return buckets[_bucketName].lendersInfo[_lender].depositedAmount;\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(ILiquidityMiningRewardDistributor).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Calculates the reward and updates the state for a user in a specific bucket.\n     * @param _bucketName The name of the bucket.\n     * @param _user The address of the user.\n     * @param _multiplicator The multiplicator in WAD format to be applied to the reward calculation.\n     * @return reward The calculated reward amount.\n     */\n    function _calculateRewardAndUpdateState(\n        string memory _bucketName,\n        address _user,\n        uint256 _multiplicator\n    ) internal returns (uint256 reward) {\n        reward =\n            (buckets[_bucketName].lendersInfo[_user].points * buckets[_bucketName].totalPmxReward) /\n            buckets[_bucketName].totalPoints;\n        reward = reward.wmul(_multiplicator);\n\n        delete buckets[_bucketName].lendersInfo[_user];\n        buckets[_bucketName].withdrawnRewards += reward;\n\n        reward += extraRewards[_user][_bucketName];\n        delete extraRewards[_user][_bucketName];\n    }\n\n    /**\n     * @notice Claims the specified reward amount for a user from a specific bucket.\n     * @param _reward The amount of reward to be claimed.\n     * @param _user The address of the user.\n     * @param _bucket The address of the bucket.\n     */\n    function _claimReward(uint256 _reward, address _user, address _bucket) internal whenNotPaused {\n        // transfer rewards on the balance in traderBalanceVault\n        pmx.transfer(address(traderBalanceVault), _reward);\n        traderBalanceVault.topUpAvailableBalance(_user, address(pmx), _reward);\n        emit ClaimedReward(_user, _bucket, _reward);\n    }\n\n    /**\n     * @notice Calculates the mining points based on params provided.\n     * @param _depositedAmount The amount of tokens deposited by the user.\n     * @param _stabilizationEndTimestamp The timestamp when stabilization period ends.\n     * @param _maxDuration The maximum duration.\n     * @param _currentTimestamp The current timestamp.\n     * @return The calculated mining points.\n     */\n    function _calculatePoints(\n        uint256 _depositedAmount,\n        uint256 _stabilizationEndTimestamp,\n        uint256 _maxDuration,\n        uint256 _currentTimestamp\n    ) private pure returns (uint256) {\n        return (_depositedAmount * (_stabilizationEndTimestamp - _currentTimestamp)).wdiv(_maxDuration);\n    }\n}\n"
    },
    "contracts/LiquidityMiningRewardDistributor/LiquidityMiningRewardDistributorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {ILiquidityMiningRewardDistributorStorage, IPrimexDNS, ITraderBalanceVault, IERC20} from \"./ILiquidityMiningRewardDistributorStorage.sol\";\n\ncontract LiquidityMiningRewardDistributorStorage is\n    ILiquidityMiningRewardDistributorStorage,\n    PausableUpgradeable,\n    ERC165Upgradeable,\n    ReentrancyGuardUpgradeable\n{\n    IPrimexDNS public override primexDNS;\n    IERC20 public override pmx;\n    ITraderBalanceVault public override traderBalanceVault;\n    address public override registry;\n    address public treasury;\n    uint256 public override reinvestmentRate;\n    uint256 public override reinvestmentDuration;\n    mapping(address => mapping(string => uint256)) public override extraRewards;\n    IWhiteBlackList internal whiteBlackList;\n    // internal because we can't create getter for storage mapping inside structure\n    // Mapping from bucket name => BucketInfo\n    mapping(string => BucketInfo) internal buckets;\n}\n"
    },
    "contracts/mocks/ArbGasInfoMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\ncontract ArbGasInfoMock {\n    uint256 public l1GasPrice;\n\n    // solhint-disable-next-line comprehensive-interface\n    function getL1BaseFeeEstimate() external view returns (uint256) {\n        return l1GasPrice;\n    }\n\n    // solhint-disable-next-line comprehensive-interface\n    function setL1BaseFeeEstimate(uint256 _newL1GasPrice) external {\n        l1GasPrice = _newL1GasPrice;\n    }\n}\n"
    },
    "contracts/mocks/AttackerBucket.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IPToken} from \"../PToken/IPToken.sol\";\nimport {IAttackerBucket} from \"./mocksInterfaces/IAttackerBucket.sol\";\n\ncontract AttackerBucket is IAttackerBucket, IERC165 {\n    string public name;\n    IPToken public pToken;\n\n    function setName(string calldata _name) external override {\n        name = _name;\n    }\n\n    function setPTokenAddress(IPToken _pToken) external override {\n        pToken = _pToken;\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function supportsInterface(bytes4) public view virtual override returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/mocks/BucketMock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\n\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IDebtToken} from \"../DebtToken/IDebtToken.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IPToken} from \"../PToken/IPToken.sol\";\nimport {IReserve} from \"../Reserve/IReserve.sol\";\nimport {IBucketMock} from \"./mocksInterfaces/IBucketMock.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {ILiquidityMiningRewardDistributor} from \"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\";\nimport {IInterestRateStrategy} from \"../interfaces/IInterestRateStrategy.sol\";\nimport {ISwapManager} from \"../interfaces/ISwapManager.sol\";\n\ncontract BucketMock is IBucket, IERC165, IBucketMock {\n    IDebtToken public override debtToken;\n    IPToken public override pToken;\n    bool public override isActive;\n    bool public override isDelisted;\n    IWhiteBlackList public whiteBlackList;\n    uint256 public normalizedIncome = 1e28;\n    // solhint-disable-next-line var-name-mixedcase\n    LiquidityMiningParams private LMparams;\n    // default true, to pass tests\n    bool private isClaimable = true;\n\n    function setInterestRateStrategy(address _interestRateStrategy) external override {}\n\n    function batchDecreaseTradersDebt(\n        address[] memory _traders,\n        uint256[] memory _debtsToBurn,\n        address _traderBalanceVault,\n        uint256 _totalProfit,\n        uint256 _permanentLossAmount,\n        uint256 _length\n    ) external override {}\n\n    function getNormalizedIncome() external view override returns (uint256) {\n        return normalizedIncome;\n    }\n\n    //DebtToken\n    function setDebtToken(address _debtToken) public override {\n        debtToken = IDebtToken(_debtToken);\n    }\n\n    function mintDebtToken(address _trader, uint256 _amount, uint256 _index) public override {\n        debtToken.mint(_trader, _amount, _index);\n    }\n\n    function burnDebtToken(address _trader, uint256 _amount, uint256 _index) public override {\n        debtToken.burn(_trader, _amount, _index);\n    }\n\n    function setVariableBorrowIndex(uint128 _variableBorrowIndex) public override {\n        variableBorrowIndex = _variableBorrowIndex;\n    }\n\n    //PToken\n    function setPToken(address _pToken) public override {\n        pToken = IPToken(_pToken);\n    }\n\n    function setWhiteBlackList(address _whiteBlackList) public override {\n        whiteBlackList = IWhiteBlackList(_whiteBlackList);\n    }\n\n    function mintPToken(address _trader, uint256 _amount, uint256 _index) public override {\n        pToken.mint(_trader, _amount, _index);\n    }\n\n    function burnPToken(address _trader, uint256 _amount, uint256 _index) public override {\n        pToken.burn(_trader, _amount, _index);\n    }\n\n    function setLiquidityIndex(uint128 _liquidityIndex) public override {\n        liquidityIndex = _liquidityIndex;\n    }\n\n    function setNormalizedIncome(uint256 _normalizedIncome) public override {\n        normalizedIncome = _normalizedIncome;\n    }\n\n    //original methods\n    /* solhint-disable no-unused-vars */\n    string public override name;\n    address public override registry;\n    IPrimexDNS internal dns;\n    IPositionManager public override positionManager;\n    IPriceOracle internal priceOracle;\n    IERC20Metadata public override borrowedAsset;\n    uint256 public override feeBuffer;\n    uint256 public override withdrawalFeeRate;\n    // bar = borrowing annual rate (originally APR)\n    uint128 public override bar;\n    // lar = lending annual rate (originally APY)\n    uint128 public override lar;\n    uint128 public override estimatedBar;\n    uint128 public override estimatedLar;\n    uint128 public override liquidityIndex = 1e27;\n    uint128 public override variableBorrowIndex = 1e27;\n    uint256 public override maxTotalDeposit;\n    mapping(address => Asset) public override allowedAssets;\n\n    function initialize(ConstructorParams memory _params, address _registry) external override {}\n\n    function removeAsset(address _assetToDelete) external override {}\n\n    function setReserveRate(uint256 _fee) external override {}\n\n    function setFeeBuffer(uint256 _feeBuffer) external override {}\n\n    function setMaxTotalDeposit(uint256 _maxTotalDeposit) external override {}\n\n    function setWithdrawalFee(uint256 _withdrawalFee) external override {}\n\n    function setBarCalculationParams(bytes memory _params) external override {}\n\n    function withdrawAfterDelisting(uint256 _amount) external override {}\n\n    function receiveDeposit(\n        address _pTokenReceiver,\n        uint256 _amount,\n        uint256 _duration,\n        string memory _bucketFrom\n    ) external override {}\n\n    function depositFromBucket(\n        string calldata _bucketTo,\n        ISwapManager _swapManager,\n        PrimexPricingLibrary.Route[] calldata routes,\n        uint256 _amountOutMin\n    ) external override {}\n\n    function returnLiquidityFromAaveToBucket() external override {}\n\n    function setActive(bool _active) external override returns (bool) {\n        isActive = _active;\n        return _active;\n    }\n\n    function setDelisted(bool _delisted) external override returns (bool) {\n        isDelisted = _delisted;\n        return _delisted;\n    }\n\n    function deposit(address _pTokenReceiver, uint256 _amount) external override {}\n\n    function withdraw(address _borrowAssetReceiver, uint256 _amount) external override {}\n\n    function increaseDebt(address _trader, uint256 _amount, address _to) external override {}\n\n    function decreaseTraderDebt(\n        address _trader,\n        uint256 _debtToBurn,\n        address _traderBalanceVault,\n        uint256 _profitToTrader,\n        uint256 _permanentLossAmount\n    ) external override {}\n\n    function setLiquidityMiningParams(LiquidityMiningParams memory _newLMparams) external override {\n        LMparams = _newLMparams;\n    }\n\n    function setCanClaimReward(bool _isClaimable) external override {\n        isClaimable = _isClaimable;\n    }\n\n    function isDeprecated() external view override returns (bool) {}\n\n    function isWithdrawAfterDelistingAvailable() external view override returns (bool) {}\n\n    function getLiquidityMiningParams() external view override returns (LiquidityMiningParams memory) {\n        return LMparams;\n    }\n\n    function isBucketStable() external view override returns (bool) {\n        return isClaimable;\n    }\n\n    function permanentLoss() external view override returns (uint256) {}\n\n    function interestRateStrategy() external view override returns (IInterestRateStrategy) {}\n\n    function maxAssetLeverage(address _asset) external pure override returns (uint256) {\n        _asset = address(0);\n        return 1;\n    }\n\n    function getNormalizedVariableDebt() external pure override returns (uint256) {\n        return 1;\n    }\n\n    function getAllowedAssets() external pure override returns (address[] memory) {\n        address[] memory returnValue = new address[](1);\n        return returnValue;\n    }\n\n    function addAsset(address _newAsset) public override {}\n\n    function paybackPermanentLoss(uint256 amount) public override {}\n\n    function permanentLossScaled() public view override returns (uint256) {}\n\n    function reserve() public view override returns (IReserve) {}\n\n    /// @notice Interface checker\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IBucket).interfaceId || _interfaceId == type(IERC165).interfaceId;\n    }\n\n    function availableLiquidity() public pure override returns (uint256) {\n        return 1;\n    }\n\n    /* solhint-enable no-unused-vars */\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IERC20Mock} from \"../interfaces/IERC20Mock.sol\";\n\n// mock class using ERC20\ncontract ERC20Mock is ERC20, Ownable, IERC20Mock {\n    uint8 public dec;\n    bool public isTimeLimitedMinting;\n    mapping(address => uint256) public timeToUnlockMinting;\n    uint256 public immutable mintingAmount;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address[] memory _initialAccounts,\n        uint256[] memory _initialBalances,\n        uint256 _mintingAmount\n    ) ERC20(_name, _symbol) {\n        require(\n            _initialAccounts.length == _initialBalances.length,\n            \"ERC20Mock::constructor:number of initial accounts and balances does not match\"\n        );\n        for (uint256 i; i < _initialAccounts.length; i++) {\n            _mint(_initialAccounts[i], _initialBalances[i]);\n        }\n        dec = _decimals;\n        mintingAmount = _mintingAmount;\n    }\n\n    function setMintTimeLimit(bool _isLimited) external override onlyOwner {\n        isTimeLimitedMinting = _isLimited;\n    }\n\n    function mint(address _account, uint256 _amount) public override {\n        if (isTimeLimitedMinting) {\n            // slither-disable-next-line timestamp\n            require(timeToUnlockMinting[msg.sender] <= block.timestamp, \"mint tokens possible once a day\");\n            timeToUnlockMinting[msg.sender] = block.timestamp + 1 days;\n            _mint(msg.sender, mintingAmount);\n        } else {\n            _mint(_account, _amount);\n        }\n    }\n\n    function burn(uint256 _amount) public override {\n        _burn(msg.sender, _amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return dec;\n    }\n}\n"
    },
    "contracts/mocks/MaliciousDexMock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IMaliciousDexMock} from \"./mocksInterfaces/IMaliciousDexMock.sol\";\n\ncontract MaliciousDexMock is IMaliciousDexMock {\n    // Mock of possible malicious dex, that returns value but doesn't swap anything\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256,\n        address[] calldata,\n        address,\n        uint256\n    ) external virtual override returns (uint256[] memory amounts) {\n        amounts = new uint256[](2);\n        amounts[0] = amountIn;\n        amounts[1] = 1 ether;\n    }\n}\n"
    },
    "contracts/mocks/MockNearestSearch.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {FeeExecutor} from \"../BonusExecutor/FeeExecutor.sol\";\nimport {IPMXBonusNFT} from \"../PMXBonusNFT/IPMXBonusNFT.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IMockNearestSearch} from \"./mocksInterfaces/IMockNearestSearch.sol\";\n\ncontract MockNearestSearch is IMockNearestSearch, FeeExecutor {\n    function initialize(\n        IPMXBonusNFT _nft,\n        address _registry,\n        address _primexDNS,\n        IWhiteBlackList _whiteBlackList\n    ) external override initializer {\n        __FeeExecutor_init(_nft, _registry, _primexDNS, _whiteBlackList);\n    }\n\n    function setIndexes(uint256[] memory _timestamps, uint256[] memory _indexes, address _bucket) external override {\n        for (uint256 i; i < _timestamps.length; i++) {\n            indexes[_bucket][_timestamps[i]] = _indexes[i];\n        }\n    }\n\n    function activateBonus(uint256, uint256, address, address) external pure override {}\n\n    function updateBonus(uint256) external pure override {}\n\n    function claim(uint256, uint256) external pure override {}\n\n    function searchNearestIndex(\n        uint256 _bonusDeadline,\n        uint256[] memory _timetamps,\n        uint256 _currentIndex,\n        address _bucket\n    ) public override returns (uint256) {\n        updatedTimestamps[_bucket] = _timetamps;\n        return _searchApproxIndex(_bonusDeadline, _currentIndex, _bucket);\n    }\n\n    function updateBonus(address, uint256, address, uint256) public pure override {}\n\n    function getAccumulatedAmount(address, uint256) public pure override returns (uint256) {}\n}\n"
    },
    "contracts/mocks/mocksInterfaces/IAttackerBucket.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IPToken} from \"../../PToken/IPToken.sol\";\n\ninterface IAttackerBucket {\n    function setName(string calldata _name) external;\n\n    function setPTokenAddress(IPToken _pToken) external;\n}\n"
    },
    "contracts/mocks/mocksInterfaces/IBucketMock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IBucketStorage} from \"../../Bucket/IBucketStorage.sol\";\n\ninterface IBucketMock {\n    function setDebtToken(address _debtToken) external;\n\n    function mintDebtToken(address _trader, uint256 _amount, uint256 _index) external;\n\n    function burnDebtToken(address _trader, uint256 _amount, uint256 _index) external;\n\n    function setVariableBorrowIndex(uint128 _variableBorrowIndex) external;\n\n    function setPToken(address _pToken) external;\n\n    function mintPToken(address _trader, uint256 _amount, uint256 _index) external;\n\n    function burnPToken(address _trader, uint256 _amount, uint256 _index) external;\n\n    function setLiquidityIndex(uint128 _liquidityIndex) external;\n\n    function setNormalizedIncome(uint256 _normalizedIncome) external;\n\n    function setWhiteBlackList(address _whiteBlackList) external;\n\n    function setActive(bool _active) external returns (bool);\n\n    function setDelisted(bool _delisted) external returns (bool);\n\n    function setLiquidityMiningParams(IBucketStorage.LiquidityMiningParams memory _newLMparams) external;\n\n    function setCanClaimReward(bool _isClaimable) external;\n}\n"
    },
    "contracts/mocks/mocksInterfaces/IMaliciousDexMock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IMaliciousDexMock {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256,\n        address[] calldata,\n        address,\n        uint256\n    ) external returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/mocks/mocksInterfaces/IMockNearestSearch.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IPMXBonusNFT} from \"../../PMXBonusNFT/IPMXBonusNFT.sol\";\nimport {IWhiteBlackList} from \"../../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\n\ninterface IMockNearestSearch {\n    function setIndexes(uint256[] memory _timestamps, uint256[] memory _indexes, address _bucket) external;\n\n    function searchNearestIndex(\n        uint256 _bonusDeadline,\n        uint256[] memory _timetamps,\n        uint256 _currentIndex,\n        address _bucket\n    ) external returns (uint256);\n}\n"
    },
    "contracts/mocks/PrimexPricingLibraryMock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {IPrimexPricingLibraryMock} from \"../interfaces/IPrimexPricingLibraryMock.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\n\nimport \"../libraries/Errors.sol\";\n\ncontract PrimexPricingLibraryMock is IPrimexPricingLibraryMock {\n    using WadRayMath for uint256;\n\n    function getAmountOut(PrimexPricingLibrary.AmountParams memory _params) public override returns (uint256) {\n        return PrimexPricingLibrary.getAmountOut(_params);\n    }\n\n    function getDepositAmountInBorrowed(\n        PrimexPricingLibrary.AmountParams memory _params,\n        bool _isThirdAsset,\n        address _priceOracle\n    ) public override returns (uint256) {\n        return PrimexPricingLibrary.getDepositAmountInBorrowed(_params, _isThirdAsset, _priceOracle);\n    }\n\n    function multiSwap(\n        PrimexPricingLibrary.MultiSwapParams memory _params,\n        uint256 _oracleTolerableLimit,\n        address _primexDNS,\n        address _priceOracle,\n        bool _needCheck\n    ) public override returns (uint256) {\n        return PrimexPricingLibrary.multiSwap(_params, _oracleTolerableLimit, _primexDNS, _priceOracle, _needCheck);\n    }\n\n    function getAmountIn(PrimexPricingLibrary.AmountParams memory _params) public override returns (uint256) {\n        return PrimexPricingLibrary.getAmountIn(_params);\n    }\n\n    function getOracleAmountsOut(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountAssetA,\n        address _priceOracle\n    ) public view override returns (uint256) {\n        return PrimexPricingLibrary.getOracleAmountsOut(_tokenA, _tokenB, _amountAssetA, _priceOracle);\n    }\n\n    function getLiquidationPrice(\n        address _bucket,\n        address _positionAsset,\n        uint256 _positionAmount,\n        uint256 _positionDebt\n    ) public view override returns (uint256) {\n        return PrimexPricingLibrary.getLiquidationPrice(_bucket, _positionAsset, _positionAmount, _positionDebt);\n    }\n\n    /**\n     * @notice Calculates the liquidation price for a given order.\n     * @dev liquidationPrice = (feeBuffer * limitPrice * (leverage - 1)) /\n     * ((1 - securityBuffer) * (1 - oracleTolerableLimit) * (1 - priceDrop) * leverage)\n     * @param _bucket The address of the bucket.\n     * @param _positionAsset The address of the position asset.\n     * @param _limitPrice The limit price for the order.\n     * @param _leverage The leverage in WAD format for the order.\n     * @return The liquidation price calculated.\n     */\n    function getLiquidationPriceByOrder(\n        address _bucket,\n        address _positionAsset,\n        uint256 _limitPrice,\n        uint256 _leverage\n    ) public view override returns (uint256) {\n        _require(_positionAsset != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        if (_leverage == WadRayMath.WAD) return 0;\n        PrimexPricingLibrary.LiquidationPriceData memory data;\n        data.bucket = IBucket(_bucket);\n\n        (, bool tokenAllowed) = data.bucket.allowedAssets(_positionAsset);\n        _require(tokenAllowed, Errors.TOKEN_NOT_SUPPORTED.selector);\n\n        data.positionManager = data.bucket.positionManager();\n        data.priceOracle = data.positionManager.priceOracle();\n        data.borrowedAsset = data.bucket.borrowedAsset();\n\n        uint256 numerator = (data.bucket.feeBuffer()).wmul(_leverage - WadRayMath.WAD);\n        uint256 denominator = (WadRayMath.WAD - data.positionManager.securityBuffer())\n            .wmul(\n                WadRayMath.WAD -\n                    data.positionManager.getOracleTolerableLimit(_positionAsset, address(data.borrowedAsset))\n            )\n            .wmul(WadRayMath.WAD - data.priceOracle.getPairPriceDrop(_positionAsset, address(data.borrowedAsset)))\n            .wmul(_leverage);\n\n        return numerator.wdiv(denominator).wmul(_limitPrice);\n    }\n}\n"
    },
    "contracts/mocks/TokenTransfersLibraryMock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nlibrary TokenTransfersLibraryMock {\n    function doTransferIn(address, address, uint256) public pure returns (uint256) {}\n\n    function doTransferFromTo(address, address, address, uint256) public pure returns (uint256) {}\n\n    function doTransferOut(address, address, uint256) public pure {}\n}\n"
    },
    "contracts/mocks/upgradeMocks/ActivityRewardDistributorV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ActivityRewardDistributor} from \"../../ActivityRewardDistributor/ActivityRewardDistributor.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract ActivityRewardDistributorV2 is IUpgradeInterface, ActivityRewardDistributor {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"ActivityRewardDistributorV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/BatchManagerV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {BatchManager} from \"../../BatchManager.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\nimport {IPositionManager} from \"../../PositionManager/IPositionManager.sol\";\nimport {IPriceOracle} from \"../../PriceOracle/IPriceOracle.sol\";\nimport {IWhiteBlackList} from \"../../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\n\ncontract BatchManagerV2 is IUpgradeInterface, BatchManager {\n    uint256 public value;\n\n    constructor(\n        IPositionManager _positionManager,\n        IPriceOracle _priceOracle,\n        IWhiteBlackList _whiteBlackList,\n        address _registry\n    ) BatchManager(_positionManager, _priceOracle, _whiteBlackList, _registry) {}\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"BatchManagerV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/BucketV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {Bucket} from \"../../Bucket/Bucket.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract BucketV2 is IUpgradeInterface, Bucket {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"BucketV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/DebtTokenV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {DebtToken} from \"../../DebtToken/DebtToken.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract DebtTokenV2 is IUpgradeInterface, DebtToken {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"DebtTokenV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/DexAdapterV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {DexAdapter} from \"../../DexAdapter.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract DexAdapterV2 is IUpgradeInterface, DexAdapter {\n    uint256 public value;\n\n    constructor(address _registry) DexAdapter(_registry) {}\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"DexAdapterV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/EPMXTokenV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {EPMXToken} from \"../../EPMXToken.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract EPMXTokenV2 is IUpgradeInterface, EPMXToken {\n    uint256 public value;\n\n    constructor(address _recipient, address _registry) EPMXToken(_recipient, _registry) {}\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"EPMXTokenV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/FeeDecreaserV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {FeeDecreaser} from \"../../BonusExecutor/FeeDecreaser.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract FeeDecreaserV2 is IUpgradeInterface, FeeDecreaser {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"FeeDecreaserV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/InterestIncreaserV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {InterestIncreaser} from \"../../BonusExecutor/InterestIncreaser.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract InterestIncreaserV2 is IUpgradeInterface, InterestIncreaser {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"InterestIncreaserV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/IUpgradeInterface.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IUpgradeInterface {\n    function testUpgrade() external pure returns (string memory);\n\n    function setValue(uint256 _value) external;\n}\n"
    },
    "contracts/mocks/upgradeMocks/KeeperRewardDistributorV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {KeeperRewardDistributor} from \"../../KeeperRewardDistributor/KeeperRewardDistributor.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract KeeperRewardDistributorV2 is IUpgradeInterface, KeeperRewardDistributor {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"KeeperRewardDistributorV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/LimitOrderManagerV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport {LimitOrderManager} from \"../../LimitOrderManager/LimitOrderManager.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract LimitOrderManagerV2 is IUpgradeInterface, LimitOrderManager {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"LimitOrderManagerV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/LiquidityMiningRewardDistributorV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {LiquidityMiningRewardDistributor} from \"../../LiquidityMiningRewardDistributor/LiquidityMiningRewardDistributor.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract LiquidityMiningRewardDistributorV2 is IUpgradeInterface, LiquidityMiningRewardDistributor {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"LiquidityMiningRewardDistributorV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/PMXBonusNFTV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {PMXBonusNFT} from \"../../PMXBonusNFT/PMXBonusNFT.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract PMXBonusNFTV2 is IUpgradeInterface, PMXBonusNFT {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"PMXBonusNFTV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/PositionManagerV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {WadRayMath} from \"../../libraries/utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"../../libraries/PrimexPricingLibrary.sol\";\nimport {TokenTransfersLibrary} from \"../../libraries/TokenTransfersLibrary.sol\";\n\nimport \"../../Constants.sol\";\nimport \"../../PositionManager/PositionManagerStorage.sol\";\nimport {IPositionManager} from \"../../PositionManager/IPositionManager.sol\";\nimport {IConditionalClosingManager} from \"../../interfaces/IConditionalClosingManager.sol\";\nimport {ISpotTradingRewardDistributor} from \"../../SpotTradingRewardDistributor/ISpotTradingRewardDistributor.sol\";\nimport {IBucket} from \"../../Bucket/IBucket.sol\";\nimport {IPausable} from \"../../interfaces/IPausable.sol\";\nimport {IWhiteBlackList} from \"../../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IKeeperRewardDistributorStorage} from \"../../KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract PositionManagerV2 is IPositionManager, IUpgradeInterface, PositionManagerStorage {\n    using WadRayMath for uint256;\n    using PositionLibrary for PositionLibrary.Position;\n\n    uint256 public value;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function initialize(\n        address _registry,\n        address _primexDNS,\n        address payable _traderBalanceVault,\n        address _priceOracle,\n        address _keeperRewardDistributor,\n        address _whiteBlackList\n    ) external override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(_primexDNS).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165Upgradeable(_traderBalanceVault).supportsInterface(type(ITraderBalanceVault).interfaceId) &&\n                IERC165Upgradeable(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId) &&\n                IERC165Upgradeable(_keeperRewardDistributor).supportsInterface(\n                    type(IKeeperRewardDistributor).interfaceId\n                ) &&\n                IERC165Upgradeable(_whiteBlackList).supportsInterface(type(IWhiteBlackList).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = IAccessControl(_registry);\n        primexDNS = IPrimexDNS(_primexDNS);\n        traderBalanceVault = ITraderBalanceVault(_traderBalanceVault);\n        priceOracle = IPriceOracle(_priceOracle);\n        keeperRewardDistributor = IKeeperRewardDistributor(_keeperRewardDistributor);\n        whiteBlackList = IWhiteBlackList(_whiteBlackList);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __ERC165_init();\n    }\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"PositionManagerV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n\n    function setMaxPositionSize(\n        address _token0,\n        address _token1,\n        uint256 _amountInToken0,\n        uint256 _amountInToken1\n    ) external virtual override {}\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setDefaultOracleTolerableLimit(uint256 _percent) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(_percent <= WadRayMath.WAD, Errors.INVALID_PERCENT_NUMBER.selector);\n        defaultOracleTolerableLimit = _percent;\n        emit SetDefaultOracleTolerableLimit(_percent);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function doTransferOut(address _token, address _to, uint256 _amount) external override {\n        _onlyRole(BATCH_MANAGER_ROLE);\n        TokenTransfersLibrary.doTransferOut(_token, _to, _amount);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setSecurityBuffer(uint256 _newSecurityBuffer) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(_newSecurityBuffer < WadRayMath.WAD, Errors.INVALID_SECURITY_BUFFER.selector);\n        securityBuffer = _newSecurityBuffer;\n        emit SecurityBufferChanged(_newSecurityBuffer);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setMaintenanceBuffer(uint256 _newMaintenanceBuffer) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(\n            _newMaintenanceBuffer > 0 && _newMaintenanceBuffer < WadRayMath.WAD,\n            Errors.INVALID_MAINTENANCE_BUFFER.selector\n        );\n        maintenanceBuffer = _newMaintenanceBuffer;\n        emit MaintenanceBufferChanged(_newMaintenanceBuffer);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setOracleTolerableLimit(address _assetA, address _assetB, uint256 _percent) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        PositionLibrary.setOracleTolerableLimit(oracleTolerableLimits, _assetA, _assetB, _percent);\n        emit SetOracleTolerableLimit(_assetA, _assetB, _percent);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setOracleTolerableLimitMultiplier(uint256 newMultiplier) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(\n            newMultiplier >= WadRayMath.WAD && newMultiplier < 10 * WadRayMath.WAD,\n            Errors.WRONG_TRUSTED_MULTIPLIER.selector\n        );\n\n        oracleTolerableLimitMultiplier = newMultiplier;\n        emit OracleTolerableLimitMultiplierChanged(newMultiplier);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setMinPositionSize(uint256 _minPositionSize, address _minPositionAsset) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        minPositionSize = _minPositionSize;\n        minPositionAsset = _minPositionAsset;\n        emit MinPositionSizeAndAssetChanged(_minPositionSize, _minPositionAsset);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setKeeperRewardDistributor(IKeeperRewardDistributor _keeperRewardDistributor) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        _require(\n            IERC165Upgradeable(address(_keeperRewardDistributor)).supportsInterface(\n                type(IKeeperRewardDistributor).interfaceId\n            ),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        keeperRewardDistributor = _keeperRewardDistributor;\n        emit KeeperRewardDistributorChanged(address(_keeperRewardDistributor));\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function openPositionByOrder(\n        LimitOrderLibrary.OpenPositionByOrderParams calldata _params\n    ) external override whenNotPaused returns (uint256, uint256, uint256, uint256) {\n        _onlyRole(LOM_ROLE);\n        (PositionLibrary.Position memory newPosition, PositionLibrary.OpenPositionVars memory vars) = PositionLibrary\n            .createPositionByOrder(_params, priceOracle);\n        PositionLibrary.OpenPositionEventData memory posEventData = _openPosition(newPosition, vars);\n\n        PositionLibrary.Position memory position = positions[positions.length - 1];\n\n        _updateTraderActivity(_params.order.trader, position.positionAsset, position.positionAmount, position.bucket);\n\n        emit OpenPosition({\n            positionId: position.id,\n            trader: _params.order.trader,\n            openedBy: _params.sender,\n            position: position,\n            feeToken: _params.order.feeToken,\n            protocolFee: posEventData.protocolFee,\n            entryPrice: posEventData.entryPrice,\n            leverage: posEventData.leverage,\n            closeConditions: vars.closeConditions\n        });\n        return (\n            vars.borrowedAmount + position.depositAmountInSoldAsset,\n            position.positionAmount,\n            position.id,\n            posEventData.entryPrice\n        );\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function openPosition(\n        PositionLibrary.OpenPositionParams calldata _params\n    ) external payable override nonReentrant whenNotPaused {\n        _notBlackListed();\n        (PositionLibrary.Position memory newPosition, PositionLibrary.OpenPositionVars memory vars) = PositionLibrary\n            .createPosition(_params, primexDNS, priceOracle);\n        PositionLibrary.OpenPositionEventData memory posEventData = _openPosition(newPosition, vars);\n\n        PositionLibrary.Position memory position = positions[positions.length - 1];\n        _updateTraderActivity(msg.sender, position.positionAsset, position.positionAmount, position.bucket);\n\n        emit OpenPosition({\n            positionId: position.id,\n            trader: position.trader,\n            openedBy: position.trader,\n            position: position,\n            feeToken: _params.isProtocolFeeInPmx ? primexDNS.pmx() : NATIVE_CURRENCY,\n            protocolFee: posEventData.protocolFee,\n            entryPrice: posEventData.entryPrice,\n            leverage: posEventData.leverage,\n            closeConditions: vars.closeConditions\n        });\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function closePositionByCondition(\n        uint256 _id,\n        address _keeper,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _conditionIndex,\n        bytes calldata _ccmAdditionalParams,\n        PositionLibrary.CloseReason _closeReason\n    ) external override nonReentrant {\n        _require(_closeReason != PositionLibrary.CloseReason.CLOSE_BY_TRADER, Errors.FORBIDDEN.selector);\n        _notBlackListed();\n        uint256 initialGasleft = gasleft();\n        LimitOrderLibrary.Condition memory condition;\n        if (_conditionIndex < closeConditions[_id].length) condition = closeConditions[_id][_conditionIndex];\n        _closePosition(_id, _keeper, _routes, 0, condition, _ccmAdditionalParams, _closeReason, initialGasleft);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function updatePositionConditions(\n        uint256 _positionId,\n        LimitOrderLibrary.Condition[] calldata _closeConditions\n    ) external override nonReentrant {\n        _notBlackListed();\n        PositionLibrary.Position storage position = positions[positionIndexes[_positionId]];\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\n\n        if (keccak256(abi.encode(_closeConditions)) != keccak256(abi.encode(closeConditions[_positionId]))) {\n            position.setCloseConditions(closeConditions, _closeConditions, primexDNS);\n            position.updatedConditionsAt = block.timestamp;\n            emit UpdatePositionConditions({\n                positionId: _positionId,\n                trader: position.trader,\n                closeConditions: _closeConditions\n            });\n        }\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function increaseDeposit(\n        uint256 _positionId,\n        uint256 _amount,\n        address _asset,\n        bool _takeDepositFromWallet,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin\n    ) external override nonReentrant {\n        _notBlackListed();\n        PositionLibrary.Position storage position = positions[positionIndexes[_positionId]];\n        uint256 depositDelta = position.increaseDeposit(\n            PositionLibrary.IncreaseDepositParams({\n                amount: _amount,\n                asset: _asset,\n                takeDepositFromWallet: _takeDepositFromWallet,\n                routes: _routes,\n                primexDNS: primexDNS,\n                priceOracle: priceOracle,\n                traderBalanceVault: traderBalanceVault,\n                amountOutMin: _amountOutMin\n            })\n        );\n\n        emit IncreaseDeposit({\n            positionId: position.id,\n            trader: position.trader,\n            depositDelta: depositDelta,\n            scaledDebtAmount: position.scaledDebtAmount\n        });\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function decreaseDeposit(uint256 _positionId, uint256 _amount) external override nonReentrant whenNotPaused {\n        _notBlackListed();\n        PositionLibrary.Position storage position = positions[positionIndexes[_positionId]];\n        position.decreaseDeposit(\n            PositionLibrary.DecreaseDepositParams({\n                amount: _amount,\n                primexDNS: primexDNS,\n                priceOracle: priceOracle,\n                traderBalanceVault: traderBalanceVault,\n                pairPriceDrop: priceOracle.getPairPriceDrop(position.positionAsset, position.soldAsset),\n                securityBuffer: securityBuffer,\n                oracleTolerableLimit: getOracleTolerableLimit(position.positionAsset, position.soldAsset),\n                maintenanceBuffer: maintenanceBuffer\n            })\n        );\n        emit DecreaseDeposit({\n            positionId: position.id,\n            trader: position.trader,\n            depositDelta: _amount,\n            scaledDebtAmount: position.scaledDebtAmount\n        });\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function partiallyClosePosition(\n        uint256 _positionId,\n        uint256 _amount,\n        address _depositReceiver,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin\n    ) external override nonReentrant {\n        _notBlackListed();\n        _onlyExist(_positionId);\n        PositionLibrary.Position memory position = positions[positionIndexes[_positionId]];\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\n        _require(_amount < position.positionAmount, Errors.AMOUNT_IS_MORE_THAN_POSITION_AMOUNT.selector);\n        PositionLibrary.ScaledParams memory scaledParams;\n        scaledParams.borrowedAmountIsNotZero = position.scaledDebtAmount != 0;\n        scaledParams.decreasePercent = _amount.wdiv(position.positionAmount);\n        scaledParams.scaledDebtAmount = scaledParams.borrowedAmountIsNotZero\n            ? position.scaledDebtAmount.wmul(scaledParams.decreasePercent)\n            : 0;\n        scaledParams.depositDecrease = position.depositAmountInSoldAsset.wmul(scaledParams.decreasePercent);\n        LimitOrderLibrary.Condition memory condition;\n        PositionLibrary.ClosePositionEventData memory posEventData = position.closePosition(\n            PositionLibrary.ClosePositionParams({\n                closeAmount: _amount,\n                depositDecrease: scaledParams.depositDecrease,\n                scaledDebtAmount: scaledParams.scaledDebtAmount,\n                depositReceiver: _depositReceiver,\n                routes: _routes,\n                amountOutMin: _amountOutMin,\n                oracleTolerableLimit: scaledParams.borrowedAmountIsNotZero\n                    ? getOracleTolerableLimit(position.positionAsset, position.soldAsset)\n                    : 0,\n                primexDNS: primexDNS,\n                priceOracle: priceOracle,\n                traderBalanceVault: traderBalanceVault,\n                closeCondition: condition,\n                ccmAdditionalParams: \"\",\n                borrowedAmountIsNotZero: scaledParams.borrowedAmountIsNotZero,\n                pairPriceDrop: priceOracle.getPairPriceDrop(position.positionAsset, position.soldAsset),\n                securityBuffer: securityBuffer,\n                needOracleTolerableLimitCheck: scaledParams.borrowedAmountIsNotZero\n            }),\n            PositionLibrary.CloseReason.CLOSE_BY_TRADER\n        );\n        position.positionAmount -= _amount;\n        position.scaledDebtAmount -= scaledParams.scaledDebtAmount;\n        position.depositAmountInSoldAsset -= scaledParams.depositDecrease;\n        PrimexPricingLibrary.validateMinPositionSize(\n            minPositionSize,\n            minPositionAsset,\n            position.positionAmount,\n            position.positionAsset,\n            address(priceOracle)\n        );\n\n        positions[positionIndexes[_positionId]] = position;\n        emit PartialClosePosition({\n            positionId: _positionId,\n            trader: msg.sender,\n            bucketAddress: address(position.bucket),\n            soldAsset: position.soldAsset,\n            positionAsset: position.positionAsset,\n            decreasePositionAmount: _amount,\n            depositedAmount: position.depositAmountInSoldAsset,\n            scaledDebtAmount: position.scaledDebtAmount,\n            profit: posEventData.profit,\n            positionDebt: posEventData.debtAmount,\n            amountOut: posEventData.amountOut\n        });\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override {\n        _onlyRole(EMERGENCY_ADMIN);\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override {\n        _onlyRole(SMALL_TIMELOCK_ADMIN);\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function canBeClosed(\n        uint256 _positionId,\n        uint256 _conditionIndex,\n        bytes calldata _additionalParams\n    ) external override returns (bool) {\n        _require(\n            _conditionIndex < closeConditions[_positionId].length,\n            Errors.CONDITION_INDEX_IS_OUT_OF_BOUNDS.selector\n        );\n        LimitOrderLibrary.Condition storage condition = closeConditions[_positionId][_conditionIndex];\n        return\n            IConditionalClosingManager(primexDNS.cmTypeToAddress(condition.managerType)).canBeClosedBeforeSwap(\n                positions[positionIndexes[_positionId]],\n                condition.params,\n                _additionalParams\n            );\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setSpotTradingRewardDistributor(address _spotTradingRewardDistributor) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        spotTradingRewardDistributor = ISpotTradingRewardDistributor(_spotTradingRewardDistributor);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function deletePositions(\n        uint256[] calldata _ids,\n        address[] calldata _traders,\n        uint256 _length,\n        address _bucket\n    ) external override {\n        _onlyRole(BATCH_MANAGER_ROLE);\n        for (uint256 i; i < _length; i++) {\n            _onlyExist(_ids[i]);\n            _deletePosition(_ids[i], _bucket, _traders[i]);\n        }\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getPosition(uint256 _id) external view override returns (PositionLibrary.Position memory) {\n        _onlyExist(_id);\n        return positions[positionIndexes[_id]];\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getPositionByIndex(uint256 _index) external view override returns (PositionLibrary.Position memory) {\n        return positions[_index];\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getAllPositionsLength() external view override returns (uint256) {\n        return positions.length;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getTraderPositionsLength(address _trader) external view override returns (uint256) {\n        return traderPositionIds[_trader].length;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getBucketPositionsLength(address _bucket) external view override returns (uint256) {\n        return bucketPositionIds[_bucket].length;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getPositionDebt(uint256 _id) external view override returns (uint256) {\n        _onlyExist(_id);\n        return positions[positionIndexes[_id]].getDebt();\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function isPositionRisky(uint256 _id) external view override returns (bool) {\n        return healthPosition(_id) < WadRayMath.WAD;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function isDelistedPosition(uint256 _id) external view override returns (bool) {\n        _onlyExist(_id);\n        PositionLibrary.Position storage position = positions[positionIndexes[_id]];\n        return position.bucket == IBucket(address(0)) ? false : position.bucket.isDelisted();\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function closePosition(\n        uint256 _id,\n        address _depositReceiver,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin\n    ) public override nonReentrant {\n        _notBlackListed();\n        LimitOrderLibrary.Condition memory condition;\n        _closePosition(\n            _id,\n            _depositReceiver,\n            _routes,\n            _amountOutMin,\n            condition,\n            bytes(\"\"),\n            PositionLibrary.CloseReason.CLOSE_BY_TRADER,\n            0\n        );\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getOracleTolerableLimit(address assetA, address assetB) public view override returns (uint256) {\n        uint256 oracleTolerableLimit = oracleTolerableLimits[assetA][assetB];\n        return oracleTolerableLimit > 0 ? oracleTolerableLimit : defaultOracleTolerableLimit;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function healthPosition(uint256 _id) public view override returns (uint256) {\n        _onlyExist(_id);\n        PositionLibrary.Position storage position = positions[positionIndexes[_id]];\n        return\n            position.health(\n                priceOracle,\n                priceOracle.getPairPriceDrop(position.positionAsset, position.soldAsset),\n                securityBuffer,\n                getOracleTolerableLimit(position.positionAsset, position.soldAsset)\n            );\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getCloseCondition(\n        uint256 _positionId,\n        uint256 _index\n    ) public view override returns (LimitOrderLibrary.Condition memory) {\n        return closeConditions[_positionId][_index];\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getCloseConditions(\n        uint256 _positionId\n    ) public view override returns (LimitOrderLibrary.Condition[] memory) {\n        return closeConditions[_positionId];\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IPositionManager).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Opens a new position.\n     * @param _position The position data.\n     * @param _vars The variables for opening the position.\n     * @return posEventData The event data for the opened position.\n     */\n    function _openPosition(\n        PositionLibrary.Position memory _position,\n        PositionLibrary.OpenPositionVars memory _vars\n    ) internal returns (PositionLibrary.OpenPositionEventData memory) {\n        (\n            PositionLibrary.Position memory position,\n            PositionLibrary.OpenPositionEventData memory posEventData\n        ) = PositionLibrary.openPosition(\n                _position,\n                _vars,\n                PositionLibrary.PositionManagerParams({\n                    primexDNS: primexDNS,\n                    priceOracle: priceOracle,\n                    traderBalanceVault: traderBalanceVault,\n                    oracleTolerableLimitForThirdAsset: _vars.isThirdAsset\n                        ? getOracleTolerableLimit(_vars.depositData.depositAsset, _position.positionAsset)\n                        : 0,\n                    oracleTolerableLimit: _vars.needOracleTolerableLimitCheck\n                        ? getOracleTolerableLimit(_position.soldAsset, _position.positionAsset)\n                        : 0,\n                    minPositionSize: minPositionSize,\n                    minPositionAsset: minPositionAsset,\n                    maxPositionSize: maxPositionSize[_position.soldAsset][_position.positionAsset]\n                })\n            );\n\n        // create position and update indexes (by trader, by bucket)\n        position.id = positionsId;\n        positionsId++;\n\n        positions.push(position);\n        positionIndexes[position.id] = positions.length - 1;\n\n        traderPositionIds[position.trader].push(position.id);\n        traderPositionIndexes[position.id] = traderPositionIds[position.trader].length - 1;\n\n        bucketPositionIds[address(position.bucket)].push(position.id);\n        bucketPositionIndexes[position.id] = bucketPositionIds[address(position.bucket)].length - 1;\n\n        position.setCloseConditions(closeConditions, _vars.closeConditions, primexDNS);\n        return posEventData;\n    }\n\n    /**\n     * @dev delete position and update indexes (by trader, by bucket)\n     * can be simplified with EnumerableMap by OpenZeppelin\n     * @param _id the id of the position to be deleted\n     * @param _bucket the bucket of the position to be deleted\n     * @param _trader the trader of the position to be deleted\n     */\n    function _deletePosition(uint256 _id, address _bucket, address _trader) internal {\n        delete closeConditions[_id];\n\n        uint256 lastBucketPositionId = bucketPositionIds[_bucket][bucketPositionIds[_bucket].length - 1];\n        bucketPositionIds[_bucket][bucketPositionIndexes[_id]] = lastBucketPositionId;\n        bucketPositionIndexes[lastBucketPositionId] = bucketPositionIndexes[_id];\n        bucketPositionIds[_bucket].pop();\n        delete bucketPositionIndexes[_id];\n\n        uint256 lastTraderPositionId = traderPositionIds[_trader][traderPositionIds[_trader].length - 1];\n        traderPositionIds[_trader][traderPositionIndexes[_id]] = lastTraderPositionId;\n        traderPositionIndexes[lastTraderPositionId] = traderPositionIndexes[_id];\n        traderPositionIds[_trader].pop();\n        delete traderPositionIndexes[_id];\n\n        positions[positionIndexes[_id]] = positions[positions.length - 1];\n        positionIndexes[positions[positions.length - 1].id] = positionIndexes[_id];\n        positions.pop();\n        delete positionIndexes[_id];\n    }\n\n    /**\n     * @notice Close a position.\n     * @param _id The ID of the position to be closed.\n     * @param _depositReceiver The address to receive the deposit assets.\n     * @param _routes The trading routes to be used for swapping assets.\n     * @param _amountOutMin The minimum amount of output asset expected from the swaps.\n     * @param closeCondition The condition that must be satisfied to close the position.\n     * @param _ccmAdditionalParams Additional parameters for custom closing managers.\n     * @param _closeReason The reason for closing the position.\n     */\n    function _closePosition(\n        uint256 _id,\n        address _depositReceiver,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin,\n        LimitOrderLibrary.Condition memory closeCondition,\n        bytes memory _ccmAdditionalParams,\n        PositionLibrary.CloseReason _closeReason,\n        uint256 _initialGasLeft\n    ) internal {\n        _onlyExist(_id);\n        _require(_depositReceiver != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        ClosePositionVars memory vars;\n        vars.position = positions[positionIndexes[_id]];\n        vars.borrowedAmountIsNotZero = vars.position.scaledDebtAmount > 0;\n        // we don't check limit when the close reason is CLOSE_BY_TRADER AND a position is spot\n        vars.needOracleTolerableLimitCheck =\n            _closeReason != PositionLibrary.CloseReason.CLOSE_BY_TRADER ||\n            vars.borrowedAmountIsNotZero;\n\n        if (vars.needOracleTolerableLimitCheck) {\n            vars.oracleTolerableLimit = getOracleTolerableLimit(vars.position.positionAsset, vars.position.soldAsset);\n            if (registry.hasRole(TRUSTED_TOLERABLE_LIMIT_ROLE, msg.sender)) {\n                vars.oracleTolerableLimit = vars.oracleTolerableLimit.wmul(oracleTolerableLimitMultiplier);\n            }\n        }\n        PositionLibrary.ClosePositionParams memory _params = PositionLibrary.ClosePositionParams({\n            closeAmount: vars.position.positionAmount,\n            depositDecrease: vars.position.depositAmountInSoldAsset,\n            scaledDebtAmount: vars.position.scaledDebtAmount,\n            depositReceiver: _depositReceiver,\n            routes: _routes,\n            amountOutMin: _amountOutMin,\n            oracleTolerableLimit: vars.oracleTolerableLimit,\n            primexDNS: primexDNS,\n            priceOracle: priceOracle,\n            traderBalanceVault: traderBalanceVault,\n            closeCondition: closeCondition,\n            ccmAdditionalParams: _ccmAdditionalParams,\n            borrowedAmountIsNotZero: vars.borrowedAmountIsNotZero,\n            pairPriceDrop: priceOracle.getPairPriceDrop(vars.position.positionAsset, vars.position.soldAsset),\n            securityBuffer: securityBuffer,\n            needOracleTolerableLimitCheck: vars.needOracleTolerableLimitCheck\n        });\n        IKeeperRewardDistributorStorage.KeeperActionType actionType = vars\n            .position\n            .closePosition(_params, _closeReason)\n            .actionType;\n\n        _deletePosition(_id, address(vars.position.bucket), vars.position.trader);\n        if (\n            _closeReason != PositionLibrary.CloseReason.CLOSE_BY_TRADER &&\n            vars.position.updatedConditionsAt != block.timestamp\n        ) {\n            // to avoid abuse of the reward system, we will not pay the reward to\n            // the keeper if the position open in the same block as the open conditions change\n            keeperRewardDistributor.updateReward(\n                IKeeperRewardDistributor.UpdateRewardParams({\n                    keeper: _depositReceiver,\n                    positionAsset: vars.position.positionAsset,\n                    positionSize: vars.position.positionAmount,\n                    action: actionType,\n                    numberOfActions: 1,\n                    gasSpent: _initialGasLeft - gasleft(),\n                    decreasingCounter: new uint256[](0),\n                    routesLength: abi.encode(_routes).length\n                })\n            );\n        }\n    }\n\n    /**\n     * @notice Internal function to update trader activity.\n     * @dev This function updates the activity of a trader by calling the `updateTraderActivity` function\n     * @param trader The address of the trader whose activity is being updated.\n     * @param positionAsset The address of the position asset.\n     * @param positionSize The size of the position.\n     * @param bucket The bucket for which the trader's activity is being updated.\n     */\n    function _updateTraderActivity(\n        address trader,\n        address positionAsset,\n        uint256 positionSize,\n        IBucket bucket\n    ) internal {\n        // Tracks only spot trading activity.\n        if (\n            bucket == IBucket(address(0)) && spotTradingRewardDistributor != ISpotTradingRewardDistributor(address(0))\n        ) {\n            spotTradingRewardDistributor.updateTraderActivity(trader, positionAsset, positionSize);\n        }\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    function _onlyRole(bytes32 _role) internal view {\n        _require(registry.hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    function _notBlackListed() internal view {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n    }\n\n    /**\n     * @dev Modifier to check if a position exists.\n     * @param _id The ID of the position to check.\n     */\n    function _onlyExist(uint256 _id) internal view {\n        _require(\n            positions.length > 0 && _id == positions[positionIndexes[_id]].id,\n            Errors.POSITION_DOES_NOT_EXIST.selector\n        );\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/PriceOracleV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport {PriceOracle} from \"../../PriceOracle/PriceOracle.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract PriceOracleV2 is IUpgradeInterface, PriceOracle {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"PriceOracleV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/PrimexDNSV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {PrimexDNS} from \"../../PrimexDNS/PrimexDNS.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract PrimexDNSV2 is IUpgradeInterface, PrimexDNS {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"PrimexDNSV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/PTokenV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {PToken} from \"../../PToken/PToken.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract PTokenV2 is IUpgradeInterface, PToken {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"PTokenV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/ReferralProgramV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ReferralProgram} from \"../../ReferralProgram/ReferralProgram.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract ReferralProgramV2 is IUpgradeInterface, ReferralProgram {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"ReferralProgramV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/ReserveV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport {Reserve} from \"../../Reserve/Reserve.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract ReserveV2 is IUpgradeInterface, Reserve {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"ReserveV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/SpotTradingRewardDistributorV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport {SpotTradingRewardDistributor} from \"../../SpotTradingRewardDistributor/SpotTradingRewardDistributor.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract SpotTradingRewardDistributorV2 is IUpgradeInterface, SpotTradingRewardDistributor {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"SpotTradingRewardDistributorV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/SwapManagerV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {SwapManager} from \"../../SwapManager.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract SwapManagerV2 is IUpgradeInterface, SwapManager {\n    uint256 public value;\n\n    constructor(\n        address _registry,\n        address _primexDNS,\n        address payable _traderBalanceVault,\n        address _priceOracle,\n        address _whiteBlackList\n    ) SwapManager(_registry, _primexDNS, _traderBalanceVault, _priceOracle, _whiteBlackList) {}\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"SwapManagerV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/TraderBalanceVaultV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {TraderBalanceVault} from \"../../TraderBalanceVault/TraderBalanceVault.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract TraderBalanceVaultV2 is IUpgradeInterface, TraderBalanceVault {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"TraderBalanceVaultV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/TreasuryV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport {Treasury} from \"../../Treasury/Treasury.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract TreasuryV2 is IUpgradeInterface, Treasury {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"TreasuryV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/mocks/upgradeMocks/WhiteBlackListV2.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport {WhiteBlackList} from \"../../WhiteBlackList/WhiteBlackList/WhiteBlackList.sol\";\nimport {IUpgradeInterface} from \"./IUpgradeInterface.sol\";\n\ncontract WhiteBlackListV2 is IUpgradeInterface, WhiteBlackList {\n    uint256 public value;\n\n    function testUpgrade() external pure override returns (string memory) {\n        return \"WhiteBlackListV2\";\n    }\n\n    function setValue(uint256 _value) external override {\n        value = _value;\n    }\n}\n"
    },
    "contracts/PMXBonusNFT/IPMXBonusNFT.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IBonusExecutor} from \"../BonusExecutor/IBonusExecutor.sol\";\nimport {IPMXBonusNFTStorage} from \"./IPMXBonusNFTStorage.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\n\ninterface IPMXBonusNFT is IPMXBonusNFTStorage, IERC721EnumerableUpgradeable, IPausable {\n    struct SafeMintParams {\n        uint256 bonusTypeId;\n        uint256 tier;\n        uint256 chainId;\n        uint256 id;\n        address recipient;\n        string[] uris;\n    }\n\n    event ExecutorChanged(address indexed executor);\n    event BlockedNftWithId(uint256 indexed id);\n    event UnblockedNftWithId(uint256 indexed id);\n\n    /**\n     * @notice Initializes the PMXBonusNFT contract.\n     * @param _primexDNS The address of the PrimexDNS contract.\n     * @param _registry The address of the Registry contract.\n     * @param _whiteBlackList The address of the WhiteBlacklist contract.\n     */\n    function initialize(IPrimexDNS _primexDNS, address _registry, IWhiteBlackList _whiteBlackList) external;\n\n    /**\n     * @notice Mints an NFT with the provided signature and parameters.\n     * @dev The signature should be created by the user with NFT_MINTER role assigned.\n     * @param _sig The signature used to validate the minter.\n     * @param _nftParams The SafeMintParams struct containing the parameters for minting the NFT.\n     */\n    function mint(bytes memory _sig, SafeMintParams memory _nftParams) external;\n\n    /**\n     * @notice Mints an NFT with the provided parameters.\n     * @dev Only callable by the NFT_MINTER role.\n     * @param _nftParams The SafeMintParams struct containing the parameters for minting the NFT.\n     */\n    function mint(SafeMintParams memory _nftParams) external;\n\n    /**\n     * @notice Activates an NFT with the specified ID\n     * @dev Only callable by the owner of the NFT.\n     * @param _id The ID of the NFT to activate.\n     * @param _bucketName The name of the bucket to assign the NFT to.\n     */\n    function activate(uint256 _id, string memory _bucketName) external;\n\n    /**\n     * @notice Sets the executor for the specified bonus type.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _bonusFor The ID of the bonus type.\n     * @param _executor The address of the bonus executor contract.\n     */\n    function setExecutor(uint256 _bonusFor, IBonusExecutor _executor) external;\n\n    /**\n     * @notice Blocks the specified NFT.\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\n     * @param _id The ID of the NFT to block.\n     */\n    function blockNft(uint256 _id) external;\n\n    /**\n     * @notice Unblocks the specified NFT.\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\n     * @param _id The ID of the NFT to unblock.\n     */\n    function unblockNft(uint256 _id) external;\n\n    /**\n     * @notice Retrieves the metadata of an NFT.\n     * @param _id The ID of the NFT.\n     * @return The NftMetadata struct representing the metadata of the NFT.\n     */\n    function getNft(uint256 _id) external view returns (NftMetadata memory);\n\n    /**\n     * @notice Retrieves the token URI of the specified NFT.\n     * @param _id The ID of the NFT.\n     * @return The URI string.\n     */\n    function tokenURI(uint256 _id) external view returns (string memory);\n}\n"
    },
    "contracts/PMXBonusNFT/IPMXBonusNFTStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IBonusExecutor} from \"../BonusExecutor/IBonusExecutor.sol\";\n\ninterface IPMXBonusNFTStorage {\n    struct NftMetadata {\n        address bucket;\n        uint256 bonusTypeId;\n        uint256 tier;\n        address activatedBy; //The bonus is always left to the one who activates it, although the nft token can be transferred to anyone\n        string uri;\n    }\n\n    function bonusExecutors(uint256) external view returns (IBonusExecutor);\n}\n"
    },
    "contracts/PMXBonusNFT/PMXBonusNFT.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport \"./PMXBonusNFTStorage.sol\";\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN, NFT_MINTER} from \"../Constants.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IPMXBonusNFT, IPausable} from \"./IPMXBonusNFT.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IBonusExecutor} from \"../BonusExecutor/IBonusExecutor.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\n\ncontract PMXBonusNFT is IPMXBonusNFT, PMXBonusNFTStorage {\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Modifier that checks if given id exists\n     * @param _id The NFT id to check.\n     */\n    modifier exist(uint256 _id) {\n        _require(_exists(_id), Errors.ID_DOES_NOT_EXIST.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    modifier notBlackListed() {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc IPMXBonusNFT\n     */\n    function initialize(\n        IPrimexDNS _primexDNS,\n        address _registry,\n        IWhiteBlackList _whiteBlackList\n    ) external override initializer {\n        _require(\n            IERC165Upgradeable(address(_primexDNS)).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165Upgradeable(address(_whiteBlackList)).supportsInterface(type(IWhiteBlackList).interfaceId) &&\n                IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n        primexDNS = _primexDNS;\n        whiteBlackList = _whiteBlackList;\n        chainId = block.chainid;\n        __ERC721_init(\"PMXBonusNFT\", \"PMXBNFT\");\n        __Pausable_init();\n    }\n\n    /**\n     * @inheritdoc IPMXBonusNFT\n     */\n    function blockNft(uint256 _id) external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        if (_exists(_id)) {\n            NftMetadata storage data = nftList[idToIndex[_id]];\n            // if we are able to override executor for bonusTypeId it won't work correctly\n            if (data.activatedBy != address(0))\n                bonusExecutors[data.bonusTypeId].deactivateBonus(data.activatedBy, data.bucket);\n        }\n        isBlocked[_id] = true;\n        emit BlockedNftWithId(_id);\n    }\n\n    /**\n     * @inheritdoc IPMXBonusNFT\n     */\n    function unblockNft(uint256 _id) external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        isBlocked[_id] = false;\n        emit UnblockedNftWithId(_id);\n    }\n\n    /**\n     * @inheritdoc IPMXBonusNFT\n     */\n    function mint(bytes memory _sig, SafeMintParams memory _nftParams) external override notBlackListed {\n        _require(!isBlocked[_nftParams.id], Errors.TOKEN_IS_BLOCKED.selector);\n        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(abi.encode(_nftParams)), _sig);\n        _require(IAccessControl(registry).hasRole(NFT_MINTER, signer), Errors.FORBIDDEN.selector);\n        _mint(_nftParams);\n    }\n\n    /**\n     * @inheritdoc IPMXBonusNFT\n     */\n    function mint(SafeMintParams memory _nftParams) external override {\n        _require(!isBlocked[_nftParams.id], Errors.TOKEN_IS_BLOCKED.selector);\n        _require(IAccessControl(registry).hasRole(NFT_MINTER, msg.sender), Errors.FORBIDDEN.selector);\n        _mint(_nftParams);\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc IPMXBonusNFT\n     */\n    function activate(\n        uint256 _id,\n        string memory _bucketName\n    ) external override exist(_id) whenNotPaused notBlackListed {\n        _require(!isBlocked[_id], Errors.TOKEN_IS_BLOCKED.selector);\n        _require(ownerOf(_id) == msg.sender, Errors.CALLER_IS_NOT_OWNER.selector);\n        NftMetadata storage data = nftList[idToIndex[_id]];\n        _require(data.activatedBy == address(0), Errors.TOKEN_IS_ALREADY_ACTIVATED.selector);\n        data.activatedBy = msg.sender;\n        data.bucket = primexDNS.getBucketAddress(_bucketName);\n        bonusExecutors[data.bonusTypeId].activateBonus(_id, data.tier, data.bucket, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IPMXBonusNFT\n     */\n    function setExecutor(\n        uint256 _bonusTypeId,\n        IBonusExecutor _executor\n    ) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165Upgradeable(address(_executor)).supportsInterface(type(IBonusExecutor).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        bonusExecutors[_bonusTypeId] = _executor;\n        emit ExecutorChanged(address(_executor));\n    }\n\n    /**\n     * @inheritdoc IPMXBonusNFT\n     */\n    function getNft(uint256 _id) external view override exist(_id) returns (NftMetadata memory) {\n        NftMetadata memory metadata = nftList[idToIndex[_id]];\n        metadata.uri = _getURI(metadata, _id);\n        return metadata;\n    }\n\n    /**\n     * @inheritdoc IPMXBonusNFT\n     */\n    function tokenURI(\n        uint256 _id\n    ) public view override(ERC721Upgradeable, IPMXBonusNFT) exist(_id) returns (string memory) {\n        return _getURI(nftList[idToIndex[_id]], _id);\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) public view virtual override(ERC721EnumerableUpgradeable, IERC165Upgradeable) returns (bool) {\n        return _interfaceId == type(IPMXBonusNFT).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Mints an NFT with the provided parameters.\n     * @param _nftParams The SafeMintParams struct containing the parameters for minting the NFT.\n     */\n    function _mint(SafeMintParams memory _nftParams) internal {\n        _require(_nftParams.chainId == chainId, Errors.WRONG_NETWORK.selector);\n        _require(_nftParams.uris.length > 0, Errors.WRONG_URIS_LENGTH.selector);\n        idToIndex[_nftParams.id] = nftList.length;\n        nftList.push(\n            NftMetadata({\n                bucket: address(0),\n                bonusTypeId: _nftParams.bonusTypeId,\n                tier: _nftParams.tier,\n                activatedBy: address(0),\n                uri: \"\"\n            })\n        );\n        _safeMint(_nftParams.recipient, _nftParams.id);\n        idToURIs[_nftParams.id] = _nftParams.uris;\n    }\n\n    /**\n     * @notice Retrieves the token URI based on it's activation state\n     * @param _metadata  The NftMetadata struct.\n     * @param _id  The ID of the NFT.\n     * @return string  The URI string\n     */\n    function _getURI(NftMetadata memory _metadata, uint256 _id) internal view returns (string memory) {\n        return (idToURIs[_id].length > 1 && _metadata.activatedBy != address(0)) ? idToURIs[_id][1] : idToURIs[_id][0];\n    }\n\n    /**\n     * @notice Returns baseURI string\n     * @return string The baseURI string.\n     */\n    function _baseURI() internal pure override returns (string memory) {\n        return \"primexURL/\";\n    }\n}\n"
    },
    "contracts/PMXBonusNFT/PMXBonusNFTStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IPMXBonusNFT} from \"./IPMXBonusNFT.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IBonusExecutor} from \"../BonusExecutor/IBonusExecutor.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPMXBonusNFTStorage} from \"./IPMXBonusNFTStorage.sol\";\n\nabstract contract PMXBonusNFTStorage is IPMXBonusNFTStorage, ERC721EnumerableUpgradeable, PausableUpgradeable {\n    IPrimexDNS public primexDNS;\n    address public registry;\n    mapping(uint256 => uint256) public idToIndex;\n    // Mapping from bonus type id to address of its executor\n    mapping(uint256 => IBonusExecutor) public override bonusExecutors;\n    uint256 public chainId;\n    NftMetadata[] internal nftList;\n    mapping(uint256 => string[]) internal idToURIs;\n    mapping(uint256 => bool) internal isBlocked;\n    IWhiteBlackList internal whiteBlackList;\n}\n"
    },
    "contracts/PMXToken.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PMXToken is ERC20, ERC165 {\n    constructor(address _recipient) ERC20(\"Primex\", \"PMX\") {\n        if (_recipient == address(0)) {\n            _recipient = msg.sender;\n        }\n\n        _mint(_recipient, 1000000000 * 10 ** decimals());\n    }\n\n    /**\n     * @notice Interface checker\n     * @param interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/PositionManager/IPositionManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\n\nimport {IPositionManagerStorage} from \"./IPositionManagerStorage.sol\";\nimport {IKeeperRewardDistributor} from \"../KeeperRewardDistributor/IKeeperRewardDistributor.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface IPositionManager is IPositionManagerStorage, IPausable {\n    struct ClosePositionVars {\n        PositionLibrary.Position position;\n        bool borrowedAmountIsNotZero;\n        uint256 oracleTolerableLimit;\n        bool needOracleTolerableLimitCheck;\n    }\n\n    event SetMaxPositionSize(address token0, address token1, uint256 amountInToken0, uint256 amountInToken1);\n    event SetDefaultOracleTolerableLimit(uint256 indexed oracleTolerableLimit);\n    event SecurityBufferChanged(uint256 indexed securityBuffer);\n    event MaintenanceBufferChanged(uint256 indexed maintenanceBuffer);\n    event SetOracleTolerableLimit(address indexed assetA, address indexed assetB, uint256 oracleTolerableLimit);\n    event KeeperRewardDistributorChanged(address indexed _keeperRewardDistributor);\n    event MinPositionSizeAndAssetChanged(uint256 indexed _minPositionSize, address indexed _minPositionAsset);\n    event OracleTolerableLimitMultiplierChanged(uint256 indexed newMultiplier);\n\n    event OpenPosition(\n        uint256 indexed positionId,\n        address indexed trader,\n        address indexed openedBy,\n        PositionLibrary.Position position,\n        address feeToken,\n        uint256 protocolFee,\n        uint256 entryPrice,\n        uint256 leverage,\n        LimitOrderLibrary.Condition[] closeConditions\n    );\n\n    event PartialClosePosition(\n        uint256 indexed positionId,\n        address indexed trader,\n        address bucketAddress,\n        address soldAsset,\n        address positionAsset,\n        uint256 decreasePositionAmount,\n        uint256 depositedAmount,\n        uint256 scaledDebtAmount,\n        int256 profit,\n        uint256 positionDebt,\n        uint256 amountOut\n    );\n\n    event IncreaseDeposit(\n        uint256 indexed positionId,\n        address indexed trader,\n        uint256 depositDelta,\n        uint256 scaledDebtAmount\n    );\n\n    event DecreaseDeposit(\n        uint256 indexed positionId,\n        address indexed trader,\n        uint256 depositDelta,\n        uint256 scaledDebtAmount\n    );\n\n    event UpdatePositionConditions(\n        uint256 indexed positionId,\n        address indexed trader,\n        LimitOrderLibrary.Condition[] closeConditions\n    );\n\n    /**\n     * @notice Initializes the contract with the specified addresses and initializes inherited contracts.\n     * @param _registry The address of the Registry contract.\n     * @param _primexDNS The address of the PrimexDNS contract.\n     * @param _traderBalanceVault The address of the TraderBalanceVault contract.\n     * @param _priceOracle The address of the PriceOracle contract.\n     * @param _keeperRewardDistributor The address of the KeeperRewardDistributor contract.\n     * @param _whiteBlackList The address of the WhiteBlacklist contract.\n     */\n    function initialize(\n        address _registry,\n        address _primexDNS,\n        address payable _traderBalanceVault,\n        address _priceOracle,\n        address _keeperRewardDistributor,\n        address _whiteBlackList\n    ) external;\n\n    /**\n     * @notice Sets the maximum position size for a pair of tokens.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _token0 The address of the first token in the pair.\n     * @param _token1 The address of the second token in the pair.\n     * @param _amountInToken0 The maximum amount of token0 allowed in the position.\n     * @param _amountInToken1 The maximum amount of token1 allowed in the position.\n     */\n    function setMaxPositionSize(\n        address _token0,\n        address _token1,\n        uint256 _amountInToken0,\n        uint256 _amountInToken1\n    ) external;\n\n    /**\n     * @notice Sets the default oracle tolerable limit for the protocol.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _percent The new value for the default oracle tolerable limit. Measured in WAD (1 WAD = 100%).\n     */\n    function setDefaultOracleTolerableLimit(uint256 _percent) external;\n\n    /**\n     * @notice Sets the oracle tolerable limit between two assets.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _assetA The address of the first asset.\n     * @param _assetB The address of the second asset.\n     * @param _percent The new value for the oracle tolerable limit between two assets. Measured in WAD (1 WAD = 100%).\n     */\n    function setOracleTolerableLimit(address _assetA, address _assetB, uint256 _percent) external;\n\n    /**\n     * @notice Function to set oracleTolerableLimitMultiplier.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param newMultiplier New multiplier in WAD format.\n     */\n    function setOracleTolerableLimitMultiplier(uint256 newMultiplier) external;\n\n    /**\n     * @notice Sets the security buffer value.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * 0 <= newSecurityBuffer < 1.\n     * Buffer security parameter is used in calculating the liquidation conditions\n     * https://docs.google.com/document/d/1kR8eaqV4289MAbLKgIfKsZ2NgjFpeC0vpVL7jVUTvho/edit#bookmark=id.i9v508hvrv42\n     * @param newSecurityBuffer The new value of the security buffer in WAD format.\n     */\n    function setSecurityBuffer(uint256 newSecurityBuffer) external;\n\n    /**\n     * @notice Sets the maintenance buffer value.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * The new maintenance buffer value should be greater than zero and less than one.\n     * Maintenance buffer is used in calculating the maximum leverage\n     * https://docs.google.com/document/d/1kR8eaqV4289MAbLKgIfKsZ2NgjFpeC0vpVL7jVUTvho/edit#bookmark=id.87oc1j1s9z21\n     * @param newMaintenanceBuffer The new value of the maintenance buffer in WAD format.\n     */\n    function setMaintenanceBuffer(uint256 newMaintenanceBuffer) external;\n\n    /**\n     * @notice Sets the address of the SpotTradingRewardDistributor contract.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _spotTradingRewardDistributor The address of the SpotTradingRewardDistributor contract.\n     */\n    function setSpotTradingRewardDistributor(address _spotTradingRewardDistributor) external;\n\n    /**\n     * @notice Sets the KeeperRewardDistributor contract.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _keeperRewardDistributor The address of the KeeperRewardDistributor contract.\n     */\n    function setKeeperRewardDistributor(IKeeperRewardDistributor _keeperRewardDistributor) external;\n\n    /**\n     * @notice Opens a position based on the provided order parameters.\n     * @dev Only callable by the LOM_ROLE role.\n     * @param _params The parameters for opening a position.\n     * @return The total borrowed amount, position amount, position ID, and entry price of the new position.\n     */\n    function openPositionByOrder(\n        LimitOrderLibrary.OpenPositionByOrderParams calldata _params\n    ) external returns (uint256, uint256, uint256, uint256);\n\n    /**\n     * @notice Opens margin position.\n     * @dev Locks trader's collateral in TraderBalanceVault. Takes loan from bucket for deal.\n     * Makes swap bucket borrowedAsset amount on '_dex'. Updates rates and indexes in the '_bucket'.\n     * Mints debtToken for trader (msg.sender)\n     * @param _params The parameters required to open a position.\n     */\n    function openPosition(PositionLibrary.OpenPositionParams calldata _params) external payable;\n\n    /**\n     * @notice Close trader's active position or liquidate risky position.\n     * @dev Protocol will fall down (revert) if two conditions occur both:\n     * 1. (token1Price + position.depositedAmount).wdiv(positionDebt) will become lower than 1,\n     * so position will make loss for Protocol.\n     * 2. Not enough liquidity in bucket to pay that loss.\n     * @param _id Position id for `msg.sender`.\n     * @param _dealReceiver The receiver of the rest of trader's deposit.\n     * @param _routes swap routes on dexes\n     * @param _amountOutMin minimum allowed amount out for position\n     */\n    function closePosition(\n        uint256 _id,\n        address _dealReceiver,\n        PrimexPricingLibrary.Route[] memory _routes,\n        uint256 _amountOutMin\n    ) external;\n\n    /**\n     * @notice Closes trader's active position by closing condition\n     * @param _id Position id.\n     * @param _keeper The address of the keeper or the recipient of the reward.\n     * @param _routes An array of routes for executing trades, swap routes on dexes.\n     * @param _conditionIndex The index of the condition to be used for closing the position.\n     * @param _ccmAdditionalParams Additional params needed for canBeClosed() of the ConditionalClosingManager.\n     * @param _closeReason The reason for closing the position.\n     */\n    function closePositionByCondition(\n        uint256 _id,\n        address _keeper,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _conditionIndex,\n        bytes calldata _ccmAdditionalParams,\n        PositionLibrary.CloseReason _closeReason\n    ) external;\n\n    /**\n     * @notice Allows the trader to partially close a position.\n     * @param _positionId The ID of the position to be partially closed.\n     * @param _amount The amount of the position asset to be closed from the position.\n     * @param _depositReceiver The address where the remaining deposit will be sent.\n     * @param _routes The routing information for swapping assets.\n     * @param _amountOutMin The minimum amount to be received after swapping, measured in the same decimal format as the position's asset.\n     */\n    function partiallyClosePosition(\n        uint256 _positionId,\n        uint256 _amount,\n        address _depositReceiver,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin\n    ) external;\n\n    /**\n     * @notice Updates the position with the given position ID by setting new close conditions.\n     * @param _positionId The ID of the position to update.\n     * @param _closeConditions An array of close conditions for the position.\n     * @dev The caller of this function must be the trader who owns the position.\n     * @dev Emits an `UpdatePositionConditions` event upon successful update.\n     */\n    function updatePositionConditions(\n        uint256 _positionId,\n        LimitOrderLibrary.Condition[] calldata _closeConditions\n    ) external;\n\n    /**\n     * @notice Increases the deposit amount for a given position.\n     * @param _positionId The ID of the position to increase the deposit for.\n     * @param _amount The amount to increase the deposit by.\n     * @param _asset The address of the asset to deposit.\n     * @param _takeDepositFromWallet A flag indicating whether to make the deposit immediately.\n     * @param _routes An array of routes to use for trading.\n     * @param _amountOutMin The minimum amount of the output asset to receive from trading.\n     */\n    function increaseDeposit(\n        uint256 _positionId,\n        uint256 _amount,\n        address _asset,\n        bool _takeDepositFromWallet,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin\n    ) external;\n\n    /**\n     * @notice Decreases the deposit amount for a given position.\n     * @param _positionId The ID of the position.\n     * @param _amount The amount to decrease the deposit by.\n     */\n    function decreaseDeposit(uint256 _positionId, uint256 _amount) external;\n\n    /**\n     * @notice Sets the minimum position size and the corresponding asset for positions.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _minPositionSize The new minimum position size.\n     * @param _minPositionAsset The address of the asset associated with the minimum position size.\n     */\n    function setMinPositionSize(uint256 _minPositionSize, address _minPositionAsset) external;\n\n    /**\n     * @notice Checks if a position can be closed based on a specific condition.\n     * @param _positionId The ID of the position.\n     * @param _conditionIndex The index of the condition within the position's close conditions.\n     * @param _additionalParams Additional parameters required for the condition check.\n     * @return A boolean indicating whether the position can be closed.\n     */\n    function canBeClosed(\n        uint256 _positionId,\n        uint256 _conditionIndex,\n        bytes calldata _additionalParams\n    ) external returns (bool);\n\n    /**\n     * @notice Deletes a positions by their IDs from a specific bucket for a given traders.\n     * @param _ids The IDs of the positions to be deleted.\n     * @param _traders The addresses of the traders who owns the position.\n     * @param _length The length of the traders array.\n     * @param _bucket The address of the bucket from which the position is to be deleted.\n     */\n    function deletePositions(\n        uint256[] calldata _ids,\n        address[] calldata _traders,\n        uint256 _length,\n        address _bucket\n    ) external;\n\n    /**\n     * @notice Transfers a specified amount of tokens from the contract to a specified address.\n     * @dev Only callable by the BATCH_MANAGER_ROLE role.\n     * @param _token The address of the token to be transferred.\n     * @param _to The address to which the tokens will be transferred.\n     * @param _amount The amount of tokens to be transferred.\n     */\n    function doTransferOut(address _token, address _to, uint256 _amount) external;\n\n    /**\n     * @notice Returns the oracle tolerable limit for the given asset pair.\n     * @param assetA The address of the first asset in the pair.\n     * @param assetB The address of the second asset in the pair.\n     * @return The oracle tolerable limit in WAD format (1 WAD = 100%) for the asset pair.\n     */\n    function getOracleTolerableLimit(address assetA, address assetB) external view returns (uint256);\n\n    /**\n     * @notice Retrieves the position information for a given ID.\n     * @param _id The ID of the position to retrieve.\n     * @return position The position information associated with the given ID.\n     */\n    function getPosition(uint256 _id) external view returns (PositionLibrary.Position memory);\n\n    /**\n     * @notice Retrieves the position at the specified index.\n     * @param _index The index of the position to retrieve.\n     * @return The Position struct at the specified index.\n     */\n    function getPositionByIndex(uint256 _index) external view returns (PositionLibrary.Position memory);\n\n    /**\n     * @notice Returns the length of the positions array.\n     * @return The length of the positions array.\n     */\n    function getAllPositionsLength() external view returns (uint256);\n\n    /**\n     * @notice Returns the length of the array containing the positions of a specific trader.\n     * @param _trader The address of the trader.\n     * @return The number of positions the trader has.\n     */\n    function getTraderPositionsLength(address _trader) external view returns (uint256);\n\n    /**\n     * @notice Returns the length of the array containing the positions of a specific bucket.\n     * @param _bucket The address of the bucket.\n     * @return The number of positions the bucket has.\n     */\n    function getBucketPositionsLength(address _bucket) external view returns (uint256);\n\n    /**\n     * @notice Returns the debt of a position with the given ID.\n     * @param _id The ID of the position.\n     * @return The debt of the position, measured in the same decimal format as debtTokens.\n     */\n    function getPositionDebt(uint256 _id) external view returns (uint256);\n\n    /**\n     * @notice Retrieves the close conditions for a specific position.\n     * @param _positionId The ID of the position.\n     * @return An array of close conditions associated with the position.\n     */\n    function getCloseConditions(uint256 _positionId) external view returns (LimitOrderLibrary.Condition[] memory);\n\n    /**\n     * @notice Retrieves the close condition for a given position and index.\n     * @param _positionId The identifier of the position.\n     * @param _index The index of the close condition.\n     * @return The close condition at the specified position and index.\n     */\n    function getCloseCondition(\n        uint256 _positionId,\n        uint256 _index\n    ) external view returns (LimitOrderLibrary.Condition memory);\n\n    /**\n     * @notice Сhecks if the position is risky.\n     * @param _id the id of the position\n     * @return (1) True if position is risky\n     */\n    function isPositionRisky(uint256 _id) external view returns (bool);\n\n    /**\n     * @notice Checks if a position with the given ID is delisted.\n     * @param _id The ID of the position.\n     * @return A boolean indicating whether the position is delisted or not.\n     */\n    function isDelistedPosition(uint256 _id) external view returns (bool);\n\n    /**\n     * @notice Retrieves the health value of a position.\n     * @param _id The ID of the position.\n     * @return The health value of the position in WAD format.\n     */\n    function healthPosition(uint256 _id) external view returns (uint256);\n}\n"
    },
    "contracts/PositionManager/IPositionManagerStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\n\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IKeeperRewardDistributor} from \"../KeeperRewardDistributor/IKeeperRewardDistributor.sol\";\nimport {ISpotTradingRewardDistributor} from \"../SpotTradingRewardDistributor/ISpotTradingRewardDistributor.sol\";\n\ninterface IPositionManagerStorage {\n    function maxPositionSize(address, address) external returns (uint256);\n\n    function defaultOracleTolerableLimit() external returns (uint256);\n\n    function securityBuffer() external view returns (uint256);\n\n    function maintenanceBuffer() external view returns (uint256);\n\n    function positionsId() external view returns (uint256);\n\n    function traderPositionIds(address _trader, uint256 _index) external view returns (uint256);\n\n    function bucketPositionIds(address _bucket, uint256 _index) external view returns (uint256);\n\n    function registry() external view returns (IAccessControl);\n\n    function traderBalanceVault() external view returns (ITraderBalanceVault);\n\n    function primexDNS() external view returns (IPrimexDNS);\n\n    function priceOracle() external view returns (IPriceOracle);\n\n    function keeperRewardDistributor() external view returns (IKeeperRewardDistributor);\n\n    function spotTradingRewardDistributor() external view returns (ISpotTradingRewardDistributor);\n\n    function minPositionSize() external view returns (uint256);\n\n    function minPositionAsset() external view returns (address);\n}\n"
    },
    "contracts/PositionManager/PositionManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {TokenTransfersLibrary} from \"../libraries/TokenTransfersLibrary.sol\";\n\nimport \"../Constants.sol\";\nimport \"./PositionManagerStorage.sol\";\nimport {IPositionManager} from \"./IPositionManager.sol\";\nimport {IConditionalClosingManager} from \"../interfaces/IConditionalClosingManager.sol\";\nimport {ISpotTradingRewardDistributor} from \"../SpotTradingRewardDistributor/ISpotTradingRewardDistributor.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IKeeperRewardDistributorStorage} from \"../KeeperRewardDistributor/IKeeperRewardDistributorStorage.sol\";\n\ncontract PositionManager is IPositionManager, PositionManagerStorage {\n    using WadRayMath for uint256;\n    using PositionLibrary for PositionLibrary.Position;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function initialize(\n        address _registry,\n        address _primexDNS,\n        address payable _traderBalanceVault,\n        address _priceOracle,\n        address _keeperRewardDistributor,\n        address _whiteBlackList\n    ) external override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(_primexDNS).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165Upgradeable(_traderBalanceVault).supportsInterface(type(ITraderBalanceVault).interfaceId) &&\n                IERC165Upgradeable(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId) &&\n                IERC165Upgradeable(_keeperRewardDistributor).supportsInterface(\n                    type(IKeeperRewardDistributor).interfaceId\n                ) &&\n                IERC165Upgradeable(_whiteBlackList).supportsInterface(type(IWhiteBlackList).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = IAccessControl(_registry);\n        primexDNS = IPrimexDNS(_primexDNS);\n        traderBalanceVault = ITraderBalanceVault(_traderBalanceVault);\n        priceOracle = IPriceOracle(_priceOracle);\n        keeperRewardDistributor = IKeeperRewardDistributor(_keeperRewardDistributor);\n        whiteBlackList = IWhiteBlackList(_whiteBlackList);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __ERC165_init();\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setMaxPositionSize(\n        address _token0,\n        address _token1,\n        uint256 _amountInToken0,\n        uint256 _amountInToken1\n    ) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        PositionLibrary.setMaxPositionSize(maxPositionSize, _token0, _token1, _amountInToken0, _amountInToken1);\n        emit SetMaxPositionSize(_token0, _token1, _amountInToken0, _amountInToken1);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setDefaultOracleTolerableLimit(uint256 _percent) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(_percent <= WadRayMath.WAD, Errors.INVALID_PERCENT_NUMBER.selector);\n        defaultOracleTolerableLimit = _percent;\n        emit SetDefaultOracleTolerableLimit(_percent);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function doTransferOut(address _token, address _to, uint256 _amount) external override {\n        _onlyRole(BATCH_MANAGER_ROLE);\n        TokenTransfersLibrary.doTransferOut(_token, _to, _amount);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setSecurityBuffer(uint256 _newSecurityBuffer) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(_newSecurityBuffer < WadRayMath.WAD, Errors.INVALID_SECURITY_BUFFER.selector);\n        securityBuffer = _newSecurityBuffer;\n        emit SecurityBufferChanged(_newSecurityBuffer);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setMaintenanceBuffer(uint256 _newMaintenanceBuffer) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(\n            _newMaintenanceBuffer > 0 && _newMaintenanceBuffer < WadRayMath.WAD,\n            Errors.INVALID_MAINTENANCE_BUFFER.selector\n        );\n        maintenanceBuffer = _newMaintenanceBuffer;\n        emit MaintenanceBufferChanged(_newMaintenanceBuffer);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setOracleTolerableLimit(address _assetA, address _assetB, uint256 _percent) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        PositionLibrary.setOracleTolerableLimit(oracleTolerableLimits, _assetA, _assetB, _percent);\n        emit SetOracleTolerableLimit(_assetA, _assetB, _percent);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setOracleTolerableLimitMultiplier(uint256 newMultiplier) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        _require(\n            newMultiplier >= WadRayMath.WAD && newMultiplier < 10 * WadRayMath.WAD,\n            Errors.WRONG_TRUSTED_MULTIPLIER.selector\n        );\n\n        oracleTolerableLimitMultiplier = newMultiplier;\n        emit OracleTolerableLimitMultiplierChanged(newMultiplier);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setMinPositionSize(uint256 _minPositionSize, address _minPositionAsset) external override {\n        _onlyRole(MEDIUM_TIMELOCK_ADMIN);\n        minPositionSize = _minPositionSize;\n        minPositionAsset = _minPositionAsset;\n        emit MinPositionSizeAndAssetChanged(_minPositionSize, _minPositionAsset);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setKeeperRewardDistributor(IKeeperRewardDistributor _keeperRewardDistributor) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        _require(\n            IERC165Upgradeable(address(_keeperRewardDistributor)).supportsInterface(\n                type(IKeeperRewardDistributor).interfaceId\n            ),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        keeperRewardDistributor = _keeperRewardDistributor;\n        emit KeeperRewardDistributorChanged(address(_keeperRewardDistributor));\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function openPositionByOrder(\n        LimitOrderLibrary.OpenPositionByOrderParams calldata _params\n    ) external override whenNotPaused returns (uint256, uint256, uint256, uint256) {\n        _onlyRole(LOM_ROLE);\n        (PositionLibrary.Position memory newPosition, PositionLibrary.OpenPositionVars memory vars) = PositionLibrary\n            .createPositionByOrder(_params, priceOracle);\n        PositionLibrary.OpenPositionEventData memory posEventData = _openPosition(newPosition, vars);\n\n        PositionLibrary.Position memory position = positions[positions.length - 1];\n\n        _updateTraderActivity(_params.order.trader, position.positionAsset, position.positionAmount, position.bucket);\n\n        emit OpenPosition({\n            positionId: position.id,\n            trader: _params.order.trader,\n            openedBy: _params.sender,\n            position: position,\n            feeToken: _params.order.feeToken,\n            protocolFee: posEventData.protocolFee,\n            entryPrice: posEventData.entryPrice,\n            leverage: posEventData.leverage,\n            closeConditions: vars.closeConditions\n        });\n        return (\n            vars.borrowedAmount + position.depositAmountInSoldAsset,\n            position.positionAmount,\n            position.id,\n            posEventData.entryPrice\n        );\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function openPosition(\n        PositionLibrary.OpenPositionParams calldata _params\n    ) external payable override nonReentrant whenNotPaused {\n        _notBlackListed();\n        (PositionLibrary.Position memory newPosition, PositionLibrary.OpenPositionVars memory vars) = PositionLibrary\n            .createPosition(_params, primexDNS, priceOracle);\n        PositionLibrary.OpenPositionEventData memory posEventData = _openPosition(newPosition, vars);\n\n        PositionLibrary.Position memory position = positions[positions.length - 1];\n        _updateTraderActivity(msg.sender, position.positionAsset, position.positionAmount, position.bucket);\n\n        emit OpenPosition({\n            positionId: position.id,\n            trader: position.trader,\n            openedBy: position.trader,\n            position: position,\n            feeToken: _params.isProtocolFeeInPmx ? primexDNS.pmx() : NATIVE_CURRENCY,\n            protocolFee: posEventData.protocolFee,\n            entryPrice: posEventData.entryPrice,\n            leverage: posEventData.leverage,\n            closeConditions: vars.closeConditions\n        });\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function closePositionByCondition(\n        uint256 _id,\n        address _keeper,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _conditionIndex,\n        bytes calldata _ccmAdditionalParams,\n        PositionLibrary.CloseReason _closeReason\n    ) external override nonReentrant {\n        _require(_closeReason != PositionLibrary.CloseReason.CLOSE_BY_TRADER, Errors.FORBIDDEN.selector);\n        _notBlackListed();\n        uint256 initialGasleft = gasleft();\n        LimitOrderLibrary.Condition memory condition;\n        if (_conditionIndex < closeConditions[_id].length) condition = closeConditions[_id][_conditionIndex];\n        _closePosition(_id, _keeper, _routes, 0, condition, _ccmAdditionalParams, _closeReason, initialGasleft);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function updatePositionConditions(\n        uint256 _positionId,\n        LimitOrderLibrary.Condition[] calldata _closeConditions\n    ) external override nonReentrant {\n        _notBlackListed();\n        PositionLibrary.Position storage position = positions[positionIndexes[_positionId]];\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\n\n        if (keccak256(abi.encode(_closeConditions)) != keccak256(abi.encode(closeConditions[_positionId]))) {\n            position.setCloseConditions(closeConditions, _closeConditions, primexDNS);\n            position.updatedConditionsAt = block.timestamp;\n            emit UpdatePositionConditions({\n                positionId: _positionId,\n                trader: position.trader,\n                closeConditions: _closeConditions\n            });\n        }\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function increaseDeposit(\n        uint256 _positionId,\n        uint256 _amount,\n        address _asset,\n        bool _takeDepositFromWallet,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin\n    ) external override nonReentrant {\n        _notBlackListed();\n        PositionLibrary.Position storage position = positions[positionIndexes[_positionId]];\n        uint256 depositDelta = position.increaseDeposit(\n            PositionLibrary.IncreaseDepositParams({\n                amount: _amount,\n                asset: _asset,\n                takeDepositFromWallet: _takeDepositFromWallet,\n                routes: _routes,\n                primexDNS: primexDNS,\n                priceOracle: priceOracle,\n                traderBalanceVault: traderBalanceVault,\n                amountOutMin: _amountOutMin\n            })\n        );\n\n        emit IncreaseDeposit({\n            positionId: position.id,\n            trader: position.trader,\n            depositDelta: depositDelta,\n            scaledDebtAmount: position.scaledDebtAmount\n        });\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function decreaseDeposit(uint256 _positionId, uint256 _amount) external override nonReentrant whenNotPaused {\n        _notBlackListed();\n        PositionLibrary.Position storage position = positions[positionIndexes[_positionId]];\n        position.decreaseDeposit(\n            PositionLibrary.DecreaseDepositParams({\n                amount: _amount,\n                primexDNS: primexDNS,\n                priceOracle: priceOracle,\n                traderBalanceVault: traderBalanceVault,\n                pairPriceDrop: priceOracle.getPairPriceDrop(position.positionAsset, position.soldAsset),\n                securityBuffer: securityBuffer,\n                oracleTolerableLimit: getOracleTolerableLimit(position.positionAsset, position.soldAsset),\n                maintenanceBuffer: maintenanceBuffer\n            })\n        );\n        emit DecreaseDeposit({\n            positionId: position.id,\n            trader: position.trader,\n            depositDelta: _amount,\n            scaledDebtAmount: position.scaledDebtAmount\n        });\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function partiallyClosePosition(\n        uint256 _positionId,\n        uint256 _amount,\n        address _depositReceiver,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin\n    ) external override nonReentrant {\n        _notBlackListed();\n        _onlyExist(_positionId);\n        PositionLibrary.Position memory position = positions[positionIndexes[_positionId]];\n        _require(msg.sender == position.trader, Errors.CALLER_IS_NOT_TRADER.selector);\n        _require(_amount < position.positionAmount, Errors.AMOUNT_IS_MORE_THAN_POSITION_AMOUNT.selector);\n        PositionLibrary.ScaledParams memory scaledParams;\n        scaledParams.borrowedAmountIsNotZero = position.scaledDebtAmount != 0;\n        scaledParams.decreasePercent = _amount.wdiv(position.positionAmount);\n        scaledParams.scaledDebtAmount = scaledParams.borrowedAmountIsNotZero\n            ? position.scaledDebtAmount.wmul(scaledParams.decreasePercent)\n            : 0;\n        scaledParams.depositDecrease = position.depositAmountInSoldAsset.wmul(scaledParams.decreasePercent);\n        LimitOrderLibrary.Condition memory condition;\n        PositionLibrary.ClosePositionEventData memory posEventData = position.closePosition(\n            PositionLibrary.ClosePositionParams({\n                closeAmount: _amount,\n                depositDecrease: scaledParams.depositDecrease,\n                scaledDebtAmount: scaledParams.scaledDebtAmount,\n                depositReceiver: _depositReceiver,\n                routes: _routes,\n                amountOutMin: _amountOutMin,\n                oracleTolerableLimit: scaledParams.borrowedAmountIsNotZero\n                    ? getOracleTolerableLimit(position.positionAsset, position.soldAsset)\n                    : 0,\n                primexDNS: primexDNS,\n                priceOracle: priceOracle,\n                traderBalanceVault: traderBalanceVault,\n                closeCondition: condition,\n                ccmAdditionalParams: \"\",\n                borrowedAmountIsNotZero: scaledParams.borrowedAmountIsNotZero,\n                pairPriceDrop: priceOracle.getPairPriceDrop(position.positionAsset, position.soldAsset),\n                securityBuffer: securityBuffer,\n                needOracleTolerableLimitCheck: scaledParams.borrowedAmountIsNotZero\n            }),\n            PositionLibrary.CloseReason.CLOSE_BY_TRADER\n        );\n        position.positionAmount -= _amount;\n        position.scaledDebtAmount -= scaledParams.scaledDebtAmount;\n        position.depositAmountInSoldAsset -= scaledParams.depositDecrease;\n        PrimexPricingLibrary.validateMinPositionSize(\n            minPositionSize,\n            minPositionAsset,\n            position.positionAmount,\n            position.positionAsset,\n            address(priceOracle)\n        );\n\n        positions[positionIndexes[_positionId]] = position;\n        emit PartialClosePosition({\n            positionId: _positionId,\n            trader: msg.sender,\n            bucketAddress: address(position.bucket),\n            soldAsset: position.soldAsset,\n            positionAsset: position.positionAsset,\n            decreasePositionAmount: _amount,\n            depositedAmount: position.depositAmountInSoldAsset,\n            scaledDebtAmount: position.scaledDebtAmount,\n            profit: posEventData.profit,\n            positionDebt: posEventData.debtAmount,\n            amountOut: posEventData.amountOut\n        });\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override {\n        _onlyRole(EMERGENCY_ADMIN);\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override {\n        _onlyRole(SMALL_TIMELOCK_ADMIN);\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function canBeClosed(\n        uint256 _positionId,\n        uint256 _conditionIndex,\n        bytes calldata _additionalParams\n    ) external override returns (bool) {\n        _require(\n            _conditionIndex < closeConditions[_positionId].length,\n            Errors.CONDITION_INDEX_IS_OUT_OF_BOUNDS.selector\n        );\n        LimitOrderLibrary.Condition storage condition = closeConditions[_positionId][_conditionIndex];\n        return\n            IConditionalClosingManager(primexDNS.cmTypeToAddress(condition.managerType)).canBeClosedBeforeSwap(\n                positions[positionIndexes[_positionId]],\n                condition.params,\n                _additionalParams\n            );\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function setSpotTradingRewardDistributor(address _spotTradingRewardDistributor) external override {\n        _onlyRole(BIG_TIMELOCK_ADMIN);\n        spotTradingRewardDistributor = ISpotTradingRewardDistributor(_spotTradingRewardDistributor);\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function deletePositions(\n        uint256[] calldata _ids,\n        address[] calldata _traders,\n        uint256 _length,\n        address _bucket\n    ) external override {\n        _onlyRole(BATCH_MANAGER_ROLE);\n        for (uint256 i; i < _length; i++) {\n            _onlyExist(_ids[i]);\n            _deletePosition(_ids[i], _bucket, _traders[i]);\n        }\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getPosition(uint256 _id) external view override returns (PositionLibrary.Position memory) {\n        _onlyExist(_id);\n        return positions[positionIndexes[_id]];\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getPositionByIndex(uint256 _index) external view override returns (PositionLibrary.Position memory) {\n        return positions[_index];\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getAllPositionsLength() external view override returns (uint256) {\n        return positions.length;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getTraderPositionsLength(address _trader) external view override returns (uint256) {\n        return traderPositionIds[_trader].length;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getBucketPositionsLength(address _bucket) external view override returns (uint256) {\n        return bucketPositionIds[_bucket].length;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getPositionDebt(uint256 _id) external view override returns (uint256) {\n        _onlyExist(_id);\n        return positions[positionIndexes[_id]].getDebt();\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function isPositionRisky(uint256 _id) external view override returns (bool) {\n        return healthPosition(_id) < WadRayMath.WAD;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function isDelistedPosition(uint256 _id) external view override returns (bool) {\n        _onlyExist(_id);\n        PositionLibrary.Position storage position = positions[positionIndexes[_id]];\n        return position.bucket == IBucket(address(0)) ? false : position.bucket.isDelisted();\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function closePosition(\n        uint256 _id,\n        address _depositReceiver,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin\n    ) public override nonReentrant {\n        _notBlackListed();\n        LimitOrderLibrary.Condition memory condition;\n        _closePosition(\n            _id,\n            _depositReceiver,\n            _routes,\n            _amountOutMin,\n            condition,\n            bytes(\"\"),\n            PositionLibrary.CloseReason.CLOSE_BY_TRADER,\n            0\n        );\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getOracleTolerableLimit(address assetA, address assetB) public view override returns (uint256) {\n        uint256 oracleTolerableLimit = oracleTolerableLimits[assetA][assetB];\n        return oracleTolerableLimit > 0 ? oracleTolerableLimit : defaultOracleTolerableLimit;\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function healthPosition(uint256 _id) public view override returns (uint256) {\n        _onlyExist(_id);\n        PositionLibrary.Position storage position = positions[positionIndexes[_id]];\n        return\n            position.health(\n                priceOracle,\n                priceOracle.getPairPriceDrop(position.positionAsset, position.soldAsset),\n                securityBuffer,\n                getOracleTolerableLimit(position.positionAsset, position.soldAsset)\n            );\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getCloseCondition(\n        uint256 _positionId,\n        uint256 _index\n    ) public view override returns (LimitOrderLibrary.Condition memory) {\n        return closeConditions[_positionId][_index];\n    }\n\n    /**\n     * @inheritdoc IPositionManager\n     */\n    function getCloseConditions(\n        uint256 _positionId\n    ) public view override returns (LimitOrderLibrary.Condition[] memory) {\n        return closeConditions[_positionId];\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IPositionManager).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Opens a new position.\n     * @param _position The position data.\n     * @param _vars The variables for opening the position.\n     * @return posEventData The event data for the opened position.\n     */\n    function _openPosition(\n        PositionLibrary.Position memory _position,\n        PositionLibrary.OpenPositionVars memory _vars\n    ) internal returns (PositionLibrary.OpenPositionEventData memory) {\n        (\n            PositionLibrary.Position memory position,\n            PositionLibrary.OpenPositionEventData memory posEventData\n        ) = PositionLibrary.openPosition(\n                _position,\n                _vars,\n                PositionLibrary.PositionManagerParams({\n                    primexDNS: primexDNS,\n                    priceOracle: priceOracle,\n                    traderBalanceVault: traderBalanceVault,\n                    oracleTolerableLimitForThirdAsset: _vars.isThirdAsset\n                        ? getOracleTolerableLimit(_vars.depositData.depositAsset, _position.positionAsset)\n                        : 0,\n                    oracleTolerableLimit: _vars.needOracleTolerableLimitCheck\n                        ? getOracleTolerableLimit(_position.soldAsset, _position.positionAsset)\n                        : 0,\n                    minPositionSize: minPositionSize,\n                    minPositionAsset: minPositionAsset,\n                    maxPositionSize: maxPositionSize[_position.soldAsset][_position.positionAsset]\n                })\n            );\n\n        // create position and update indexes (by trader, by bucket)\n        position.id = positionsId;\n        positionsId++;\n\n        positions.push(position);\n        positionIndexes[position.id] = positions.length - 1;\n\n        traderPositionIds[position.trader].push(position.id);\n        traderPositionIndexes[position.id] = traderPositionIds[position.trader].length - 1;\n\n        bucketPositionIds[address(position.bucket)].push(position.id);\n        bucketPositionIndexes[position.id] = bucketPositionIds[address(position.bucket)].length - 1;\n\n        position.setCloseConditions(closeConditions, _vars.closeConditions, primexDNS);\n        return posEventData;\n    }\n\n    /**\n     * @dev delete position and update indexes (by trader, by bucket)\n     * can be simplified with EnumerableMap by OpenZeppelin\n     * @param _id the id of the position to be deleted\n     * @param _bucket the bucket of the position to be deleted\n     * @param _trader the trader of the position to be deleted\n     */\n    function _deletePosition(uint256 _id, address _bucket, address _trader) internal {\n        delete closeConditions[_id];\n\n        uint256 lastBucketPositionId = bucketPositionIds[_bucket][bucketPositionIds[_bucket].length - 1];\n        bucketPositionIds[_bucket][bucketPositionIndexes[_id]] = lastBucketPositionId;\n        bucketPositionIndexes[lastBucketPositionId] = bucketPositionIndexes[_id];\n        bucketPositionIds[_bucket].pop();\n        delete bucketPositionIndexes[_id];\n\n        uint256 lastTraderPositionId = traderPositionIds[_trader][traderPositionIds[_trader].length - 1];\n        traderPositionIds[_trader][traderPositionIndexes[_id]] = lastTraderPositionId;\n        traderPositionIndexes[lastTraderPositionId] = traderPositionIndexes[_id];\n        traderPositionIds[_trader].pop();\n        delete traderPositionIndexes[_id];\n\n        positions[positionIndexes[_id]] = positions[positions.length - 1];\n        positionIndexes[positions[positions.length - 1].id] = positionIndexes[_id];\n        positions.pop();\n        delete positionIndexes[_id];\n    }\n\n    /**\n     * @notice Close a position.\n     * @param _id The ID of the position to be closed.\n     * @param _depositReceiver The address to receive the deposit assets.\n     * @param _routes The trading routes to be used for swapping assets.\n     * @param _amountOutMin The minimum amount of output asset expected from the swaps.\n     * @param closeCondition The condition that must be satisfied to close the position.\n     * @param _ccmAdditionalParams Additional parameters for custom closing managers.\n     * @param _closeReason The reason for closing the position.\n     */\n    function _closePosition(\n        uint256 _id,\n        address _depositReceiver,\n        PrimexPricingLibrary.Route[] calldata _routes,\n        uint256 _amountOutMin,\n        LimitOrderLibrary.Condition memory closeCondition,\n        bytes memory _ccmAdditionalParams,\n        PositionLibrary.CloseReason _closeReason,\n        uint256 _initialGasLeft\n    ) internal {\n        _onlyExist(_id);\n        _require(_depositReceiver != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        ClosePositionVars memory vars;\n        vars.position = positions[positionIndexes[_id]];\n        vars.borrowedAmountIsNotZero = vars.position.scaledDebtAmount > 0;\n        // we don't check limit when the close reason is CLOSE_BY_TRADER AND a position is spot\n        vars.needOracleTolerableLimitCheck =\n            _closeReason != PositionLibrary.CloseReason.CLOSE_BY_TRADER ||\n            vars.borrowedAmountIsNotZero;\n\n        if (vars.needOracleTolerableLimitCheck) {\n            vars.oracleTolerableLimit = getOracleTolerableLimit(vars.position.positionAsset, vars.position.soldAsset);\n            if (registry.hasRole(TRUSTED_TOLERABLE_LIMIT_ROLE, msg.sender)) {\n                vars.oracleTolerableLimit = vars.oracleTolerableLimit.wmul(oracleTolerableLimitMultiplier);\n            }\n        }\n        PositionLibrary.ClosePositionParams memory _params = PositionLibrary.ClosePositionParams({\n            closeAmount: vars.position.positionAmount,\n            depositDecrease: vars.position.depositAmountInSoldAsset,\n            scaledDebtAmount: vars.position.scaledDebtAmount,\n            depositReceiver: _depositReceiver,\n            routes: _routes,\n            amountOutMin: _amountOutMin,\n            oracleTolerableLimit: vars.oracleTolerableLimit,\n            primexDNS: primexDNS,\n            priceOracle: priceOracle,\n            traderBalanceVault: traderBalanceVault,\n            closeCondition: closeCondition,\n            ccmAdditionalParams: _ccmAdditionalParams,\n            borrowedAmountIsNotZero: vars.borrowedAmountIsNotZero,\n            pairPriceDrop: priceOracle.getPairPriceDrop(vars.position.positionAsset, vars.position.soldAsset),\n            securityBuffer: securityBuffer,\n            needOracleTolerableLimitCheck: vars.needOracleTolerableLimitCheck\n        });\n        IKeeperRewardDistributorStorage.KeeperActionType actionType = vars\n            .position\n            .closePosition(_params, _closeReason)\n            .actionType;\n\n        _deletePosition(_id, address(vars.position.bucket), vars.position.trader);\n        if (\n            _closeReason != PositionLibrary.CloseReason.CLOSE_BY_TRADER &&\n            vars.position.updatedConditionsAt != block.timestamp\n        ) {\n            // to avoid abuse of the reward system, we will not pay the reward to\n            // the keeper if the position open in the same block as the open conditions change\n            keeperRewardDistributor.updateReward(\n                IKeeperRewardDistributor.UpdateRewardParams({\n                    keeper: _depositReceiver,\n                    positionAsset: vars.position.positionAsset,\n                    positionSize: vars.position.positionAmount,\n                    action: actionType,\n                    numberOfActions: 1,\n                    gasSpent: _initialGasLeft - gasleft(),\n                    decreasingCounter: new uint256[](0),\n                    routesLength: abi.encode(_routes).length\n                })\n            );\n        }\n    }\n\n    /**\n     * @notice Internal function to update trader activity.\n     * @dev This function updates the activity of a trader by calling the `updateTraderActivity` function\n     * @param trader The address of the trader whose activity is being updated.\n     * @param positionAsset The address of the position asset.\n     * @param positionSize The size of the position.\n     * @param bucket The bucket for which the trader's activity is being updated.\n     */\n    function _updateTraderActivity(\n        address trader,\n        address positionAsset,\n        uint256 positionSize,\n        IBucket bucket\n    ) internal {\n        // Tracks only spot trading activity.\n        if (\n            bucket == IBucket(address(0)) && spotTradingRewardDistributor != ISpotTradingRewardDistributor(address(0))\n        ) {\n            spotTradingRewardDistributor.updateTraderActivity(trader, positionAsset, positionSize);\n        }\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    function _onlyRole(bytes32 _role) internal view {\n        _require(registry.hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    function _notBlackListed() internal view {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n    }\n\n    /**\n     * @dev Modifier to check if a position exists.\n     * @param _id The ID of the position to check.\n     */\n    function _onlyExist(uint256 _id) internal view {\n        _require(\n            positions.length > 0 && _id == positions[positionIndexes[_id]].id,\n            Errors.POSITION_DOES_NOT_EXIST.selector\n        );\n    }\n}\n"
    },
    "contracts/PositionManager/PositionManagerStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport \"../libraries/Errors.sol\";\n\nimport {IPositionManagerStorage} from \"./IPositionManagerStorage.sol\";\nimport {IKeeperRewardDistributor} from \"../KeeperRewardDistributor/IKeeperRewardDistributor.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {ISpotTradingRewardDistributor} from \"../SpotTradingRewardDistributor/ISpotTradingRewardDistributor.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\n\nabstract contract PositionManagerStorage is\n    IPositionManagerStorage,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    ERC165Upgradeable\n{\n    // Mapping from asset sell to mapping of asset buy with max amount in asset buy\n    mapping(address => mapping(address => uint256)) public override maxPositionSize;\n\n    //The oracleTolerableLimit is the percentage by which a deviation from the oracle price is allowed.\n    //This means that the dex amount out must be greater than oracle amount out * (100% - oracleTolerableLimit)\n    //Specified in the WAD format: 1e17 = 10%, 1e18 = 100% and so on\n\n    //The defaultOracleTolerableLimit this is the oracleTolerableLimit that is returned when there is\n    //no set the oracleTolerableLimit for a specific pair of asset\n    uint256 public override defaultOracleTolerableLimit;\n\n    // Buffer security parameter, which characterizes additional price drop, occurs due to some unexpected events\n    // Specified in the WAD format: 1e17 = 0.1, 5e17 = 0.5 and so on\n    uint256 public override securityBuffer;\n\n    // Additional parameter is needed to avoid immediate liquidation when Trader choses maximal leverage.\n    // Specified in the WAD format, 0 < maintenanceBuffer < 1e18\n    uint256 public override maintenanceBuffer;\n\n    // Mapping from asset A to mapping of asset B with the oracleTolerableLimit\n    mapping(address => mapping(address => uint256)) internal oracleTolerableLimits;\n\n    uint256 public oracleTolerableLimitMultiplier;\n\n    PositionLibrary.Position[] internal positions;\n    uint256 public override positionsId;\n    // mapping from trader address to the position ids array\n    mapping(address => uint256[]) public override traderPositionIds;\n    // mapping from bucket address to the position ids array\n    mapping(address => uint256[]) public override bucketPositionIds;\n    // mapping from position to close conditions\n    mapping(uint256 => LimitOrderLibrary.Condition[]) internal closeConditions;\n\n    IAccessControl public override registry;\n    ITraderBalanceVault public override traderBalanceVault;\n    IPrimexDNS public override primexDNS;\n    IPriceOracle public override priceOracle;\n    IKeeperRewardDistributor public override keeperRewardDistributor;\n    ISpotTradingRewardDistributor public override spotTradingRewardDistributor;\n\n    // minimum position size allowed\n    uint256 public override minPositionSize;\n    // ERC20 token for minimum position size\n    address public override minPositionAsset;\n\n    // mapping from positionId to the index in the positions array\n    mapping(uint256 => uint256) internal positionIndexes;\n    // mapping from positionId to the index in the traderPositionIds[trader] array\n    //NOTE: positionId is unique for all traders hence we can put everything in one mapping\n    mapping(uint256 => uint256) internal traderPositionIndexes;\n    // mapping from positionId to the index in the bucketPositionIds[bucket] array\n    mapping(uint256 => uint256) internal bucketPositionIndexes;\n    IWhiteBlackList internal whiteBlackList;\n}\n"
    },
    "contracts/PriceOracle/IPriceOracle.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IPriceOracleStorage} from \"./IPriceOracleStorage.sol\";\n\ninterface IPriceOracle is IPriceOracleStorage {\n    event PairPriceDropChanged(address indexed assetA, address indexed assetB, uint256 pairPriceDrop);\n    event PriceFeedUpdated(address indexed assetA, address indexed assetB, address indexed priceFeed);\n    event PriceDropFeedUpdated(address indexed assetA, address indexed assetB, address indexed priceDropFeed);\n    event GasPriceFeedChanged(address priceFeed);\n\n    /**\n     * @param _registry The address of PrimexRegistry contract\n     * @param _eth Weth address if eth isn't native token of network. Otherwise set to zero address.\n     */\n    function initialize(address _registry, address _eth) external;\n\n    /**\n     * @notice Function to set (change) the pair priceDrop of the trading assets\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN.\n     * @param _assetA The address of position asset\n     * @param _assetB The address of borrowed asset\n     * @param _pairPriceDrop The pair priceDrop (in wad)\n     */\n    function setPairPriceDrop(address _assetA, address _assetB, uint256 _pairPriceDrop) external;\n\n    /**\n     * @notice Increases the priceDrop of a pair of assets in the system.\n     * @dev Only callable by the EMERGENCY_ADMIN role.\n     * The _pairPriceDrop value must be greater than the current priceDrop value for the pair\n     * and less than the maximum allowed priceDrop (WadRayMath.WAD / 2).\n     * @param _assetA The address of position asset\n     * @param _assetB The address of borrowed asset\n     * @param _pairPriceDrop The new priceDrop value for the pair (in wad)\n     */\n    function increasePairPriceDrop(address _assetA, address _assetB, uint256 _pairPriceDrop) external;\n\n    /**\n     * @notice Add or update price feed for assets pair. For only the admin role.\n     * @param assetA The first currency within the currency pair quotation (the base currency).\n     * @param assetB The second currency within the currency pair quotation (the quote currency).\n     * @param priceFeed The chain link price feed address for the pair assetA/assetB\n     */\n    function updatePriceFeed(address assetA, address assetB, address priceFeed) external;\n\n    /**\n     * @notice Sets the gas price feed contract address.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param priceFeed The address of the gas price feed contract.\n     */\n    function setGasPriceFeed(address priceFeed) external;\n\n    /**\n     * @notice Updates the priceDrop feed for a specific pair of assets.\n     * @dev Add or update priceDrop feed for assets pair.\n     * Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param assetA The address of the first asset in the pair.\n     * @param assetB The address of the second asset in the pair.\n     * @param priceDropFeed The chain link priceDrop feed address for the pair assetA/assetB\n     */\n    function updatePriceDropFeed(address assetA, address assetB, address priceDropFeed) external;\n\n    /**\n     * @notice Requests two priceFeeds - assetA/ETH and assetB/ETH (or assetA/USD and assetB/USD).\n     * @dev If there is no price feed found, the code will return a message that no price feed found.\n     * @param baseAsset The first currency within the currency pair quotation (the base currency).\n     * @param quoteAsset The second currency within the currency pair quotation (the quote currency).\n     * @return A tuple of basePriceFeed and quotePriceFeed. The addresses of the price feed for the base asset and quote asset respectively.\n     */\n    function getPriceFeedsPair(address baseAsset, address quoteAsset) external view returns (address, address);\n\n    /**\n     * @notice Requests priceFeed for the actual exchange rate for an assetA/assetB pair.\n     * @dev If no price feed for the pair found, USD and ETH are used as intermediate tokens.\n     * A price for assetA/assetB can be derived if two data feeds exist:\n     * assetA/ETH and assetB/ETH (or assetA/USD and assetB/USD).\n     * If there is no price feed found, the code will return a message that no price feed found.\n     * @param assetA The first currency within the currency pair quotation (the base currency).\n     * @param assetB The second currency within the currency pair quotation (the quote currency).\n     * @return exchangeRate for assetA/assetB in 10**18 decimality which will be recalucaled in PrimexPricingLibrary.\n     * @return direction of a pair as it stored in chainLinkPriceFeeds (i.e. returns 'true' for assetA/assetB, and 'false' for assetB/assetA).\n     * Throws if priceFeed wasn't found or priceFeed hasn't answer is 0.\n     */\n    function getExchangeRate(address assetA, address assetB) external view returns (uint256, bool);\n\n    /**\n     * @notice Retrieves the direct price feed for the given asset pair.\n     * @param assetA The address of the first asset.\n     * @param assetB The address of the second asset.\n     * @return priceFeed The address of the direct price feed.\n     */\n    function getDirectPriceFeed(address assetA, address assetB) external view returns (address);\n\n    /**\n     * @notice Retrieves the current gas price from the specified gas price feed.\n     * @return The current gas price.\n     */\n    function getGasPrice() external view returns (int256);\n\n    /**\n     * @notice For a given asset pair retrieves the priceDrop rate which is the higher\n     * of the oracle pair priceDrop and the historical pair priceDrop.\n     * @param _assetA The address of asset A.\n     * @param _assetB The address of asset B.\n     * @return The priceDrop rate.\n     */\n    function getPairPriceDrop(address _assetA, address _assetB) external view returns (uint256);\n\n    /**\n     * @notice Retrieves the priceDrop rate between two assets based on the oracle pair priceDrop.\n     * @param assetA The address of the first asset.\n     * @param assetB The address of the second asset.\n     * @return The priceDrop rate as a uint256 value.\n     */\n    function getOraclePriceDrop(address assetA, address assetB) external view returns (uint256);\n\n    /**\n     * @notice Retreives a priceDrop feed address from the oraclePriceDropFeeds mapping\n     * @param assetA The address of the first asset in the pair.\n     * @param assetB The address of the second asset in the pair.\n     * @return priceDropFeed The address of the priceDrop feed associated with the asset pair.\n     */\n    function getOraclePriceDropFeed(address assetA, address assetB) external view returns (address);\n}\n"
    },
    "contracts/PriceOracle/IPriceOracleStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IPriceOracleStorage {\n    function registry() external view returns (address);\n\n    function eth() external view returns (address);\n\n    function gasPriceFeed() external view returns (address);\n\n    function pairPriceDrops(address, address) external view returns (uint256);\n}\n"
    },
    "contracts/PriceOracle/PriceOracle.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport \"./PriceOracleStorage.sol\";\nimport \"../libraries/Errors.sol\";\n\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, NATIVE_CURRENCY, EMERGENCY_ADMIN, USD} from \"../Constants.sol\";\nimport {IPriceOracle} from \"./IPriceOracle.sol\";\n\ncontract PriceOracle is IPriceOracle, PriceOracleStorage {\n    using WadRayMath for uint256;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 role) {\n        _require(IAccessControl(registry).hasRole(role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function initialize(address _registry, address _eth) external override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n        eth = _eth;\n        __ERC165_init();\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function increasePairPriceDrop(\n        address _assetA,\n        address _assetB,\n        uint256 _pairPriceDrop\n    ) external override onlyRole(EMERGENCY_ADMIN) {\n        _require(\n            _pairPriceDrop > pairPriceDrops[_assetA][_assetB] && _pairPriceDrop <= WadRayMath.WAD / 2,\n            Errors.PAIR_PRICE_DROP_IS_NOT_CORRECT.selector\n        );\n        _setPairPriceDrop(_assetA, _assetB, _pairPriceDrop);\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function setPairPriceDrop(\n        address _assetA,\n        address _assetB,\n        uint256 _pairPriceDrop\n    ) external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _require(_pairPriceDrop > 0 && _pairPriceDrop < WadRayMath.WAD, Errors.PAIR_PRICE_DROP_IS_NOT_CORRECT.selector);\n        _setPairPriceDrop(_assetA, _assetB, _pairPriceDrop);\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function updatePriceDropFeed(\n        address assetA,\n        address assetB,\n        address priceDropFeed\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(assetA != assetB, Errors.IDENTICAL_TOKEN_ADDRESSES.selector);\n        oraclePriceDropFeeds[assetA][assetB] = priceDropFeed;\n        emit PriceDropFeedUpdated(assetA, assetB, priceDropFeed);\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function updatePriceFeed(\n        address assetA,\n        address assetB,\n        address priceFeed\n    ) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(assetA != assetB, Errors.IDENTICAL_TOKEN_ADDRESSES.selector);\n        chainLinkPriceFeeds[assetA][assetB] = priceFeed;\n        emit PriceFeedUpdated(assetA, assetB, priceFeed);\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function getExchangeRate(address assetA, address assetB) external view override returns (uint256, bool) {\n        address priceFeed = chainLinkPriceFeeds[assetA][assetB];\n        bool isForward = true;\n\n        if (priceFeed == address(0)) {\n            priceFeed = chainLinkPriceFeeds[assetB][assetA];\n            if (priceFeed == address(0)) {\n                (address basePriceFeed, address quotePriceFeed) = getPriceFeedsPair(assetA, assetB);\n\n                (, int256 basePrice, , , ) = AggregatorV3Interface(basePriceFeed).latestRoundData();\n                (, int256 quotePrice, , , ) = AggregatorV3Interface(quotePriceFeed).latestRoundData();\n\n                _require(basePrice > 0 && quotePrice > 0, Errors.ZERO_EXCHANGE_RATE.selector);\n                //the return value will always be 18 decimals if the basePrice and quotePrice have the same decimals\n                return (uint256(basePrice).wdiv(uint256(quotePrice)), true);\n            }\n            isForward = false;\n        }\n\n        (, int256 answer, , , ) = AggregatorV3Interface(priceFeed).latestRoundData();\n        _require(answer > 0, Errors.ZERO_EXCHANGE_RATE.selector);\n\n        uint256 answerDecimals = AggregatorV3Interface(priceFeed).decimals();\n        return ((uint256(answer) * 10 ** (18 - answerDecimals)), isForward);\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function getDirectPriceFeed(address assetA, address assetB) external view override returns (address) {\n        _require(assetA != assetB, Errors.IDENTICAL_TOKEN_ADDRESSES.selector);\n        address priceFeed = chainLinkPriceFeeds[assetA][assetB];\n        _require(priceFeed != address(0), Errors.NO_PRICEFEED_FOUND.selector);\n        return priceFeed;\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function getPairPriceDrop(address _assetA, address _assetB) external view override returns (uint256 priceDrop) {\n        uint256 oraclePairPriceDrop = getOraclePriceDrop(_assetA, _assetB);\n        uint256 pairPriceDrop = pairPriceDrops[_assetA][_assetB];\n        priceDrop = pairPriceDrop > oraclePairPriceDrop ? pairPriceDrop : oraclePairPriceDrop;\n        if (priceDrop > WadRayMath.WAD) return WadRayMath.WAD;\n        return priceDrop;\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function getOraclePriceDropFeed(address assetA, address assetB) external view override returns (address) {\n        _require(assetA != assetB, Errors.IDENTICAL_TOKEN_ADDRESSES.selector);\n        address priceDropFeed = oraclePriceDropFeeds[assetA][assetB];\n        _require(priceDropFeed != address(0), Errors.NO_PRICE_DROP_FEED_FOUND.selector);\n        return priceDropFeed;\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function setGasPriceFeed(address priceFeed) public override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        gasPriceFeed = priceFeed;\n        emit GasPriceFeedChanged(priceFeed);\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function getOraclePriceDrop(address assetA, address assetB) public view override returns (uint256) {\n        address priceDropFeed = oraclePriceDropFeeds[assetA][assetB];\n        if (priceDropFeed == address(0)) return 0;\n        (, int256 answer, , , ) = AggregatorV3Interface(priceDropFeed).latestRoundData();\n        uint256 answerDecimals = AggregatorV3Interface(priceDropFeed).decimals();\n        return (uint256(answer) * 10 ** (18 - answerDecimals));\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function getPriceFeedsPair(\n        address baseAsset,\n        address quoteAsset\n    ) public view override returns (address basePriceFeed, address quotePriceFeed) {\n        _require(baseAsset != quoteAsset, Errors.IDENTICAL_TOKEN_ADDRESSES.selector);\n        basePriceFeed = chainLinkPriceFeeds[baseAsset][USD];\n        quotePriceFeed = chainLinkPriceFeeds[quoteAsset][USD];\n\n        if (basePriceFeed == address(0) || quotePriceFeed == address(0)) {\n            basePriceFeed = chainLinkPriceFeeds[baseAsset][eth];\n            quotePriceFeed = chainLinkPriceFeeds[quoteAsset][eth];\n            _require(basePriceFeed != address(0) && quotePriceFeed != address(0), Errors.NO_PRICEFEED_FOUND.selector);\n        }\n    }\n\n    /**\n     * @inheritdoc IPriceOracle\n     */\n    function getGasPrice() public view override returns (int256 price) {\n        if (gasPriceFeed != address(0)) (, price, , , ) = AggregatorV3Interface(gasPriceFeed).latestRoundData();\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IPriceOracle).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @notice Sets the priceDrop for a pair of assets.\n     * @param _assetA The address of the first asset in the pair.\n     * @param _assetB The address of the second asset in the pair.\n     * @param _pairPriceDrop The priceDrop value in WAD format to be set for the pair.\n     */\n    function _setPairPriceDrop(address _assetA, address _assetB, uint256 _pairPriceDrop) internal {\n        _require(_assetA != address(0) && _assetB != address(0), Errors.ASSET_ADDRESS_NOT_SUPPORTED.selector);\n        _require(_assetA != _assetB, Errors.IDENTICAL_ASSET_ADDRESSES.selector);\n        pairPriceDrops[_assetA][_assetB] = _pairPriceDrop;\n        emit PairPriceDropChanged(_assetA, _assetB, _pairPriceDrop);\n    }\n}\n"
    },
    "contracts/PriceOracle/PriceOracleStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport {IPriceOracleStorage} from \"./IPriceOracleStorage.sol\";\n\nabstract contract PriceOracleStorage is IPriceOracleStorage, ERC165Upgradeable {\n    address public override registry;\n    address public override eth;\n    address public override gasPriceFeed;\n\n    // PriceDrop of asset A relative to asset B\n    mapping(address => mapping(address => uint256)) public override pairPriceDrops;\n\n    /**\n     * @notice The mapping stores priceDrop feeds adresses associated with the asset pair.\n     * @dev 'The address of the first asset in the pair' -> ' The address of the second asset in the pair' -> 'priceDrop feed address'\n     */\n    mapping(address => mapping(address => address)) internal oraclePriceDropFeeds;\n\n    /**\n     * @notice The mapping stores price feeds for currency pairs.\n     * @dev 'base currency address' -> 'quote currency address' -> 'price feed address'\n     */\n    mapping(address => mapping(address => address)) internal chainLinkPriceFeeds;\n}\n"
    },
    "contracts/PrimexDNS/IPrimexDNS.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IPrimexDNSStorage, IPrimexDNSStorageV2} from \"./IPrimexDNSStorage.sol\";\n\ninterface IPrimexDNS is IPrimexDNSStorage {\n    event AddNewBucket(BucketData newBucketData);\n    event BucketDeprecated(address bucketAddress, uint256 delistingTime);\n    event AddNewDex(DexData newDexData);\n    event ChangeFeeRate(OrderType orderType, address token, uint256 rate);\n    event ConditionalManagerChanged(uint256 indexed cmType, address indexed cmAddress);\n    event PMXchanged(address indexed pmx);\n    event AavePoolChanged(address indexed aavePool);\n    event BucketActivated(address indexed bucketAddress);\n    event BucketFrozen(address indexed bucketAddress);\n    event DexAdapterChanged(address indexed newAdapterAddress);\n    event DexActivated(address indexed routerAddress);\n    event DexFrozen(address indexed routerAddress);\n\n    /**\n     * @param orderType The order type for which the rate is set\n     * @param feeToken The token address for which the rate is set\n     * @param rate Setting rate in WAD format (1 WAD = 100%)\n     */\n    struct FeeRateParams {\n        OrderType orderType;\n        address feeToken;\n        uint256 rate;\n    }\n\n    /**\n     * @notice Initializes the contract with the specified parameters.\n     * @param _registry The address of the PrimexRegistry contract.\n     * @param _pmx The address of the PMX token contract.\n     * @param _treasury The address of the Treasury contract.\n     * @param _delistingDelay The time (in seconds) between deprecation and delisting of a bucket.\n     * @param _adminWithdrawalDelay The time (in seconds) between delisting of a bucket and an adminDeadline.\n     * @param _feeRateParams Initial fee params\n     */\n    function initialize(\n        address _registry,\n        address _pmx,\n        address _treasury,\n        uint256 _delistingDelay,\n        uint256 _adminWithdrawalDelay,\n        FeeRateParams[] calldata _feeRateParams\n    ) external;\n\n    /**\n     * @notice Deprecates a bucket.\n     * @dev This function is used to deprecate a bucket by changing its current status to \"Deprecated\".\n     * Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _bucket The name of the bucket to deprecate.\n     * Emits a BucketDeprecated event with the bucket address and the delisting time.\n     */\n    function deprecateBucket(string memory _bucket) external;\n\n    /**\n     * @notice This function is used to set the address of the Aave pool contract.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _aavePool The address of the Aave pool contract to be set.\n     */\n    function setAavePool(address _aavePool) external;\n\n    /**\n     * @notice Sets the protocol rate in PMX.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     */\n    function setFeeRate(FeeRateParams calldata _feeRateParams) external;\n\n    /**\n     * @notice Sets the address of the PMX token contract.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _pmx The address of the PMX token contract.\n     */\n    function setPMX(address _pmx) external;\n\n    /**\n     * @notice Activates a bucket by changing its status from inactive to active.\n     * @dev Only callable by the SMALL_TIMELOCK_ADMIN role.\n     * @param _bucket The bucket to activate.\n     */\n    function activateBucket(string memory _bucket) external;\n\n    /**\n     * @notice Freezes a bucket, preventing further operations on it,\n     * by changing its status from active to inactive.\n     * @dev Only callable by the EMERGENCY_ADMIN role.\n     * @param _bucket The bucket to be frozen.\n     */\n    function freezeBucket(string memory _bucket) external;\n\n    /**\n     * @notice Adds a new bucket.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param _newBucket The address of the new bucket to be added.\n     * @param _pmxRewardAmount The amount of PMX tokens to be rewarded from the bucket.\n     * Emits a AddNewBucket event with the struct BucketData of the newly added bucket.\n     */\n    function addBucket(address _newBucket, uint256 _pmxRewardAmount) external;\n\n    /**\n     * @notice Activates a DEX by changing flag isActive on to true.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _dex The name of the DEX to activate.\n     */\n    function activateDEX(string memory _dex) external;\n\n    /**\n     * @notice Freezes a DEX by changing flag isActive to false.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _dex The name of the DEX to be frozen.\n     */\n    function freezeDEX(string memory _dex) external;\n\n    /**\n     * @notice Adds a new DEX to the protocol.\n     * @dev Only callable by the MEDIUM_TIMELOCK_ADMIN role.\n     * @param _name The name of the DEX.\n     * @param _routerAddress The address of the DEX router.\n     */\n    function addDEX(string memory _name, address _routerAddress) external;\n\n    /**\n     * @notice Sets the address of the DEX adapter.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param newAdapterAddress The address of the new DEX adapter.\n     */\n    function setDexAdapter(address newAdapterAddress) external;\n\n    /**\n     * @dev The function to specify the address of conditional manager of some type\n     * 1 => LimitPriceCOM\n     * 2 => TakeProfitStopLossCCM\n     * 3 => TrailingStopCCM\n     * @param _address Address to be set for a conditional manager\n     * @param _cmType The type of a conditional manager\n     */\n    function setConditionalManager(uint256 _cmType, address _address) external;\n\n    /**\n     * @notice Retrieves the address of a bucket by its name.\n     * @param _name The name of the bucket.\n     * @return The address of the bucket.\n     */\n    function getBucketAddress(string memory _name) external view returns (address);\n\n    /**\n     * @notice Retrieves the address of the DEX router based on the given DEX name.\n     * @param _name The name of the DEX.\n     * @return The address of the DEX router.\n     */\n    function getDexAddress(string memory _name) external view returns (address);\n\n    /**\n     * @notice Retrieves the names of Dexes registered in the protocol.\n     * @return An array of strings containing the names of all Dexes.\n     */\n    function getAllDexes() external view returns (string[] memory);\n}\n\ninterface IPrimexDNSV2 is IPrimexDNS, IPrimexDNSStorageV2 {\n    event ChangeFeeRestrictions(OrderType indexed orderType, FeeRestrictions feeRestrictions);\n\n    /**\n     * @notice Set the protocol fee restriction for one type of order.\n     * @dev Only callable by the BIG_TIMELOCK_ADMIN role.\n     */\n    function setFeeRestrictions(OrderType _orderType, FeeRestrictions calldata _feeRestrictions) external;\n}\n"
    },
    "contracts/PrimexDNS/IPrimexDNSStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IPrimexDNSStorage {\n    enum Status {\n        Inactive,\n        Active,\n        Deprecated\n    }\n\n    enum OrderType {\n        MARKET_ORDER,\n        LIMIT_ORDER,\n        SWAP_MARKET_ORDER,\n        SWAP_LIMIT_ORDER\n    }\n\n    struct BucketData {\n        address bucketAddress;\n        Status currentStatus;\n        uint256 delistingDeadline;\n        // The deadline is for the admin to call Bucket.withdrawAfterDelisting().\n        uint256 adminDeadline;\n    }\n    struct DexData {\n        address routerAddress;\n        bool isActive;\n    }\n\n    struct AdapterData {\n        string[] dexes;\n        bool isAdded;\n    }\n\n    function registry() external view returns (address);\n\n    function delistingDelay() external view returns (uint256);\n\n    function adminWithdrawalDelay() external view returns (uint256);\n\n    function buckets(string memory) external view returns (address, Status, uint256, uint256);\n\n    function dexes(string memory) external view returns (address, bool);\n\n    function cmTypeToAddress(uint256 cmType) external view returns (address);\n\n    function dexAdapter() external view returns (address);\n\n    function pmx() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function aavePool() external view returns (address);\n\n    function feeRates(OrderType _orderType, address _token) external view returns (uint256);\n}\n\ninterface IPrimexDNSStorageV2 is IPrimexDNSStorage {\n    struct FeeRestrictions {\n        uint256 minProtocolFee;\n        uint256 maxProtocolFee;\n    }\n\n    function feeRestrictions(\n        OrderType _orderType\n    ) external view returns (uint256 minProtocolFee, uint256 maxProtocolFee);\n}\n"
    },
    "contracts/PrimexDNS/PrimexDNS.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport \"./PrimexDNSStorage.sol\";\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \"../Constants.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\nimport {IPrimexDNSV2, IPrimexDNS} from \"./IPrimexDNS.sol\";\nimport {IDexAdapter} from \"../interfaces/IDexAdapter.sol\";\nimport {ILiquidityMiningRewardDistributor} from \"../LiquidityMiningRewardDistributor/ILiquidityMiningRewardDistributor.sol\";\nimport {ITreasury} from \"../Treasury/ITreasury.sol\";\nimport {IConditionalClosingManager} from \"../interfaces/IConditionalClosingManager.sol\";\nimport {IConditionalOpeningManager} from \"../interfaces/IConditionalOpeningManager.sol\";\n\ncontract PrimexDNS is IPrimexDNSV2, PrimexDNSStorageV2 {\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function initialize(\n        address _registry,\n        address _pmx,\n        address _treasury,\n        uint256 _delistingDelay,\n        uint256 _adminWithdrawalDelay,\n        FeeRateParams[] calldata _feeRateParams\n    ) public override initializer {\n        _require(\n            IERC165Upgradeable(_pmx).supportsInterface(type(IERC20).interfaceId) &&\n                IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(_treasury).supportsInterface(type(ITreasury).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        for (uint256 i; i < _feeRateParams.length; i++) {\n            _setFeeRate(_feeRateParams[i]);\n        }\n        pmx = _pmx;\n        registry = _registry;\n        treasury = _treasury;\n        delistingDelay = _delistingDelay;\n        adminWithdrawalDelay = _adminWithdrawalDelay;\n        __ERC165_init();\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function setConditionalManager(uint256 _cmType, address _address) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165Upgradeable(_address).supportsInterface(type(IConditionalOpeningManager).interfaceId) ||\n                IERC165Upgradeable(_address).supportsInterface(type(IConditionalClosingManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        cmTypeToAddress[_cmType] = _address;\n        emit ConditionalManagerChanged(_cmType, _address);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function setPMX(address _pmx) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165Upgradeable(_pmx).supportsInterface(type(IERC20).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        pmx = _pmx;\n        emit PMXchanged(_pmx);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function setFeeRate(FeeRateParams calldata _feeRateParams) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _setFeeRate(_feeRateParams);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNSV2\n     */\n    function setFeeRestrictions(\n        OrderType _orderType,\n        FeeRestrictions calldata _feeRestrictions\n    ) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            _feeRestrictions.minProtocolFee <= _feeRestrictions.maxProtocolFee,\n            Errors.INCORRECT_RESTRICTIONS.selector\n        );\n        feeRestrictions[_orderType] = _feeRestrictions;\n        emit ChangeFeeRestrictions(_orderType, _feeRestrictions);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function setAavePool(address _aavePool) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        aavePool = _aavePool;\n        emit AavePoolChanged(_aavePool);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function deprecateBucket(string memory _bucket) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        BucketData storage bucket = buckets[_bucket];\n        _require(bucket.currentStatus != Status.Deprecated, Errors.BUCKET_IS_ALREADY_DEPRECATED.selector);\n        bucket.currentStatus = Status.Deprecated;\n        uint256 delistingDeadline = block.timestamp + delistingDelay;\n        bucket.delistingDeadline = delistingDeadline;\n        bucket.adminDeadline = delistingDeadline + adminWithdrawalDelay;\n        emit BucketDeprecated(bucket.bucketAddress, delistingDeadline);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function activateBucket(string memory _bucket) external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        BucketData storage bucket = buckets[_bucket];\n        _require(bucket.currentStatus == Status.Inactive, Errors.BUCKET_ALREADY_ACTIVATED.selector);\n        _require(bucket.bucketAddress != address(0), Errors.BUCKET_NOT_ADDED.selector);\n        bucket.currentStatus = Status.Active;\n        emit BucketActivated(bucket.bucketAddress);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function freezeBucket(string memory _bucket) external override onlyRole(EMERGENCY_ADMIN) {\n        _require(buckets[_bucket].currentStatus == Status.Active, Errors.BUCKET_ALREADY_FROZEN.selector);\n        buckets[_bucket].currentStatus = Status.Inactive;\n        emit BucketFrozen(buckets[_bucket].bucketAddress);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function addBucket(address _newBucket, uint256 _pmxRewardAmount) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165Upgradeable(_newBucket).supportsInterface(type(IBucket).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        string memory name = IBucket(_newBucket).name();\n        _require(buckets[name].bucketAddress == address(0), Errors.BUCKET_IS_ALREADY_ADDED.selector);\n\n        IBucket.LiquidityMiningParams memory params = IBucket(_newBucket).getLiquidityMiningParams();\n        if (params.accumulatingAmount != 0) {\n            // can be changed on transferAsset in traderBalanceVault to moving untransferable token\n            IERC20(pmx).transferFrom(msg.sender, address(params.liquidityMiningRewardDistributor), _pmxRewardAmount);\n            params.liquidityMiningRewardDistributor.updateBucketReward(name, _pmxRewardAmount);\n        }\n\n        BucketData memory newBucket = BucketData(_newBucket, Status.Active, 0, 0);\n        buckets[name] = newBucket;\n        emit AddNewBucket(newBucket);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function activateDEX(string memory _dex) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(!dexes[_dex].isActive, Errors.DEX_IS_ALREADY_ACTIVATED.selector);\n        dexes[_dex].isActive = true;\n        emit DexActivated(dexes[_dex].routerAddress);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function freezeDEX(string memory _dex) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(dexes[_dex].isActive, Errors.DEX_IS_ALREADY_FROZEN.selector);\n        dexes[_dex].isActive = false;\n        emit DexFrozen(dexes[_dex].routerAddress);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function addDEX(string memory _name, address _routerAddress) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(dexes[_name].routerAddress == address(0), Errors.DEX_IS_ALREADY_ADDED.selector);\n        _require(_routerAddress != address(0), Errors.CAN_NOT_ADD_WITH_ZERO_ADDRESS.selector);\n        dexesNames.push(_name);\n        DexData memory newDEX = DexData(_routerAddress, true);\n        dexes[_name] = newDEX;\n        emit AddNewDex(newDEX);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function setDexAdapter(address _newAdapterAddress) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165Upgradeable(_newAdapterAddress).supportsInterface(type(IDexAdapter).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        dexAdapter = _newAdapterAddress;\n        emit DexAdapterChanged(_newAdapterAddress);\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function getAllDexes() external view override returns (string[] memory) {\n        return dexesNames;\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function getBucketAddress(string memory _name) external view override returns (address) {\n        BucketData memory bucket = buckets[_name];\n        _require(bucket.bucketAddress != address(0), Errors.BUCKET_NOT_ADDED.selector);\n        _require(bucket.currentStatus == Status.Active, Errors.BUCKET_IS_INACTIVE.selector);\n        return bucket.bucketAddress;\n    }\n\n    /**\n     * @inheritdoc IPrimexDNS\n     */\n    function getDexAddress(string memory _name) external view override returns (address) {\n        DexData memory dex = dexes[_name];\n        _require(dex.routerAddress != address(0), Errors.DEX_NOT_ADDED.selector);\n        _require(dex.isActive, Errors.DEX_NOT_ACTIVE.selector);\n        return dex.routerAddress;\n    }\n\n    /**\n     * @notice Interface checker\n     * @param interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IPrimexDNSV2).interfaceId ||\n            interfaceId == type(IPrimexDNS).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _setFeeRate(FeeRateParams calldata _feeRateParams) internal {\n        _require(_feeRateParams.rate <= WadRayMath.WAD, Errors.INCORRECT_FEE_RATE.selector);\n        feeRates[_feeRateParams.orderType][_feeRateParams.feeToken] = _feeRateParams.rate;\n        emit ChangeFeeRate(_feeRateParams.orderType, _feeRateParams.feeToken, _feeRateParams.rate);\n    }\n}\n"
    },
    "contracts/PrimexDNS/PrimexDNSStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport {IPrimexDNSStorage, IPrimexDNSStorageV2} from \"./IPrimexDNSStorage.sol\";\n\nabstract contract PrimexDNSStorage is IPrimexDNSStorage, ERC165Upgradeable {\n    address public override registry;\n\n    /**\n     * @notice check the scheme below for additional info\n     */\n    uint256 public override delistingDelay;\n    uint256 public override adminWithdrawalDelay;\n\n    /* solhint-disable max-line-length */\n    //                                          =========================================================\n    //                                            \"delistingDelay\" and \"adminWithdrawalDelay\" explained\n    //                                          =========================================================\n\n    //                  * Lenders can’t add liquidity to Bucket.         * Keepers can close all positions opened                * Admin can withdraw all funds from the bucket to Treasury.\n    //                  * New positions or orders can’t be opened          through this Bucket.                                  * Admin can withdraw to Treasury all PMX rewards granted to\n    //                    in this Bucket.                                * Lenders can withdraw their funds, which became          this bucket for liquidity mining (except already withdrawn amount).\n    //                  * Lenders can withdraw existing deposits,          available after all positions were closed by\n    //                    traders can close existing positions.            keepers.\n    //\n    //                |----------------delistingDelay------------------|---------------adminWithdrawalDelay------------------|---------------------------------------------------------------\n    //                |                                                |                                                     |\n    //      ----------|------------------------------------------------|-----------------------------------------------------|---------------------------------------------------------------\n    //                |                                        delistingDeadline                                        adminDeadline\n    //      -= bucket is DEPRECATED =-                      -= bucket is DELISTED =-\n    //\n    //\n    /* solhint-enable max-line-length */\n\n    address public override pmx;\n    address public override treasury;\n    mapping(string => BucketData) public override buckets;\n    mapping(string => DexData) public override dexes;\n    mapping(uint256 => address) public override cmTypeToAddress;\n    address public override dexAdapter;\n    address public override aavePool;\n\n    // action to token to fee amount\n    mapping(OrderType => mapping(address => uint256)) public override feeRates;\n\n    string[] internal dexesNames;\n}\n\nabstract contract PrimexDNSStorageV2 is IPrimexDNSStorageV2, PrimexDNSStorage {\n    mapping(OrderType => FeeRestrictions) public override feeRestrictions;\n}\n"
    },
    "contracts/PrimexProxyAdmin.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ProxyAdmin, ITransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport \"./libraries/Errors.sol\";\nimport {BIG_TIMELOCK_ADMIN} from \"./Constants.sol\";\nimport {IPrimexProxyAdmin} from \"./interfaces/IPrimexProxyAdmin.sol\";\n\n/**\n * @dev This is openzeppelin proxy admin with AccessControl access.\n * Also, there remains the functionality of the Ownable contract\n * for compatibility with the hardhat-deploy plugin,\n * but it does not give privileged access\n */\ncontract PrimexProxyAdmin is ProxyAdmin, IPrimexProxyAdmin {\n    address public immutable registry;\n\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(address _registry) {\n        _transferOwnership(address(this));\n        _require(\n            IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(\n        ITransparentUpgradeableProxy proxy,\n        address newAdmin\n    ) public override onlyRole(BIG_TIMELOCK_ADMIN) {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Changes the admin of the `beacon` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeBeaconProxyAdmin(\n        UpgradeableBeacon beacon,\n        address newAdmin\n    ) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        beacon.transferOwnership(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(\n        ITransparentUpgradeableProxy proxy,\n        address implementation\n    ) public override onlyRole(BIG_TIMELOCK_ADMIN) {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        ITransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable override onlyRole(BIG_TIMELOCK_ADMIN) {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n\n    /**\n     * @dev Upgrades the beacon to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     * - implementation must be a contract.\n     */\n\n    function upgradeBeacon(\n        UpgradeableBeacon beacon,\n        address implementation\n    ) public override onlyRole(BIG_TIMELOCK_ADMIN) {\n        beacon.upgradeTo(implementation);\n    }\n}\n"
    },
    "contracts/PrimexRegistry.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport \"./libraries/Errors.sol\";\n\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \"./Constants.sol\";\nimport {IPrimexRegistry} from \"./interfaces/IPrimexRegistry.sol\";\n\ncontract PrimexRegistry is IPrimexRegistry, AccessControl {\n    constructor() {\n        _grantRole(BIG_TIMELOCK_ADMIN, msg.sender);\n        // MEDIUM_TIMELOCK_ADMIN is admin for SMALL_TIMELOCK_ADMIN\n        _setRoleAdmin(SMALL_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN);\n        // SMALL_TIMELOCK_ADMIN is admin for EMERGENCY_ADMIN\n        _setRoleAdmin(EMERGENCY_ADMIN, SMALL_TIMELOCK_ADMIN);\n        // BIG_TIMELOCK_ADMIN is admin for other roles\n    }\n\n    /**\n     * @inheritdoc IPrimexRegistry\n     */\n    mapping(bytes32 => bool) public override isRoleForContractsOnly;\n\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    /**\n     * @inheritdoc IPrimexRegistry\n     */\n    function setRolesForContractsOnly(bytes32[] calldata roles) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        for (uint256 i; i < roles.length; i++) {\n            isRoleForContractsOnly[roles[i]] = true;\n        }\n    }\n\n    /**\n     * @inheritdoc IPrimexRegistry\n     */\n    function removeRolesForContractsOnly(bytes32[] calldata roles) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        for (uint256 i; i < roles.length; i++) {\n            isRoleForContractsOnly[roles[i]] = false;\n        }\n    }\n\n    function grantRole(bytes32 role, address account) public override(AccessControl, IPrimexRegistry) {\n        if (isRoleForContractsOnly[role]) {\n            _require(account.code.length > 0, Errors.ADDRESS_IS_NOT_CONTRACT.selector);\n        }\n        super.grantRole(role, account);\n    }\n}\n"
    },
    "contracts/PrimexTimelock.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/governance/TimelockController.sol\";\n\nimport \"./libraries/Errors.sol\";\n\nimport {GUARDIAN_ADMIN} from \"./Constants.sol\";\nimport {IPausable} from \"./interfaces/IPausable.sol\";\n\ncontract PrimexTimelock is IPausable, TimelockController, Pausable {\n    address public immutable registry;\n\n    /**\n     * @dev Modifier that allows only the Guardian admin to access the function.\n     * Throws an error if the sender does not have the GUARDIAN_ADMIN role.\n     */\n    modifier onlyGuardian() {\n        _require(IAccessControl(registry).hasRole(GUARDIAN_ADMIN, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(\n        uint256 _minDelay,\n        address[] memory _proposers,\n        address[] memory _executors,\n        address _admin,\n        address _registry\n    ) TimelockController(_minDelay, _proposers, _executors, _admin) {\n        _require(\n            IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyGuardian {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyGuardian {\n        _unpause();\n    }\n\n    /**\n     * @notice This function overrides a function in the parent contract.\n     * @dev The function will revert with the `OPERATION_NOT_SUPPORTED` error.\n     */\n    function updateDelay(uint256) external pure override {\n        _revert(Errors.OPERATION_NOT_SUPPORTED.selector);\n    }\n\n    /**\n     * @dev Schedules a transaction to be executed in the future.\n     * This function can only be called when the contract is not paused.\n     * Only callable by the PROPOSER_ROLE role.\n     * @param target The address of the contract to be called.\n     * @param value The amount of native tokens (in wei) to be sent with the transaction.\n     * @param data The data to be passed to the contract's function.\n     * @param predecessor The hash of the preceding transaction in the same function.\n     * @param salt A random value used as a salt for the scheduled transaction.\n     * @param delay The delay, in seconds, before the transaction can be executed.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public override whenNotPaused {\n        super.schedule(target, value, data, predecessor, salt, delay);\n    }\n\n    /**\n     * @dev Schedules a batch of transactions to be executed after a specified delay.\n     * This function can only be called when the contract is not paused.\n     * Only callable by the PROPOSER_ROLE role.\n     * @param targets The array of target addresses for the transactions.\n     * @param values The array of values to be sent with each transaction.\n     * @param payloads The array of payload data for each transaction.\n     * @param predecessor The predecessor hash for the batch of transactions.\n     * @param salt The salt value for generating the schedule hash.\n     * @param delay The delay in seconds after which the transactions can be executed.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public override whenNotPaused {\n        super.scheduleBatch(targets, values, payloads, predecessor, salt, delay);\n    }\n\n    /**\n     * @notice Cancels a specific task by its ID.\n     * @dev This function can only be called by a guardian admin.\n     * @param id The ID of the task to be canceled.\n     */\n    function cancel(bytes32 id) public override {\n        bool isGuardian = IAccessControl(registry).hasRole(GUARDIAN_ADMIN, msg.sender);\n        if (isGuardian) {\n            _grantRole(CANCELLER_ROLE, msg.sender);\n        }\n        super.cancel(id);\n        if (isGuardian) {\n            _revokeRole(CANCELLER_ROLE, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Executes a transaction to the specified target with the given parameters.\n     * @dev This function can only be called when the contract is not paused.\n     * Only callable by the EXECUTOR_ROLE role.\n     * @param target The address of the contract to execute the transaction on.\n     * @param value The amount of native tokens (in wei) to send along with the transaction.\n     * @param payload The data payload to include in the transaction.\n     * @param predecessor The predecessor of the transaction (optional).\n     * @param salt The salt value to use for the transaction (optional).\n     */\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable override whenNotPaused {\n        super.execute(target, value, payload, predecessor, salt);\n    }\n\n    /**\n     * @notice Executes a batch of transactions.\n     * @dev This function can only be called when the contract is not paused.\n     * Only callable by the EXECUTOR_ROLE role.\n     * @param targets The array of target addresses for the transactions.\n     * @param values The array of values to be sent with each transaction.\n     * @param payloads The array of payload data for each transaction.\n     * @param predecessor The predecessor block's hash.\n     * @param salt The salt value for generating a deterministic pseudo-random address.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable override whenNotPaused {\n        super.executeBatch(targets, values, payloads, predecessor, salt);\n    }\n}\n"
    },
    "contracts/PrimexUpkeep.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {LimitOrderLibrary} from \"./libraries/LimitOrderLibrary.sol\";\nimport {PrimexPricingLibrary} from \"./libraries/PrimexPricingLibrary.sol\";\nimport {PositionLibrary} from \"./libraries/PositionLibrary.sol\";\nimport \"./libraries/Errors.sol\";\n\nimport {BIG_TIMELOCK_ADMIN} from \"./Constants.sol\";\nimport {IPositionManager} from \"./PositionManager/IPositionManager.sol\";\nimport {ILimitOrderManager} from \"./LimitOrderManager/ILimitOrderManager.sol\";\nimport {IPrimexUpkeep} from \"./interfaces/IPrimexUpkeep.sol\";\nimport {IBestDexLens} from \"./interfaces/IBestDexLens.sol\";\nimport {IPrimexLens} from \"./interfaces/IPrimexLens.sol\";\nimport {ILimitPriceCOM} from \"./interfaces/ILimitPriceCOM.sol\";\nimport {ITakeProfitStopLossCCM} from \"./interfaces/ITakeProfitStopLossCCM.sol\";\n\ncontract PrimexUpkeep is IPrimexUpkeep {\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n\n    IPositionManager public immutable override pm;\n    ILimitOrderManager public immutable override lom;\n    IPrimexLens public immutable override primexLens;\n    address public immutable override registry;\n    IBestDexLens public immutable override bestDexLens;\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(\n        IPositionManager _positionManager,\n        ILimitOrderManager _limitOrderManager,\n        address _registry,\n        IBestDexLens _bestDexLens,\n        IPrimexLens _primexLens\n    ) {\n        _require(\n            IERC165(address(_bestDexLens)).supportsInterface(type(IBestDexLens).interfaceId) &&\n                IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165(address(_positionManager)).supportsInterface(type(IPositionManager).interfaceId) &&\n                IERC165(address(_primexLens)).supportsInterface(type(IPrimexLens).interfaceId) &&\n                IERC165(address(_limitOrderManager)).supportsInterface(type(ILimitOrderManager).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        pm = _positionManager;\n        lom = _limitOrderManager;\n        registry = _registry;\n        bestDexLens = _bestDexLens;\n        primexLens = _primexLens;\n    }\n\n    /**\n     * @inheritdoc IPrimexUpkeep\n     */\n    function checkUpkeep(\n        bytes calldata checkData,\n        IBestDexLens.DexWithAncillaryData[] memory _dexesWithAncillaryData,\n        uint256 _cursor,\n        uint256 _count,\n        uint256 _outputSize\n    ) external override returns (uint256 newCursor, bool upkeepNeeded, bytes memory performData) {\n        _require(_outputSize > 0, Errors.NUMBER_IS_0.selector);\n        LiquidationSource liquidationSource = abi.decode(checkData, (LiquidationSource));\n\n        if (liquidationSource == LiquidationSource.POSITION) {\n            return\n                _checkPositionUpkeep(\n                    CheckUpkeepParams({\n                        dexes: _dexesWithAncillaryData,\n                        cursor: _cursor,\n                        count: _count,\n                        outputSize: _outputSize\n                    })\n                );\n        } else if (liquidationSource == LiquidationSource.ORDER) {\n            return\n                _checkOrderUpkeep(\n                    CheckUpkeepParams({\n                        dexes: _dexesWithAncillaryData,\n                        cursor: _cursor,\n                        count: _count,\n                        outputSize: _outputSize\n                    })\n                );\n        }\n    }\n\n    /**\n     * @inheritdoc IPrimexUpkeep\n     */\n    function performUpkeepOrders(OpenByOrderInfo[] calldata toOpenByOrder, address keeper) external override {\n        for (uint256 i; i < toOpenByOrder.length; i++) {\n            try\n                lom.openPositionByOrder(\n                    LimitOrderLibrary.OpenPositionParams({\n                        orderId: toOpenByOrder[i].id,\n                        conditionIndex: toOpenByOrder[i].conditionIndex,\n                        comAdditionalParams: toOpenByOrder[i].comAdditionalParams,\n                        firstAssetRoutes: toOpenByOrder[i].firstAssetRoutes,\n                        depositInThirdAssetRoutes: toOpenByOrder[i].depositInThirdAssetRoutes,\n                        keeper: keeper\n                    })\n                )\n            {} catch Error(string memory revertReason) {\n                emit ErrorHandled(toOpenByOrder[i].id, keeper, revertReason);\n            } catch Panic(uint revertReason) {\n                emit PanicErrorHandled(revertReason);\n            } catch (bytes memory revertReason) {\n                emit LowLevelErrorHandled(revertReason);\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IPrimexUpkeep\n     */\n    function performUpkeepOrdersUnsafe(OpenByOrderInfo[] calldata toOpenByOrder, address keeper) external override {\n        for (uint256 i; i < toOpenByOrder.length; i++) {\n            lom.openPositionByOrder(\n                LimitOrderLibrary.OpenPositionParams({\n                    orderId: toOpenByOrder[i].id,\n                    conditionIndex: toOpenByOrder[i].conditionIndex,\n                    comAdditionalParams: toOpenByOrder[i].comAdditionalParams,\n                    firstAssetRoutes: toOpenByOrder[i].firstAssetRoutes,\n                    depositInThirdAssetRoutes: toOpenByOrder[i].depositInThirdAssetRoutes,\n                    keeper: keeper\n                })\n            );\n        }\n    }\n\n    /**\n     * @inheritdoc IPrimexUpkeep\n     */\n    function performUpkeepPositions(LiquidatePositionInfo[] calldata toLiquidate, address keeper) external override {\n        for (uint256 i; i < toLiquidate.length; i++) {\n            try\n                pm.closePositionByCondition(\n                    toLiquidate[i].id,\n                    keeper,\n                    toLiquidate[i].positionAssetRoutes,\n                    toLiquidate[i].conditionIndex,\n                    toLiquidate[i].ccmAdditionalParams,\n                    toLiquidate[i].closeReason\n                )\n            {} catch Error(string memory revertReason) {\n                emit ErrorHandled(toLiquidate[i].id, keeper, revertReason);\n            } catch Panic(uint revertReason) {\n                emit PanicErrorHandled(revertReason);\n            } catch (bytes memory revertReason) {\n                emit LowLevelErrorHandled(revertReason);\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IPrimexUpkeep\n     */\n    function performUpkeepPositionsUnsafe(\n        LiquidatePositionInfo[] calldata toLiquidate,\n        address keeper\n    ) external override {\n        for (uint256 i; i < toLiquidate.length; i++) {\n            pm.closePositionByCondition(\n                toLiquidate[i].id,\n                keeper,\n                toLiquidate[i].positionAssetRoutes,\n                toLiquidate[i].conditionIndex,\n                toLiquidate[i].ccmAdditionalParams,\n                toLiquidate[i].closeReason\n            );\n        }\n    }\n\n    /**\n     * @inheritdoc IPrimexUpkeep\n     */\n    function performUpkeep(bytes calldata performData, address keeper) external override {\n        (LiquidationSource liquidationSource, uint256 count) = abi.decode(\n            performData[:64],\n            (LiquidationSource, uint256)\n        );\n\n        if (liquidationSource == LiquidationSource.POSITION) {\n            (, , LiquidatePositionInfo[] memory toLiquidate) = abi.decode(\n                performData,\n                (LiquidationSource, uint256, LiquidatePositionInfo[])\n            );\n\n            for (uint256 i; i < count; i++) {\n                try\n                    pm.closePositionByCondition(\n                        toLiquidate[i].id,\n                        keeper,\n                        toLiquidate[i].positionAssetRoutes,\n                        toLiquidate[i].conditionIndex,\n                        toLiquidate[i].ccmAdditionalParams,\n                        toLiquidate[i].closeReason\n                    )\n                {} catch {}\n            }\n        } else if (liquidationSource == LiquidationSource.ORDER) {\n            (, , OpenByOrderInfo[] memory toOpenByOrder) = abi.decode(\n                performData,\n                (LiquidationSource, uint256, OpenByOrderInfo[])\n            );\n\n            for (uint256 i; i < count; i++) {\n                try\n                    lom.openPositionByOrder(\n                        LimitOrderLibrary.OpenPositionParams({\n                            orderId: toOpenByOrder[i].id,\n                            conditionIndex: toOpenByOrder[i].conditionIndex,\n                            comAdditionalParams: toOpenByOrder[i].comAdditionalParams,\n                            firstAssetRoutes: toOpenByOrder[i].firstAssetRoutes,\n                            depositInThirdAssetRoutes: toOpenByOrder[i].depositInThirdAssetRoutes,\n                            keeper: keeper\n                        })\n                    )\n                {} catch {}\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IPrimexUpkeep\n     */\n    function getClosingParamsByCondition(\n        address ccm,\n        PrimexPricingLibrary.Route[] memory secondAssetRoutes\n    ) public view override returns (bytes memory params) {\n        if (IERC165(ccm).supportsInterface(type(ITakeProfitStopLossCCM).interfaceId)) {\n            return abi.encode(ITakeProfitStopLossCCM.AdditionalParams({routes: secondAssetRoutes}));\n        }\n    }\n\n    /**\n     * @notice Internal function to check position upkeep and perform liquidation if necessary.\n     * @param _params CheckUpkeepParams struct containing the necessary parameters.\n     * @return newCursor The new cursor value. Cursor is non-zero if there are more positions available.\n     * @return upkeepNeeded Boolean indicating whether upkeep is needed.\n     * @return performData Encoded data indicating the liquidation source, count, and liquidation information.\n     */\n    function _checkPositionUpkeep(\n        CheckUpkeepParams memory _params\n    ) internal returns (uint256 newCursor, bool upkeepNeeded, bytes memory performData) {\n        LiquidatePositionInfo[] memory toLiquidate = new LiquidatePositionInfo[](_params.outputSize);\n        uint256 count;\n        (IPrimexLens.OpenPositionWithConditions[] memory openPositionsWithConditions, uint256 _newCursor) = primexLens\n            .getOpenPositionsWithConditions(address(pm), _params.cursor, _params.count);\n        for (uint256 i; i < openPositionsWithConditions.length; i++) {\n            PrimexPricingLibrary.Route[] memory secondAssetRoutes;\n            try\n                bestDexLens.getBestDexByPosition(pm, openPositionsWithConditions[i].positionData.id, 10, _params.dexes)\n            returns (IBestDexLens.GetBestMultipleDexesReturnParams memory _dexParams) {\n                secondAssetRoutes = _dexParams.routes;\n            } catch {\n                continue;\n            }\n            Closable memory closable;\n\n            if (pm.isPositionRisky(openPositionsWithConditions[i].positionData.id)) {\n                closable.canBeClosed = true;\n                closable.isRiskyOrDelisted = true;\n                closable.closeReason = PositionLibrary.CloseReason.RISKY_POSITION;\n            } else if (pm.isDelistedPosition(openPositionsWithConditions[i].positionData.id)) {\n                closable.canBeClosed = true;\n                closable.isRiskyOrDelisted = true;\n                closable.closeReason = PositionLibrary.CloseReason.BUCKET_DELISTED;\n            }\n            for (uint256 j; j < openPositionsWithConditions[i].conditionsData.length; j++) {\n                bytes memory additionalParams = getClosingParamsByCondition(\n                    pm.primexDNS().cmTypeToAddress(openPositionsWithConditions[i].conditionsData[j].managerType),\n                    secondAssetRoutes\n                );\n                if (\n                    !closable.canBeClosed &&\n                    pm.canBeClosed(openPositionsWithConditions[i].positionData.id, j, additionalParams)\n                ) {\n                    closable.canBeClosed = true;\n                    closable.closeReason = PositionLibrary.CloseReason.LIMIT_CONDITION;\n                }\n                if (closable.canBeClosed) {\n                    try\n                        pm.closePositionByCondition(\n                            openPositionsWithConditions[i].positionData.id,\n                            msg.sender,\n                            secondAssetRoutes,\n                            closable.isRiskyOrDelisted ? MAX_UINT256 : j,\n                            closable.isRiskyOrDelisted ? bytes(\"\") : additionalParams,\n                            closable.closeReason\n                        )\n                    {} catch {\n                        continue;\n                    }\n                    toLiquidate[count] = LiquidatePositionInfo({\n                        id: openPositionsWithConditions[i].positionData.id,\n                        conditionIndex: closable.isRiskyOrDelisted ? MAX_UINT256 : j,\n                        ccmAdditionalParams: closable.isRiskyOrDelisted ? bytes(\"\") : additionalParams,\n                        positionAssetRoutes: secondAssetRoutes,\n                        closeReason: closable.closeReason\n                    });\n                    count++;\n                    if (count == _params.outputSize) {\n                        return (\n                            _params.cursor + _params.outputSize,\n                            true,\n                            abi.encode(LiquidationSource.POSITION, count, toLiquidate)\n                        );\n                    }\n                    break;\n                }\n            }\n        }\n        if (count > 0) {\n            upkeepNeeded = true;\n        }\n        return (_newCursor, upkeepNeeded, abi.encode(LiquidationSource.POSITION, count, toLiquidate));\n    }\n\n    /**\n     * @notice Internal function to check the upkeep of an order.\n     * @param _params The CheckUpkeepParams struct containing the necessary parameters.\n     * @return newCursor The new cursor value. Cursor is non-zero if there are more orders available.\n     * @return upkeepNeeded Boolean indicating whether upkeep is needed.\n     * @return performData Encoded data indicating the upkeep source, count, and order filling information.\n     */\n    function _checkOrderUpkeep(\n        CheckUpkeepParams memory _params\n    ) internal returns (uint256 newCursor, bool upkeepNeeded, bytes memory performData) {\n        OpenByOrderInfo[] memory toOpenByOrder = new OpenByOrderInfo[](_params.outputSize);\n        uint256 count;\n        (IPrimexLens.LimitOrderWithConditions[] memory limitOrdersWithConditions, uint256 _newCursor) = primexLens\n            .getLimitOrdersWithConditions(address(lom), _params.cursor, _params.count);\n        for (uint256 i; i < limitOrdersWithConditions.length; i++) {\n            IBestDexLens.GetBestDexByOrderReturnParams memory bestDexLensReturnParams;\n            try\n                bestDexLens.getBestDexByOrder(\n                    IBestDexLens.BestDexByOrderParams({\n                        positionManager: pm,\n                        limitOrderManager: lom,\n                        orderId: limitOrdersWithConditions[i].limitOrderData.id,\n                        shares: IBestDexLens.Shares({\n                            firstAssetShares: 10,\n                            depositInThirdAssetShares: 10,\n                            depositToBorrowedShares: 10\n                        }),\n                        dexes: _params.dexes\n                    })\n                )\n            returns (IBestDexLens.GetBestDexByOrderReturnParams memory _dexParams) {\n                bestDexLensReturnParams = _dexParams;\n            } catch {\n                continue;\n            }\n            Routes memory routes;\n            routes.firstAssetRoutes = bestDexLensReturnParams.firstAssetReturnParams.routes;\n            routes.depositInThirdAssetRoutes = bestDexLensReturnParams.depositInThirdAssetReturnParams.routes;\n            {\n                for (uint256 j; j < limitOrdersWithConditions[i].openConditionsData.length; j++) {\n                    bytes memory additionalParams = _getOpeningParamsByCondition(\n                        pm.primexDNS().cmTypeToAddress(limitOrdersWithConditions[i].openConditionsData[j].managerType),\n                        routes\n                    );\n                    if (lom.canBeFilled(limitOrdersWithConditions[i].limitOrderData.id, j, additionalParams)) {\n                        try\n                            lom.openPositionByOrder(\n                                LimitOrderLibrary.OpenPositionParams({\n                                    orderId: limitOrdersWithConditions[i].limitOrderData.id,\n                                    conditionIndex: j,\n                                    comAdditionalParams: additionalParams,\n                                    firstAssetRoutes: routes.firstAssetRoutes,\n                                    depositInThirdAssetRoutes: routes.depositInThirdAssetRoutes,\n                                    keeper: msg.sender\n                                })\n                            )\n                        {} catch {\n                            continue;\n                        }\n                        toOpenByOrder[count] = OpenByOrderInfo({\n                            id: limitOrdersWithConditions[i].limitOrderData.id,\n                            conditionIndex: j,\n                            comAdditionalParams: additionalParams,\n                            firstAssetRoutes: routes.firstAssetRoutes,\n                            depositInThirdAssetRoutes: routes.depositInThirdAssetRoutes\n                        });\n\n                        count++;\n                        if (count == _params.outputSize) {\n                            return (\n                                _params.cursor + _params.outputSize,\n                                true,\n                                abi.encode(LiquidationSource.ORDER, count, toOpenByOrder)\n                            );\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        if (count > 0) {\n            upkeepNeeded = true;\n        }\n        return (_newCursor, upkeepNeeded, abi.encode(LiquidationSource.ORDER, count, toOpenByOrder));\n    }\n\n    /**\n     * @notice Retrieves the opening parameters based on a condition.\n     * @param com The address of the COM contract.\n     * @param routes The Routes struct containing the asset routes.\n     * @return params The encoded opening parameters.\n     */\n    function _getOpeningParamsByCondition(\n        address com,\n        Routes memory routes\n    ) internal view returns (bytes memory params) {\n        if (IERC165(com).supportsInterface(type(ILimitPriceCOM).interfaceId)) {\n            return\n                abi.encode(\n                    ILimitPriceCOM.AdditionalParams({\n                        firstAssetRoutes: routes.firstAssetRoutes,\n                        depositInThirdAssetRoutes: routes.depositInThirdAssetRoutes\n                    })\n                );\n        }\n    }\n}\n"
    },
    "contracts/PToken/IPToken.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\n\nimport {IPTokenStorage, IBucket, IFeeExecutor, IERC20MetadataUpgradeable, IActivityRewardDistributor} from \"./IPTokenStorage.sol\";\n\ninterface IPToken is IPTokenStorage {\n    /**\n     * @dev Emitted after the mint action\n     * @param from The address performing the mint\n     * @param value The amount being\n     */\n    event Mint(address indexed from, uint256 value);\n\n    /**\n     * @dev Emitted after pTokens are burned\n     * @param from The owner of the aTokens, getting them burned\n     * @param value The amount being burned\n     */\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * @dev Emitted during the transfer action\n     * @param from The user whose tokens are being transferred\n     * @param to The recipient\n     * @param amount The amount being transferred\n     * @param index The new liquidity index of the reserve\n     */\n    event BalanceTransfer(address indexed from, address indexed to, uint256 amount, uint256 index);\n\n    event LockDeposit(address indexed user, uint256 indexed id, uint256 deadline, uint256 amount);\n    event UnlockDeposit(address indexed user, uint256 indexed id);\n\n    /**\n     * @dev contract initializer\n     * @param _name The name of the ERC20 token.\n     * @param _symbol The symbol of the ERC20 token.\n     * @param _decimals The number of decimals for the ERC20 token.\n     * @param _bucketsFactory Address of the buckets factory that will call the setBucket fucntion\n     */\n    function initialize(string memory _name, string memory _symbol, uint8 _decimals, address _bucketsFactory) external;\n\n    /**\n     * @dev Sets the bucket for the contract.\n     * @param _bucket The address of the bucket to set.\n     */\n    function setBucket(IBucket _bucket) external;\n\n    /**\n     * @dev Sets the InterestIncreaser for current PToken.\n     * @param _interestIncreaser The interest increaser address.\n     */\n    function setInterestIncreaser(IFeeExecutor _interestIncreaser) external;\n\n    /**\n     * @dev Sets the lender reward distributor contract address.\n     * @param _lenderRewardDistributor The address of the lender reward distributor contract.\n     */\n    function setLenderRewardDistributor(IActivityRewardDistributor _lenderRewardDistributor) external;\n\n    /**\n     * @notice Locks a deposit for a specified user.\n     * @param _user The address of the user for whom the deposit is being locked.\n     * @param _amount The amount to be locked as a deposit.\n     * @param _duration The duration for which the deposit will be locked.\n     * @dev This function can only be called externally and overrides the corresponding function in the parent contract.\n     * @dev The user must not be blacklisted.\n     */\n    function lockDeposit(address _user, uint256 _amount, uint256 _duration) external;\n\n    /**\n     * @dev Unlocks a specific deposit.\n     * @param _depositId The ID of the deposit to be unlocked.\n     */\n    function unlockDeposit(uint256 _depositId) external;\n\n    /**\n     * @dev Mints `amount` pTokens to `user`\n     * @param _user The address receiving the minted tokens\n     * @param _amount The amount of tokens getting minted\n     * @param _index The current liquidityIndex\n     * @return Minted amount of PTokens\n     */\n    function mint(address _user, uint256 _amount, uint256 _index) external returns (uint256);\n\n    /**\n     * @dev Mints pTokens to the reserve address\n     * Compared to the normal mint, we don't revert when the amountScaled is equal to the zero. Additional checks were also removed\n     * Only callable by the Bucket\n     * @param _reserve The address of the reserve\n     * @param _amount The amount of tokens getting minted\n     * @param _index The current liquidityIndex\n     */\n    function mintToReserve(address _reserve, uint256 _amount, uint256 _index) external;\n\n    /**\n     * @dev Burns pTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n     * @param _user The owner of the pTokens, getting them burned\n     * @param _amount The amount of underlying token being returned to receiver\n     * @param _index The current liquidityIndex\n     * @return Burned amount of PTokens\n     */\n    function burn(address _user, uint256 _amount, uint256 _index) external returns (uint256);\n\n    /**\n     * @dev Returns the scaled balance of the user.\n     * @param _user The owner of pToken\n     * @return The scaled balances of the user\n     */\n    function scaledBalanceOf(address _user) external view returns (uint256);\n\n    /**\n     * @dev Returns available balance of the user.\n     * @param _user The owner of pToken\n     * @return The available balance of the user\n     */\n    function availableBalanceOf(address _user) external view returns (uint256);\n\n    /**\n     * @dev Returns locked deposits and balance of user\n     * @param _user The owner of locked deposits\n     * @return Structure with deposits and total locked balance of user\n     */\n    function getUserLockedBalance(address _user) external view returns (LockedBalance memory);\n\n    /**\n     * @dev Returns the scaled total supply of pToken.\n     * @return The scaled total supply of the pToken.\n     */\n    function scaledTotalSupply() external view returns (uint256);\n\n    /**\n     * @dev Function to get a deposit index in user's deposit array.\n     * @param id Deposit id.\n     * @return index Deposit index in user's 'deposit' array.\n     */\n    function getDepositIndexById(uint256 id) external returns (uint256 index);\n}\n"
    },
    "contracts/PToken/IPTokensFactory.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IPToken} from \"./IPToken.sol\";\n\ninterface IPTokensFactory {\n    /**\n     * @dev Deploying a new PToken contract. Can be called by BucketsFactory only.\n     * @param _name The name of the new PToken.\n     * @param _symbol The symbol of the new PToken.\n     */\n    function createPToken(string memory _name, string memory _symbol, uint8 _decimals) external returns (IPToken);\n\n    /**\n     * @dev Sets the BucketsFactory address. Only callable by the BIG_TIMELOCK_ADMIN role.\n     * @param bucketsFactory The BucketsFactory address.\n     */\n    function setBucketsFactory(address bucketsFactory) external;\n\n    /**\n     * @dev Gets a BucketsFactory contract address.\n     */\n    function bucketsFactory() external view returns (address);\n\n    /**\n     * @dev Gets a Registry contract address.\n     */\n    function registry() external view returns (address);\n}\n"
    },
    "contracts/PToken/IPTokenStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20MetadataUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IFeeExecutor} from \"../BonusExecutor/IFeeExecutor.sol\";\nimport {IActivityRewardDistributor} from \"../ActivityRewardDistributor/IActivityRewardDistributor.sol\";\n\ninterface IPTokenStorage is IERC20MetadataUpgradeable {\n    struct Deposit {\n        uint256 lockedBalance;\n        uint256 deadline;\n        uint256 id;\n    }\n\n    struct LockedBalance {\n        uint256 totalLockedBalance;\n        Deposit[] deposits;\n    }\n\n    function bucket() external view returns (IBucket);\n\n    function interestIncreaser() external view returns (IFeeExecutor);\n\n    function lenderRewardDistributor() external view returns (IActivityRewardDistributor);\n}\n"
    },
    "contracts/PToken/PToken.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport \"./PTokenStorage.sol\";\nimport {BIG_TIMELOCK_ADMIN} from \"../Constants.sol\";\nimport {IPToken, IAccessControl, IERC165Upgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable, IActivityRewardDistributor} from \"./IPToken.sol\";\n\ncontract PToken is IPToken, PTokenStorage {\n    using WadRayMath for uint256;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Throws if called by any account other than the bucket.\n     */\n    modifier onlyBucket() {\n        _require(address(bucket) == msg.sender, Errors.CALLER_IS_NOT_BUCKET.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(bucket.registry()).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    modifier notBlackListed() {\n        _require(\n            !IWhiteBlackList(bucket.whiteBlackList()).isBlackListed(msg.sender),\n            Errors.SENDER_IS_BLACKLISTED.selector\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the recipient is not blacklisted.\n     */\n    modifier isRecipientNotBlackListed(address _recipient) {\n        _require(\n            !IWhiteBlackList(bucket.whiteBlackList()).isBlackListed(_recipient),\n            Errors.RECIPIENT_IS_BLACKLISTED.selector\n        );\n        _;\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _bucketsFactory\n    ) public override initializer {\n        __ERC20_init(_name, _symbol);\n        __ERC165_init();\n        __ReentrancyGuard_init();\n        tokenDecimals = _decimals;\n        bucketsFactory = _bucketsFactory;\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function setBucket(IBucket _bucket) external override {\n        _require(msg.sender == bucketsFactory, Errors.FORBIDDEN.selector);\n        _require(address(bucket) == address(0), Errors.BUCKET_IS_IMMUTABLE.selector);\n        _require(\n            IERC165Upgradeable(address(_bucket)).supportsInterface(type(IBucket).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        bucket = _bucket;\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function setInterestIncreaser(IFeeExecutor _interestIncreaser) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            address(_interestIncreaser) == address(0) ||\n                IERC165Upgradeable(address(_interestIncreaser)).supportsInterface(type(IFeeExecutor).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        interestIncreaser = _interestIncreaser;\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function setLenderRewardDistributor(\n        IActivityRewardDistributor _lenderRewardDistributor\n    ) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            address(_lenderRewardDistributor) == address(0) ||\n                IERC165Upgradeable(address(_lenderRewardDistributor)).supportsInterface(\n                    type(IActivityRewardDistributor).interfaceId\n                ),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        lenderRewardDistributor = _lenderRewardDistributor;\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function lockDeposit(\n        address _user,\n        uint256 _amount,\n        uint256 _duration\n    ) external override nonReentrant notBlackListed onlyBucket {\n        _require(_duration != 0, Errors.DURATION_MUST_BE_MORE_THAN_0.selector);\n        _require(bucket.isActive(), Errors.BUCKET_IS_NOT_ACTIVE.selector);\n        (_amount, ) = _getAvailableBalance(_user, _amount, bucket.getNormalizedIncome());\n        lockedBalances[_user].totalLockedBalance += _amount;\n        lockedDepositsIndexes.push(lockedBalances[_user].deposits.length);\n        uint256 deadline = block.timestamp + _duration;\n        lockedBalances[_user].deposits.push(Deposit(_amount, deadline, lockedDepositsIndexes.length - 1));\n\n        emit LockDeposit(_user, lockedDepositsIndexes.length - 1, deadline, _amount);\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function unlockDeposit(uint256 _depositId) external override nonReentrant notBlackListed {\n        Deposit[] storage deposits = lockedBalances[msg.sender].deposits;\n        _require(deposits.length > 0, Errors.THERE_ARE_NO_LOCK_DEPOSITS.selector);\n        uint256 index = lockedDepositsIndexes[_depositId];\n        _require(deposits[index].id == _depositId, Errors.INCORRECT_ID.selector);\n        if (!bucket.isDelisted()) {\n            _require(deposits[index].deadline < block.timestamp, Errors.LOCK_TIME_IS_NOT_EXPIRED.selector);\n        }\n        lockedBalances[msg.sender].totalLockedBalance -= deposits[index].lockedBalance;\n        deposits[index] = deposits[deposits.length - 1];\n        lockedDepositsIndexes[deposits[deposits.length - 1].id] = index;\n\n        deposits.pop();\n        delete lockedDepositsIndexes[_depositId];\n\n        emit UnlockDeposit(msg.sender, _depositId);\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function mint(address _user, uint256 _amount, uint256 _index) external override onlyBucket returns (uint256) {\n        _require(_user != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        _require(_amount != 0, Errors.AMOUNT_IS_0.selector);\n        uint256 amountScaled = _amount.rdiv(_index);\n        _require(amountScaled != 0, Errors.INVALID_MINT_AMOUNT.selector);\n        if (address(interestIncreaser) != address(0)) {\n            //in this case the _index will be equal to the getNormalizedIncome()\n            try interestIncreaser.updateBonus(_user, scaledBalanceOf(_user), address(bucket), _index) {} catch {\n                emit Errors.Log(Errors.INTEREST_INCREASER_CALL_FAILED.selector);\n            }\n        }\n\n        _mint(_user, amountScaled);\n\n        if (address(lenderRewardDistributor) != address(0)) {\n            try\n                lenderRewardDistributor.updateUserActivity(\n                    bucket,\n                    _user,\n                    scaledBalanceOf(_user),\n                    IActivityRewardDistributor.Role.LENDER\n                )\n            {} catch {\n                emit Errors.Log(Errors.LENDER_REWARD_DISTRIBUTOR_CALL_FAILED.selector);\n            }\n        }\n\n        emit Mint(_user, _amount);\n        return amountScaled.rmul(_index);\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function mintToReserve(address _reserve, uint256 _amount, uint256 _index) external override onlyBucket {\n        uint256 amountScaled = _amount.rdiv(_index);\n        if (amountScaled == 0) {\n            return;\n        }\n        _mint(_reserve, amountScaled);\n        emit Mint(_reserve, _amount);\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function burn(address _user, uint256 _amount, uint256 _index) external override onlyBucket returns (uint256) {\n        _require(_user != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        uint256 amountScaled;\n        (_amount, amountScaled) = _getAvailableBalance(_user, _amount, _index);\n        if (address(interestIncreaser) != address(0)) {\n            //in this case the _index will be equal to the getNormalizedIncome()\n            try interestIncreaser.updateBonus(_user, scaledBalanceOf(_user), address(bucket), _index) {} catch {\n                emit Errors.Log(Errors.INTEREST_INCREASER_CALL_FAILED.selector);\n            }\n        }\n\n        _burn(_user, amountScaled);\n\n        if (address(lenderRewardDistributor) != address(0)) {\n            try\n                lenderRewardDistributor.updateUserActivity(\n                    bucket,\n                    _user,\n                    scaledBalanceOf(_user),\n                    IActivityRewardDistributor.Role.LENDER\n                )\n            {} catch {\n                emit Errors.Log(Errors.LENDER_REWARD_DISTRIBUTOR_CALL_FAILED.selector);\n            }\n        }\n\n        emit Burn(_user, _amount);\n        return _amount;\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function getDepositIndexById(uint256 id) external view override returns (uint256 index) {\n        _require(id < lockedDepositsIndexes.length, Errors.DEPOSIT_DOES_NOT_EXIST.selector);\n        return lockedDepositsIndexes[id];\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function getUserLockedBalance(address _user) external view override returns (LockedBalance memory) {\n        return lockedBalances[_user];\n    }\n\n    /**\n     * @dev Transfers the pTokens from 'msg.sender' to recipient.\n     * @param _recipient The recipient address\n     * @param _amount The amount of pTokens to be transferred.\n     * If scpecified amount = type(uint256).max the all tokens of 'msg.sender' will be transferred.\n     */\n    function transfer(\n        address _recipient,\n        uint256 _amount\n    )\n        public\n        override(ERC20Upgradeable, IERC20Upgradeable)\n        nonReentrant\n        isRecipientNotBlackListed(_recipient)\n        returns (bool)\n    {\n        _require(_recipient != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        uint256 amountScaled;\n        uint256 index = bucket.getNormalizedIncome();\n        (_amount, amountScaled) = _getAvailableBalance(msg.sender, _amount, index);\n\n        _updateBonusesAndRewards(msg.sender, _recipient, index, amountScaled);\n\n        bool transfer_ = super.transfer(_recipient, amountScaled);\n\n        emit BalanceTransfer(msg.sender, _recipient, _amount, index);\n        return transfer_;\n    }\n\n    /**\n     * @dev Transfers the pTokens between 'sender' and 'recipient' using allowance mechanism.\n     * @param _sender The source address\n     * @param _recipient The recipient address\n     * @param _amount The amount of pTokens to be transferred.\n     * If scpecified amount = type(uint256).max the all tokens of 'msg.sender' will be transferred.\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    )\n        public\n        override(ERC20Upgradeable, IERC20Upgradeable)\n        nonReentrant\n        isRecipientNotBlackListed(_recipient)\n        returns (bool)\n    {\n        _require(_recipient != address(0) && _sender != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        uint256 amountScaled;\n        uint256 liquidityIndex = bucket.getNormalizedIncome();\n        (_amount, amountScaled) = _getAvailableBalance(_sender, _amount, liquidityIndex);\n        uint256 currentAllowance = allowance(_sender, msg.sender);\n\n        _require(currentAllowance >= _amount, Errors.TRANSFER_AMOUNT_EXCEED_ALLOWANCE.selector);\n        unchecked {\n            super._approve(_sender, msg.sender, currentAllowance - _amount);\n        }\n        _updateBonusesAndRewards(_sender, _recipient, liquidityIndex, amountScaled);\n        super._transfer(_sender, _recipient, amountScaled);\n\n        emit BalanceTransfer(_sender, _recipient, _amount, liquidityIndex);\n        return true;\n    }\n\n    /**\n     * @dev Returns the number of decimal places used for token values.\n     * @return The number of decimal places as a uint8.\n     */\n    function decimals() public view override(ERC20Upgradeable, IERC20MetadataUpgradeable) returns (uint8) {\n        return tokenDecimals;\n    }\n\n    /**\n     * @dev Caalculates actual 'user' balance on current block.\n     * Calculates as 'principal' + 'interest'.\n     * @param _user The owner of pTokens\n     * @return The balance of the 'user'\n     */\n    function balanceOf(address _user) public view override(ERC20Upgradeable, IERC20Upgradeable) returns (uint256) {\n        return super.balanceOf(_user).rmul(bucket.getNormalizedIncome());\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function scaledBalanceOf(address _user) public view override returns (uint256) {\n        return super.balanceOf(_user);\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function availableBalanceOf(address _user) public view override returns (uint256 result) {\n        result = balanceOf(_user) - lockedBalances[_user].totalLockedBalance;\n        if (!bucket.isBucketStable()) {\n            // solhint-disable-next-line var-name-mixedcase\n            IBucket.LiquidityMiningParams memory LMparams = bucket.getLiquidityMiningParams();\n            result -= LMparams.liquidityMiningRewardDistributor.getLenderAmountInMining(bucket.name(), _user);\n        }\n    }\n\n    /**\n     * @dev Calculates the total supply of the pToken.\n     * It increments over blocks mining.\n     * @return The current total supply of the pToken.\n     */\n    function totalSupply() public view override(ERC20Upgradeable, IERC20Upgradeable) returns (uint256) {\n        uint256 currentSupplyScaled = super.totalSupply();\n        if (currentSupplyScaled == 0) {\n            return 0;\n        }\n        return currentSupplyScaled.rmul(bucket.getNormalizedIncome());\n    }\n\n    /**\n     * @inheritdoc IPToken\n     */\n    function scaledTotalSupply() public view override returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /// @notice Interface checker\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IPToken).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /**\n     * @dev Internal function to update bonuses and rewards for the given sender and recipient.\n     * @param _sender The address of the sender.\n     * @param _recipient The address of the recipient.\n     * @param _index The index used for updating bonuses.\n     * @param _amountScaled The scaled amount of pTokens to be transferred.\n     */\n    function _updateBonusesAndRewards(\n        address _sender,\n        address _recipient,\n        uint256 _index,\n        uint256 _amountScaled\n    ) internal {\n        bool hasInterestIncreaser = address(interestIncreaser) != address(0);\n        bool hasRewardDistributor = address(lenderRewardDistributor) != address(0);\n        if (!hasInterestIncreaser && !hasRewardDistributor) return;\n\n        address[] memory users = new address[](2);\n        uint256[] memory scaledBalances = new uint256[](2);\n        users[0] = _sender;\n        users[1] = _recipient;\n        scaledBalances[0] = scaledBalanceOf(_sender);\n        scaledBalances[1] = scaledBalanceOf(_recipient);\n        if (hasInterestIncreaser) {\n            try interestIncreaser.updateBonuses(users, scaledBalances, address(bucket), _index) {} catch {\n                emit Errors.Log(Errors.INTEREST_INCREASER_CALL_FAILED.selector);\n            }\n        }\n\n        if (hasRewardDistributor) {\n            scaledBalances[0] -= _amountScaled;\n            scaledBalances[1] += _amountScaled;\n            try\n                lenderRewardDistributor.updateUsersActivities(\n                    bucket,\n                    users,\n                    scaledBalances,\n                    users.length,\n                    IActivityRewardDistributor.Role.LENDER\n                )\n            {} catch {\n                emit Errors.Log(Errors.LENDER_REWARD_DISTRIBUTOR_CALL_FAILED.selector);\n            }\n        }\n    }\n\n    /**\n     * @dev Retrieves available balance for a user.\n     * @param _user The address of the user.\n     * @param _amount The requested amount.\n     * @param _currentIndex The current index.\n     * @return _amount The valid amount.\n     * @return amountScaled The scaled amount.\n     */\n    function _getAvailableBalance(\n        address _user,\n        uint256 _amount,\n        uint256 _currentIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 availableBalance = super.balanceOf(_user).rmul(_currentIndex) -\n            lockedBalances[_user].totalLockedBalance;\n        if (!bucket.isBucketStable()) {\n            // solhint-disable-next-line var-name-mixedcase\n            IBucket.LiquidityMiningParams memory LMparams = bucket.getLiquidityMiningParams();\n            availableBalance -= LMparams.liquidityMiningRewardDistributor.getLenderAmountInMining(bucket.name(), _user);\n        }\n\n        if (_amount == type(uint256).max) {\n            _amount = availableBalance;\n        } else {\n            _require(availableBalance >= _amount, Errors.ACTION_ONLY_WITH_AVAILABLE_BALANCE.selector);\n        }\n        uint256 amountScaled = _amount.rdiv(_currentIndex);\n        _require(amountScaled != 0, Errors.INVALID_AMOUNT.selector);\n        return (_amount, amountScaled);\n    }\n}\n"
    },
    "contracts/PToken/PTokensFactory.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\n\nimport {PToken} from \"./PToken.sol\";\nimport {IPTokensFactory} from \"./IPTokensFactory.sol\";\nimport {IPToken} from \"./IPToken.sol\";\nimport {IBucketsFactory} from \"../Bucket/IBucketsFactory.sol\";\nimport {BIG_TIMELOCK_ADMIN} from \"../Constants.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"../libraries/Errors.sol\";\n\ncontract PTokensFactory is UpgradeableBeacon, IPTokensFactory, IERC165 {\n    address public override bucketsFactory;\n    address public override registry;\n\n    event PTokenCreated(address pTokenAddress);\n\n    /**\n     * @dev Throws if called by any account other than the bucket.\n     */\n    modifier onlyBucketsFactory() {\n        _require(bucketsFactory == msg.sender, Errors.CALLER_IS_NOT_A_BUCKET_FACTORY.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(address _ptokenImplementation, address _registry) UpgradeableBeacon(_ptokenImplementation) {\n        _require(\n            IERC165(_ptokenImplementation).supportsInterface(type(IPToken).interfaceId) &&\n                IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n    }\n\n    /**\n     * @inheritdoc IPTokensFactory\n     */\n    function createPToken(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) external override onlyBucketsFactory returns (IPToken) {\n        bytes memory initData = abi.encodeWithSelector(\n            IPToken.initialize.selector,\n            _name,\n            _symbol,\n            _decimals,\n            bucketsFactory\n        );\n        address instance = address(new BeaconProxy(address(this), initData));\n        emit PTokenCreated(instance);\n        return IPToken(instance);\n    }\n\n    /**\n     * @inheritdoc IPTokensFactory\n     */\n    function setBucketsFactory(address _bucketsFactory) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            IERC165(_bucketsFactory).supportsInterface(type(IBucketsFactory).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        bucketsFactory = _bucketsFactory;\n    }\n\n    /**\n     * @inheritdoc UpgradeableBeacon\n     */\n\n    function upgradeTo(address _ptokenImplementation) public override {\n        _require(\n            IERC165(_ptokenImplementation).supportsInterface(type(IPToken).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        super.upgradeTo(_ptokenImplementation);\n    }\n\n    /// @notice Interface checker\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IPTokensFactory).interfaceId || _interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/PToken/PTokenStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IPTokenStorage, IBucket, IFeeExecutor, IActivityRewardDistributor} from \"./IPTokenStorage.sol\";\n\nabstract contract PTokenStorage is IPTokenStorage, ERC20Upgradeable, ERC165Upgradeable, ReentrancyGuardUpgradeable {\n    IBucket public override bucket;\n    IFeeExecutor public override interestIncreaser;\n    IActivityRewardDistributor public override lenderRewardDistributor;\n\n    uint256[] internal lockedDepositsIndexes; // index of this array is the depositId, value is the deposit index in user's 'deposits' array\n    uint8 internal tokenDecimals;\n    mapping(address => LockedBalance) internal lockedBalances;\n    address internal bucketsFactory;\n}\n"
    },
    "contracts/Redeemer.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {TokenTransfersLibrary} from \"./libraries/TokenTransfersLibrary.sol\";\nimport \"./libraries/Errors.sol\";\n\nimport {BIG_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \"./Constants.sol\";\nimport {IRedeemer} from \"./interfaces/IRedeemer.sol\";\nimport {IPausable} from \"./interfaces/IPausable.sol\";\nimport {IEPMXToken} from \"./interfaces/IEPMXToken.sol\";\n\ncontract Redeemer is IRedeemer, IPausable, Pausable, ReentrancyGuard {\n    uint256 internal constant WAD = 10 ** 18;\n    address public immutable registry;\n    address public immutable earlyPmx;\n    address public immutable pmx;\n    uint256 public rate = WAD;\n\n    /**\n     * @dev Modifier that checks if the caller has a specific role.\n     * @param _role The role identifier to check.\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    constructor(address _earlyPmx, address _pmx, address _registry) {\n        _require(\n            IERC165(_earlyPmx).supportsInterface(type(IEPMXToken).interfaceId) &&\n                IERC165(_pmx).supportsInterface(type(IERC20).interfaceId) &&\n                IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n\n        registry = _registry;\n        earlyPmx = _earlyPmx;\n        pmx = _pmx;\n    }\n\n    /**\n     * @inheritdoc IRedeemer\n     */\n    function changeRate(uint256 _rate) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(_rate > 0, Errors.ZERO_EXCHANGE_RATE.selector);\n        rate = _rate;\n        emit RateChanged(_rate);\n    }\n\n    /**\n     * @inheritdoc IRedeemer\n     */\n    function redeem() external override nonReentrant whenNotPaused {\n        uint256 amount = IERC20(earlyPmx).balanceOf(msg.sender);\n        TokenTransfersLibrary.doTransferIn(earlyPmx, msg.sender, amount);\n        // i don't use the WadRayMath because it can round up\n        TokenTransfersLibrary.doTransferOut(pmx, msg.sender, (amount * rate) / WAD);\n        IEPMXToken(earlyPmx).burn(amount);\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n}\n"
    },
    "contracts/ReferralProgram/IReferralProgram.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IReferralProgramStorage} from \"./IReferralProgramStorage.sol\";\n\ninterface IReferralProgram is IReferralProgramStorage {\n    /**\n     * @dev event of register success\n     * @param user  address\n     * @param parent referrerOf of user\n     */\n    event RegisteredUser(address indexed user, address indexed parent);\n\n    /**\n     * @dev The event for set referrer by Admin.\n     * @param referrer Address of a referrer added by Admin.\n     */\n    event SetReferrerByAdmin(address indexed referrer);\n\n    /**\n     * @dev The event for set referral by admin. The referral is set in accordance with her referrer.\n     * @param referrer The address of a referrer.\n     * @param referral The address of a referrer's referral.\n     */\n    event SetReferralByAdmin(address indexed referrer, address indexed referral);\n\n    /**\n     * @dev contract initializer\n     * @param _registry The Registry contract address\n     */\n    function initialize(address _registry) external;\n\n    /**\n     * @dev Function to add new referral. Adds address that signed a hashed message as referrer\n     * @param _referrerSignature Hash of MAGIC_MESSAGE signed by referrer\n     */\n    function register(bytes calldata _referrerSignature) external;\n\n    /**\n     *\n     * @param referralProgramUnits Array of referrers with their referrals\n     */\n    function setReferrals(ReferralProgramUnit[] calldata referralProgramUnits) external;\n\n    /**\n     * @dev get list of referrers\n     */\n    function getReferrers() external view returns (address[] memory);\n\n    /**\n     * @dev Gets referrals array of particular referrer\n     * @param _referrer The address of a referrer\n     */\n    function getReferralsOf(address _referrer) external view returns (address[] memory);\n\n    /**\n     * @dev The amount of referrals for a particular referrer\n     * @param _referrer The address of a referrer\n     */\n    function getReferralsOfLength(address _referrer) external view returns (uint256);\n}\n"
    },
    "contracts/ReferralProgram/IReferralProgramStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IReferralProgramStorage {\n    struct ReferralProgramUnit {\n        address referrer;\n        address[] referrals;\n    }\n\n    /**\n     * @dev registry address\n     */\n    function registry() external view returns (address);\n\n    /**\n     * @dev referrer of address\n     */\n    function referrerOf(address) external view returns (address);\n\n    /**\n     * @dev referral Of address at index\n     * @param _referrer address\n     * @param _index index of referral\n     * @return referral address\n     */\n    function referralsOf(address _referrer, uint256 _index) external view returns (address referral);\n}\n"
    },
    "contracts/ReferralProgram/ReferralProgram.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IAccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {ECDSAUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport {ReferralProgramStorage} from \"./ReferralProgramStorage.sol\";\nimport {MEDIUM_TIMELOCK_ADMIN} from \"../Constants.sol\";\nimport {IReferralProgram} from \"./IReferralProgram.sol\";\n\ncontract ReferralProgram is IReferralProgram, ReferralProgramStorage {\n    bytes public constant MAGIC_MESSAGE = \"Referral link\";\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Throws if caller is not granted with _role\n     * @param _role The role that is being checked for a function caller\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControlUpgradeable(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc IReferralProgram\n     */\n    function initialize(address _registry) external override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControlUpgradeable).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n        __ERC165_init();\n    }\n\n    /**\n     * @inheritdoc IReferralProgram\n     */\n    function register(bytes calldata _sig) external override {\n        _require(\n            referrerOf[msg.sender] == address(0) && !alreadyReferrer[msg.sender],\n            Errors.CALLER_ALREADY_REGISTERED.selector\n        );\n        address parent = ECDSAUpgradeable.recover(ECDSAUpgradeable.toEthSignedMessageHash(MAGIC_MESSAGE), _sig);\n        _require(msg.sender != parent, Errors.MISMATCH.selector);\n\n        if (!alreadyReferrer[parent]) {\n            alreadyReferrer[parent] = true;\n            referrers.push(parent);\n        }\n        referrerOf[msg.sender] = parent;\n        referralsOf[parent].push(msg.sender);\n        emit RegisteredUser(msg.sender, parent);\n    }\n\n    /**\n     * @inheritdoc IReferralProgram\n     */\n    function setReferrals(\n        ReferralProgramUnit[] calldata referralProgramUnits\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        for (uint256 i; i < referralProgramUnits.length; i++) {\n            if (referralProgramUnits[i].referrals.length > 0) {\n                for (uint256 j; j < referralProgramUnits[i].referrals.length; j++) {\n                    if (referrerOf[referralProgramUnits[i].referrals[j]] == address(0)) {\n                        referralsOf[referralProgramUnits[i].referrer].push(referralProgramUnits[i].referrals[j]);\n                        referrerOf[referralProgramUnits[i].referrals[j]] = referralProgramUnits[i].referrer;\n                        emit SetReferralByAdmin(referralProgramUnits[i].referrer, referralProgramUnits[i].referrals[j]);\n                    }\n                }\n            }\n            if (\n                !alreadyReferrer[referralProgramUnits[i].referrer] &&\n                referralsOf[referralProgramUnits[i].referrer].length > 0\n            ) {\n                alreadyReferrer[referralProgramUnits[i].referrer] = true;\n                referrers.push(referralProgramUnits[i].referrer);\n                emit SetReferrerByAdmin(referralProgramUnits[i].referrer);\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IReferralProgram\n     */\n    function getReferralsOf(address _referrer) external view override returns (address[] memory) {\n        return referralsOf[_referrer];\n    }\n\n    /**\n     * @inheritdoc IReferralProgram\n     */\n    function getReferralsOfLength(address _referrer) external view override returns (uint256) {\n        return referralsOf[_referrer].length;\n    }\n\n    /**\n     * @inheritdoc IReferralProgram\n     */\n    function getReferrers() external view override returns (address[] memory) {\n        return referrers;\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(_interfaceId) || _interfaceId == type(IReferralProgram).interfaceId;\n    }\n}\n"
    },
    "contracts/ReferralProgram/ReferralProgramStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\n\nimport {IReferralProgramStorage} from \"./IReferralProgramStorage.sol\";\n\nabstract contract ReferralProgramStorage is IReferralProgramStorage, ERC165Upgradeable {\n    address public override registry;\n    mapping(address => address) public referrerOf; // referral => referrer\n    mapping(address => address[]) public referralsOf; // referrer => referrals\n    address[] public referrers; // list of all referrers\n    mapping(address => bool) internal alreadyReferrer;\n}\n"
    },
    "contracts/Reserve/IReserve.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IReserveStorage} from \"./IReserveStorage.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface IReserve is IReserveStorage, IPausable {\n    event BurnAmountCalculated(uint256 burnAmount);\n    event TransferRestrictionsChanged(address indexed pToken, TransferRestrictions newTransferRestrictions);\n\n    /**\n     * @dev contract initializer\n     * @param dns The address of PrimexDNS contract\n     * @param registry The address of Registry contract\n     */\n    function initialize(IPrimexDNS dns, address registry) external;\n\n    /**\n     * @dev Burns the permanent loss amount (presented in pTokens) from the Reserve for a particular bucket\n     * @param bucket The address of a bucket\n     * Emits BurnAmountCalculated(burnAmount) event\n     */\n    function paybackPermanentLoss(IBucket bucket) external;\n\n    /**\n     * @dev Transfers some bonus in pTokens to receiver from Reserve\n     * Can be called by executor only\n     * @param _bucketName The bucket where the msg.sender should be a fee decreaser (for debtToken) or\n     * interest increaser (for pToken)\n     * @param _to The receiver of bonus pTokens\n     * @param _amount The amount of bonus pTokens to transfer\n     */\n    function payBonus(string memory _bucketName, address _to, uint256 _amount) external;\n\n    /**\n     * @dev Function to transfer tokens to the Treasury. Only BIG_TIMELOCK_ADMIN can call it.\n     * @param bucket The bucket from which to transfer pTokens\n     * @param amount The amount of pTokens to transfer\n     */\n    function transferToTreasury(address bucket, uint256 amount) external;\n\n    /**\n     * @dev Function to set transfer restrictions for a token.\n     * @notice Only BIG_TIMELOCK_ADMIN can call it.\n     * @param pToken pToken to set restrictions for\n     * @param transferRestrictions Min amount to be left in the Reserve\n     */\n    function setTransferRestrictions(address pToken, TransferRestrictions calldata transferRestrictions) external;\n}\n"
    },
    "contracts/Reserve/IReserveStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IReserveStorage {\n    struct TransferRestrictions {\n        uint256 minAmountToBeLeft;\n        uint256 minPercentOfTotalSupplyToBeLeft;\n    }\n\n    event TransferFromReserve(address pToken, address to, uint256 amount);\n\n    function transferRestrictions(address pToken) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/Reserve/Reserve.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport \"../libraries/Errors.sol\";\n\nimport {ReserveStorage} from \"./ReserveStorage.sol\";\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \"../Constants.sol\";\nimport {IReserve, IPausable} from \"./IReserve.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {IPToken} from \"../PToken/IPToken.sol\";\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\n\ncontract Reserve is IReserve, ReserveStorage {\n    using WadRayMath for uint256;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Throws if caller is not granted with _role\n     * @param _role The role to be checked\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc IReserve\n     */\n    function initialize(IPrimexDNS _dns, address _registry) external override initializer {\n        _require(\n            IERC165Upgradeable(address(_dns)).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n        dns = _dns;\n        __Pausable_init();\n        __ERC165_init();\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @inheritdoc IReserve\n     */\n    function payBonus(string memory _bucketName, address _to, uint256 _amount) external override {\n        (address bucket, , , ) = dns.buckets(_bucketName);\n        IPToken pToken = IBucket(bucket).pToken();\n        _require(\n            address(IBucket(bucket).debtToken().feeDecreaser()) == msg.sender ||\n                address(pToken.interestIncreaser()) == msg.sender,\n            Errors.CALLER_IS_NOT_EXECUTOR.selector\n        );\n        pToken.transfer(_to, _amount);\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc IReserve\n     */\n    function setTransferRestrictions(\n        address pToken,\n        TransferRestrictions calldata newTransferRestrictions\n    ) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(\n            newTransferRestrictions.minPercentOfTotalSupplyToBeLeft <= WadRayMath.WAD,\n            Errors.INCORRECT_TRANSFER_RESTRICTIONS.selector\n        );\n        transferRestrictions[pToken] = newTransferRestrictions;\n        emit TransferRestrictionsChanged(pToken, newTransferRestrictions);\n    }\n\n    /**\n     * @inheritdoc IReserve\n     */\n    function transferToTreasury(\n        address bucket,\n        uint256 amount\n    ) public override whenNotPaused onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _require(IBucket(bucket).getLiquidityMiningParams().isBucketLaunched, Errors.BUCKET_IS_NOT_LAUNCHED.selector);\n        IPToken pToken = IBucket(bucket).pToken();\n        uint256 reserveBalance = pToken.balanceOf(address(this));\n\n        TransferRestrictions storage restrictions = transferRestrictions[address(pToken)];\n\n        _require(\n            reserveBalance >= (restrictions.minAmountToBeLeft + amount) &&\n                reserveBalance >= (pToken.totalSupply().wmul(restrictions.minPercentOfTotalSupplyToBeLeft) + amount),\n            Errors.NOT_SUFFICIENT_RESERVE_BALANCE.selector\n        );\n\n        IBucket(bucket).withdraw(dns.treasury(), amount);\n\n        emit TransferFromReserve(address(pToken), dns.treasury(), amount);\n    }\n\n    /**\n     * @inheritdoc IReserve\n     */\n    function paybackPermanentLoss(IBucket _bucket) public override whenNotPaused nonReentrant {\n        (address bucket, , , ) = dns.buckets(_bucket.name());\n        _require(bucket == address(_bucket), Errors.ADDRESS_NOT_PRIMEX_BUCKET.selector);\n        uint256 permanentLoss = _bucket.permanentLoss();\n        uint256 balance = _bucket.pToken().balanceOf(address(this));\n\n        uint256 burnAmount = permanentLoss <= balance ? permanentLoss : balance;\n        emit BurnAmountCalculated(burnAmount);\n\n        _require(burnAmount > 0, Errors.BURN_AMOUNT_IS_ZERO.selector);\n        _bucket.paybackPermanentLoss(burnAmount);\n    }\n\n    /**\n     *  @notice Interface checker\n     *  @param _interfaceID The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceID) public view override returns (bool) {\n        return _interfaceID == type(IReserve).interfaceId || super.supportsInterface(_interfaceID);\n    }\n}\n"
    },
    "contracts/Reserve/ReserveStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IPrimexDNS} from \"../PrimexDNS/IPrimexDNS.sol\";\nimport {IReserveStorage} from \"./IReserveStorage.sol\";\n\nabstract contract ReserveStorage is\n    IReserveStorage,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC165Upgradeable\n{\n    IPrimexDNS internal dns;\n    address internal registry;\n\n    // map pToken address to its transfer restrictions\n    mapping(address => TransferRestrictions) public override transferRestrictions;\n}\n"
    },
    "contracts/SpotTradingRewardDistributor/ISpotTradingRewardDistributor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ISpotTradingRewardDistributorStorage} from \"./ISpotTradingRewardDistributorStorage.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface ISpotTradingRewardDistributor is ISpotTradingRewardDistributorStorage, IPausable {\n    event SpotTradingClaimReward(address indexed trader, uint256 amount);\n    event RewardPerPeriodDecreased(uint256 indexed rewardPerPeriod);\n    event TopUpUndistributedPmxBalance(uint256 indexed amount);\n    event RewardPerPeriodChanged(uint256 indexed rewardPerPeriod);\n    event PmxWithdrawn(uint256 indexed amount);\n\n    /**\n     * @dev contract initializer\n     * @param registry The address of Registry contract\n     * @param periodDuration The duration of a reward period\n     * @param priceOracle The address of PriceOracle contract\n     * @param pmx The address of PMX token\n     * @param traderBalanceVault The address of TraderBalanceVault contract\n     * @param treasury The address of Treasury contract\n     */\n    function initialize(\n        address registry,\n        uint256 periodDuration,\n        address priceOracle,\n        address pmx,\n        address payable traderBalanceVault,\n        address treasury\n    ) external;\n\n    /**\n     * @dev Function to update spot trader activity. Only PM_ROLE can call it.\n     * @param trader Address of a trader\n     * @param positionAsset Address of a position asset\n     * @param positionAmount Amount of a position asset\n     */\n    function updateTraderActivity(address trader, address positionAsset, uint256 positionAmount) external;\n\n    /**\n     * @dev Function to claim reward for spot trading activity.\n     * Transfer rewards on the balance in traderBalanceVault\n     * Emits SpotTradingClaimReward(address trader, uint256 amount)\n     */\n    function claimReward() external;\n\n    /**\n     * @dev Function to set new reward per period. Only BIG_TIMELOCK_ADMIN can call it.\n     * @param rewardPerPeriod New value for reward per period\n     */\n    function setRewardPerPeriod(uint256 rewardPerPeriod) external;\n\n    /**\n     * @dev Function to decrease reward per period. Only EMERGENCY_ADMIN can call it.\n     * @param _rewardPerPeriod New value for reward per period, must be less than the current value\n     */\n    function decreaseRewardPerPeriod(uint256 _rewardPerPeriod) external;\n\n    /**\n     * @dev Function to topUp the contract PMX balance\n     * @param amount PMX amount to add to the contract balance\n     */\n    function topUpUndistributedPmxBalance(uint256 amount) external;\n\n    /**\n     * @dev Function to withdraw PMX from the contract to treasury\n     * @param amount Amount of PMX to withdraw from the contract\n     */\n    function withdrawPmx(uint256 amount) external;\n\n    /**\n     * @dev Function to get SpotTraderActivity\n     * @param periodNumber Period number\n     * @param traderAddress Address of a trader\n     * @return A struct with activity and hasClaimed members\n     */\n    function getSpotTraderActivity(uint256 periodNumber, address traderAddress) external view returns (uint256);\n\n    /**\n     * @dev Get information for the period corresponding to the given timestamp\n     * @param timestamp The timestamp to get information about\n     * @return totalReward Total reward for the corresponding period\n     * @return totalActivity Total activity for the corresponding period\n     */\n    function getPeriodInfo(uint256 timestamp) external view returns (uint256, uint256);\n\n    /**\n     * @dev Function to get an array of period numbers when trader had any activity\n     * @param trader Address of a trader\n     * @return An array of period numbers with trader activity\n     */\n    function getPeriodsWithTraderActivity(address trader) external view returns (uint256[] memory);\n\n    /**\n     * @dev Function to calculate trader's reward for her activities during periods\n     * @param trader Address of a trader\n     * @return reward Amount of reward\n     * @return currentPeriod The current period\n     */\n    function calculateReward(address trader) external view returns (uint256 reward, uint256 currentPeriod);\n}\n"
    },
    "contracts/SpotTradingRewardDistributor/ISpotTradingRewardDistributorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ISpotTradingRewardDistributorStorage {\n    struct PeriodInfo {\n        uint256 totalReward;\n        // map trader address to her activity\n        mapping(address => uint256) traderActivity;\n        uint256 totalActivity;\n    }\n\n    function registry() external view returns (address);\n\n    function dns() external view returns (address);\n\n    function periodDuration() external view returns (uint256);\n\n    function initialPeriodTimestamp() external view returns (uint256);\n\n    function rewardPerPeriod() external view returns (uint256);\n\n    function pmx() external view returns (address);\n\n    function priceOracle() external view returns (address);\n\n    function treasury() external view returns (address);\n\n    function traderBalanceVault() external view returns (address payable);\n\n    function undistributedPMX() external view returns (uint256);\n\n    function periods(uint256 periodNumber) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/SpotTradingRewardDistributor/SpotTradingRewardDistributor.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport \"../libraries/Errors.sol\";\n\nimport {SpotTradingRewardDistributorStorage} from \"./SpotTradingRewardDistributorStorage.sol\";\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN, PM_ROLE, USD} from \"../Constants.sol\";\nimport {ISpotTradingRewardDistributor, IPausable} from \"./ISpotTradingRewardDistributor.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {ITreasury} from \"../Treasury/ITreasury.sol\";\n\ncontract SpotTradingRewardDistributor is ISpotTradingRewardDistributor, SpotTradingRewardDistributorStorage {\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Throws if caller is not granted with _role\n     * @param _role The role that is being checked for a function caller\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function initialize(\n        address _registry,\n        uint256 _periodDuration,\n        address _priceOracle,\n        address _pmx,\n        address payable _traderBalanceVault,\n        address _treasury\n    ) external override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId) &&\n                IERC165Upgradeable(address(_traderBalanceVault)).supportsInterface(\n                    type(ITraderBalanceVault).interfaceId\n                ) &&\n                IERC165Upgradeable(_pmx).supportsInterface(type(IERC20).interfaceId) &&\n                IERC165Upgradeable(_treasury).supportsInterface(type(ITreasury).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        _require(_periodDuration > 0, Errors.PERIOD_DURATION_IS_ZERO.selector);\n        registry = _registry;\n        initialPeriodTimestamp = block.timestamp;\n        periodDuration = _periodDuration;\n        priceOracle = _priceOracle;\n        pmx = _pmx;\n        traderBalanceVault = _traderBalanceVault;\n        treasury = _treasury;\n        __ERC165_init();\n        __ReentrancyGuard_init();\n        __Pausable_init();\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function updateTraderActivity(\n        address trader,\n        address positionAsset,\n        uint256 positionAmount\n    ) external override onlyRole(PM_ROLE) {\n        uint256 currentPeriod = _getCurrentPeriod(block.timestamp);\n        PeriodInfo storage periodInfo = periods[currentPeriod];\n\n        if (periodInfo.totalReward == 0) {\n            if (rewardPerPeriod == 0 || rewardPerPeriod > undistributedPMX) {\n                return;\n            }\n            undistributedPMX -= rewardPerPeriod;\n            periodInfo.totalReward = rewardPerPeriod;\n        }\n\n        uint256 positionSizeInUsd = PrimexPricingLibrary.getOracleAmountsOut(\n            positionAsset,\n            USD,\n            positionAmount,\n            priceOracle\n        );\n\n        periodInfo.traderActivity[trader] += positionSizeInUsd;\n        periodInfo.totalActivity += positionSizeInUsd;\n\n        if (\n            periodsWithTraderActivity[trader].length == 0 ||\n            periodsWithTraderActivity[trader][periodsWithTraderActivity[trader].length - 1] != currentPeriod\n        ) {\n            periodsWithTraderActivity[trader].push(currentPeriod);\n        }\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function setRewardPerPeriod(uint256 _rewardPerPeriod) external override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        rewardPerPeriod = _rewardPerPeriod;\n        emit RewardPerPeriodChanged(_rewardPerPeriod);\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function decreaseRewardPerPeriod(uint256 _rewardPerPeriod) external override onlyRole(EMERGENCY_ADMIN) {\n        _require(_rewardPerPeriod < rewardPerPeriod, Errors.REWARD_PER_PERIOD_IS_NOT_CORRECT.selector);\n        rewardPerPeriod = _rewardPerPeriod;\n        emit RewardPerPeriodDecreased(_rewardPerPeriod);\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function claimReward() external override nonReentrant whenNotPaused {\n        (uint256 reward, uint256 currentPeriod) = calculateReward(msg.sender);\n        _require(reward > 0, Errors.REWARD_AMOUNT_IS_ZERO.selector);\n        uint256[] memory periodNumbers = periodsWithTraderActivity[msg.sender];\n        delete periodsWithTraderActivity[msg.sender];\n\n        if (periodNumbers[periodNumbers.length - 1] == currentPeriod) {\n            periodsWithTraderActivity[msg.sender].push(currentPeriod);\n        }\n\n        IERC20(pmx).transfer(address(traderBalanceVault), reward);\n        ITraderBalanceVault(traderBalanceVault).topUpAvailableBalance(msg.sender, address(pmx), reward);\n\n        emit SpotTradingClaimReward(msg.sender, reward);\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function topUpUndistributedPmxBalance(uint256 amount) external override nonReentrant {\n        undistributedPMX += amount;\n        IERC20(pmx).transferFrom(msg.sender, address(this), amount);\n        emit TopUpUndistributedPmxBalance(amount);\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function withdrawPmx(uint256 amount) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(undistributedPMX >= amount, Errors.AMOUNT_EXCEEDS_AVAILABLE_BALANCE.selector);\n        undistributedPMX -= amount;\n        IERC20(pmx).transfer(treasury, amount);\n        emit PmxWithdrawn(amount);\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function getPeriodInfo(uint256 _timestamp) external view override returns (uint256, uint256) {\n        uint256 periodNumber = _getCurrentPeriod(_timestamp);\n        uint256 currentPeriodNumber = _getCurrentPeriod(block.timestamp);\n        PeriodInfo storage periodInfo = periods[periodNumber];\n        uint256 totalReward;\n\n        if (periodInfo.totalReward == 0 && currentPeriodNumber == periodNumber) {\n            totalReward = rewardPerPeriod;\n        } else {\n            totalReward = periodInfo.totalReward;\n        }\n        return (totalReward, periodInfo.totalActivity);\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function getSpotTraderActivity(uint256 periodNumber, address trader) external view override returns (uint256) {\n        return periods[periodNumber].traderActivity[trader];\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function calculateReward(address trader) public view override returns (uint256 reward, uint256 currentPeriod) {\n        currentPeriod = _getCurrentPeriod(block.timestamp);\n        uint256[] memory periodNumbers = periodsWithTraderActivity[trader];\n        if (periodNumbers.length == 0) return (0, currentPeriod);\n\n        uint256 length = periodNumbers[periodNumbers.length - 1] == currentPeriod\n            ? periodNumbers.length - 1\n            : periodNumbers.length;\n        for (uint256 i; i < length; i++) {\n            PeriodInfo storage periodInfo = periods[periodNumbers[i]];\n            reward += (periodInfo.totalReward * periodInfo.traderActivity[trader]) / periodInfo.totalActivity;\n        }\n        return (reward, currentPeriod);\n    }\n\n    /**\n     * @inheritdoc ISpotTradingRewardDistributor\n     */\n    function getPeriodsWithTraderActivity(address trader) public view override returns (uint256[] memory) {\n        return periodsWithTraderActivity[trader];\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\n        return _interfaceId == type(ISpotTradingRewardDistributor).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    function _getCurrentPeriod(uint256 currentTimestamp) internal view returns (uint256) {\n        return (currentTimestamp - initialPeriodTimestamp) / periodDuration;\n    }\n}\n"
    },
    "contracts/SpotTradingRewardDistributor/SpotTradingRewardDistributorStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {ISpotTradingRewardDistributorStorage} from \"./ISpotTradingRewardDistributorStorage.sol\";\n\nabstract contract SpotTradingRewardDistributorStorage is\n    ISpotTradingRewardDistributorStorage,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    ERC165Upgradeable\n{\n    address public override registry;\n    address public override dns;\n    uint256 public override periodDuration;\n    uint256 public override initialPeriodTimestamp;\n    uint256 public override rewardPerPeriod;\n    address public override pmx;\n    address public override priceOracle;\n    address public override treasury;\n    address payable public override traderBalanceVault;\n    uint256 public override undistributedPMX;\n\n    //map period number to period info\n    mapping(uint256 => PeriodInfo) public override periods;\n\n    //map trader to array of period numbers with her activity\n    mapping(address => uint256[]) internal periodsWithTraderActivity;\n}\n"
    },
    "contracts/SwapManager.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {WadRayMath} from \"./libraries/utils/WadRayMath.sol\";\n\nimport {PrimexPricingLibrary} from \"./libraries/PrimexPricingLibrary.sol\";\nimport {TokenTransfersLibrary} from \"./libraries/TokenTransfersLibrary.sol\";\nimport \"./libraries/Errors.sol\";\n\nimport {BIG_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN, NO_FEE_ROLE, NATIVE_CURRENCY} from \"./Constants.sol\";\nimport {ISwapManager} from \"./interfaces/ISwapManager.sol\";\nimport {ITraderBalanceVault} from \"./TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IPrimexDNS} from \"./PrimexDNS/IPrimexDNS.sol\";\nimport {IPrimexDNSStorage} from \"./PrimexDNS/IPrimexDNSStorage.sol\";\nimport {IPriceOracle} from \"./PriceOracle/IPriceOracle.sol\";\nimport {IWhiteBlackList} from \"./WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IPausable} from \"./interfaces/IPausable.sol\";\n\ncontract SwapManager is ISwapManager, ReentrancyGuard, Pausable, IERC165 {\n    using WadRayMath for uint256;\n\n    IAccessControl public immutable override registry;\n    ITraderBalanceVault public immutable override traderBalanceVault;\n    IPrimexDNS public immutable override primexDNS;\n    IPriceOracle public immutable override priceOracle;\n    IWhiteBlackList internal immutable whiteBlackList;\n\n    /**\n     * @dev Throws if caller is not granted with _role\n     * @param _role The role that is being checked for a function caller\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the sender is not blacklisted.\n     */\n    modifier notBlackListed() {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n        _;\n    }\n\n    constructor(\n        address _registry,\n        address _primexDNS,\n        address payable _traderBalanceVault,\n        address _priceOracle,\n        address _whiteBlackList\n    ) {\n        _require(\n            IERC165(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165(address(_primexDNS)).supportsInterface(type(IPrimexDNS).interfaceId) &&\n                IERC165(_traderBalanceVault).supportsInterface(type(ITraderBalanceVault).interfaceId) &&\n                IERC165(_priceOracle).supportsInterface(type(IPriceOracle).interfaceId) &&\n                IERC165(_whiteBlackList).supportsInterface(type(IWhiteBlackList).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        whiteBlackList = IWhiteBlackList(_whiteBlackList);\n        registry = IAccessControl(_registry);\n        primexDNS = IPrimexDNS(_primexDNS);\n        traderBalanceVault = ITraderBalanceVault(_traderBalanceVault);\n        priceOracle = IPriceOracle(_priceOracle);\n    }\n\n    /**\n     * @inheritdoc ISwapManager\n     */\n    function swap(\n        SwapParams calldata params,\n        uint256 maximumOracleTolerableLimit,\n        bool needOracleTolerableLimitCheck\n    ) external payable override nonReentrant notBlackListed whenNotPaused returns (uint256) {\n        bool isFeeRole = registry.hasRole(NO_FEE_ROLE, msg.sender);\n        if (!isFeeRole) {\n            address feeToken = params.isSwapFeeInPmx ? primexDNS.pmx() : NATIVE_CURRENCY;\n            PrimexPricingLibrary.payProtocolFee(\n                PrimexPricingLibrary.ProtocolFeeParams({\n                    depositData: PrimexPricingLibrary.DepositData({\n                        protocolFee: 0,\n                        depositAsset: params.tokenA,\n                        depositAmount: params.amountTokenA,\n                        leverage: WadRayMath.WAD\n                    }),\n                    feeToken: feeToken,\n                    isSwapFromWallet: params.payFeeFromWallet,\n                    calculateFee: true,\n                    orderType: IPrimexDNSStorage.OrderType.SWAP_MARKET_ORDER,\n                    trader: msg.sender,\n                    priceOracle: address(priceOracle),\n                    traderBalanceVault: traderBalanceVault,\n                    primexDNS: primexDNS\n                })\n            );\n        }\n        address dexAdapter = address(primexDNS.dexAdapter());\n        if (params.isSwapFromWallet) {\n            TokenTransfersLibrary.doTransferFromTo(params.tokenA, msg.sender, dexAdapter, params.amountTokenA);\n        } else {\n            traderBalanceVault.useTraderAssets(\n                ITraderBalanceVault.LockAssetParams({\n                    trader: msg.sender,\n                    depositReceiver: dexAdapter,\n                    depositAsset: params.tokenA,\n                    depositAmount: params.amountTokenA,\n                    openType: ITraderBalanceVault.OpenType.OPEN\n                })\n            );\n        }\n\n        uint256 amountOut = PrimexPricingLibrary.multiSwap(\n            PrimexPricingLibrary.MultiSwapParams({\n                tokenA: params.tokenA,\n                tokenB: params.tokenB,\n                amountTokenA: params.amountTokenA,\n                routes: params.routes,\n                dexAdapter: dexAdapter,\n                receiver: params.isSwapToWallet ? params.receiver : address(traderBalanceVault),\n                deadline: params.deadline\n            }),\n            maximumOracleTolerableLimit,\n            address(primexDNS),\n            address(priceOracle),\n            isFeeRole && needOracleTolerableLimitCheck\n        );\n        _require(amountOut >= params.amountOutMin, Errors.SLIPPAGE_TOLERANCE_EXCEEDED.selector);\n\n        if (!params.isSwapToWallet) {\n            traderBalanceVault.topUpAvailableBalance(params.receiver, params.tokenB, amountOut);\n        }\n        emit SpotSwap({\n            trader: msg.sender,\n            receiver: params.receiver,\n            tokenA: params.tokenA,\n            tokenB: params.tokenB,\n            amountSold: params.amountTokenA,\n            amountBought: amountOut\n        });\n        return amountOut;\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IERC165).interfaceId || _interfaceId == type(ISwapManager).interfaceId;\n    }\n}\n"
    },
    "contracts/test/PositionManagerFuzz.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport {PositionManager} from \"../PositionManager/PositionManager.sol\";\nimport {IPositionManager} from \"../PositionManager/IPositionManager.sol\";\nimport {PositionLibrary} from \"../libraries/PositionLibrary.sol\";\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {LimitOrderLibrary} from \"../libraries/LimitOrderLibrary.sol\";\nimport {IERC20Mock} from \"../interfaces/IERC20Mock.sol\";\nimport {IBucket} from \"../Bucket/IBucket.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IPriceFeedUpdaterTestService} from \"../interfaces/IPriceFeedUpdaterTestService.sol\";\nimport {PrimexAggregatorV3TestService} from \"../TestnetServices/PrimexAggregatorV3TestService.sol\";\nimport {NATIVE_CURRENCY} from \"../Constants.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\nimport {IDexAdapter} from \"../interfaces/IDexAdapter.sol\";\nimport {IEPMXToken} from \"../interfaces/IEPMXToken.sol\";\nimport {IPrimexDNSStorage} from \"../PrimexDNS/IPrimexDNSStorage.sol\";\n\ncontract PositionManagerFuzz {\n    /* solhint-disable */\n    using WadRayMath for uint256;\n    address constant randomAddress = 0x3Ce6356Cd31eDFd208eCe2CA515f264Fd90DD5AB;\n    PositionManager internal pm;\n    uint256 constant WAD = 10 ** 18;\n    IERC20Mock internal depositToken;\n    IERC20Mock internal epmx;\n    IERC20Mock[4] internal tokensToBuy;\n    uint256[4] internal decimals;\n    uint256 internal depositTokenDecimals;\n    IBucket internal bucket;\n    IPriceOracle internal priceOracle;\n    IDexAdapter internal dexAdapter;\n    string[5] internal dexes;\n    ITraderBalanceVault internal traderBalanceVault;\n    IPriceFeedUpdaterTestService internal priceFeedUpdaterTestService;\n    uint256 internal protocolRate;\n    uint256 internal protocolRateInPmx;\n    uint256 internal MIN_DEPOSIT_AMOUNT;\n    uint256 internal MAX_DEPOSIT_AMOUNT;\n    uint256 internal MIN_BORROWED_AMOUNT;\n    uint256 internal MAX_BORROWED_AMOUNT;\n\n    receive() external payable {}\n\n    constructor() payable {\n        pm = PositionManager(0xb581A901E74a160865c6D5DeEaa65eE0e4eD15E9);\n        //usdc\n        depositToken = IERC20Mock(0x871DD7C2B4b25E1Aa18728e9D5f2Af4C4e431f5c);\n        bucket = IBucket(0x51A3F39ee1CA547b6D04B9A0a2358342b3a3F832);\n\n        priceOracle = IPriceOracle(0xaE52826fC2AB091C026Cf8c919b76b3A4996fd8B);\n        dexAdapter = IDexAdapter(0x786fE8061fBd5ECDe5fdc5fa03b4672F217880e6);\n        // \"weth\", \"wbtc\", \"link\", \"uni\"\n        tokensToBuy = [\n            IERC20Mock(0x1dC4c1cEFEF38a777b15aA20260a54E584b16C48),\n            IERC20Mock(0x1D7022f5B17d2F8B695918FB48fa1089C9f85401),\n            IERC20Mock(0x0B1ba0af832d7C05fD64161E0Db78E85978E8082),\n            IERC20Mock(0x48BaCB9266a570d521063EF5dD96e61686DbE788)\n        ];\n        decimals = [18, 8, 18, 18];\n        depositTokenDecimals = 6;\n        dexes = [\"uniswap\", \"sushiswap\", \"uniswapv3\", \"quickswapv3\", \"meshswap\"];\n        priceFeedUpdaterTestService = IPriceFeedUpdaterTestService(0x538281ccF8aD9266e6e3f6C6077e122B1F56dBd6);\n        MIN_DEPOSIT_AMOUNT = 1 * 10 ** depositTokenDecimals;\n        MAX_DEPOSIT_AMOUNT = 10000 * 10 ** depositTokenDecimals;\n        MIN_BORROWED_AMOUNT = 0;\n        traderBalanceVault = ITraderBalanceVault(payable(0x1660b74302A5d34b2db784CAF456BD39C2D9942c));\n        epmx = IERC20Mock(0xD1aE64401d65E9B0d1bF7E08Fbf75bb2F26eF70a);\n        protocolRate = pm.primexDNS().feeRates(IPrimexDNSStorage.OrderType.MARKET_ORDER, address(0));\n        protocolRateInPmx = pm.primexDNS().feeRates(IPrimexDNSStorage.OrderType.MARKET_ORDER, address(epmx));\n    }\n\n    struct SetCorrectOraclePriceParams {\n        uint256 swapSize;\n        string dex;\n        address[] path;\n        uint256 aTokenDecimals;\n        uint256 bTokenDecimals;\n    }\n\n    struct LocalVars {\n        uint256 depositAmount;\n        uint256 borrowedAmount;\n        address positionAsset;\n        uint256 positionAssetDecimals;\n        uint256 protocolFee;\n        uint256 positionId;\n        string dex;\n        address[] path;\n        uint256 closeAmount;\n        PrimexPricingLibrary.Route[] routes;\n        LimitOrderLibrary.Condition[] conditions;\n    }\n\n    struct OpenPositionParams {\n        uint256 depositAmount;\n        uint256 borrowedAmount;\n        address depositAsset;\n        address positionAsset;\n        uint256 positionAssetDecimals;\n        bool isProtocolFeeInPmx;\n        bool takeDepositFromWallet;\n        string dex;\n    }\n\n    function increaseDeposit_never_revert(\n        uint40 _increaseAmountSeed,\n        uint40 _depositAmountSeed,\n        uint40 _borrowedAmountSeed,\n        bool _takeDepositFromWallet,\n        bool _isProtocolFeeInPmx\n    ) public {\n        LocalVars memory vars;\n        vars.depositAmount = MIN_DEPOSIT_AMOUNT + (_depositAmountSeed % (MAX_DEPOSIT_AMOUNT - MIN_DEPOSIT_AMOUNT));\n        (vars.positionAsset, vars.positionAssetDecimals) = _getRandomPositionAsset(0);\n        MIN_BORROWED_AMOUNT = 1 * 10 ** depositTokenDecimals;\n        //calculate max borrowed amount considering the maxAssetLeverage\n        MAX_BORROWED_AMOUNT = bucket.maxAssetLeverage(vars.positionAsset).wmul(vars.depositAmount) - vars.depositAmount;\n        vars.borrowedAmount = MIN_BORROWED_AMOUNT + (_borrowedAmountSeed % (MAX_BORROWED_AMOUNT - MIN_BORROWED_AMOUNT));\n        //uniswap\n        vars.dex = _getRandomDex(0);\n        vars.positionId = _openValidPosition(\n            OpenPositionParams(\n                vars.depositAmount,\n                vars.borrowedAmount,\n                address(depositToken),\n                vars.positionAsset,\n                vars.positionAssetDecimals,\n                _isProtocolFeeInPmx,\n                _takeDepositFromWallet,\n                vars.dex\n            )\n        );\n\n        //closeRoutes\n        vars.routes = new PrimexPricingLibrary.Route[](1);\n        vars.routes[0] = PrimexPricingLibrary.Route({paths: new PrimexPricingLibrary.SwapPath[](1), shares: 1});\n        vars.path = new address[](2);\n        vars.path[0] = vars.positionAsset;\n        vars.path[1] = address(depositToken);\n        vars.routes[0].paths[0].encodedPath = PrimexPricingLibrary.encodePath(\n            vars.path,\n            pm.primexDNS().getDexAddress(vars.dex),\n            _getAncillaryDexData(vars.dex),\n            pm.primexDNS().dexAdapter(),\n            false\n        );\n\n        //between 1 and balance of this contract\n        uint256 increaseAmount = 1 + (_increaseAmountSeed % IERC20Mock(depositToken).balanceOf(address(this)));\n        IERC20Mock(depositToken).approve(address(pm), increaseAmount);\n        _increaseDeposit_should_not_revert(\n            vars.positionId,\n            increaseAmount,\n            address(depositToken),\n            true,\n            vars.routes,\n            0\n        );\n        revert();\n    }\n\n    function _increaseDeposit_should_not_revert(\n        uint256 _positionId,\n        uint256 _amount,\n        address _asset,\n        bool _takeDepositFromWallet,\n        PrimexPricingLibrary.Route[] memory _routes,\n        uint256 _amountOutMin\n    ) internal {\n        try pm.increaseDeposit(_positionId, _amount, _asset, _takeDepositFromWallet, _routes, _amountOutMin) {} catch {\n            assert(false);\n        }\n    }\n\n    function partiallyClosePosition_never_revert(\n        uint40 _closeAmountSeed,\n        uint40 _depositAmountSeed,\n        uint40 _borrowedAmountSeed,\n        bool _takeDepositFromWallet,\n        bool _isProtocolFeeInPmx,\n        bool _randomReceiver\n    ) public {\n        LocalVars memory vars;\n        vars.depositAmount = MIN_DEPOSIT_AMOUNT + (_depositAmountSeed % (MAX_DEPOSIT_AMOUNT - MIN_DEPOSIT_AMOUNT));\n        (vars.positionAsset, vars.positionAssetDecimals) = _getRandomPositionAsset(0);\n        MIN_BORROWED_AMOUNT = 1 * 10 ** depositTokenDecimals;\n        //calculate max borrowed amount considering the maxAssetLeverage\n        MAX_BORROWED_AMOUNT = bucket.maxAssetLeverage(vars.positionAsset).wmul(vars.depositAmount) - vars.depositAmount;\n        vars.borrowedAmount = MIN_BORROWED_AMOUNT + (_borrowedAmountSeed % (MAX_BORROWED_AMOUNT - MIN_BORROWED_AMOUNT));\n\n        //uniswap\n        vars.dex = _getRandomDex(0);\n        vars.positionId = _openValidPosition(\n            OpenPositionParams(\n                vars.depositAmount,\n                vars.borrowedAmount,\n                address(depositToken),\n                vars.positionAsset,\n                vars.positionAssetDecimals,\n                _isProtocolFeeInPmx,\n                _takeDepositFromWallet,\n                vars.dex\n            )\n        );\n        vars.path[0] = vars.positionAsset;\n        vars.path[1] = address(depositToken);\n        vars.routes[0].paths[0].encodedPath = PrimexPricingLibrary.encodePath(\n            vars.path,\n            pm.primexDNS().getDexAddress(vars.dex),\n            _getAncillaryDexData(vars.dex),\n            pm.primexDNS().dexAdapter(),\n            false\n        );\n        uint256 positionAmount = pm.getPosition(vars.positionId).positionAmount;\n        // between 0 and positionAmount;\n        uint256 closeAmount = (_closeAmountSeed % positionAmount);\n\n        // to avoid trying to burn 0 debt tokens.\n        if (vars.borrowedAmount == 0 || vars.borrowedAmount.wmul(closeAmount.wdiv(positionAmount)) > 0) {\n            _setCorrectOraclePrice(\n                SetCorrectOraclePriceParams(\n                    closeAmount,\n                    vars.dex,\n                    vars.path,\n                    vars.positionAssetDecimals,\n                    depositTokenDecimals\n                )\n            );\n            _partiallyClosePosition_should_not_revert(\n                vars.positionId,\n                closeAmount,\n                _randomReceiver ? randomAddress : address(this),\n                vars.routes,\n                0\n            );\n        }\n        revert();\n    }\n\n    function openPosition_and_closePosition_never_revert(\n        uint40 _depositAmountSeed,\n        uint40 _borrowedAmountSeed,\n        uint8 _positionAssetSeed,\n        uint8 _dexSeed,\n        bool _takeDepositFromWallet,\n        bool _isProtocolFeeInPmx,\n        bool _randomReceiver\n    ) public {\n        LocalVars memory vars;\n        vars.depositAmount = MIN_DEPOSIT_AMOUNT + (_depositAmountSeed % (MAX_DEPOSIT_AMOUNT - MIN_DEPOSIT_AMOUNT));\n        (vars.positionAsset, vars.positionAssetDecimals) = _getRandomPositionAsset(_positionAssetSeed);\n\n        //calculate max borrowed amount considering the maxAssetLeverage\n        MAX_BORROWED_AMOUNT = bucket.maxAssetLeverage(vars.positionAsset).wmul(vars.depositAmount) - vars.depositAmount;\n        vars.borrowedAmount = MIN_BORROWED_AMOUNT + (_borrowedAmountSeed % (MAX_BORROWED_AMOUNT - MIN_BORROWED_AMOUNT));\n        _addLiquidityToBucket(vars.borrowedAmount);\n        vars.dex = _getRandomDex(_dexSeed);\n        PrimexPricingLibrary.Route[] memory routes = new PrimexPricingLibrary.Route[](1);\n        PrimexPricingLibrary.Route memory route = PrimexPricingLibrary.Route({\n            paths: new PrimexPricingLibrary.SwapPath[](1),\n            shares: 1\n        });\n        address[] memory path = new address[](2);\n        path[0] = address(depositToken);\n        path[1] = vars.positionAsset;\n        route.paths[0] = PrimexPricingLibrary.SwapPath({\n            dexName: vars.dex,\n            encodedPath: PrimexPricingLibrary.encodePath(\n                path,\n                pm.primexDNS().getDexAddress(vars.dex),\n                _getAncillaryDexData(vars.dex),\n                pm.primexDNS().dexAdapter(),\n                false\n            )\n        });\n        routes[0] = route;\n        vars.closeAmount = _setCorrectOraclePrice(\n            SetCorrectOraclePriceParams(\n                vars.depositAmount + vars.borrowedAmount,\n                vars.dex,\n                path,\n                depositTokenDecimals,\n                vars.positionAssetDecimals\n            )\n        );\n        PositionLibrary.OpenPositionMarginParams memory marginParams = PositionLibrary.OpenPositionMarginParams({\n            bucket: vars.borrowedAmount == 0 ? new string(0) : bucket.name(),\n            borrowedAmount: vars.borrowedAmount,\n            depositInThirdAssetRoutes: new PrimexPricingLibrary.Route[](0)\n        });\n        LimitOrderLibrary.Condition[] memory cond = new LimitOrderLibrary.Condition[](0);\n        PositionLibrary.OpenPositionParams memory params = PositionLibrary.OpenPositionParams({\n            marginParams: marginParams,\n            firstAssetRoutes: routes,\n            depositAsset: address(depositToken),\n            depositAmount: vars.depositAmount,\n            isProtocolFeeInPmx: _isProtocolFeeInPmx,\n            positionAsset: vars.positionAsset,\n            amountOutMin: 0,\n            deadline: block.timestamp + 100,\n            takeDepositFromWallet: _takeDepositFromWallet,\n            payFeeFromWallet: _takeDepositFromWallet,\n            closeConditions: cond\n        });\n        vars.protocolFee = _beforeDeposit(\n            _takeDepositFromWallet,\n            _isProtocolFeeInPmx,\n            vars.depositAmount,\n            vars.borrowedAmount\n        );\n        _openPosition_should_not_revert(params, _takeDepositFromWallet && !_isProtocolFeeInPmx ? vars.protocolFee : 0);\n        path[0] = vars.positionAsset;\n        path[1] = address(depositToken);\n        routes[0].paths[0].encodedPath = PrimexPricingLibrary.encodePath(\n            path,\n            pm.primexDNS().getDexAddress(vars.dex),\n            _getAncillaryDexData(vars.dex),\n            pm.primexDNS().dexAdapter(),\n            false\n        );\n        _setCorrectOraclePrice(\n            SetCorrectOraclePriceParams(\n                vars.closeAmount,\n                vars.dex,\n                path,\n                vars.positionAssetDecimals,\n                depositTokenDecimals\n            )\n        );\n        _closePosition_should_not_revert(0, _randomReceiver ? randomAddress : address(this), routes, 0);\n        revert();\n    }\n\n    function health_never_revert(\n        uint256 _borrowedAssetAmountOutSeed,\n        uint256 _pairPriceDropSeed,\n        uint256 _securityBufferSeed,\n        uint256 _oracleTolerableLimitSeed,\n        uint256 _positionDebtSeed,\n        uint256 _feeBufferSeed\n    ) internal pure {\n        // _feeBufferSeed == 0 then divide by zero\n        uint256 feeBuffer = WadRayMath.WAD + (_feeBufferSeed % (WadRayMath.WAD * 100 - WadRayMath.WAD));\n        uint256 debt = 100 + ((_positionDebtSeed % type(uint56).max) - 1);\n        uint256 _borrowedAssetAmountOut = 1 + (_borrowedAssetAmountOutSeed % (type(uint56).max - 1));\n        try\n            PositionLibrary.health(\n                _borrowedAssetAmountOut,\n                _pairPriceDropSeed % WadRayMath.WAD, // max WadRayMath.WAD - 1\n                _securityBufferSeed % WadRayMath.WAD, // max WadRayMath.WAD - 1\n                (_oracleTolerableLimitSeed % WadRayMath.WAD) + 1, // max WadRayMath.WAD\n                debt,\n                feeBuffer\n            )\n        returns (uint256 health) {\n            assert(health > 0);\n        } catch {\n            assert(false);\n        }\n    }\n\n    function _partiallyClosePosition_should_not_revert(\n        uint256 _positionId,\n        uint256 _amount,\n        address _depositReceiver,\n        PrimexPricingLibrary.Route[] memory _routes,\n        uint256 _amountOutMin\n    ) internal {\n        try pm.partiallyClosePosition(_positionId, _amount, _depositReceiver, _routes, _amountOutMin) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n\n    function _addLiquidityToBucket(uint256 _amount) internal {\n        if (_amount > 0) {\n            depositToken.approve(address(bucket), _amount);\n            bucket.deposit(address(this), _amount);\n        }\n    }\n\n    function _getRandomDex(uint8 _seed) internal view returns (string memory) {\n        return dexes[_seed % dexes.length];\n    }\n\n    function _getRandomPositionAsset(uint8 _seed) internal view returns (address, uint256) {\n        return (address(tokensToBuy[_seed % tokensToBuy.length]), decimals[_seed % tokensToBuy.length]);\n    }\n\n    function _getAncillaryDexData(string memory _dex) internal pure returns (bytes32) {\n        if (keccak256(bytes(_dex)) == keccak256(\"uniswapv3\")) {\n            return bytes32(uint256(3000));\n        }\n        return bytes32(0);\n    }\n\n    function _getAmountsOut(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountA,\n        string memory _dex\n    ) internal returns (uint256) {\n        address[] memory path = new address[](2);\n        path[0] = _tokenA;\n        path[1] = _tokenB;\n        return\n            dexAdapter.getAmountsOut(\n                IDexAdapter.GetAmountsParams(\n                    PrimexPricingLibrary.encodePath(\n                        path,\n                        pm.primexDNS().getDexAddress(_dex),\n                        _getAncillaryDexData(_dex),\n                        pm.primexDNS().dexAdapter(),\n                        false\n                    ),\n                    _amountA,\n                    pm.primexDNS().getDexAddress(_dex)\n                )\n            )[1];\n    }\n\n    function _setCorrectOraclePrice(SetCorrectOraclePriceParams memory _params) internal returns (uint256) {\n        if (_params.swapSize == 0) return 0;\n        uint256 amountOutB = _getAmountsOut(_params.path[0], _params.path[1], _params.swapSize, _params.dex);\n        amountOutB = amountOutB * 10 ** (18 - _params.bTokenDecimals);\n        (address basePriceFeed, address quotePriceFeed) = priceOracle.getPriceFeedsPair(\n            _params.path[0],\n            _params.path[1]\n        );\n        (, int256 quotePrice, , , ) = AggregatorV3Interface(quotePriceFeed).latestRoundData();\n\n        (, bool isForward) = priceOracle.getExchangeRate(_params.path[0], _params.path[1]);\n        uint256 basePrice;\n        quotePrice = quotePrice * 10 ** (18 - 8);\n        if (isForward) {\n            // (amountB * mulB) / (amountA * mulA) * quotePrice\n            uint256 targetPrice = amountOutB.wdiv(_params.swapSize * 10 ** (18 - _params.aTokenDecimals));\n            basePrice = targetPrice.wmul(uint256(quotePrice));\n        } else {\n            // (amountA * mulA) / (amountB * mulB) * quotePrice\n            uint256 targetPrice = (_params.swapSize * 10 ** (18 - _params.aTokenDecimals)).wdiv(amountOutB);\n            basePrice = targetPrice.wmul(uint256(quotePrice));\n        }\n        priceFeedUpdaterTestService.updatePriceFeed(\n            PrimexAggregatorV3TestService(basePriceFeed),\n            int256(basePrice / 10 ** (18 - 8))\n        );\n        return amountOutB / 10 ** (18 - _params.bTokenDecimals);\n    }\n\n    function _openValidPosition(OpenPositionParams memory _params) internal returns (uint256) {\n        _addLiquidityToBucket(_params.borrowedAmount);\n        PrimexPricingLibrary.Route[] memory routes = new PrimexPricingLibrary.Route[](1);\n        routes[0] = PrimexPricingLibrary.Route({paths: new PrimexPricingLibrary.SwapPath[](1), shares: 1});\n\n        address[] memory path = new address[](2);\n        path[0] = _params.depositAsset;\n        path[1] = _params.positionAsset;\n        routes[0].paths[0] = PrimexPricingLibrary.SwapPath({\n            dexName: _params.dex,\n            encodedPath: PrimexPricingLibrary.encodePath(\n                path,\n                pm.primexDNS().getDexAddress(_params.dex),\n                _getAncillaryDexData(_params.dex),\n                pm.primexDNS().dexAdapter(),\n                false\n            )\n        });\n        PositionLibrary.OpenPositionMarginParams memory marginParams = PositionLibrary.OpenPositionMarginParams({\n            bucket: _params.borrowedAmount == 0 ? new string(0) : bucket.name(),\n            borrowedAmount: _params.borrowedAmount,\n            depositInThirdAssetRoutes: new PrimexPricingLibrary.Route[](0)\n        });\n        LimitOrderLibrary.Condition[] memory conditions = new LimitOrderLibrary.Condition[](0);\n        PositionLibrary.OpenPositionParams memory params = PositionLibrary.OpenPositionParams({\n            marginParams: marginParams,\n            firstAssetRoutes: routes,\n            depositAsset: _params.depositAsset,\n            depositAmount: _params.depositAmount,\n            isProtocolFeeInPmx: _params.isProtocolFeeInPmx,\n            positionAsset: _params.positionAsset,\n            amountOutMin: 0,\n            deadline: block.timestamp + 100,\n            takeDepositFromWallet: _params.takeDepositFromWallet,\n            payFeeFromWallet: _params.takeDepositFromWallet,\n            closeConditions: conditions\n        });\n        uint256 protocolFee = _beforeDeposit(\n            _params.takeDepositFromWallet,\n            _params.isProtocolFeeInPmx,\n            _params.depositAmount,\n            _params.borrowedAmount\n        );\n        _setCorrectOraclePrice(\n            SetCorrectOraclePriceParams(\n                _params.depositAmount + _params.borrowedAmount,\n                _params.dex,\n                path,\n                depositTokenDecimals,\n                _params.positionAssetDecimals\n            )\n        );\n        return\n            _openPosition_should_not_revert(\n                params,\n                _params.takeDepositFromWallet && !_params.isProtocolFeeInPmx ? protocolFee : 0\n            );\n    }\n\n    function _beforeDeposit(\n        bool _takeDepositFromWallet,\n        bool _isProtocolFeeInPmx,\n        uint256 _depositAmount,\n        uint256 _borrowedAmount\n    ) internal returns (uint256 protocolFee) {\n        protocolFee = PrimexPricingLibrary.getOracleAmountsOut(\n            address(depositToken),\n            _isProtocolFeeInPmx ? address(epmx) : NATIVE_CURRENCY,\n            (_depositAmount + _borrowedAmount).wmul(_isProtocolFeeInPmx ? protocolRateInPmx : protocolRate),\n            address(priceOracle)\n        );\n        if (_takeDepositFromWallet) {\n            depositToken.approve(address(pm), _depositAmount);\n            if (_isProtocolFeeInPmx) epmx.approve(address(pm), protocolFee);\n        } else {\n            depositToken.approve(address(traderBalanceVault), _depositAmount);\n            traderBalanceVault.deposit(address(depositToken), _depositAmount);\n            if (_isProtocolFeeInPmx) {\n                epmx.approve(address(traderBalanceVault), protocolFee);\n                traderBalanceVault.deposit(address(epmx), protocolFee);\n            } else {\n                traderBalanceVault.deposit{value: protocolFee}(address(0), 0);\n            }\n        }\n    }\n\n    function _openPosition_should_not_revert(\n        PositionLibrary.OpenPositionParams memory _params,\n        uint256 _value\n    ) internal returns (uint256 positionId) {\n        positionId = pm.positionsId();\n        try pm.openPosition{value: _value}(_params) {} catch {\n            assert(false);\n        }\n    }\n\n    function _closePosition_should_not_revert(\n        uint256 _id,\n        address _depositReceiver,\n        PrimexPricingLibrary.Route[] memory _routes,\n        uint256 _amountOutMin\n    ) internal {\n        try pm.closePosition(_id, _depositReceiver, _routes, _amountOutMin) {\n            assert(true);\n        } catch {\n            assert(false);\n        }\n    }\n\n    function _openPosition_should_revert(PositionLibrary.OpenPositionParams memory _params, uint256 _value) internal {\n        try pm.openPosition{value: _value}(_params) {\n            assert(false);\n        } catch {\n            assert(true);\n        }\n    }\n}\n"
    },
    "contracts/test/SwapManagerFuzz.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\nimport {SwapManager, ISwapManager} from \"../SwapManager.sol\";\nimport {ITraderBalanceVault} from \"../TraderBalanceVault/ITraderBalanceVault.sol\";\nimport {IPriceOracle} from \"../PriceOracle/IPriceOracle.sol\";\nimport {ITreasury} from \"../Treasury/ITreasury.sol\";\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\nimport {IERC20Mock} from \"../interfaces/IERC20Mock.sol\";\nimport {NATIVE_CURRENCY} from \"../Constants.sol\";\nimport {IPrimexDNSStorage} from \"../PrimexDNS/IPrimexDNSStorage.sol\";\n\ncontract SwapManagerFuzz {\n    using WadRayMath for uint256;\n\n    SwapManager internal sm = SwapManager(0x24DF5F93B17Bab7C5a61a944D45901f73D0c072a);\n    IPriceOracle internal priceOracle = IPriceOracle(0xaE52826fC2AB091C026Cf8c919b76b3A4996fd8B);\n    ITreasury internal treasury = ITreasury(payable(0x6E1D5f7e162eE74F333E0c433196434A5Dedd2A7));\n    ITraderBalanceVault internal traderBalanceVault =\n        ITraderBalanceVault(payable(0x1660b74302A5d34b2db784CAF456BD39C2D9942c));\n    IERC20Mock internal epmx = IERC20Mock(0xD1aE64401d65E9B0d1bF7E08Fbf75bb2F26eF70a);\n\n    // \"usdc\", \"weth\", \"wbtc\", \"link\", \"uni\", \"usdt\"\n    IERC20Mock[6] internal tokens = [\n        IERC20Mock(0x871DD7C2B4b25E1Aa18728e9D5f2Af4C4e431f5c),\n        IERC20Mock(0x1dC4c1cEFEF38a777b15aA20260a54E584b16C48),\n        IERC20Mock(0x1D7022f5B17d2F8B695918FB48fa1089C9f85401),\n        IERC20Mock(0x0B1ba0af832d7C05fD64161E0Db78E85978E8082),\n        IERC20Mock(0x48BaCB9266a570d521063EF5dD96e61686DbE788),\n        IERC20Mock(0x34D402F14D58E001D8EfBe6585051BF9706AA064)\n    ];\n    uint8[6] internal decimals = [6, 18, 8, 18, 18, 6];\n\n    string[5] internal dexes = [\"uniswap\", \"sushiswap\", \"uniswapv3\", \"quickswapv3\", \"meshswap\"];\n\n    uint256 internal swapRate = sm.primexDNS().feeRates(IPrimexDNSStorage.OrderType.SWAP_MARKET_ORDER, address(0));\n    uint256 internal swapRateInPmx =\n        sm.primexDNS().feeRates(IPrimexDNSStorage.OrderType.SWAP_MARKET_ORDER, address(epmx));\n\n    struct Vars {\n        address tokenA;\n        address tokenB;\n        uint8 tokenADecimals;\n        uint8 tokenBDecimals;\n        uint256 amountTokenA;\n        uint256 minTokenAAmount;\n        uint256 maxTokenAAmount;\n        uint256 amountOut;\n        string dex;\n        PrimexPricingLibrary.Route[] routes;\n        PrimexPricingLibrary.Route route;\n        address[] path;\n        ISwapManager.SwapParams params;\n        address feeToken;\n        uint256 swapFee;\n        uint256 traderBalanceTokenABefore;\n        uint256 traderBalanceTokenBBefore;\n        uint256 traderBalancePmxBefore;\n        uint256 traderBalanceETHBefore;\n        uint256 traderBalanceOnTraderBalanceVaultFeeTokenBefore;\n        uint256 traderBalanceOnTraderBalanceVaultTokenABefore;\n        uint256 traderBalanceOnTraderBalanceVaultTokenBBefore;\n        uint256 treasuryBalancePmxBefore;\n        uint256 treasuryBalanceETHBefore;\n        uint256 traderBalanceTokenAAfter;\n        uint256 traderBalanceTokenBAfter;\n        uint256 traderBalancePmxAfter;\n        uint256 traderBalanceETHAfter;\n        uint256 traderBalanceOnTraderBalanceVaultFeeTokenAfter;\n        uint256 traderBalanceOnTraderBalanceVaultTokenAAfter;\n        uint256 traderBalanceOnTraderBalanceVaultTokenBAfter;\n        uint256 treasuryBalancePmxAfter;\n        uint256 treasuryBalanceETHAfter;\n    }\n\n    constructor() payable {}\n\n    // solhint-disable-next-line comprehensive-interface\n    function testSwap(\n        uint128 _tokenASeed,\n        uint128 _tokenBSeed,\n        uint256 _amountTokenASeed,\n        uint8 _dexSeed,\n        bool _isSwapFromWallet,\n        bool _isSwapToWallet,\n        bool _isSwapFeeInPmx\n    ) public {\n        // Pre-conditiion\n        Vars memory vars;\n        (vars.tokenA, vars.tokenADecimals) = _getRandomToken(_tokenASeed);\n        (vars.tokenB, vars.tokenBDecimals) = _getRandomToken(_tokenBSeed);\n        vars.minTokenAAmount = 1 * 10 ** vars.tokenADecimals;\n        vars.maxTokenAAmount = 10000 * 10 ** vars.tokenADecimals;\n        vars.amountTokenA = vars.minTokenAAmount + (_amountTokenASeed % (vars.maxTokenAAmount - vars.minTokenAAmount));\n        vars.dex = _getRandomDex(_dexSeed);\n        vars.routes = new PrimexPricingLibrary.Route[](1);\n        vars.route = PrimexPricingLibrary.Route({paths: new PrimexPricingLibrary.SwapPath[](1), shares: 1});\n        vars.path = new address[](2);\n        vars.path[0] = vars.tokenA;\n        vars.path[1] = vars.tokenB;\n        vars.route.paths[0] = PrimexPricingLibrary.SwapPath({\n            dexName: vars.dex,\n            encodedPath: PrimexPricingLibrary.encodePath(\n                vars.path,\n                sm.primexDNS().getDexAddress(vars.dex),\n                _getAncillaryDexData(vars.dex),\n                sm.primexDNS().dexAdapter(),\n                false\n            )\n        });\n        vars.routes[0] = vars.route;\n        vars.params = ISwapManager.SwapParams({\n            tokenA: vars.tokenA,\n            tokenB: vars.tokenB,\n            amountTokenA: vars.amountTokenA,\n            amountOutMin: 0,\n            routes: vars.routes,\n            receiver: address(this),\n            deadline: block.timestamp + 100,\n            isSwapFromWallet: _isSwapFromWallet,\n            isSwapToWallet: _isSwapToWallet,\n            isSwapFeeInPmx: _isSwapFeeInPmx,\n            payFeeFromWallet: _isSwapFromWallet\n        });\n\n        (vars.feeToken, vars.swapFee) = _getSwapFee(vars.tokenA, vars.amountTokenA, _isSwapFeeInPmx);\n\n        if (_isSwapFromWallet) {\n            IERC20Mock(vars.tokenA).approve(address(sm), vars.amountTokenA);\n            if (_isSwapFeeInPmx) {\n                epmx.approve(address(sm), vars.swapFee);\n            }\n        } else {\n            IERC20Mock(vars.tokenA).approve(address(traderBalanceVault), vars.amountTokenA);\n            traderBalanceVault.deposit(vars.tokenA, vars.amountTokenA);\n            if (_isSwapFeeInPmx) {\n                epmx.approve(address(traderBalanceVault), vars.swapFee);\n                traderBalanceVault.deposit(address(epmx), vars.swapFee);\n            } else {\n                traderBalanceVault.deposit{value: vars.swapFee}(address(0), 0);\n            }\n        }\n\n        vars.traderBalanceTokenABefore = IERC20Mock(vars.tokenA).balanceOf(address(this));\n        vars.traderBalanceTokenBBefore = IERC20Mock(vars.tokenB).balanceOf(address(this));\n        vars.traderBalancePmxBefore = epmx.balanceOf(address(this));\n        vars.traderBalanceETHBefore = address(this).balance;\n        vars.treasuryBalancePmxBefore = epmx.balanceOf(address(treasury));\n        vars.treasuryBalanceETHBefore = address(treasury).balance;\n        (vars.traderBalanceOnTraderBalanceVaultFeeTokenBefore, ) = traderBalanceVault.balances(\n            address(this),\n            vars.feeToken\n        );\n        (vars.traderBalanceOnTraderBalanceVaultTokenABefore, ) = traderBalanceVault.balances(\n            address(this),\n            vars.tokenA\n        );\n        (vars.traderBalanceOnTraderBalanceVaultTokenBBefore, ) = traderBalanceVault.balances(\n            address(this),\n            vars.tokenB\n        );\n\n        // Action\n        vars.amountOut = sm.swap(vars.params, 0, false);\n\n        // Post-condition\n        vars.traderBalanceTokenAAfter = IERC20Mock(vars.tokenA).balanceOf(address(this));\n        vars.traderBalanceTokenBAfter = IERC20Mock(vars.tokenB).balanceOf(address(this));\n        vars.traderBalancePmxAfter = epmx.balanceOf(address(this));\n        vars.traderBalanceETHAfter = address(this).balance;\n        vars.treasuryBalancePmxAfter = epmx.balanceOf(address(treasury));\n        vars.treasuryBalanceETHAfter = address(treasury).balance;\n        (vars.traderBalanceOnTraderBalanceVaultFeeTokenAfter, ) = traderBalanceVault.balances(\n            address(this),\n            vars.feeToken\n        );\n        (vars.traderBalanceOnTraderBalanceVaultTokenAAfter, ) = traderBalanceVault.balances(address(this), vars.tokenA);\n        (vars.traderBalanceOnTraderBalanceVaultTokenBAfter, ) = traderBalanceVault.balances(address(this), vars.tokenB);\n\n        if (_isSwapFromWallet) {\n            if (_isSwapFeeInPmx) {\n                assert(vars.traderBalancePmxBefore - vars.swapFee == vars.traderBalancePmxAfter);\n                assert(vars.treasuryBalancePmxBefore + vars.swapFee == vars.treasuryBalancePmxAfter);\n            } else {\n                assert(vars.traderBalanceETHBefore - vars.swapFee == vars.traderBalanceETHAfter);\n                assert(vars.treasuryBalanceETHBefore + vars.swapFee == vars.treasuryBalanceETHAfter);\n            }\n\n            if (_isSwapToWallet) {\n                assert(vars.traderBalanceTokenABefore - vars.amountTokenA == vars.traderBalanceTokenAAfter);\n                assert(vars.traderBalanceTokenBBefore + vars.amountOut == vars.traderBalanceTokenBAfter);\n            } else {\n                assert(vars.traderBalanceTokenABefore - vars.amountTokenA == vars.traderBalanceTokenAAfter);\n                assert(\n                    vars.traderBalanceOnTraderBalanceVaultTokenBBefore + vars.amountOut ==\n                        vars.traderBalanceOnTraderBalanceVaultTokenBAfter\n                );\n            }\n        } else {\n            assert(\n                vars.traderBalanceOnTraderBalanceVaultFeeTokenBefore - vars.swapFee ==\n                    vars.traderBalanceOnTraderBalanceVaultFeeTokenAfter\n            );\n            if (_isSwapFeeInPmx) {\n                assert(vars.treasuryBalancePmxBefore + vars.swapFee == vars.treasuryBalancePmxAfter);\n            } else {\n                assert(vars.treasuryBalanceETHBefore + vars.swapFee == vars.treasuryBalanceETHAfter);\n            }\n\n            if (_isSwapToWallet) {\n                assert(\n                    vars.traderBalanceOnTraderBalanceVaultTokenABefore - vars.amountTokenA ==\n                        vars.traderBalanceOnTraderBalanceVaultTokenAAfter\n                );\n                assert(vars.traderBalanceTokenBBefore + vars.amountOut == vars.traderBalanceTokenBAfter);\n            } else {\n                assert(\n                    vars.traderBalanceOnTraderBalanceVaultTokenABefore - vars.amountTokenA ==\n                        vars.traderBalanceOnTraderBalanceVaultTokenAAfter\n                );\n                assert(\n                    vars.traderBalanceOnTraderBalanceVaultTokenBBefore + vars.amountOut ==\n                        vars.traderBalanceOnTraderBalanceVaultTokenBAfter\n                );\n            }\n        }\n    }\n\n    function _getRandomDex(uint8 _seed) internal view returns (string memory) {\n        return dexes[_seed % dexes.length];\n    }\n\n    function _getRandomToken(uint256 _seed) internal view returns (address, uint8) {\n        _seed = uint8(_seed % tokens.length);\n        return (address(tokens[_seed]), decimals[_seed]);\n    }\n\n    function _getAncillaryDexData(string memory _dex) internal pure returns (bytes32) {\n        if (keccak256(bytes(_dex)) == keccak256(\"uniswapv3\")) {\n            return bytes32(uint256(3000));\n        }\n        return bytes32(0);\n    }\n\n    function _getSwapFee(\n        address tokenA,\n        uint256 amountTokenA,\n        bool _isSwapFeeInPmx\n    ) internal view returns (address feeToken, uint256 swapFee) {\n        feeToken = _isSwapFeeInPmx ? address(epmx) : NATIVE_CURRENCY;\n        swapFee = PrimexPricingLibrary.getOracleAmountsOut(\n            address(tokenA),\n            feeToken,\n            (amountTokenA).wmul(WadRayMath.WAD).wmul(_isSwapFeeInPmx ? swapRateInPmx : swapRate),\n            address(priceOracle)\n        );\n        assert(swapFee > 0);\n    }\n}\n"
    },
    "contracts/TestnetServices/BalancerBotLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./../libraries/Errors.sol\";\n\nimport {IBalancer} from \"../interfaces/IBalancer.sol\";\nimport {IAsset} from \"../interfaces/IAsset.sol\";\nimport {IBalancerBotLens} from \"./interfaces/IBalancerBotLens.sol\";\n\ncontract BalancerBotLens is IBalancerBotLens {\n    function removeAndSetLiquidity(\n        IBalancer _vault,\n        PoolUpdateData[] calldata _pools,\n        IERC20[] calldata _tokensToReturn\n    ) external override {\n        for (uint256 i; i < _pools.length; i++) {\n            (address poolAddress, ) = _vault.getPool(_pools[i].poolId);\n            IERC20(poolAddress).transferFrom(msg.sender, address(this), IERC20(poolAddress).balanceOf(msg.sender));\n            IERC20(poolAddress).approve(address(_vault), type(uint256).max);\n\n            (IAsset[] memory tokens, uint256[] memory balances, ) = _vault.getPoolTokens(_pools[i].poolId);\n            _require(balances.length == _pools[i].amounts.length, Errors.WRONG_BALANCES.selector);\n\n            IBalancer.JoinPoolRequest memory joinData;\n            joinData.assets = tokens;\n            joinData.maxAmountsIn = new uint256[](balances.length);\n\n            IBalancer.ExitPoolRequest memory exitData;\n            exitData.assets = tokens;\n            exitData.minAmountsOut = new uint256[](balances.length);\n\n            for (uint256 j; j < joinData.assets.length; j++) {\n                // avoid stack too deep error\n                address vaultAddress = address(_vault);\n\n                IERC20 tokenERC20 = IERC20(address(joinData.assets[j]));\n                uint256 senderBalance = tokenERC20.balanceOf(msg.sender);\n                if (senderBalance > 0) tokenERC20.transferFrom(msg.sender, address(this), senderBalance);\n                if (tokenERC20.allowance(address(this), vaultAddress) < senderBalance)\n                    tokenERC20.approve(vaultAddress, type(uint256).max);\n\n                if (_pools[i].amounts[j] > balances[j]) {\n                    joinData.maxAmountsIn[j] = _pools[i].amounts[j] - balances[j];\n                    exitData.minAmountsOut[j] = 0;\n                } else {\n                    joinData.maxAmountsIn[j] = 0;\n                    exitData.minAmountsOut[j] = balances[j] - _pools[i].amounts[j];\n                }\n            }\n\n            // EXACT_TOKENS_IN_FOR_BPT_OUT=1\n            joinData.userData = abi.encode(1, joinData.maxAmountsIn, 0);\n            _vault.joinPool(_pools[i].poolId, address(this), address(this), joinData);\n\n            // BPT_IN_FOR_EXACT_TOKENS_OUT=2\n            exitData.userData = abi.encode(2, exitData.minAmountsOut, type(uint256).max);\n            _vault.exitPool(_pools[i].poolId, address(this), payable(address(this)), exitData);\n\n            IERC20(poolAddress).transfer(msg.sender, IERC20(poolAddress).balanceOf(address(this)));\n        }\n\n        for (uint256 i; i < _tokensToReturn.length; i++) {\n            uint256 balance = _tokensToReturn[i].balanceOf(address(this));\n            if (balance > 0) _tokensToReturn[i].transfer(msg.sender, balance);\n        }\n    }\n}\n"
    },
    "contracts/TestnetServices/CurveBotLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {ICurvePool} from \"../interfaces/routers/ICurvePool.sol\";\nimport {ICurveBotLens} from \"./interfaces/ICurveBotLens.sol\";\n\ncontract CurveBotLens is ICurveBotLens {\n    using WadRayMath for uint256;\n\n    function removeAndSetLiquidity(ICurvePool _pool, uint256[3] memory _amounts) external override {\n        IERC20 lpToken = IERC20(_pool.token());\n        // remove all liquidity of msg.sender\n        uint256 lpTokenBalance = lpToken.balanceOf(msg.sender);\n        if (lpTokenBalance > 0) {\n            uint256 toRemove = lpToken.totalSupply() == lpTokenBalance ? lpTokenBalance - 1 : lpTokenBalance;\n            if (toRemove > 0) {\n                lpToken.transferFrom(msg.sender, address(this), toRemove);\n                lpToken.approve(address(_pool), toRemove);\n                uint256[3] memory minAmounts;\n                _pool.remove_liquidity(toRemove, minAmounts);\n            }\n        }\n\n        // increase amounts if some of the balances is higher than requested amount\n        ///HACK: can increase amounts and exceed approved or available balance of msg.sender\n        uint256 increaseAssets = WadRayMath.WAD;\n        for (uint256 i; i < 3; i++) {\n            uint256 poolBalance = _pool.balances(i);\n            if (poolBalance > _amounts[i]) {\n                ///HACK: can overflow if requested amount is too low\n                uint256 increaseThisAsset = poolBalance.wdiv(_amounts[i]);\n                if (increaseThisAsset > increaseAssets) {\n                    increaseAssets = increaseThisAsset;\n                }\n            }\n        }\n\n        for (uint256 i; i < 3; i++) {\n            IERC20 asset = IERC20(_pool.coins(i));\n            uint256 poolBalance = _pool.balances(i);\n            uint256 lensBalance = asset.balanceOf(address(this));\n            if (increaseAssets > WadRayMath.WAD) {\n                _amounts[i] = _amounts[i].wmul(increaseAssets);\n            }\n\n            _amounts[i] = _amounts[i] - poolBalance;\n            if (lensBalance < _amounts[i]) {\n                asset.transferFrom(msg.sender, address(this), _amounts[i] - lensBalance);\n            }\n            asset.approve(address(_pool), _amounts[i]);\n        }\n\n        _pool.add_liquidity(_amounts, 0);\n\n        // return assets and lp tokens to user\n        lpToken.transfer(msg.sender, lpToken.balanceOf(address(this)));\n        for (uint256 i; i < 3; i++) {\n            IERC20 asset = IERC20(_pool.coins(i));\n            asset.transfer(msg.sender, asset.balanceOf(address(this)));\n        }\n    }\n}\n"
    },
    "contracts/TestnetServices/interfaces/IBalancerBotLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IBalancer} from \"../../interfaces/IBalancer.sol\";\n\ninterface IBalancerBotLens {\n    struct PoolUpdateData {\n        bytes32 poolId;\n        uint256[] amounts;\n    }\n\n    function removeAndSetLiquidity(\n        IBalancer _vault,\n        PoolUpdateData[] calldata _pools,\n        IERC20[] calldata _tokensToReturn\n    ) external;\n}\n"
    },
    "contracts/TestnetServices/interfaces/ICurveBotLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ICurvePool} from \"../../interfaces/routers/ICurvePool.sol\";\n\ninterface ICurveBotLens {\n    function removeAndSetLiquidity(ICurvePool _pool, uint256[3] memory _amounts) external;\n}\n"
    },
    "contracts/TestnetServices/interfaces/IPrimexAggregatorV3TestService.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IPrimexAggregatorV3TestService {\n    function setAnswer(int256 answer) external;\n\n    function setDecimals(uint256 newDecimals) external;\n}\n"
    },
    "contracts/TestnetServices/interfaces/ISynchronizationBotLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IUniswapV2Router02} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\ninterface ISynchronizationBotLens {\n    function swapAndAddLiquidity(\n        IUniswapV2Router02 _uniswapV2Router02,\n        address[] calldata _swapPath,\n        uint256 _swapAmount,\n        address[] calldata _liquidityPath,\n        uint256[] calldata _liquidityAmounts\n    ) external;\n\n    function swapAndRemoveLiquidity(\n        IUniswapV2Router02 _uniswapV2Router02,\n        address[] calldata _swapPath,\n        uint256 _swapAmount,\n        address[] calldata _liquidityPath,\n        uint256 _liquidityK\n    ) external;\n}\n"
    },
    "contracts/TestnetServices/interfaces/ISynchronizationBotLensQuickswapTestService.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ISwapRouter} from \"@cryptoalgebra/solidity-interfaces/contracts/periphery/ISwapRouter.sol\";\nimport {IAlgebraPool} from \"@cryptoalgebra/solidity-interfaces/contracts/core/IAlgebraPool.sol\";\n\ninterface ISynchronizationBotLensQuickswapTestService {\n    function swapWithQuickswap(\n        ISwapRouter _swapRouterQuickswap,\n        ISwapRouter.ExactInputSingleParams[] memory params\n    ) external;\n\n    function getUserBalances(\n        address sender,\n        address[] calldata assets\n    ) external view returns (uint256 nativeBalance, uint256[] memory assetsBalances, uint256 blockNumber);\n\n    function getArraySqrtPriceX96(\n        IAlgebraPool[] calldata pools\n    ) external view returns (uint160[] memory arraySqrtPriceX96);\n}\n"
    },
    "contracts/TestnetServices/interfaces/ISynchronizationBotLensUniV3TestService.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ISwapRouter} from \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\ninterface ISynchronizationBotLensUniV3TestService {\n    function swapUniswapV3(ISwapRouter _swapRouterUniV3, ISwapRouter.ExactInputSingleParams[] memory params) external;\n\n    function getUserBalances(\n        address sender,\n        address[] calldata assets\n    ) external view returns (uint256 nativeBalance, uint256[] memory assetsBalances, uint256 blockNumber);\n\n    function getArraySqrtPriceX96(\n        IUniswapV3Pool[] calldata pools\n    ) external view returns (uint160[] memory arraySqrtPriceX96);\n}\n"
    },
    "contracts/TestnetServices/PriceFeedUpdaterTestService.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport {PrimexPricingLibrary} from \"../libraries/PrimexPricingLibrary.sol\";\nimport \"./../libraries/Errors.sol\";\n\nimport {PrimexAggregatorV3TestService} from \"./PrimexAggregatorV3TestService.sol\";\nimport {IDexAdapter} from \"../interfaces/IDexAdapter.sol\";\nimport {IPriceFeedUpdaterTestService} from \"../interfaces/IPriceFeedUpdaterTestService.sol\";\n\ncontract PriceFeedUpdaterTestService is IPriceFeedUpdaterTestService, AccessControl {\n    bytes32 public constant DEFAULT_UPDATER_ROLE = keccak256(\"DEFAULT_UPDATER_ROLE\");\n\n    address[] public routers;\n    IDexAdapter public dexAdapter;\n\n    // Divide swapped token amount to reduce the impact of liquidity on the price\n    uint256 public divider = 1000;\n\n    constructor(address _updater, IDexAdapter _dexAdapter, address[] memory _routers) {\n        _require(\n            IERC165(address(_dexAdapter)).supportsInterface(type(IDexAdapter).interfaceId) && _updater != address(0),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        dexAdapter = _dexAdapter;\n\n        for (uint256 i; i < _routers.length; i++) {\n            _require(_routers[i] != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        }\n        routers = _routers;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        // DEFAULT_UPDATER_ROLE for msg.sender to facilitate initial setup and dev/stage work\n        _grantRole(DEFAULT_UPDATER_ROLE, msg.sender);\n        _grantRole(DEFAULT_UPDATER_ROLE, _updater);\n    }\n\n    function addRouter(address _newRouter) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _require(_newRouter != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        routers.push(_newRouter);\n    }\n\n    function deleteRouter(uint256 _index) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _require(_index < routers.length, Errors.INVALID_INDEX.selector);\n        routers[_index] = routers[routers.length - 1];\n        routers.pop();\n    }\n\n    function setDivider(uint256 _divider) external override onlyRole(DEFAULT_ADMIN_ROLE) {\n        _require(_divider != 0, Errors.INVALID_DIVIDER.selector);\n        divider = _divider;\n    }\n\n    function checkArrayPriceFeed(PriceFeed[] memory _priceFeeds) external override returns (PriceFeedStatus[] memory) {\n        PriceFeedStatus[] memory statuses = new PriceFeedStatus[](_priceFeeds.length);\n        for (uint256 i; i < _priceFeeds.length; i++) {\n            statuses[i] = checkPriceFeed(_priceFeeds[i]);\n        }\n        return statuses;\n    }\n\n    function updateArrayPriceFeed(\n        PrimexAggregatorV3TestService[] memory _priceFeeds,\n        int256[] memory _newAnswers\n    ) external override onlyRole(DEFAULT_UPDATER_ROLE) {\n        _require(_priceFeeds.length == _newAnswers.length, Errors.ARRAYS_LENGTHS_IS_NOT_EQUAL.selector);\n        for (uint256 i; i < _priceFeeds.length; i++) {\n            _priceFeeds[i].setAnswer(_newAnswers[i]);\n        }\n    }\n\n    function getRouters() external view override returns (address[] memory _routers) {\n        return routers;\n    }\n\n    function checkPriceFeed(PriceFeed memory _priceFeed) public override returns (PriceFeedStatus memory) {\n        _require(\n            _priceFeed.token0 != address(0) &&\n                _priceFeed.token1 != address(0) &&\n                address(_priceFeed.priceFeed) != address(0),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        uint256 priceSum;\n        uint256 denominator;\n        address[] memory path = new address[](2);\n        path[0] = _priceFeed.token0;\n        path[1] = _priceFeed.token1;\n        for (uint256 i; i < routers.length; i++) {\n            bytes32 ancillaryDexData;\n            IDexAdapter.DexType type_ = dexAdapter.dexType(routers[i]);\n            if (type_ == IDexAdapter.DexType.UniswapV2 || type_ == IDexAdapter.DexType.Curve) {\n                ancillaryDexData = 0x0;\n            } else if (type_ == IDexAdapter.DexType.UniswapV3) {\n                ancillaryDexData = bytes32(uint256(3000));\n            }\n            // slither-disable-next-line unused-return\n            try\n                dexAdapter.getAmountsOut(\n                    IDexAdapter.GetAmountsParams({\n                        encodedPath: PrimexPricingLibrary.encodePath(\n                            path,\n                            routers[i],\n                            ancillaryDexData,\n                            address(dexAdapter),\n                            false\n                        ),\n                        amount: 10 ** IERC20Metadata(_priceFeed.token0).decimals() / divider,\n                        dexRouter: routers[i]\n                    })\n                )\n            returns (uint256[3] memory amounts) {\n                // slither-disable-next-line variable-scope\n                priceSum += amounts[1];\n                denominator++;\n            } catch {\n                continue;\n            }\n        }\n        _require(denominator != 0, Errors.DENOMINATOR_IS_0.selector);\n        PriceFeedStatus memory status;\n        status.priceFeed = _priceFeed.priceFeed;\n        // need mul on 100 because, always in ur envs use price feeds for USD with decimals 8,\n        // but calculate its price by USDC with decimals 6\n        // multiplication is needed in contracts because this is where we check whether the price feeds need to be updated or not\n        status.lastAverageDexPrice = ((priceSum * divider) / denominator) * 100;\n        status.isNeedUpdate = uint256(_priceFeed.priceFeed.latestAnswer()) != status.lastAverageDexPrice;\n        return status;\n    }\n\n    function updatePriceFeed(\n        PrimexAggregatorV3TestService _priceFeed,\n        int256 _newAnswer\n    ) public override onlyRole(DEFAULT_UPDATER_ROLE) {\n        _require(_newAnswer != 0, Errors.AMOUNT_IS_0.selector);\n        _require(address(_priceFeed) != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n\n        _priceFeed.setAnswer(_newAnswer);\n    }\n}\n"
    },
    "contracts/TestnetServices/PrimexAggregatorV3TestService.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {AggregatorV2V3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport {IPrimexAggregatorV3TestService} from \"./interfaces/IPrimexAggregatorV3TestService.sol\";\n\ncontract PrimexAggregatorV3TestService is IPrimexAggregatorV3TestService, AggregatorV2V3Interface, AccessControl {\n    uint80 internal constant MAX_UINT80_HEX = 0xFFFFFFFFFFFFFFFFFFFF;\n    bytes32 public constant DEFAULT_UPDATER_ROLE = keccak256(\"DEFAULT_UPDATER_ROLE\");\n\n    struct RoundData {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n\n    uint8 private _decimals;\n    string private _name;\n    uint80 private _currentRound;\n    mapping(uint80 => RoundData) private _answers;\n    RoundData public latestRounddata;\n\n    constructor(string memory name, address updater) {\n        _name = name;\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        // DEFAULT_UPDATER_ROLE for msg.sender to facilitate initial setup and dev/stage work\n        _grantRole(DEFAULT_UPDATER_ROLE, msg.sender);\n        _grantRole(DEFAULT_UPDATER_ROLE, updater);\n    }\n\n    function latestAnswer() external view override returns (int256) {\n        return latestRounddata.answer;\n    }\n\n    function latestRoundData() external view override returns (uint80, int256, uint256, uint256, uint80) {\n        return (\n            latestRounddata.roundId,\n            latestRounddata.answer,\n            latestRounddata.startedAt,\n            latestRounddata.updatedAt,\n            latestRounddata.answeredInRound\n        );\n    }\n\n    function latestTimestamp() external view override returns (uint256) {\n        return latestRounddata.updatedAt;\n    }\n\n    function getAnswer(uint256 roundId) external view override returns (int256) {\n        if (roundId > MAX_UINT80_HEX) {\n            return 0;\n        }\n        return _answers[uint80(roundId)].answer;\n    }\n\n    function getTimestamp(uint256 roundId) external view override returns (uint256) {\n        if (roundId > MAX_UINT80_HEX) {\n            return 0;\n        }\n        return _answers[uint80(roundId)].updatedAt;\n    }\n\n    function latestRound() external view override returns (uint256) {\n        return latestRounddata.roundId;\n    }\n\n    function setAnswer(int256 answer) public override onlyRole(DEFAULT_UPDATER_ROLE) {\n        latestRounddata.answer = answer;\n        latestRounddata.roundId = _currentRound;\n        latestRounddata.startedAt = block.timestamp;\n        latestRounddata.updatedAt = block.timestamp;\n        latestRounddata.answeredInRound = _currentRound;\n        _answers[_currentRound] = latestRounddata;\n        _currentRound++;\n        emit AnswerUpdated(answer, latestRounddata.roundId, block.timestamp);\n    }\n\n    function setDecimals(uint256 newDecimals) public override onlyRole(DEFAULT_UPDATER_ROLE) {\n        _decimals = uint8(newDecimals);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function getRoundData(uint80 _roundId) public view override returns (uint80, int256, uint256, uint256, uint80) {\n        RoundData memory roundData = _answers[_roundId];\n        return (\n            roundData.roundId,\n            roundData.answer,\n            roundData.startedAt,\n            roundData.updatedAt,\n            roundData.answeredInRound\n        );\n    }\n\n    function description() public pure override returns (string memory) {}\n\n    function version() public pure override returns (uint256) {}\n}\n"
    },
    "contracts/TestnetServices/SynchronizationBotLens.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SignedMath} from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport {IUniswapV2Router02} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport {IUniswapV2Factory} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport {IUniswapV2Pair} from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nimport {ISynchronizationBotLens} from \"./interfaces/ISynchronizationBotLens.sol\";\n\ncontract SynchronizationBotLens is ISynchronizationBotLens {\n    function swapAndAddLiquidity(\n        IUniswapV2Router02 _uniswapV2Router02,\n        address[] calldata _swapPath,\n        uint256 _swapAmount,\n        address[] calldata _liquidityPath,\n        uint256[] calldata _liquidityAmounts\n    ) public override {\n        if (_swapAmount > 0) {\n            if ((_uniswapV2Router02.getAmountsOut(_swapAmount, _swapPath))[1] != 0) {\n                IERC20(_swapPath[0]).transferFrom(msg.sender, address(this), _swapAmount);\n                IERC20(_swapPath[0]).approve(address(_uniswapV2Router02), _swapAmount);\n                _uniswapV2Router02.swapExactTokensForTokens(_swapAmount, 0, _swapPath, msg.sender, type(uint256).max);\n            }\n        }\n\n        address pair = IUniswapV2Factory(_uniswapV2Router02.factory()).getPair(_liquidityPath[0], _liquidityPath[1]);\n        (uint112 _reserve0, uint112 _reserve1, ) = IUniswapV2Pair(pair).getReserves();\n        if (_liquidityPath[0] != IUniswapV2Pair(pair).token0()) {\n            (_reserve0, _reserve1) = (_reserve1, _reserve0);\n        }\n        uint256[2] memory optimalAmounts = _addLiquidityOptimalAmounts(_liquidityAmounts, [_reserve0, _reserve1]);\n        uint256 lpTokenTotalSupply = IUniswapV2Pair(pair).totalSupply();\n\n        if (\n            SignedMath.min(\n                int256((optimalAmounts[0] * lpTokenTotalSupply) / _reserve0),\n                int256((optimalAmounts[1] * lpTokenTotalSupply) / _reserve1)\n            ) == 0\n        ) {\n            return;\n        }\n\n        IERC20(_liquidityPath[0]).transferFrom(msg.sender, address(this), _liquidityAmounts[0]);\n        IERC20(_liquidityPath[1]).transferFrom(msg.sender, address(this), _liquidityAmounts[1]);\n\n        IERC20(_liquidityPath[0]).approve(address(_uniswapV2Router02), _liquidityAmounts[0]);\n        IERC20(_liquidityPath[1]).approve(address(_uniswapV2Router02), _liquidityAmounts[1]);\n\n        _uniswapV2Router02.addLiquidity(\n            _liquidityPath[0],\n            _liquidityPath[1],\n            _liquidityAmounts[0],\n            _liquidityAmounts[1],\n            0,\n            0,\n            msg.sender,\n            type(uint256).max\n        );\n    }\n\n    function swapAndRemoveLiquidity(\n        IUniswapV2Router02 _uniswapV2Router02,\n        address[] calldata _swapPath,\n        uint256 _swapAmount,\n        address[] calldata _liquidityPath,\n        uint256 _liquidityK\n    ) public override {\n        if (_swapAmount > 0) {\n            if ((_uniswapV2Router02.getAmountsOut(_swapAmount, _swapPath))[1] != 0) {\n                IERC20(_swapPath[0]).transferFrom(msg.sender, address(this), _swapAmount);\n                IERC20(_swapPath[0]).approve(address(_uniswapV2Router02), _swapAmount);\n                _uniswapV2Router02.swapExactTokensForTokens(_swapAmount, 0, _swapPath, msg.sender, type(uint256).max);\n            }\n        }\n\n        address pair = IUniswapV2Factory(_uniswapV2Router02.factory()).getPair(_liquidityPath[0], _liquidityPath[1]);\n        (uint112 _reserve0, uint112 _reserve1, ) = IUniswapV2Pair(pair).getReserves();\n        uint256 lpTokenTotalSupply = IUniswapV2Pair(pair).totalSupply();\n        uint256 liquidity = (_liquidityK * lpTokenTotalSupply) / (10 ** 18);\n\n        {\n            uint256 senderBalance = IERC20(pair).balanceOf(msg.sender);\n            if (liquidity > senderBalance) {\n                liquidity = senderBalance;\n            }\n        }\n\n        if (_liquidityPath[0] != IUniswapV2Pair(pair).token0()) {\n            (_reserve0, _reserve1) = (_reserve1, _reserve0);\n        }\n\n        uint256 amount0 = (liquidity * _reserve0) / lpTokenTotalSupply;\n        uint256 amount1 = (liquidity * _reserve1) / lpTokenTotalSupply;\n\n        if (amount0 == 0 || amount1 == 0) {\n            return;\n        }\n\n        IERC20(pair).transferFrom(msg.sender, address(this), liquidity);\n        IERC20(pair).approve(address(_uniswapV2Router02), liquidity);\n\n        _uniswapV2Router02.removeLiquidity(\n            _liquidityPath[0],\n            _liquidityPath[1],\n            liquidity,\n            0,\n            0,\n            msg.sender,\n            type(uint256).max\n        );\n    }\n\n    function _addLiquidityOptimalAmounts(\n        uint256[] calldata _amounts,\n        uint112[2] memory _reserves\n    ) internal virtual returns (uint256[2] memory optimalAmounts) {\n        if (_reserves[0] == 0 && _reserves[1] == 0) {\n            optimalAmounts = [_amounts[0], _amounts[1]];\n        } else {\n            uint256 amountBOptimal = (_amounts[0] * _reserves[1]) / _reserves[0];\n            if (amountBOptimal <= _amounts[1]) {\n                optimalAmounts = [_amounts[0], amountBOptimal];\n            } else {\n                uint256 amountAOptimal = (_amounts[1] * _reserves[0]) / _reserves[1];\n                if (amountAOptimal > _amounts[0]) {\n                    optimalAmounts = [uint256(0), uint256(0)];\n                }\n                optimalAmounts = [amountAOptimal, _amounts[1]];\n            }\n        }\n    }\n}\n"
    },
    "contracts/TestnetServices/SynchronizationBotLensQuickswapTestService.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ISwapRouter} from \"@cryptoalgebra/solidity-interfaces/contracts/periphery/ISwapRouter.sol\";\nimport {IAlgebraPool} from \"@cryptoalgebra/solidity-interfaces/contracts/core/IAlgebraPool.sol\";\n\nimport {TokenTransfersLibrary} from \"../libraries/TokenTransfersLibrary.sol\";\n\nimport {ISynchronizationBotLensQuickswapTestService} from \"./interfaces/ISynchronizationBotLensQuickswapTestService.sol\";\n\ncontract SynchronizationBotLensQuickswapTestService is ISynchronizationBotLensQuickswapTestService {\n    function swapWithQuickswap(\n        ISwapRouter _swapRouterQuickswap,\n        ISwapRouter.ExactInputSingleParams[] memory params\n    ) public override {\n        for (uint256 i; i < params.length; i++) {\n            if (params[i].amountIn == type(uint256).max) {\n                params[i].amountIn = IERC20(params[i].tokenIn).balanceOf(msg.sender);\n            }\n            TokenTransfersLibrary.doTransferIn(params[i].tokenIn, msg.sender, params[i].amountIn);\n\n            IERC20(params[i].tokenIn).approve(address(_swapRouterQuickswap), params[i].amountIn);\n\n            _swapRouterQuickswap.exactInputSingle(params[i]);\n\n            TokenTransfersLibrary.doTransferOut(\n                params[i].tokenIn,\n                params[i].recipient,\n                IERC20(params[i].tokenIn).balanceOf(address(this))\n            );\n        }\n    }\n\n    function getUserBalances(\n        address sender,\n        address[] calldata assets\n    ) public view override returns (uint256 nativeBalance, uint256[] memory assetsBalances, uint256 blockNumber) {\n        blockNumber = block.number;\n        nativeBalance = sender.balance;\n        assetsBalances = new uint256[](assets.length);\n        for (uint256 i; i < assets.length; i++) {\n            assetsBalances[i] = IERC20(assets[i]).balanceOf(sender);\n        }\n    }\n\n    function getArraySqrtPriceX96(\n        IAlgebraPool[] calldata pools\n    ) public view override returns (uint160[] memory arraySqrtPriceX96) {\n        arraySqrtPriceX96 = new uint160[](pools.length);\n        for (uint256 i; i < pools.length; i++) {\n            (arraySqrtPriceX96[i], , , , , , ) = pools[i].globalState();\n        }\n    }\n}\n"
    },
    "contracts/TestnetServices/SynchronizationBotLensUniV3TestService.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ISwapRouter} from \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {TokenTransfersLibrary} from \"../libraries/TokenTransfersLibrary.sol\";\n\nimport {ISynchronizationBotLensUniV3TestService} from \"./interfaces/ISynchronizationBotLensUniV3TestService.sol\";\n\ncontract SynchronizationBotLensUniV3TestService is ISynchronizationBotLensUniV3TestService {\n    function swapUniswapV3(\n        ISwapRouter _swapRouterUniV3,\n        ISwapRouter.ExactInputSingleParams[] memory params\n    ) public override {\n        for (uint256 i; i < params.length; i++) {\n            if (params[i].amountIn == type(uint256).max) {\n                params[i].amountIn = IERC20(params[i].tokenIn).balanceOf(msg.sender);\n            }\n            TokenTransfersLibrary.doTransferIn(params[i].tokenIn, msg.sender, params[i].amountIn);\n\n            IERC20(params[i].tokenIn).approve(address(_swapRouterUniV3), params[i].amountIn);\n\n            _swapRouterUniV3.exactInputSingle(params[i]);\n\n            TokenTransfersLibrary.doTransferOut(\n                params[i].tokenIn,\n                params[i].recipient,\n                IERC20(params[i].tokenIn).balanceOf(address(this))\n            );\n        }\n    }\n\n    function getUserBalances(\n        address sender,\n        address[] calldata assets\n    ) public view override returns (uint256 nativeBalance, uint256[] memory assetsBalances, uint256 blockNumber) {\n        blockNumber = block.number;\n        nativeBalance = sender.balance;\n        assetsBalances = new uint256[](assets.length);\n        for (uint256 i; i < assets.length; i++) {\n            assetsBalances[i] = IERC20(assets[i]).balanceOf(sender);\n        }\n    }\n\n    function getArraySqrtPriceX96(\n        IUniswapV3Pool[] calldata pools\n    ) public view override returns (uint160[] memory arraySqrtPriceX96) {\n        arraySqrtPriceX96 = new uint160[](pools.length);\n        for (uint256 i; i < pools.length; i++) {\n            (arraySqrtPriceX96[i], , , , , , ) = pools[i].slot0();\n        }\n    }\n}\n"
    },
    "contracts/TraderBalanceVault/ITraderBalanceVault.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ITraderBalanceVaultStorage} from \"./ITraderBalanceVaultStorage.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface ITraderBalanceVault is ITraderBalanceVaultStorage, IPausable {\n    /**\n     * Types of way to open a position or order\n     */\n    enum OpenType {\n        OPEN_BY_ORDER,\n        OPEN,\n        CREATE_LIMIT_ORDER\n    }\n\n    /**\n     * @param trader The trader, who opens margin deal\n     * @param depositReceiver the address to which the deposit is transferred when blocked.\n     * This happens because the trader's deposit is involved in the position\n     * @param borrowedAsset The token to lock for deal in a borrowed asset\n     * @param depositAsset The token is a deposit asset\n     * (it is blocked when creating a limit order\n     * For others, the operations is transferred to the account of the receiver of the deposit and is swapped )\n     * @param depositAmount Amount of tokens in a deposit asset\n     * @param depositInBorrowedAmount Amount of tokens to lock for deal in a borrowed asset\n     * @param openType Corresponds to the purpose of locking\n     */\n    struct LockAssetParams {\n        address trader;\n        address depositReceiver;\n        address depositAsset;\n        uint256 depositAmount;\n        OpenType openType;\n    }\n\n    /**\n     * @param trader The trader who opened the position\n     * @param receiver The receiver of the rest of trader deposit.\n     * @param asset Borrowed asset of the position being closed (the need for accrual of profit).\n     * @param unlockAmount The amount of unlocked collateral for deal\n     * @param returnToTrader The returned to trader amount when position was closed.\n     */\n    struct UnlockAssetParams {\n        address trader;\n        address receiver;\n        address asset;\n        uint256 amount;\n    }\n\n    /**\n     * @param traders An array of traders for which available balance should be increased\n     * @param amounts An array of amounts corresponding to traders' addresses that should be added to their available balances\n     * @param asset Asset address which amount will be increased\n     * @param length The amount of traders in an array\n     */\n    struct BatchTopUpAvailableBalanceParams {\n        address[] traders;\n        uint256[] amounts;\n        address asset;\n        uint256 length;\n    }\n\n    event Deposit(address indexed depositer, address indexed asset, uint256 amount);\n    event Withdraw(address indexed withdrawer, address asset, uint256 amount);\n\n    /**\n     * @dev contract initializer\n     * @param _registry The address of Registry contract\n     * @param _whiteBlackList The address of WhiteBlackList contract\n     */\n    function initialize(address _registry, address _whiteBlackList) external;\n\n    receive() external payable;\n\n    /**\n     * @dev Deposits trader collateral for margin deal\n     * @param _asset The collateral asset for deal\n     * @param _amount The amount of '_asset' to deposit\n     */\n    function deposit(address _asset, uint256 _amount) external payable;\n\n    /**\n     * @dev Withdraws the rest of trader's deposit after closing deal\n     * @param _asset The collateral asset for withdraw\n     * @param _amount The amount of '_asset' to withdraw\n     */\n    function withdraw(address _asset, uint256 _amount) external;\n\n    /**\n     * @dev Traders lock their collateral for the limit order.\n     * @param _trader The owner of collateral\n     * @param _asset The collateral asset for deal\n     * @param _amount The amount of '_asset' to deposit\n     */\n    function increaseLockedBalance(address _trader, address _asset, uint256 _amount) external payable;\n\n    /**\n     * @dev Locks deposited trader's assets as collateral for orders.\n     * Decreases the available balance when opening position.\n     * Transfers deposited amount to the deposit receiver.\n     * @param _params parameters necessary to lock asset\n     */\n    function useTraderAssets(LockAssetParams calldata _params) external;\n\n    /**\n     * @dev Unlocks trader's collateral when open position by order or update deposit.\n     * @param _params parameters necessary to unlock asset\n     */\n    function unlockAsset(UnlockAssetParams calldata _params) external;\n\n    /**\n     * The function to increase available balance for several traders\n     * @param _params A struct containing BatchTopUpAvailableBalanceParams\n     */\n    function batchTopUpAvailableBalance(BatchTopUpAvailableBalanceParams calldata _params) external;\n\n    /**\n     * Withdraws an asset amount from an asset holder to a receiver\n     * @param _from Withdraw from address\n     * @param _to Withdraw to address\n     * @param _asset Address of an asset\n     * @param _amount Amount of an asset\n     * @param fromLocked True if withdraw from locked balance\n     */\n    function withdrawFrom(address _from, address _to, address _asset, uint256 _amount, bool fromLocked) external;\n\n    /**\n     * Increases available balance of a receiver in the protocol\n     * @param receiver The address of an asset receiver\n     * @param asset The asset address for which available balance will be increased\n     * @param amount The amount of an asset\n     */\n    function topUpAvailableBalance(address receiver, address asset, uint256 amount) external payable;\n}\n"
    },
    "contracts/TraderBalanceVault/ITraderBalanceVaultStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface ITraderBalanceVaultStorage {\n    struct TraderBalance {\n        uint256 availableBalance;\n        uint256 lockedBalance;\n    }\n\n    function registry() external view returns (address);\n\n    /**\n     *\n     * @param trader Trader's address\n     * @param asset Asset address\n     * @return availableBalance availableBalance\n     * @return lockedBalance lockedBalance\n     */\n    function balances(\n        address trader,\n        address asset\n    ) external view returns (uint256 availableBalance, uint256 lockedBalance);\n}\n"
    },
    "contracts/TraderBalanceVault/TraderBalanceVault.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport {TokenTransfersLibrary} from \"../libraries/TokenTransfersLibrary.sol\";\nimport \"../libraries/Errors.sol\";\n\nimport \"./TraderBalanceVaultStorage.sol\";\nimport {VAULT_ACCESS_ROLE, NATIVE_CURRENCY, MAX_ASSET_DECIMALS, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \"../Constants.sol\";\nimport {ITraderBalanceVault} from \"./ITraderBalanceVault.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ncontract TraderBalanceVault is ITraderBalanceVault, TraderBalanceVaultStorage {\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Throws if caller is not granted with _role\n     * @param _role The role that is being checked for a function caller\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControl(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @dev Throws if caller is blacklisted\n     */\n    modifier notBlackListed() {\n        _require(!whiteBlackList.isBlackListed(msg.sender), Errors.SENDER_IS_BLACKLISTED.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc ITraderBalanceVault\n     */\n    function initialize(address _registry, address _whiteBlackList) public override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId) &&\n                IERC165Upgradeable(_whiteBlackList).supportsInterface(type(IWhiteBlackList).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n        whiteBlackList = IWhiteBlackList(_whiteBlackList);\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __ERC165_init();\n    }\n\n    receive() external payable override {\n        deposit(NATIVE_CURRENCY, 0);\n    }\n\n    /**\n     * @inheritdoc ITraderBalanceVault\n     */\n    function withdraw(address _asset, uint256 _amount) external override nonReentrant notBlackListed {\n        _require(_amount != 0, Errors.AMOUNT_IS_0.selector);\n        TraderBalance storage traderBalance = balances[msg.sender][_asset];\n        _require(_amount <= traderBalance.availableBalance, Errors.INSUFFICIENT_FREE_ASSETS.selector);\n        traderBalance.availableBalance -= _amount;\n        if (_asset == NATIVE_CURRENCY) {\n            TokenTransfersLibrary.doTransferOutETH(msg.sender, _amount);\n        } else {\n            TokenTransfersLibrary.doTransferOut(_asset, msg.sender, _amount);\n        }\n        emit Withdraw(msg.sender, _asset, _amount);\n    }\n\n    /**\n     * @inheritdoc ITraderBalanceVault\n     */\n    function increaseLockedBalance(\n        address _trader,\n        address _asset,\n        uint256 _amount\n    ) external payable override onlyRole(VAULT_ACCESS_ROLE) {\n        if (_asset != NATIVE_CURRENCY) {\n            _require(\n                IERC20Metadata(_asset).decimals() <= MAX_ASSET_DECIMALS,\n                Errors.ASSET_DECIMALS_EXCEEDS_MAX_VALUE.selector\n            );\n        }\n        _require(_amount != 0, Errors.AMOUNT_IS_0.selector);\n        balances[_trader][_asset].lockedBalance += _amount;\n\n        emit Deposit(_trader, _asset, _amount);\n    }\n\n    /**\n     * @inheritdoc ITraderBalanceVault\n     */\n    function useTraderAssets(LockAssetParams calldata _params) external override onlyRole(VAULT_ACCESS_ROLE) {\n        TraderBalance storage depositedBalance = balances[_params.trader][_params.depositAsset];\n        if (_params.openType != OpenType.OPEN_BY_ORDER) {\n            _require(\n                _params.depositAmount <= depositedBalance.availableBalance,\n                Errors.INSUFFICIENT_FREE_ASSETS.selector\n            );\n        }\n        if (_params.openType == OpenType.OPEN) {\n            depositedBalance.availableBalance -= _params.depositAmount;\n        } else if (_params.openType == OpenType.OPEN_BY_ORDER) {\n            depositedBalance.lockedBalance -= _params.depositAmount;\n        } else if (_params.openType == OpenType.CREATE_LIMIT_ORDER) {\n            depositedBalance.availableBalance -= _params.depositAmount;\n            depositedBalance.lockedBalance += _params.depositAmount;\n        }\n        if (_params.depositReceiver != address(0)) {\n            _require(_params.depositAsset != NATIVE_CURRENCY, Errors.NATIVE_CURRENCY_CANNOT_BE_ASSET.selector);\n            TokenTransfersLibrary.doTransferOut(_params.depositAsset, _params.depositReceiver, _params.depositAmount);\n        }\n    }\n\n    /**\n     * @inheritdoc ITraderBalanceVault\n     */\n    function batchTopUpAvailableBalance(\n        BatchTopUpAvailableBalanceParams calldata _params\n    ) external override onlyRole(VAULT_ACCESS_ROLE) {\n        for (uint256 i; i < _params.length; i++) {\n            if (_params.amounts[i] > 0) {\n                topUpAvailableBalance(_params.traders[i], _params.asset, _params.amounts[i]);\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc ITraderBalanceVault\n     */\n    function unlockAsset(UnlockAssetParams calldata _params) external override onlyRole(VAULT_ACCESS_ROLE) {\n        balances[_params.trader][_params.asset].lockedBalance -= _params.amount;\n        balances[_params.receiver][_params.asset].availableBalance += _params.amount;\n    }\n\n    /**\n     * @inheritdoc ITraderBalanceVault\n     */\n    function topUpAvailableBalance(\n        address receiver,\n        address asset,\n        uint256 amount\n    ) public payable override onlyRole(VAULT_ACCESS_ROLE) {\n        _require(asset != address(0) && receiver != address(0), Errors.ADDRESS_NOT_SUPPORTED.selector);\n        // >= since we use this function in batchTopUpAvailableBalance\n        if (asset == NATIVE_CURRENCY) _require(msg.value >= amount, Errors.INVALID_AMOUNT.selector);\n        balances[receiver][asset].availableBalance += amount;\n    }\n\n    /**\n     * @inheritdoc ITraderBalanceVault\n     */\n    function withdrawFrom(\n        address _from,\n        address _to,\n        address _asset,\n        uint256 _amount,\n        bool fromLocked\n    ) external override onlyRole(VAULT_ACCESS_ROLE) {\n        if (fromLocked) {\n            _require(balances[_from][_asset].lockedBalance >= _amount, Errors.INSUFFICIENT_FREE_ASSETS.selector);\n            balances[_from][_asset].lockedBalance -= _amount;\n        } else {\n            _require(balances[_from][_asset].availableBalance >= _amount, Errors.INSUFFICIENT_FREE_ASSETS.selector);\n            balances[_from][_asset].availableBalance -= _amount;\n        }\n        if (_asset == NATIVE_CURRENCY) {\n            TokenTransfersLibrary.doTransferOutETH(_to, _amount);\n        } else {\n            TokenTransfersLibrary.doTransferOut(_asset, _to, _amount);\n        }\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc ITraderBalanceVault\n     */\n    function deposit(\n        address _asset,\n        uint256 _amount\n    ) public payable override nonReentrant notBlackListed whenNotPaused {\n        if (_asset == NATIVE_CURRENCY) {\n            _require(msg.value > 0 && _amount == 0, Errors.AMOUNT_IS_0.selector);\n            _amount = msg.value;\n        } else {\n            _require(msg.value == 0 && _amount > 0, Errors.AMOUNT_IS_0.selector);\n            _require(\n                IERC20Metadata(_asset).decimals() <= MAX_ASSET_DECIMALS,\n                Errors.ASSET_DECIMALS_EXCEEDS_MAX_VALUE.selector\n            );\n            TokenTransfersLibrary.doTransferIn(_asset, msg.sender, _amount);\n        }\n        balances[msg.sender][_asset].availableBalance += _amount;\n        emit Deposit(msg.sender, _asset, _amount);\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(_interfaceId) || _interfaceId == type(ITraderBalanceVault).interfaceId;\n    }\n}\n"
    },
    "contracts/TraderBalanceVault/TraderBalanceVaultStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {ITraderBalanceVaultStorage} from \"./ITraderBalanceVaultStorage.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol\";\n\nabstract contract TraderBalanceVaultStorage is\n    ITraderBalanceVaultStorage,\n    ReentrancyGuardUpgradeable,\n    PausableUpgradeable,\n    ERC165Upgradeable\n{\n    address public override registry;\n\n    // trader => asset => balance\n    mapping(address => mapping(address => TraderBalance)) public override balances;\n    IWhiteBlackList internal whiteBlackList;\n}\n"
    },
    "contracts/Treasury/ITreasury.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {ITreasuryStorage} from \"./ITreasuryStorage.sol\";\nimport {IPausable} from \"../interfaces/IPausable.sol\";\n\ninterface ITreasury is ITreasuryStorage, IPausable {\n    event MaxSpendingLimitChanged(address indexed spender, address indexed token, SpendingLimits newSpendingLimits);\n\n    /**\n     * @dev contract initializer\n     * @param registry The address of Registry contract\n     */\n    function initialize(address registry) external;\n\n    receive() external payable;\n\n    /**\n     * @notice Transfers an amount of ERC20 or native token from the contract treasury to\n     *  a receiver address, subject to certain restrictions imposed by the spender.\n     * @dev The function checks the spender's transfer restrictions per transaction and per timeframe.\n     * @param amount The amount of tokens to transfer.\n     * @param token The address of the token to transfer. Use the address NATIVE_TOKEN_ADDRESS for native token.\n     * @param receiver The address of the receiver\n     */\n    function transferFromTreasury(uint256 amount, address token, address receiver) external;\n\n    /**\n     * @notice Sets the maximum spending limit and other restrictions for a given spender and token.\n     * @dev This function can only be called by an address with the BIG_TIMELOCK_ADMIN role.\n     * @param spender The address of the spender for whom to set the new spending limit.\n     * @param token The address of the token for which to set the new spending limit.\n     * @param newSpendingLimits The new spending limits and restrictions to set for the spender and token.\n     */\n    function setMaxSpendingLimit(address spender, address token, SpendingLimits calldata newSpendingLimits) external;\n\n    /**\n     * @notice Decreases Spending limits for a spender for a specific token.\n     * @dev This function can only be called by an address with the BIG_TIMELOCK_ADMIN or EMERGENCY_ADMIN role.\n     * @param spender The address of the spender for whom to decrease the maximum transfer amounts and total amount.\n     * @param token The address of the token for which to decrease the maximum transfer amounts and total amount.\n     * @param newSpendingLimits The new spending limits and restrictions to set for the spender and token.\n     */\n    function decreaseLimits(address spender, address token, SpendingLimits calldata newSpendingLimits) external;\n\n    /**\n     * @notice Checks whether a spender can transfer tokens based on the minimum time between transfers imposed by the spending restrictions.\n     * @param spender The address of the spender to check for.\n     * @param token The address of the token for which to check the time restrictions.\n     * @return A boolean indicating whether the spender can transfer tokens based on the minimum time between transfers.\n     */\n    function canTransferByTime(address spender, address token) external returns (bool);\n}\n"
    },
    "contracts/Treasury/ITreasuryStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ITreasuryStorage {\n    struct SpendingLimits {\n        //transfer settings\n        uint256 maxTotalAmount;\n        uint256 maxAmountPerTransfer;\n        uint256 maxPercentPerTransfer;\n        uint256 minTimeBetweenTransfers;\n        // timeframe settings\n        uint256 timeframeDuration;\n        uint256 maxAmountDuringTimeframe;\n    }\n    struct SpendingInfo {\n        bool isSpenderExist;\n        SpendingLimits limits;\n        uint256 lastWithdrawalTimestamp;\n        uint256 withdrawnDuringTimeframe;\n    }\n\n    event TransferFromTreasury(\n        address indexed spender,\n        address indexed receiver,\n        address indexed token,\n        uint256 amount\n    );\n\n    function spenders(\n        address spender,\n        address token\n    ) external returns (bool, SpendingLimits calldata, uint256, uint256);\n\n    function initialTimestamp() external returns (uint256);\n\n    function registry() external returns (IAccessControl);\n}\n"
    },
    "contracts/Treasury/Treasury.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {WadRayMath} from \"../libraries/utils/WadRayMath.sol\";\n\nimport {TokenTransfersLibrary} from \"../libraries/TokenTransfersLibrary.sol\";\nimport \"../libraries/Errors.sol\";\n\nimport \"./TreasuryStorage.sol\";\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN, NATIVE_CURRENCY} from \"../Constants.sol\";\nimport {ITreasury, IPausable} from \"./ITreasury.sol\";\n\ncontract Treasury is ITreasury, TreasuryStorage {\n    using WadRayMath for uint256;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Throws if caller is not granted with _role\n     * @param _role The role that is being checked for a function caller\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(registry.hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    /**\n     * @inheritdoc ITreasury\n     */\n    function initialize(address _registry) external override initializer {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControl).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = IAccessControl(_registry);\n        initialTimestamp = block.timestamp;\n        __ReentrancyGuard_init();\n        __Pausable_init();\n        __ERC165_init();\n    }\n\n    receive() external payable override {}\n\n    /**\n     * @inheritdoc ITreasury\n     */\n    function transferFromTreasury(\n        uint256 _amount,\n        address _token,\n        address _receiver\n    ) external override whenNotPaused nonReentrant {\n        SpendingInfo storage spender = spenders[msg.sender][_token];\n        // Check restrictions per transaction\n        _require(\n            _amount > 0 &&\n                _amount <= spender.limits.maxAmountPerTransfer &&\n                spender.lastWithdrawalTimestamp + spender.limits.minTimeBetweenTransfers <= block.timestamp &&\n                _amount <= spender.limits.maxTotalAmount,\n            Errors.TRANSFER_RESTRICTIONS_NOT_MET.selector\n        );\n        if (_token == NATIVE_CURRENCY) {\n            _require(\n                _amount <= address(this).balance.wmul(spender.limits.maxPercentPerTransfer),\n                Errors.INSUFFICIENT_NATIVE_TOKEN_BALANCE.selector\n            );\n        } else {\n            _require(\n                _amount <= IERC20(_token).balanceOf(address(this)).wmul(spender.limits.maxPercentPerTransfer),\n                Errors.INSUFFICIENT_TOKEN_BALANCE.selector\n            );\n        }\n        // Check restrictions per timeframe\n        if (\n            _getTimeframeNumber(block.timestamp, spender) ==\n            _getTimeframeNumber(spender.lastWithdrawalTimestamp, spender)\n        ) {\n            _require(\n                spender.withdrawnDuringTimeframe + _amount <= spender.limits.maxAmountDuringTimeframe,\n                Errors.EXCEEDED_MAX_AMOUNT_DURING_TIMEFRAME.selector\n            );\n            spender.withdrawnDuringTimeframe += _amount;\n        } else {\n            _require(\n                _amount <= spender.limits.maxAmountDuringTimeframe,\n                Errors.EXCEEDED_MAX_AMOUNT_DURING_TIMEFRAME.selector\n            );\n            spender.withdrawnDuringTimeframe = _amount;\n        }\n\n        spender.lastWithdrawalTimestamp = block.timestamp;\n        spender.limits.maxTotalAmount -= _amount;\n\n        if (_token == NATIVE_CURRENCY) {\n            TokenTransfersLibrary.doTransferOutETH(_receiver, _amount);\n        } else {\n            TokenTransfersLibrary.doTransferOut(_token, _receiver, _amount);\n        }\n        emit TransferFromTreasury(msg.sender, _receiver, _token, _amount);\n    }\n\n    /**\n     * @inheritdoc ITreasury\n     */\n    function setMaxSpendingLimit(\n        address _spender,\n        address _token,\n        SpendingLimits calldata _newSpendingLimits\n    ) external override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(\n            _newSpendingLimits.maxTotalAmount > 0 &&\n                _newSpendingLimits.maxAmountPerTransfer > 0 &&\n                _newSpendingLimits.maxPercentPerTransfer > 0 &&\n                _newSpendingLimits.maxPercentPerTransfer < WadRayMath.WAD &&\n                _newSpendingLimits.maxAmountDuringTimeframe > 0 &&\n                _newSpendingLimits.timeframeDuration > 0,\n            Errors.SPENDING_LIMITS_ARE_INCORRECT.selector\n        );\n        SpendingInfo storage spender = spenders[_spender][_token];\n        spender.isSpenderExist = true;\n        spender.limits = _newSpendingLimits;\n        if (spender.lastWithdrawalTimestamp == 0) {\n            spender.lastWithdrawalTimestamp = initialTimestamp;\n        }\n        emit MaxSpendingLimitChanged(_spender, _token, _newSpendingLimits);\n    }\n\n    /**\n     * @inheritdoc ITreasury\n     */\n    function decreaseLimits(\n        address _spender,\n        address _token,\n        SpendingLimits calldata _newSpendingLimits\n    ) external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        SpendingInfo storage spender = spenders[_spender][_token];\n        SpendingLimits memory spenderLimits = spender.limits;\n        _require(spender.isSpenderExist, Errors.SPENDER_IS_NOT_EXIST.selector);\n        _require(\n            _newSpendingLimits.maxTotalAmount <= spenderLimits.maxTotalAmount &&\n                _newSpendingLimits.maxAmountPerTransfer <= spenderLimits.maxAmountPerTransfer &&\n                _newSpendingLimits.maxPercentPerTransfer <= spenderLimits.maxPercentPerTransfer &&\n                _newSpendingLimits.minTimeBetweenTransfers >= spenderLimits.minTimeBetweenTransfers &&\n                _newSpendingLimits.timeframeDuration >= spenderLimits.timeframeDuration &&\n                _newSpendingLimits.maxAmountDuringTimeframe <= spenderLimits.maxAmountDuringTimeframe,\n            Errors.EXCEEDED_MAX_SPENDING_LIMITS.selector\n        );\n        spender.limits = _newSpendingLimits;\n        emit MaxSpendingLimitChanged(_spender, _token, _newSpendingLimits);\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function pause() external override onlyRole(EMERGENCY_ADMIN) {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IPausable\n     */\n    function unpause() external override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc ITreasury\n     */\n    function canTransferByTime(address _spender, address _token) external view override returns (bool) {\n        SpendingInfo memory spender = spenders[_spender][_token];\n        _require(spender.isSpenderExist, Errors.SPENDER_IS_NOT_EXIST.selector);\n        return spender.lastWithdrawalTimestamp + spender.limits.minTimeBetweenTransfers < block.timestamp;\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view override returns (bool) {\n        return _interfaceId == type(ITreasury).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    function _getTimeframeNumber(uint256 _timestamp, SpendingInfo memory _spender) internal view returns (uint256) {\n        return ((_timestamp - initialTimestamp) / _spender.limits.timeframeDuration);\n    }\n}\n"
    },
    "contracts/Treasury/TreasuryStorage.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IAccessControl} from \"./ITreasuryStorage.sol\";\nimport {ITreasuryStorage} from \"./ITreasuryStorage.sol\";\n\nabstract contract TreasuryStorage is\n    ITreasuryStorage,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC165Upgradeable\n{\n    // user=> token => SpendingInfo\n    mapping(address => mapping(address => SpendingInfo)) public override spenders;\n    uint256 public override initialTimestamp;\n    IAccessControl public override registry;\n}\n"
    },
    "contracts/WhiteBlackList/WhiteBlackList/IWhiteBlackList.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.18;\n\ninterface IWhiteBlackList {\n    enum AccessType {\n        UNLISTED,\n        WHITELISTED,\n        BLACKLISTED\n    }\n    event WhitelistedAddressAdded(address indexed addr);\n    event WhitelistedAddressRemoved(address indexed addr);\n    event BlacklistedAddressAdded(address indexed addr);\n    event BlacklistedAddressRemoved(address indexed addr);\n\n    function addAddressToWhitelist(address _address) external;\n\n    function addAddressesToWhitelist(address[] calldata _addresses) external;\n\n    function removeAddressFromWhitelist(address _address) external;\n\n    function removeAddressesFromWhitelist(address[] calldata _addresses) external;\n\n    function addAddressToBlacklist(address _address) external;\n\n    function addAddressesToBlacklist(address[] calldata _addresses) external;\n\n    function removeAddressFromBlacklist(address _address) external;\n\n    function removeAddressesFromBlacklist(address[] calldata _addresses) external;\n\n    function getAccessType(address _address) external view returns (AccessType);\n\n    function isBlackListed(address _address) external view returns (bool);\n\n    function registry() external view returns (address);\n}\n"
    },
    "contracts/WhiteBlackList/WhiteBlackList/WhiteBlackList.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {IAccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {ECDSAUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\n\nimport \"../../libraries/Errors.sol\";\n\nimport {WhiteBlackListBase} from \"../WhiteBlackListBase/WhiteBlackListBase.sol\";\nimport {MEDIUM_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \"../../Constants.sol\";\n\ncontract WhiteBlackList is WhiteBlackListBase {\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev contract initializer\n     * @param _registry The address of Registry contract\n     */\n    // solhint-disable-next-line comprehensive-interface\n    function initialize(address _registry) external initializer {\n        __WhiteBlackListBase_init(_registry);\n    }\n\n    /**\n     * @inheritdoc WhiteBlackListBase\n     */\n    function addAddressToBlacklist(address _address) public override onlyRole(EMERGENCY_ADMIN) {\n        _require(accessList[_address] != AccessType.WHITELISTED, Errors.ADDRESS_IS_WHITELISTED.selector);\n        _require(_address.code.length > 0, Errors.ADDRESS_IS_NOT_CONTRACT.selector);\n        _addAddressToBlacklist(_address);\n    }\n\n    /**\n     * @inheritdoc WhiteBlackListBase\n     */\n    function addAddressToWhitelist(address _address) public override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        _addAddressToWhitelist(_address);\n    }\n}\n"
    },
    "contracts/WhiteBlackList/WhiteBlackListBase/WhiteBlackListBase.sol": {
      "content": "// (c) 2023 Primex.finance\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {IAccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\n\nimport \"../../libraries/Errors.sol\";\n\nimport {BIG_TIMELOCK_ADMIN, MEDIUM_TIMELOCK_ADMIN, SMALL_TIMELOCK_ADMIN, EMERGENCY_ADMIN} from \"../../Constants.sol\";\nimport {IWhiteBlackList} from \"../WhiteBlackList/IWhiteBlackList.sol\";\n\nabstract contract WhiteBlackListBase is IWhiteBlackList, ERC165Upgradeable {\n    mapping(address => AccessType) internal accessList;\n    address public override registry;\n\n    //to new variables without shifting down storage in the inheritance chain.\n    uint256[50] private __gap;\n\n    /**\n     * @dev Throws if caller is not granted with _role\n     * @param _role The role that is being checked for a function caller\n     */\n    modifier onlyRole(bytes32 _role) {\n        _require(IAccessControlUpgradeable(registry).hasRole(_role, msg.sender), Errors.FORBIDDEN.selector);\n        _;\n    }\n\n    function isBlackListed(address _address) external view override returns (bool) {\n        return accessList[_address] == AccessType.BLACKLISTED;\n    }\n\n    function addAddressesToWhitelist(address[] calldata _addresses) public override {\n        for (uint256 i; i < _addresses.length; i++) {\n            addAddressToWhitelist(_addresses[i]);\n        }\n    }\n\n    function removeAddressFromWhitelist(address _address) public override onlyRole(BIG_TIMELOCK_ADMIN) {\n        _require(accessList[_address] == AccessType.WHITELISTED, Errors.ADDRESS_NOT_WHITELISTED.selector);\n        accessList[_address] = AccessType.UNLISTED;\n        emit WhitelistedAddressRemoved(_address);\n    }\n\n    function removeAddressesFromWhitelist(address[] calldata _addresses) public override {\n        for (uint256 i; i < _addresses.length; i++) {\n            removeAddressFromWhitelist(_addresses[i]);\n        }\n    }\n\n    function addAddressesToBlacklist(address[] calldata _addresses) public override {\n        for (uint256 i; i < _addresses.length; i++) {\n            addAddressToBlacklist(_addresses[i]);\n        }\n    }\n\n    function removeAddressFromBlacklist(address _address) public override onlyRole(SMALL_TIMELOCK_ADMIN) {\n        _require(accessList[_address] == AccessType.BLACKLISTED, Errors.ADDRESS_NOT_BLACKLISTED.selector);\n        accessList[_address] = AccessType.UNLISTED;\n        emit BlacklistedAddressRemoved(_address);\n    }\n\n    function removeAddressesFromBlacklist(\n        address[] calldata _addresses\n    ) public override onlyRole(MEDIUM_TIMELOCK_ADMIN) {\n        for (uint256 i; i < _addresses.length; i++) {\n            removeAddressFromBlacklist(_addresses[i]);\n        }\n    }\n\n    /**\n     * @param _address The address to add to blacklist\n     */\n    function addAddressToBlacklist(address _address) public virtual override;\n\n    /**\n     * @param _address The address to add to whitelist\n     */\n    function addAddressToWhitelist(address _address) public virtual override;\n\n    /**\n     *\n     * @param _address The address to check on its AccessType\n     */\n    function getAccessType(address _address) public view override returns (AccessType) {\n        return accessList[_address];\n    }\n\n    /**\n     * @notice Interface checker\n     * @param _interfaceId The interface id to check\n     */\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IWhiteBlackList).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __WhiteBlackListBase_init(address _registry) internal onlyInitializing {\n        _require(\n            IERC165Upgradeable(_registry).supportsInterface(type(IAccessControlUpgradeable).interfaceId),\n            Errors.ADDRESS_NOT_SUPPORTED.selector\n        );\n        registry = _registry;\n        __ERC165_init();\n    }\n\n    function _addAddressToBlacklist(address _address) internal {\n        _require(accessList[_address] != AccessType.BLACKLISTED, Errors.ADDRESS_ALREADY_BLACKLISTED.selector);\n        accessList[_address] = AccessType.BLACKLISTED;\n        emit BlacklistedAddressAdded(_address);\n    }\n\n    function _addAddressToWhitelist(address _address) internal {\n        _require(accessList[_address] != AccessType.WHITELISTED, Errors.ADDRESS_ALREADY_WHITELISTED.selector);\n        accessList[_address] = AccessType.WHITELISTED;\n        emit WhitelistedAddressAdded(_address);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}